// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'drift_database.dart';

// ignore_for_file: type=lint
class $UsersTable extends Users with TableInfo<$UsersTable, User> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 300),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _surnameMeta =
      const VerificationMeta('surname');
  @override
  late final GeneratedColumn<String> surname = GeneratedColumn<String>(
      'surname', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 150),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _emailAddressMeta =
      const VerificationMeta('emailAddress');
  @override
  late final GeneratedColumn<String> emailAddress = GeneratedColumn<String>(
      'email_address', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 5, maxTextLength: 400),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _fullNameMeta =
      const VerificationMeta('fullName');
  @override
  late final GeneratedColumn<String> fullName = GeneratedColumn<String>(
      'full_name', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 300),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _mobileHashMeta =
      const VerificationMeta('mobileHash');
  @override
  late final GeneratedColumn<String> mobileHash = GeneratedColumn<String>(
      'mobile_hash', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _enableOfflineLoginMeta =
      const VerificationMeta('enableOfflineLogin');
  @override
  late final GeneratedColumn<bool> enableOfflineLogin = GeneratedColumn<bool>(
      'enable_offline_login', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("enable_offline_login" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _firebaseTokenMeta =
      const VerificationMeta('firebaseToken');
  @override
  late final GeneratedColumn<String> firebaseToken = GeneratedColumn<String>(
      'firebase_token', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _creationTimeMeta =
      const VerificationMeta('creationTime');
  @override
  late final GeneratedColumn<DateTime> creationTime = GeneratedColumn<DateTime>(
      'creation_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _lastLoginTimeMeta =
      const VerificationMeta('lastLoginTime');
  @override
  late final GeneratedColumn<DateTime> lastLoginTime =
      GeneratedColumn<DateTime>('last_login_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _currencyMeta =
      const VerificationMeta('currency');
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
      'currency', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _themeDataMeta =
      const VerificationMeta('themeData');
  @override
  late final GeneratedColumn<String> themeData = GeneratedColumn<String>(
      'theme_data', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        userName,
        name,
        surname,
        emailAddress,
        isActive,
        fullName,
        mobileHash,
        enableOfflineLogin,
        firebaseToken,
        creationTime,
        lastLoginTime,
        currency,
        themeData
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'users';
  @override
  VerificationContext validateIntegrity(Insertable<User> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    } else if (isInserting) {
      context.missing(_userNameMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('surname')) {
      context.handle(_surnameMeta,
          surname.isAcceptableOrUnknown(data['surname']!, _surnameMeta));
    } else if (isInserting) {
      context.missing(_surnameMeta);
    }
    if (data.containsKey('email_address')) {
      context.handle(
          _emailAddressMeta,
          emailAddress.isAcceptableOrUnknown(
              data['email_address']!, _emailAddressMeta));
    } else if (isInserting) {
      context.missing(_emailAddressMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('full_name')) {
      context.handle(_fullNameMeta,
          fullName.isAcceptableOrUnknown(data['full_name']!, _fullNameMeta));
    } else if (isInserting) {
      context.missing(_fullNameMeta);
    }
    if (data.containsKey('mobile_hash')) {
      context.handle(
          _mobileHashMeta,
          mobileHash.isAcceptableOrUnknown(
              data['mobile_hash']!, _mobileHashMeta));
    }
    if (data.containsKey('enable_offline_login')) {
      context.handle(
          _enableOfflineLoginMeta,
          enableOfflineLogin.isAcceptableOrUnknown(
              data['enable_offline_login']!, _enableOfflineLoginMeta));
    }
    if (data.containsKey('firebase_token')) {
      context.handle(
          _firebaseTokenMeta,
          firebaseToken.isAcceptableOrUnknown(
              data['firebase_token']!, _firebaseTokenMeta));
    }
    if (data.containsKey('creation_time')) {
      context.handle(
          _creationTimeMeta,
          creationTime.isAcceptableOrUnknown(
              data['creation_time']!, _creationTimeMeta));
    }
    if (data.containsKey('last_login_time')) {
      context.handle(
          _lastLoginTimeMeta,
          lastLoginTime.isAcceptableOrUnknown(
              data['last_login_time']!, _lastLoginTimeMeta));
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta));
    }
    if (data.containsKey('theme_data')) {
      context.handle(_themeDataMeta,
          themeData.isAcceptableOrUnknown(data['theme_data']!, _themeDataMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  User map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return User(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name'])!,
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      surname: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}surname'])!,
      emailAddress: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email_address'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      fullName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}full_name'])!,
      mobileHash: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}mobile_hash']),
      enableOfflineLogin: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}enable_offline_login'])!,
      firebaseToken: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}firebase_token']),
      creationTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}creation_time']),
      lastLoginTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_login_time']),
      currency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}currency']),
      themeData: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}theme_data']),
    );
  }

  @override
  $UsersTable createAlias(String alias) {
    return $UsersTable(attachedDatabase, alias);
  }
}

class User extends DataClass implements Insertable<User> {
  final String? tenantId;
  final int id;
  final String userName;
  final String name;
  final String surname;
  final String emailAddress;
  final bool isActive;
  final String fullName;
  final String? mobileHash;
  final bool enableOfflineLogin;
  final String? firebaseToken;
  final DateTime? creationTime;
  final DateTime? lastLoginTime;
  final String? currency;
  final String? themeData;
  const User(
      {this.tenantId,
      required this.id,
      required this.userName,
      required this.name,
      required this.surname,
      required this.emailAddress,
      required this.isActive,
      required this.fullName,
      this.mobileHash,
      required this.enableOfflineLogin,
      this.firebaseToken,
      this.creationTime,
      this.lastLoginTime,
      this.currency,
      this.themeData});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    map['user_name'] = Variable<String>(userName);
    map['name'] = Variable<String>(name);
    map['surname'] = Variable<String>(surname);
    map['email_address'] = Variable<String>(emailAddress);
    map['is_active'] = Variable<bool>(isActive);
    map['full_name'] = Variable<String>(fullName);
    if (!nullToAbsent || mobileHash != null) {
      map['mobile_hash'] = Variable<String>(mobileHash);
    }
    map['enable_offline_login'] = Variable<bool>(enableOfflineLogin);
    if (!nullToAbsent || firebaseToken != null) {
      map['firebase_token'] = Variable<String>(firebaseToken);
    }
    if (!nullToAbsent || creationTime != null) {
      map['creation_time'] = Variable<DateTime>(creationTime);
    }
    if (!nullToAbsent || lastLoginTime != null) {
      map['last_login_time'] = Variable<DateTime>(lastLoginTime);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    if (!nullToAbsent || themeData != null) {
      map['theme_data'] = Variable<String>(themeData);
    }
    return map;
  }

  UsersCompanion toCompanion(bool nullToAbsent) {
    return UsersCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      userName: Value(userName),
      name: Value(name),
      surname: Value(surname),
      emailAddress: Value(emailAddress),
      isActive: Value(isActive),
      fullName: Value(fullName),
      mobileHash: mobileHash == null && nullToAbsent
          ? const Value.absent()
          : Value(mobileHash),
      enableOfflineLogin: Value(enableOfflineLogin),
      firebaseToken: firebaseToken == null && nullToAbsent
          ? const Value.absent()
          : Value(firebaseToken),
      creationTime: creationTime == null && nullToAbsent
          ? const Value.absent()
          : Value(creationTime),
      lastLoginTime: lastLoginTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastLoginTime),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      themeData: themeData == null && nullToAbsent
          ? const Value.absent()
          : Value(themeData),
    );
  }

  factory User.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return User(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      userName: serializer.fromJson<String>(json['userName']),
      name: serializer.fromJson<String>(json['name']),
      surname: serializer.fromJson<String>(json['surname']),
      emailAddress: serializer.fromJson<String>(json['emailAddress']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      fullName: serializer.fromJson<String>(json['fullName']),
      mobileHash: serializer.fromJson<String?>(json['mobileHash']),
      enableOfflineLogin: serializer.fromJson<bool>(json['enableOfflineLogin']),
      firebaseToken: serializer.fromJson<String?>(json['firebaseToken']),
      creationTime: serializer.fromJson<DateTime?>(json['creationTime']),
      lastLoginTime: serializer.fromJson<DateTime?>(json['lastLoginTime']),
      currency: serializer.fromJson<String?>(json['currency']),
      themeData: serializer.fromJson<String?>(json['themeData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'userName': serializer.toJson<String>(userName),
      'name': serializer.toJson<String>(name),
      'surname': serializer.toJson<String>(surname),
      'emailAddress': serializer.toJson<String>(emailAddress),
      'isActive': serializer.toJson<bool>(isActive),
      'fullName': serializer.toJson<String>(fullName),
      'mobileHash': serializer.toJson<String?>(mobileHash),
      'enableOfflineLogin': serializer.toJson<bool>(enableOfflineLogin),
      'firebaseToken': serializer.toJson<String?>(firebaseToken),
      'creationTime': serializer.toJson<DateTime?>(creationTime),
      'lastLoginTime': serializer.toJson<DateTime?>(lastLoginTime),
      'currency': serializer.toJson<String?>(currency),
      'themeData': serializer.toJson<String?>(themeData),
    };
  }

  User copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          String? userName,
          String? name,
          String? surname,
          String? emailAddress,
          bool? isActive,
          String? fullName,
          Value<String?> mobileHash = const Value.absent(),
          bool? enableOfflineLogin,
          Value<String?> firebaseToken = const Value.absent(),
          Value<DateTime?> creationTime = const Value.absent(),
          Value<DateTime?> lastLoginTime = const Value.absent(),
          Value<String?> currency = const Value.absent(),
          Value<String?> themeData = const Value.absent()}) =>
      User(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        userName: userName ?? this.userName,
        name: name ?? this.name,
        surname: surname ?? this.surname,
        emailAddress: emailAddress ?? this.emailAddress,
        isActive: isActive ?? this.isActive,
        fullName: fullName ?? this.fullName,
        mobileHash: mobileHash.present ? mobileHash.value : this.mobileHash,
        enableOfflineLogin: enableOfflineLogin ?? this.enableOfflineLogin,
        firebaseToken:
            firebaseToken.present ? firebaseToken.value : this.firebaseToken,
        creationTime:
            creationTime.present ? creationTime.value : this.creationTime,
        lastLoginTime:
            lastLoginTime.present ? lastLoginTime.value : this.lastLoginTime,
        currency: currency.present ? currency.value : this.currency,
        themeData: themeData.present ? themeData.value : this.themeData,
      );
  @override
  String toString() {
    return (StringBuffer('User(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('userName: $userName, ')
          ..write('name: $name, ')
          ..write('surname: $surname, ')
          ..write('emailAddress: $emailAddress, ')
          ..write('isActive: $isActive, ')
          ..write('fullName: $fullName, ')
          ..write('mobileHash: $mobileHash, ')
          ..write('enableOfflineLogin: $enableOfflineLogin, ')
          ..write('firebaseToken: $firebaseToken, ')
          ..write('creationTime: $creationTime, ')
          ..write('lastLoginTime: $lastLoginTime, ')
          ..write('currency: $currency, ')
          ..write('themeData: $themeData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      userName,
      name,
      surname,
      emailAddress,
      isActive,
      fullName,
      mobileHash,
      enableOfflineLogin,
      firebaseToken,
      creationTime,
      lastLoginTime,
      currency,
      themeData);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.userName == this.userName &&
          other.name == this.name &&
          other.surname == this.surname &&
          other.emailAddress == this.emailAddress &&
          other.isActive == this.isActive &&
          other.fullName == this.fullName &&
          other.mobileHash == this.mobileHash &&
          other.enableOfflineLogin == this.enableOfflineLogin &&
          other.firebaseToken == this.firebaseToken &&
          other.creationTime == this.creationTime &&
          other.lastLoginTime == this.lastLoginTime &&
          other.currency == this.currency &&
          other.themeData == this.themeData);
}

class UsersCompanion extends UpdateCompanion<User> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String> userName;
  final Value<String> name;
  final Value<String> surname;
  final Value<String> emailAddress;
  final Value<bool> isActive;
  final Value<String> fullName;
  final Value<String?> mobileHash;
  final Value<bool> enableOfflineLogin;
  final Value<String?> firebaseToken;
  final Value<DateTime?> creationTime;
  final Value<DateTime?> lastLoginTime;
  final Value<String?> currency;
  final Value<String?> themeData;
  const UsersCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.userName = const Value.absent(),
    this.name = const Value.absent(),
    this.surname = const Value.absent(),
    this.emailAddress = const Value.absent(),
    this.isActive = const Value.absent(),
    this.fullName = const Value.absent(),
    this.mobileHash = const Value.absent(),
    this.enableOfflineLogin = const Value.absent(),
    this.firebaseToken = const Value.absent(),
    this.creationTime = const Value.absent(),
    this.lastLoginTime = const Value.absent(),
    this.currency = const Value.absent(),
    this.themeData = const Value.absent(),
  });
  UsersCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    required String userName,
    required String name,
    required String surname,
    required String emailAddress,
    this.isActive = const Value.absent(),
    required String fullName,
    this.mobileHash = const Value.absent(),
    this.enableOfflineLogin = const Value.absent(),
    this.firebaseToken = const Value.absent(),
    this.creationTime = const Value.absent(),
    this.lastLoginTime = const Value.absent(),
    this.currency = const Value.absent(),
    this.themeData = const Value.absent(),
  })  : userName = Value(userName),
        name = Value(name),
        surname = Value(surname),
        emailAddress = Value(emailAddress),
        fullName = Value(fullName);
  static Insertable<User> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? userName,
    Expression<String>? name,
    Expression<String>? surname,
    Expression<String>? emailAddress,
    Expression<bool>? isActive,
    Expression<String>? fullName,
    Expression<String>? mobileHash,
    Expression<bool>? enableOfflineLogin,
    Expression<String>? firebaseToken,
    Expression<DateTime>? creationTime,
    Expression<DateTime>? lastLoginTime,
    Expression<String>? currency,
    Expression<String>? themeData,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (userName != null) 'user_name': userName,
      if (name != null) 'name': name,
      if (surname != null) 'surname': surname,
      if (emailAddress != null) 'email_address': emailAddress,
      if (isActive != null) 'is_active': isActive,
      if (fullName != null) 'full_name': fullName,
      if (mobileHash != null) 'mobile_hash': mobileHash,
      if (enableOfflineLogin != null)
        'enable_offline_login': enableOfflineLogin,
      if (firebaseToken != null) 'firebase_token': firebaseToken,
      if (creationTime != null) 'creation_time': creationTime,
      if (lastLoginTime != null) 'last_login_time': lastLoginTime,
      if (currency != null) 'currency': currency,
      if (themeData != null) 'theme_data': themeData,
    });
  }

  UsersCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String>? userName,
      Value<String>? name,
      Value<String>? surname,
      Value<String>? emailAddress,
      Value<bool>? isActive,
      Value<String>? fullName,
      Value<String?>? mobileHash,
      Value<bool>? enableOfflineLogin,
      Value<String?>? firebaseToken,
      Value<DateTime?>? creationTime,
      Value<DateTime?>? lastLoginTime,
      Value<String?>? currency,
      Value<String?>? themeData}) {
    return UsersCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      userName: userName ?? this.userName,
      name: name ?? this.name,
      surname: surname ?? this.surname,
      emailAddress: emailAddress ?? this.emailAddress,
      isActive: isActive ?? this.isActive,
      fullName: fullName ?? this.fullName,
      mobileHash: mobileHash ?? this.mobileHash,
      enableOfflineLogin: enableOfflineLogin ?? this.enableOfflineLogin,
      firebaseToken: firebaseToken ?? this.firebaseToken,
      creationTime: creationTime ?? this.creationTime,
      lastLoginTime: lastLoginTime ?? this.lastLoginTime,
      currency: currency ?? this.currency,
      themeData: themeData ?? this.themeData,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (surname.present) {
      map['surname'] = Variable<String>(surname.value);
    }
    if (emailAddress.present) {
      map['email_address'] = Variable<String>(emailAddress.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (fullName.present) {
      map['full_name'] = Variable<String>(fullName.value);
    }
    if (mobileHash.present) {
      map['mobile_hash'] = Variable<String>(mobileHash.value);
    }
    if (enableOfflineLogin.present) {
      map['enable_offline_login'] = Variable<bool>(enableOfflineLogin.value);
    }
    if (firebaseToken.present) {
      map['firebase_token'] = Variable<String>(firebaseToken.value);
    }
    if (creationTime.present) {
      map['creation_time'] = Variable<DateTime>(creationTime.value);
    }
    if (lastLoginTime.present) {
      map['last_login_time'] = Variable<DateTime>(lastLoginTime.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (themeData.present) {
      map['theme_data'] = Variable<String>(themeData.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UsersCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('userName: $userName, ')
          ..write('name: $name, ')
          ..write('surname: $surname, ')
          ..write('emailAddress: $emailAddress, ')
          ..write('isActive: $isActive, ')
          ..write('fullName: $fullName, ')
          ..write('mobileHash: $mobileHash, ')
          ..write('enableOfflineLogin: $enableOfflineLogin, ')
          ..write('firebaseToken: $firebaseToken, ')
          ..write('creationTime: $creationTime, ')
          ..write('lastLoginTime: $lastLoginTime, ')
          ..write('currency: $currency, ')
          ..write('themeData: $themeData')
          ..write(')'))
        .toString();
  }
}

class $CommunicationTable extends Communication
    with TableInfo<$CommunicationTable, CommunicationData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CommunicationTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _creationTimeMeta =
      const VerificationMeta('creationTime');
  @override
  late final GeneratedColumn<DateTime> creationTime = GeneratedColumn<DateTime>(
      'creation_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deleteTimeMeta =
      const VerificationMeta('deleteTime');
  @override
  late final GeneratedColumn<DateTime> deleteTime = GeneratedColumn<DateTime>(
      'delete_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createUserIdMeta =
      const VerificationMeta('createUserId');
  @override
  late final GeneratedColumn<int> createUserId = GeneratedColumn<int>(
      'create_user_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _creatorUserMeta =
      const VerificationMeta('creatorUser');
  @override
  late final GeneratedColumn<String> creatorUser = GeneratedColumn<String>(
      'creator_user', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastModifierUserMeta =
      const VerificationMeta('lastModifierUser');
  @override
  late final GeneratedColumn<String> lastModifierUser = GeneratedColumn<String>(
      'last_modifier_user', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastModifierUserIdMeta =
      const VerificationMeta('lastModifierUserId');
  @override
  late final GeneratedColumn<int> lastModifierUserId = GeneratedColumn<int>(
      'last_modifier_user_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _deleteUserIdMeta =
      const VerificationMeta('deleteUserId');
  @override
  late final GeneratedColumn<int> deleteUserId = GeneratedColumn<int>(
      'delete_user_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _deleterUserIdMeta =
      const VerificationMeta('deleterUserId');
  @override
  late final GeneratedColumn<String> deleterUserId = GeneratedColumn<String>(
      'deleter_user_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _importDateTimeMeta =
      const VerificationMeta('importDateTime');
  @override
  late final GeneratedColumn<DateTime> importDateTime =
      GeneratedColumn<DateTime>('import_date_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _exportDateTimeMeta =
      const VerificationMeta('exportDateTime');
  @override
  late final GeneratedColumn<DateTime> exportDateTime =
      GeneratedColumn<DateTime>('export_date_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _exportStatusMeta =
      const VerificationMeta('exportStatus');
  @override
  late final GeneratedColumn<String> exportStatus = GeneratedColumn<String>(
      'export_status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: Constant('Pending'));
  static const VerificationMeta _importStatusMeta =
      const VerificationMeta('importStatus');
  @override
  late final GeneratedColumn<String> importStatus = GeneratedColumn<String>(
      'import_status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: Constant('Pending'));
  static const VerificationMeta _syncErrorMeta =
      const VerificationMeta('syncError');
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
      'sync_error', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _serverUrlMeta =
      const VerificationMeta('serverUrl');
  @override
  late final GeneratedColumn<String> serverUrl = GeneratedColumn<String>(
      'server_url', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _newPasskeyMeta =
      const VerificationMeta('newPasskey');
  @override
  late final GeneratedColumn<String> newPasskey = GeneratedColumn<String>(
      'new_passkey', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _confirmPasskeyMeta =
      const VerificationMeta('confirmPasskey');
  @override
  late final GeneratedColumn<String> confirmPasskey = GeneratedColumn<String>(
      'confirm_passkey', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _syncFrequencyMeta =
      const VerificationMeta('syncFrequency');
  @override
  late final GeneratedColumn<String> syncFrequency = GeneratedColumn<String>(
      'sync_frequency', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _communicationTypeMeta =
      const VerificationMeta('communicationType');
  @override
  late final GeneratedColumn<String> communicationType =
      GeneratedColumn<String>('communication_type', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _typeofErpMeta =
      const VerificationMeta('typeofErp');
  @override
  late final GeneratedColumn<String> typeofErp = GeneratedColumn<String>(
      'typeof_erp', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        creationTime,
        deleteTime,
        createUserId,
        creatorUser,
        lastModifierUser,
        lastModifierUserId,
        deleteUserId,
        deleterUserId,
        isDeleted,
        importDateTime,
        exportDateTime,
        exportStatus,
        importStatus,
        syncError,
        id,
        serverUrl,
        userName,
        newPasskey,
        confirmPasskey,
        syncFrequency,
        communicationType,
        typeofErp,
        tenantId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'communication';
  @override
  VerificationContext validateIntegrity(Insertable<CommunicationData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creation_time')) {
      context.handle(
          _creationTimeMeta,
          creationTime.isAcceptableOrUnknown(
              data['creation_time']!, _creationTimeMeta));
    }
    if (data.containsKey('delete_time')) {
      context.handle(
          _deleteTimeMeta,
          deleteTime.isAcceptableOrUnknown(
              data['delete_time']!, _deleteTimeMeta));
    }
    if (data.containsKey('create_user_id')) {
      context.handle(
          _createUserIdMeta,
          createUserId.isAcceptableOrUnknown(
              data['create_user_id']!, _createUserIdMeta));
    }
    if (data.containsKey('creator_user')) {
      context.handle(
          _creatorUserMeta,
          creatorUser.isAcceptableOrUnknown(
              data['creator_user']!, _creatorUserMeta));
    }
    if (data.containsKey('last_modifier_user')) {
      context.handle(
          _lastModifierUserMeta,
          lastModifierUser.isAcceptableOrUnknown(
              data['last_modifier_user']!, _lastModifierUserMeta));
    }
    if (data.containsKey('last_modifier_user_id')) {
      context.handle(
          _lastModifierUserIdMeta,
          lastModifierUserId.isAcceptableOrUnknown(
              data['last_modifier_user_id']!, _lastModifierUserIdMeta));
    }
    if (data.containsKey('delete_user_id')) {
      context.handle(
          _deleteUserIdMeta,
          deleteUserId.isAcceptableOrUnknown(
              data['delete_user_id']!, _deleteUserIdMeta));
    }
    if (data.containsKey('deleter_user_id')) {
      context.handle(
          _deleterUserIdMeta,
          deleterUserId.isAcceptableOrUnknown(
              data['deleter_user_id']!, _deleterUserIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('import_date_time')) {
      context.handle(
          _importDateTimeMeta,
          importDateTime.isAcceptableOrUnknown(
              data['import_date_time']!, _importDateTimeMeta));
    }
    if (data.containsKey('export_date_time')) {
      context.handle(
          _exportDateTimeMeta,
          exportDateTime.isAcceptableOrUnknown(
              data['export_date_time']!, _exportDateTimeMeta));
    }
    if (data.containsKey('export_status')) {
      context.handle(
          _exportStatusMeta,
          exportStatus.isAcceptableOrUnknown(
              data['export_status']!, _exportStatusMeta));
    }
    if (data.containsKey('import_status')) {
      context.handle(
          _importStatusMeta,
          importStatus.isAcceptableOrUnknown(
              data['import_status']!, _importStatusMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('server_url')) {
      context.handle(_serverUrlMeta,
          serverUrl.isAcceptableOrUnknown(data['server_url']!, _serverUrlMeta));
    } else if (isInserting) {
      context.missing(_serverUrlMeta);
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('new_passkey')) {
      context.handle(
          _newPasskeyMeta,
          newPasskey.isAcceptableOrUnknown(
              data['new_passkey']!, _newPasskeyMeta));
    }
    if (data.containsKey('confirm_passkey')) {
      context.handle(
          _confirmPasskeyMeta,
          confirmPasskey.isAcceptableOrUnknown(
              data['confirm_passkey']!, _confirmPasskeyMeta));
    }
    if (data.containsKey('sync_frequency')) {
      context.handle(
          _syncFrequencyMeta,
          syncFrequency.isAcceptableOrUnknown(
              data['sync_frequency']!, _syncFrequencyMeta));
    } else if (isInserting) {
      context.missing(_syncFrequencyMeta);
    }
    if (data.containsKey('communication_type')) {
      context.handle(
          _communicationTypeMeta,
          communicationType.isAcceptableOrUnknown(
              data['communication_type']!, _communicationTypeMeta));
    } else if (isInserting) {
      context.missing(_communicationTypeMeta);
    }
    if (data.containsKey('typeof_erp')) {
      context.handle(_typeofErpMeta,
          typeofErp.isAcceptableOrUnknown(data['typeof_erp']!, _typeofErpMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CommunicationData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CommunicationData(
      creationTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}creation_time']),
      deleteTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}delete_time']),
      createUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}create_user_id']),
      creatorUser: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}creator_user']),
      lastModifierUser: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}last_modifier_user']),
      lastModifierUserId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}last_modifier_user_id']),
      deleteUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}delete_user_id']),
      deleterUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}deleter_user_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      importDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}import_date_time']),
      exportDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}export_date_time']),
      exportStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}export_status'])!,
      importStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}import_status'])!,
      syncError: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sync_error']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      serverUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}server_url'])!,
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      newPasskey: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}new_passkey']),
      confirmPasskey: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}confirm_passkey']),
      syncFrequency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sync_frequency'])!,
      communicationType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}communication_type'])!,
      typeofErp: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}typeof_erp']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
    );
  }

  @override
  $CommunicationTable createAlias(String alias) {
    return $CommunicationTable(attachedDatabase, alias);
  }
}

class CommunicationData extends DataClass
    implements Insertable<CommunicationData> {
  final DateTime? creationTime;
  final DateTime? deleteTime;
  final int? createUserId;
  final String? creatorUser;
  final String? lastModifierUser;
  final int? lastModifierUserId;
  final int? deleteUserId;
  final String? deleterUserId;
  final bool isDeleted;
  final DateTime? importDateTime;
  final DateTime? exportDateTime;
  final String exportStatus;
  final String importStatus;
  final String? syncError;
  final int id;
  final String serverUrl;
  final String? userName;
  final String? newPasskey;
  final String? confirmPasskey;
  final String syncFrequency;
  final String communicationType;
  final String? typeofErp;
  final String? tenantId;
  const CommunicationData(
      {this.creationTime,
      this.deleteTime,
      this.createUserId,
      this.creatorUser,
      this.lastModifierUser,
      this.lastModifierUserId,
      this.deleteUserId,
      this.deleterUserId,
      required this.isDeleted,
      this.importDateTime,
      this.exportDateTime,
      required this.exportStatus,
      required this.importStatus,
      this.syncError,
      required this.id,
      required this.serverUrl,
      this.userName,
      this.newPasskey,
      this.confirmPasskey,
      required this.syncFrequency,
      required this.communicationType,
      this.typeofErp,
      this.tenantId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || creationTime != null) {
      map['creation_time'] = Variable<DateTime>(creationTime);
    }
    if (!nullToAbsent || deleteTime != null) {
      map['delete_time'] = Variable<DateTime>(deleteTime);
    }
    if (!nullToAbsent || createUserId != null) {
      map['create_user_id'] = Variable<int>(createUserId);
    }
    if (!nullToAbsent || creatorUser != null) {
      map['creator_user'] = Variable<String>(creatorUser);
    }
    if (!nullToAbsent || lastModifierUser != null) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser);
    }
    if (!nullToAbsent || lastModifierUserId != null) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId);
    }
    if (!nullToAbsent || deleteUserId != null) {
      map['delete_user_id'] = Variable<int>(deleteUserId);
    }
    if (!nullToAbsent || deleterUserId != null) {
      map['deleter_user_id'] = Variable<String>(deleterUserId);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || importDateTime != null) {
      map['import_date_time'] = Variable<DateTime>(importDateTime);
    }
    if (!nullToAbsent || exportDateTime != null) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime);
    }
    map['export_status'] = Variable<String>(exportStatus);
    map['import_status'] = Variable<String>(importStatus);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    map['id'] = Variable<int>(id);
    map['server_url'] = Variable<String>(serverUrl);
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || newPasskey != null) {
      map['new_passkey'] = Variable<String>(newPasskey);
    }
    if (!nullToAbsent || confirmPasskey != null) {
      map['confirm_passkey'] = Variable<String>(confirmPasskey);
    }
    map['sync_frequency'] = Variable<String>(syncFrequency);
    map['communication_type'] = Variable<String>(communicationType);
    if (!nullToAbsent || typeofErp != null) {
      map['typeof_erp'] = Variable<String>(typeofErp);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    return map;
  }

  CommunicationCompanion toCompanion(bool nullToAbsent) {
    return CommunicationCompanion(
      creationTime: creationTime == null && nullToAbsent
          ? const Value.absent()
          : Value(creationTime),
      deleteTime: deleteTime == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteTime),
      createUserId: createUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(createUserId),
      creatorUser: creatorUser == null && nullToAbsent
          ? const Value.absent()
          : Value(creatorUser),
      lastModifierUser: lastModifierUser == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUser),
      lastModifierUserId: lastModifierUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUserId),
      deleteUserId: deleteUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteUserId),
      deleterUserId: deleterUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleterUserId),
      isDeleted: Value(isDeleted),
      importDateTime: importDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(importDateTime),
      exportDateTime: exportDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(exportDateTime),
      exportStatus: Value(exportStatus),
      importStatus: Value(importStatus),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      id: Value(id),
      serverUrl: Value(serverUrl),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      newPasskey: newPasskey == null && nullToAbsent
          ? const Value.absent()
          : Value(newPasskey),
      confirmPasskey: confirmPasskey == null && nullToAbsent
          ? const Value.absent()
          : Value(confirmPasskey),
      syncFrequency: Value(syncFrequency),
      communicationType: Value(communicationType),
      typeofErp: typeofErp == null && nullToAbsent
          ? const Value.absent()
          : Value(typeofErp),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory CommunicationData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CommunicationData(
      creationTime: serializer.fromJson<DateTime?>(json['creationTime']),
      deleteTime: serializer.fromJson<DateTime?>(json['deleteTime']),
      createUserId: serializer.fromJson<int?>(json['createUserId']),
      creatorUser: serializer.fromJson<String?>(json['creatorUser']),
      lastModifierUser: serializer.fromJson<String?>(json['lastModifierUser']),
      lastModifierUserId: serializer.fromJson<int?>(json['lastModifierUserId']),
      deleteUserId: serializer.fromJson<int?>(json['deleteUserId']),
      deleterUserId: serializer.fromJson<String?>(json['deleterUserId']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      importDateTime: serializer.fromJson<DateTime?>(json['importDateTime']),
      exportDateTime: serializer.fromJson<DateTime?>(json['exportDateTime']),
      exportStatus: serializer.fromJson<String>(json['exportStatus']),
      importStatus: serializer.fromJson<String>(json['importStatus']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      id: serializer.fromJson<int>(json['id']),
      serverUrl: serializer.fromJson<String>(json['serverUrl']),
      userName: serializer.fromJson<String?>(json['userName']),
      newPasskey: serializer.fromJson<String?>(json['newPasskey']),
      confirmPasskey: serializer.fromJson<String?>(json['confirmPasskey']),
      syncFrequency: serializer.fromJson<String>(json['syncFrequency']),
      communicationType: serializer.fromJson<String>(json['communicationType']),
      typeofErp: serializer.fromJson<String?>(json['typeofErp']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creationTime': serializer.toJson<DateTime?>(creationTime),
      'deleteTime': serializer.toJson<DateTime?>(deleteTime),
      'createUserId': serializer.toJson<int?>(createUserId),
      'creatorUser': serializer.toJson<String?>(creatorUser),
      'lastModifierUser': serializer.toJson<String?>(lastModifierUser),
      'lastModifierUserId': serializer.toJson<int?>(lastModifierUserId),
      'deleteUserId': serializer.toJson<int?>(deleteUserId),
      'deleterUserId': serializer.toJson<String?>(deleterUserId),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'importDateTime': serializer.toJson<DateTime?>(importDateTime),
      'exportDateTime': serializer.toJson<DateTime?>(exportDateTime),
      'exportStatus': serializer.toJson<String>(exportStatus),
      'importStatus': serializer.toJson<String>(importStatus),
      'syncError': serializer.toJson<String?>(syncError),
      'id': serializer.toJson<int>(id),
      'serverUrl': serializer.toJson<String>(serverUrl),
      'userName': serializer.toJson<String?>(userName),
      'newPasskey': serializer.toJson<String?>(newPasskey),
      'confirmPasskey': serializer.toJson<String?>(confirmPasskey),
      'syncFrequency': serializer.toJson<String>(syncFrequency),
      'communicationType': serializer.toJson<String>(communicationType),
      'typeofErp': serializer.toJson<String?>(typeofErp),
      'tenantId': serializer.toJson<String?>(tenantId),
    };
  }

  CommunicationData copyWith(
          {Value<DateTime?> creationTime = const Value.absent(),
          Value<DateTime?> deleteTime = const Value.absent(),
          Value<int?> createUserId = const Value.absent(),
          Value<String?> creatorUser = const Value.absent(),
          Value<String?> lastModifierUser = const Value.absent(),
          Value<int?> lastModifierUserId = const Value.absent(),
          Value<int?> deleteUserId = const Value.absent(),
          Value<String?> deleterUserId = const Value.absent(),
          bool? isDeleted,
          Value<DateTime?> importDateTime = const Value.absent(),
          Value<DateTime?> exportDateTime = const Value.absent(),
          String? exportStatus,
          String? importStatus,
          Value<String?> syncError = const Value.absent(),
          int? id,
          String? serverUrl,
          Value<String?> userName = const Value.absent(),
          Value<String?> newPasskey = const Value.absent(),
          Value<String?> confirmPasskey = const Value.absent(),
          String? syncFrequency,
          String? communicationType,
          Value<String?> typeofErp = const Value.absent(),
          Value<String?> tenantId = const Value.absent()}) =>
      CommunicationData(
        creationTime:
            creationTime.present ? creationTime.value : this.creationTime,
        deleteTime: deleteTime.present ? deleteTime.value : this.deleteTime,
        createUserId:
            createUserId.present ? createUserId.value : this.createUserId,
        creatorUser: creatorUser.present ? creatorUser.value : this.creatorUser,
        lastModifierUser: lastModifierUser.present
            ? lastModifierUser.value
            : this.lastModifierUser,
        lastModifierUserId: lastModifierUserId.present
            ? lastModifierUserId.value
            : this.lastModifierUserId,
        deleteUserId:
            deleteUserId.present ? deleteUserId.value : this.deleteUserId,
        deleterUserId:
            deleterUserId.present ? deleterUserId.value : this.deleterUserId,
        isDeleted: isDeleted ?? this.isDeleted,
        importDateTime:
            importDateTime.present ? importDateTime.value : this.importDateTime,
        exportDateTime:
            exportDateTime.present ? exportDateTime.value : this.exportDateTime,
        exportStatus: exportStatus ?? this.exportStatus,
        importStatus: importStatus ?? this.importStatus,
        syncError: syncError.present ? syncError.value : this.syncError,
        id: id ?? this.id,
        serverUrl: serverUrl ?? this.serverUrl,
        userName: userName.present ? userName.value : this.userName,
        newPasskey: newPasskey.present ? newPasskey.value : this.newPasskey,
        confirmPasskey:
            confirmPasskey.present ? confirmPasskey.value : this.confirmPasskey,
        syncFrequency: syncFrequency ?? this.syncFrequency,
        communicationType: communicationType ?? this.communicationType,
        typeofErp: typeofErp.present ? typeofErp.value : this.typeofErp,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('CommunicationData(')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('createUserId: $createUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('importDateTime: $importDateTime, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('importStatus: $importStatus, ')
          ..write('syncError: $syncError, ')
          ..write('id: $id, ')
          ..write('serverUrl: $serverUrl, ')
          ..write('userName: $userName, ')
          ..write('newPasskey: $newPasskey, ')
          ..write('confirmPasskey: $confirmPasskey, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('communicationType: $communicationType, ')
          ..write('typeofErp: $typeofErp, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        creationTime,
        deleteTime,
        createUserId,
        creatorUser,
        lastModifierUser,
        lastModifierUserId,
        deleteUserId,
        deleterUserId,
        isDeleted,
        importDateTime,
        exportDateTime,
        exportStatus,
        importStatus,
        syncError,
        id,
        serverUrl,
        userName,
        newPasskey,
        confirmPasskey,
        syncFrequency,
        communicationType,
        typeofErp,
        tenantId
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CommunicationData &&
          other.creationTime == this.creationTime &&
          other.deleteTime == this.deleteTime &&
          other.createUserId == this.createUserId &&
          other.creatorUser == this.creatorUser &&
          other.lastModifierUser == this.lastModifierUser &&
          other.lastModifierUserId == this.lastModifierUserId &&
          other.deleteUserId == this.deleteUserId &&
          other.deleterUserId == this.deleterUserId &&
          other.isDeleted == this.isDeleted &&
          other.importDateTime == this.importDateTime &&
          other.exportDateTime == this.exportDateTime &&
          other.exportStatus == this.exportStatus &&
          other.importStatus == this.importStatus &&
          other.syncError == this.syncError &&
          other.id == this.id &&
          other.serverUrl == this.serverUrl &&
          other.userName == this.userName &&
          other.newPasskey == this.newPasskey &&
          other.confirmPasskey == this.confirmPasskey &&
          other.syncFrequency == this.syncFrequency &&
          other.communicationType == this.communicationType &&
          other.typeofErp == this.typeofErp &&
          other.tenantId == this.tenantId);
}

class CommunicationCompanion extends UpdateCompanion<CommunicationData> {
  final Value<DateTime?> creationTime;
  final Value<DateTime?> deleteTime;
  final Value<int?> createUserId;
  final Value<String?> creatorUser;
  final Value<String?> lastModifierUser;
  final Value<int?> lastModifierUserId;
  final Value<int?> deleteUserId;
  final Value<String?> deleterUserId;
  final Value<bool> isDeleted;
  final Value<DateTime?> importDateTime;
  final Value<DateTime?> exportDateTime;
  final Value<String> exportStatus;
  final Value<String> importStatus;
  final Value<String?> syncError;
  final Value<int> id;
  final Value<String> serverUrl;
  final Value<String?> userName;
  final Value<String?> newPasskey;
  final Value<String?> confirmPasskey;
  final Value<String> syncFrequency;
  final Value<String> communicationType;
  final Value<String?> typeofErp;
  final Value<String?> tenantId;
  const CommunicationCompanion({
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.importDateTime = const Value.absent(),
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.importStatus = const Value.absent(),
    this.syncError = const Value.absent(),
    this.id = const Value.absent(),
    this.serverUrl = const Value.absent(),
    this.userName = const Value.absent(),
    this.newPasskey = const Value.absent(),
    this.confirmPasskey = const Value.absent(),
    this.syncFrequency = const Value.absent(),
    this.communicationType = const Value.absent(),
    this.typeofErp = const Value.absent(),
    this.tenantId = const Value.absent(),
  });
  CommunicationCompanion.insert({
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.importDateTime = const Value.absent(),
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.importStatus = const Value.absent(),
    this.syncError = const Value.absent(),
    this.id = const Value.absent(),
    required String serverUrl,
    this.userName = const Value.absent(),
    this.newPasskey = const Value.absent(),
    this.confirmPasskey = const Value.absent(),
    required String syncFrequency,
    required String communicationType,
    this.typeofErp = const Value.absent(),
    this.tenantId = const Value.absent(),
  })  : serverUrl = Value(serverUrl),
        syncFrequency = Value(syncFrequency),
        communicationType = Value(communicationType);
  static Insertable<CommunicationData> custom({
    Expression<DateTime>? creationTime,
    Expression<DateTime>? deleteTime,
    Expression<int>? createUserId,
    Expression<String>? creatorUser,
    Expression<String>? lastModifierUser,
    Expression<int>? lastModifierUserId,
    Expression<int>? deleteUserId,
    Expression<String>? deleterUserId,
    Expression<bool>? isDeleted,
    Expression<DateTime>? importDateTime,
    Expression<DateTime>? exportDateTime,
    Expression<String>? exportStatus,
    Expression<String>? importStatus,
    Expression<String>? syncError,
    Expression<int>? id,
    Expression<String>? serverUrl,
    Expression<String>? userName,
    Expression<String>? newPasskey,
    Expression<String>? confirmPasskey,
    Expression<String>? syncFrequency,
    Expression<String>? communicationType,
    Expression<String>? typeofErp,
    Expression<String>? tenantId,
  }) {
    return RawValuesInsertable({
      if (creationTime != null) 'creation_time': creationTime,
      if (deleteTime != null) 'delete_time': deleteTime,
      if (createUserId != null) 'create_user_id': createUserId,
      if (creatorUser != null) 'creator_user': creatorUser,
      if (lastModifierUser != null) 'last_modifier_user': lastModifierUser,
      if (lastModifierUserId != null)
        'last_modifier_user_id': lastModifierUserId,
      if (deleteUserId != null) 'delete_user_id': deleteUserId,
      if (deleterUserId != null) 'deleter_user_id': deleterUserId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (importDateTime != null) 'import_date_time': importDateTime,
      if (exportDateTime != null) 'export_date_time': exportDateTime,
      if (exportStatus != null) 'export_status': exportStatus,
      if (importStatus != null) 'import_status': importStatus,
      if (syncError != null) 'sync_error': syncError,
      if (id != null) 'id': id,
      if (serverUrl != null) 'server_url': serverUrl,
      if (userName != null) 'user_name': userName,
      if (newPasskey != null) 'new_passkey': newPasskey,
      if (confirmPasskey != null) 'confirm_passkey': confirmPasskey,
      if (syncFrequency != null) 'sync_frequency': syncFrequency,
      if (communicationType != null) 'communication_type': communicationType,
      if (typeofErp != null) 'typeof_erp': typeofErp,
      if (tenantId != null) 'tenant_id': tenantId,
    });
  }

  CommunicationCompanion copyWith(
      {Value<DateTime?>? creationTime,
      Value<DateTime?>? deleteTime,
      Value<int?>? createUserId,
      Value<String?>? creatorUser,
      Value<String?>? lastModifierUser,
      Value<int?>? lastModifierUserId,
      Value<int?>? deleteUserId,
      Value<String?>? deleterUserId,
      Value<bool>? isDeleted,
      Value<DateTime?>? importDateTime,
      Value<DateTime?>? exportDateTime,
      Value<String>? exportStatus,
      Value<String>? importStatus,
      Value<String?>? syncError,
      Value<int>? id,
      Value<String>? serverUrl,
      Value<String?>? userName,
      Value<String?>? newPasskey,
      Value<String?>? confirmPasskey,
      Value<String>? syncFrequency,
      Value<String>? communicationType,
      Value<String?>? typeofErp,
      Value<String?>? tenantId}) {
    return CommunicationCompanion(
      creationTime: creationTime ?? this.creationTime,
      deleteTime: deleteTime ?? this.deleteTime,
      createUserId: createUserId ?? this.createUserId,
      creatorUser: creatorUser ?? this.creatorUser,
      lastModifierUser: lastModifierUser ?? this.lastModifierUser,
      lastModifierUserId: lastModifierUserId ?? this.lastModifierUserId,
      deleteUserId: deleteUserId ?? this.deleteUserId,
      deleterUserId: deleterUserId ?? this.deleterUserId,
      isDeleted: isDeleted ?? this.isDeleted,
      importDateTime: importDateTime ?? this.importDateTime,
      exportDateTime: exportDateTime ?? this.exportDateTime,
      exportStatus: exportStatus ?? this.exportStatus,
      importStatus: importStatus ?? this.importStatus,
      syncError: syncError ?? this.syncError,
      id: id ?? this.id,
      serverUrl: serverUrl ?? this.serverUrl,
      userName: userName ?? this.userName,
      newPasskey: newPasskey ?? this.newPasskey,
      confirmPasskey: confirmPasskey ?? this.confirmPasskey,
      syncFrequency: syncFrequency ?? this.syncFrequency,
      communicationType: communicationType ?? this.communicationType,
      typeofErp: typeofErp ?? this.typeofErp,
      tenantId: tenantId ?? this.tenantId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creationTime.present) {
      map['creation_time'] = Variable<DateTime>(creationTime.value);
    }
    if (deleteTime.present) {
      map['delete_time'] = Variable<DateTime>(deleteTime.value);
    }
    if (createUserId.present) {
      map['create_user_id'] = Variable<int>(createUserId.value);
    }
    if (creatorUser.present) {
      map['creator_user'] = Variable<String>(creatorUser.value);
    }
    if (lastModifierUser.present) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser.value);
    }
    if (lastModifierUserId.present) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId.value);
    }
    if (deleteUserId.present) {
      map['delete_user_id'] = Variable<int>(deleteUserId.value);
    }
    if (deleterUserId.present) {
      map['deleter_user_id'] = Variable<String>(deleterUserId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (importDateTime.present) {
      map['import_date_time'] = Variable<DateTime>(importDateTime.value);
    }
    if (exportDateTime.present) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime.value);
    }
    if (exportStatus.present) {
      map['export_status'] = Variable<String>(exportStatus.value);
    }
    if (importStatus.present) {
      map['import_status'] = Variable<String>(importStatus.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (serverUrl.present) {
      map['server_url'] = Variable<String>(serverUrl.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (newPasskey.present) {
      map['new_passkey'] = Variable<String>(newPasskey.value);
    }
    if (confirmPasskey.present) {
      map['confirm_passkey'] = Variable<String>(confirmPasskey.value);
    }
    if (syncFrequency.present) {
      map['sync_frequency'] = Variable<String>(syncFrequency.value);
    }
    if (communicationType.present) {
      map['communication_type'] = Variable<String>(communicationType.value);
    }
    if (typeofErp.present) {
      map['typeof_erp'] = Variable<String>(typeofErp.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CommunicationCompanion(')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('createUserId: $createUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('importDateTime: $importDateTime, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('importStatus: $importStatus, ')
          ..write('syncError: $syncError, ')
          ..write('id: $id, ')
          ..write('serverUrl: $serverUrl, ')
          ..write('userName: $userName, ')
          ..write('newPasskey: $newPasskey, ')
          ..write('confirmPasskey: $confirmPasskey, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('communicationType: $communicationType, ')
          ..write('typeofErp: $typeofErp, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }
}

class $BackgroundJobScheduleTable extends BackgroundJobSchedule
    with TableInfo<$BackgroundJobScheduleTable, BackgroundJobScheduleData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BackgroundJobScheduleTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _jobNameMeta =
      const VerificationMeta('jobName');
  @override
  late final GeneratedColumn<String> jobName = GeneratedColumn<String>(
      'job_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _startDateTimeMeta =
      const VerificationMeta('startDateTime');
  @override
  late final GeneratedColumn<DateTime> startDateTime =
      GeneratedColumn<DateTime>('start_date_time', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _syncFrequencyMeta =
      const VerificationMeta('syncFrequency');
  @override
  late final GeneratedColumn<String> syncFrequency = GeneratedColumn<String>(
      'sync_frequency', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _enableJobMeta =
      const VerificationMeta('enableJob');
  @override
  late final GeneratedColumn<bool> enableJob = GeneratedColumn<bool>(
      'enable_job', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("enable_job" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _lastRunMeta =
      const VerificationMeta('lastRun');
  @override
  late final GeneratedColumn<DateTime> lastRun = GeneratedColumn<DateTime>(
      'last_run', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _jobStatusMeta =
      const VerificationMeta('jobStatus');
  @override
  late final GeneratedColumn<String> jobStatus = GeneratedColumn<String>(
      'job_status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        jobName,
        startDateTime,
        syncFrequency,
        enableJob,
        lastRun,
        jobStatus,
        tenantId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'background_job_schedule';
  @override
  VerificationContext validateIntegrity(
      Insertable<BackgroundJobScheduleData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('job_name')) {
      context.handle(_jobNameMeta,
          jobName.isAcceptableOrUnknown(data['job_name']!, _jobNameMeta));
    } else if (isInserting) {
      context.missing(_jobNameMeta);
    }
    if (data.containsKey('start_date_time')) {
      context.handle(
          _startDateTimeMeta,
          startDateTime.isAcceptableOrUnknown(
              data['start_date_time']!, _startDateTimeMeta));
    } else if (isInserting) {
      context.missing(_startDateTimeMeta);
    }
    if (data.containsKey('sync_frequency')) {
      context.handle(
          _syncFrequencyMeta,
          syncFrequency.isAcceptableOrUnknown(
              data['sync_frequency']!, _syncFrequencyMeta));
    } else if (isInserting) {
      context.missing(_syncFrequencyMeta);
    }
    if (data.containsKey('enable_job')) {
      context.handle(_enableJobMeta,
          enableJob.isAcceptableOrUnknown(data['enable_job']!, _enableJobMeta));
    }
    if (data.containsKey('last_run')) {
      context.handle(_lastRunMeta,
          lastRun.isAcceptableOrUnknown(data['last_run']!, _lastRunMeta));
    } else if (isInserting) {
      context.missing(_lastRunMeta);
    }
    if (data.containsKey('job_status')) {
      context.handle(_jobStatusMeta,
          jobStatus.isAcceptableOrUnknown(data['job_status']!, _jobStatusMeta));
    } else if (isInserting) {
      context.missing(_jobStatusMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BackgroundJobScheduleData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BackgroundJobScheduleData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      jobName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}job_name'])!,
      startDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}start_date_time'])!,
      syncFrequency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sync_frequency'])!,
      enableJob: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}enable_job'])!,
      lastRun: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}last_run'])!,
      jobStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}job_status'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
    );
  }

  @override
  $BackgroundJobScheduleTable createAlias(String alias) {
    return $BackgroundJobScheduleTable(attachedDatabase, alias);
  }
}

class BackgroundJobScheduleData extends DataClass
    implements Insertable<BackgroundJobScheduleData> {
  final int id;
  final String jobName;
  final DateTime startDateTime;
  final String syncFrequency;
  final bool enableJob;
  final DateTime lastRun;
  final String jobStatus;
  final String? tenantId;
  const BackgroundJobScheduleData(
      {required this.id,
      required this.jobName,
      required this.startDateTime,
      required this.syncFrequency,
      required this.enableJob,
      required this.lastRun,
      required this.jobStatus,
      this.tenantId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['job_name'] = Variable<String>(jobName);
    map['start_date_time'] = Variable<DateTime>(startDateTime);
    map['sync_frequency'] = Variable<String>(syncFrequency);
    map['enable_job'] = Variable<bool>(enableJob);
    map['last_run'] = Variable<DateTime>(lastRun);
    map['job_status'] = Variable<String>(jobStatus);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    return map;
  }

  BackgroundJobScheduleCompanion toCompanion(bool nullToAbsent) {
    return BackgroundJobScheduleCompanion(
      id: Value(id),
      jobName: Value(jobName),
      startDateTime: Value(startDateTime),
      syncFrequency: Value(syncFrequency),
      enableJob: Value(enableJob),
      lastRun: Value(lastRun),
      jobStatus: Value(jobStatus),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory BackgroundJobScheduleData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BackgroundJobScheduleData(
      id: serializer.fromJson<int>(json['id']),
      jobName: serializer.fromJson<String>(json['jobName']),
      startDateTime: serializer.fromJson<DateTime>(json['startDateTime']),
      syncFrequency: serializer.fromJson<String>(json['syncFrequency']),
      enableJob: serializer.fromJson<bool>(json['enableJob']),
      lastRun: serializer.fromJson<DateTime>(json['lastRun']),
      jobStatus: serializer.fromJson<String>(json['jobStatus']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'jobName': serializer.toJson<String>(jobName),
      'startDateTime': serializer.toJson<DateTime>(startDateTime),
      'syncFrequency': serializer.toJson<String>(syncFrequency),
      'enableJob': serializer.toJson<bool>(enableJob),
      'lastRun': serializer.toJson<DateTime>(lastRun),
      'jobStatus': serializer.toJson<String>(jobStatus),
      'tenantId': serializer.toJson<String?>(tenantId),
    };
  }

  BackgroundJobScheduleData copyWith(
          {int? id,
          String? jobName,
          DateTime? startDateTime,
          String? syncFrequency,
          bool? enableJob,
          DateTime? lastRun,
          String? jobStatus,
          Value<String?> tenantId = const Value.absent()}) =>
      BackgroundJobScheduleData(
        id: id ?? this.id,
        jobName: jobName ?? this.jobName,
        startDateTime: startDateTime ?? this.startDateTime,
        syncFrequency: syncFrequency ?? this.syncFrequency,
        enableJob: enableJob ?? this.enableJob,
        lastRun: lastRun ?? this.lastRun,
        jobStatus: jobStatus ?? this.jobStatus,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('BackgroundJobScheduleData(')
          ..write('id: $id, ')
          ..write('jobName: $jobName, ')
          ..write('startDateTime: $startDateTime, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('enableJob: $enableJob, ')
          ..write('lastRun: $lastRun, ')
          ..write('jobStatus: $jobStatus, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, jobName, startDateTime, syncFrequency,
      enableJob, lastRun, jobStatus, tenantId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BackgroundJobScheduleData &&
          other.id == this.id &&
          other.jobName == this.jobName &&
          other.startDateTime == this.startDateTime &&
          other.syncFrequency == this.syncFrequency &&
          other.enableJob == this.enableJob &&
          other.lastRun == this.lastRun &&
          other.jobStatus == this.jobStatus &&
          other.tenantId == this.tenantId);
}

class BackgroundJobScheduleCompanion
    extends UpdateCompanion<BackgroundJobScheduleData> {
  final Value<int> id;
  final Value<String> jobName;
  final Value<DateTime> startDateTime;
  final Value<String> syncFrequency;
  final Value<bool> enableJob;
  final Value<DateTime> lastRun;
  final Value<String> jobStatus;
  final Value<String?> tenantId;
  const BackgroundJobScheduleCompanion({
    this.id = const Value.absent(),
    this.jobName = const Value.absent(),
    this.startDateTime = const Value.absent(),
    this.syncFrequency = const Value.absent(),
    this.enableJob = const Value.absent(),
    this.lastRun = const Value.absent(),
    this.jobStatus = const Value.absent(),
    this.tenantId = const Value.absent(),
  });
  BackgroundJobScheduleCompanion.insert({
    this.id = const Value.absent(),
    required String jobName,
    required DateTime startDateTime,
    required String syncFrequency,
    this.enableJob = const Value.absent(),
    required DateTime lastRun,
    required String jobStatus,
    this.tenantId = const Value.absent(),
  })  : jobName = Value(jobName),
        startDateTime = Value(startDateTime),
        syncFrequency = Value(syncFrequency),
        lastRun = Value(lastRun),
        jobStatus = Value(jobStatus);
  static Insertable<BackgroundJobScheduleData> custom({
    Expression<int>? id,
    Expression<String>? jobName,
    Expression<DateTime>? startDateTime,
    Expression<String>? syncFrequency,
    Expression<bool>? enableJob,
    Expression<DateTime>? lastRun,
    Expression<String>? jobStatus,
    Expression<String>? tenantId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (jobName != null) 'job_name': jobName,
      if (startDateTime != null) 'start_date_time': startDateTime,
      if (syncFrequency != null) 'sync_frequency': syncFrequency,
      if (enableJob != null) 'enable_job': enableJob,
      if (lastRun != null) 'last_run': lastRun,
      if (jobStatus != null) 'job_status': jobStatus,
      if (tenantId != null) 'tenant_id': tenantId,
    });
  }

  BackgroundJobScheduleCompanion copyWith(
      {Value<int>? id,
      Value<String>? jobName,
      Value<DateTime>? startDateTime,
      Value<String>? syncFrequency,
      Value<bool>? enableJob,
      Value<DateTime>? lastRun,
      Value<String>? jobStatus,
      Value<String?>? tenantId}) {
    return BackgroundJobScheduleCompanion(
      id: id ?? this.id,
      jobName: jobName ?? this.jobName,
      startDateTime: startDateTime ?? this.startDateTime,
      syncFrequency: syncFrequency ?? this.syncFrequency,
      enableJob: enableJob ?? this.enableJob,
      lastRun: lastRun ?? this.lastRun,
      jobStatus: jobStatus ?? this.jobStatus,
      tenantId: tenantId ?? this.tenantId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (jobName.present) {
      map['job_name'] = Variable<String>(jobName.value);
    }
    if (startDateTime.present) {
      map['start_date_time'] = Variable<DateTime>(startDateTime.value);
    }
    if (syncFrequency.present) {
      map['sync_frequency'] = Variable<String>(syncFrequency.value);
    }
    if (enableJob.present) {
      map['enable_job'] = Variable<bool>(enableJob.value);
    }
    if (lastRun.present) {
      map['last_run'] = Variable<DateTime>(lastRun.value);
    }
    if (jobStatus.present) {
      map['job_status'] = Variable<String>(jobStatus.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BackgroundJobScheduleCompanion(')
          ..write('id: $id, ')
          ..write('jobName: $jobName, ')
          ..write('startDateTime: $startDateTime, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('enableJob: $enableJob, ')
          ..write('lastRun: $lastRun, ')
          ..write('jobStatus: $jobStatus, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }
}

class $BackgroundJobLogsTable extends BackgroundJobLogs
    with TableInfo<$BackgroundJobLogsTable, BackgroundJobLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BackgroundJobLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _jobNameMeta =
      const VerificationMeta('jobName');
  @override
  late final GeneratedColumn<String> jobName = GeneratedColumn<String>(
      'job_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _lastRunMeta =
      const VerificationMeta('lastRun');
  @override
  late final GeneratedColumn<DateTime> lastRun = GeneratedColumn<DateTime>(
      'last_run', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _jobStatusMeta =
      const VerificationMeta('jobStatus');
  @override
  late final GeneratedColumn<String> jobStatus = GeneratedColumn<String>(
      'job_status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _jobDescriptionMeta =
      const VerificationMeta('jobDescription');
  @override
  late final GeneratedColumn<String> jobDescription = GeneratedColumn<String>(
      'job_description', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [id, jobName, lastRun, jobStatus, jobDescription, tenantId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'background_job_logs';
  @override
  VerificationContext validateIntegrity(Insertable<BackgroundJobLog> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('job_name')) {
      context.handle(_jobNameMeta,
          jobName.isAcceptableOrUnknown(data['job_name']!, _jobNameMeta));
    } else if (isInserting) {
      context.missing(_jobNameMeta);
    }
    if (data.containsKey('last_run')) {
      context.handle(_lastRunMeta,
          lastRun.isAcceptableOrUnknown(data['last_run']!, _lastRunMeta));
    } else if (isInserting) {
      context.missing(_lastRunMeta);
    }
    if (data.containsKey('job_status')) {
      context.handle(_jobStatusMeta,
          jobStatus.isAcceptableOrUnknown(data['job_status']!, _jobStatusMeta));
    } else if (isInserting) {
      context.missing(_jobStatusMeta);
    }
    if (data.containsKey('job_description')) {
      context.handle(
          _jobDescriptionMeta,
          jobDescription.isAcceptableOrUnknown(
              data['job_description']!, _jobDescriptionMeta));
    } else if (isInserting) {
      context.missing(_jobDescriptionMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BackgroundJobLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BackgroundJobLog(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      jobName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}job_name'])!,
      lastRun: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}last_run'])!,
      jobStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}job_status'])!,
      jobDescription: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}job_description'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
    );
  }

  @override
  $BackgroundJobLogsTable createAlias(String alias) {
    return $BackgroundJobLogsTable(attachedDatabase, alias);
  }
}

class BackgroundJobLog extends DataClass
    implements Insertable<BackgroundJobLog> {
  final int id;
  final String jobName;
  final DateTime lastRun;
  final String jobStatus;
  final String jobDescription;
  final String? tenantId;
  const BackgroundJobLog(
      {required this.id,
      required this.jobName,
      required this.lastRun,
      required this.jobStatus,
      required this.jobDescription,
      this.tenantId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['job_name'] = Variable<String>(jobName);
    map['last_run'] = Variable<DateTime>(lastRun);
    map['job_status'] = Variable<String>(jobStatus);
    map['job_description'] = Variable<String>(jobDescription);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    return map;
  }

  BackgroundJobLogsCompanion toCompanion(bool nullToAbsent) {
    return BackgroundJobLogsCompanion(
      id: Value(id),
      jobName: Value(jobName),
      lastRun: Value(lastRun),
      jobStatus: Value(jobStatus),
      jobDescription: Value(jobDescription),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory BackgroundJobLog.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BackgroundJobLog(
      id: serializer.fromJson<int>(json['id']),
      jobName: serializer.fromJson<String>(json['jobName']),
      lastRun: serializer.fromJson<DateTime>(json['lastRun']),
      jobStatus: serializer.fromJson<String>(json['jobStatus']),
      jobDescription: serializer.fromJson<String>(json['jobDescription']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'jobName': serializer.toJson<String>(jobName),
      'lastRun': serializer.toJson<DateTime>(lastRun),
      'jobStatus': serializer.toJson<String>(jobStatus),
      'jobDescription': serializer.toJson<String>(jobDescription),
      'tenantId': serializer.toJson<String?>(tenantId),
    };
  }

  BackgroundJobLog copyWith(
          {int? id,
          String? jobName,
          DateTime? lastRun,
          String? jobStatus,
          String? jobDescription,
          Value<String?> tenantId = const Value.absent()}) =>
      BackgroundJobLog(
        id: id ?? this.id,
        jobName: jobName ?? this.jobName,
        lastRun: lastRun ?? this.lastRun,
        jobStatus: jobStatus ?? this.jobStatus,
        jobDescription: jobDescription ?? this.jobDescription,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('BackgroundJobLog(')
          ..write('id: $id, ')
          ..write('jobName: $jobName, ')
          ..write('lastRun: $lastRun, ')
          ..write('jobStatus: $jobStatus, ')
          ..write('jobDescription: $jobDescription, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, jobName, lastRun, jobStatus, jobDescription, tenantId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BackgroundJobLog &&
          other.id == this.id &&
          other.jobName == this.jobName &&
          other.lastRun == this.lastRun &&
          other.jobStatus == this.jobStatus &&
          other.jobDescription == this.jobDescription &&
          other.tenantId == this.tenantId);
}

class BackgroundJobLogsCompanion extends UpdateCompanion<BackgroundJobLog> {
  final Value<int> id;
  final Value<String> jobName;
  final Value<DateTime> lastRun;
  final Value<String> jobStatus;
  final Value<String> jobDescription;
  final Value<String?> tenantId;
  const BackgroundJobLogsCompanion({
    this.id = const Value.absent(),
    this.jobName = const Value.absent(),
    this.lastRun = const Value.absent(),
    this.jobStatus = const Value.absent(),
    this.jobDescription = const Value.absent(),
    this.tenantId = const Value.absent(),
  });
  BackgroundJobLogsCompanion.insert({
    this.id = const Value.absent(),
    required String jobName,
    required DateTime lastRun,
    required String jobStatus,
    required String jobDescription,
    this.tenantId = const Value.absent(),
  })  : jobName = Value(jobName),
        lastRun = Value(lastRun),
        jobStatus = Value(jobStatus),
        jobDescription = Value(jobDescription);
  static Insertable<BackgroundJobLog> custom({
    Expression<int>? id,
    Expression<String>? jobName,
    Expression<DateTime>? lastRun,
    Expression<String>? jobStatus,
    Expression<String>? jobDescription,
    Expression<String>? tenantId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (jobName != null) 'job_name': jobName,
      if (lastRun != null) 'last_run': lastRun,
      if (jobStatus != null) 'job_status': jobStatus,
      if (jobDescription != null) 'job_description': jobDescription,
      if (tenantId != null) 'tenant_id': tenantId,
    });
  }

  BackgroundJobLogsCompanion copyWith(
      {Value<int>? id,
      Value<String>? jobName,
      Value<DateTime>? lastRun,
      Value<String>? jobStatus,
      Value<String>? jobDescription,
      Value<String?>? tenantId}) {
    return BackgroundJobLogsCompanion(
      id: id ?? this.id,
      jobName: jobName ?? this.jobName,
      lastRun: lastRun ?? this.lastRun,
      jobStatus: jobStatus ?? this.jobStatus,
      jobDescription: jobDescription ?? this.jobDescription,
      tenantId: tenantId ?? this.tenantId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (jobName.present) {
      map['job_name'] = Variable<String>(jobName.value);
    }
    if (lastRun.present) {
      map['last_run'] = Variable<DateTime>(lastRun.value);
    }
    if (jobStatus.present) {
      map['job_status'] = Variable<String>(jobStatus.value);
    }
    if (jobDescription.present) {
      map['job_description'] = Variable<String>(jobDescription.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BackgroundJobLogsCompanion(')
          ..write('id: $id, ')
          ..write('jobName: $jobName, ')
          ..write('lastRun: $lastRun, ')
          ..write('jobStatus: $jobStatus, ')
          ..write('jobDescription: $jobDescription, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }
}

class $PreferenceTable extends Preference
    with TableInfo<$PreferenceTable, PreferenceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PreferenceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<int> tenantId = GeneratedColumn<int>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _preferenceNameMeta =
      const VerificationMeta('preferenceName');
  @override
  late final GeneratedColumn<String> preferenceName = GeneratedColumn<String>(
      'preference_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
      'value', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _domainMeta = const VerificationMeta('domain');
  @override
  late final GeneratedColumn<String> domain = GeneratedColumn<String>(
      'domain', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isGlobalMeta =
      const VerificationMeta('isGlobal');
  @override
  late final GeneratedColumn<bool> isGlobal = GeneratedColumn<bool>(
      'is_global', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_global" IN (0, 1))'),
      defaultValue: Constant(true));
  static const VerificationMeta _syncErrorMeta =
      const VerificationMeta('syncError');
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
      'sync_error', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _expiredDateTimeMeta =
      const VerificationMeta('expiredDateTime');
  @override
  late final GeneratedColumn<DateTime> expiredDateTime =
      GeneratedColumn<DateTime>('expired_date_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _dataTypeMeta =
      const VerificationMeta('dataType');
  @override
  late final GeneratedColumn<String> dataType = GeneratedColumn<String>(
      'data_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dataValueMeta =
      const VerificationMeta('dataValue');
  @override
  late final GeneratedColumn<String> dataValue = GeneratedColumn<String>(
      'data_value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _groupsMeta = const VerificationMeta('groups');
  @override
  late final GeneratedColumn<String> groups = GeneratedColumn<String>(
      'groups', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        code,
        preferenceName,
        value,
        description,
        domain,
        isGlobal,
        syncError,
        expiredDateTime,
        dataType,
        dataValue,
        groups
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'preference';
  @override
  VerificationContext validateIntegrity(Insertable<PreferenceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('preference_name')) {
      context.handle(
          _preferenceNameMeta,
          preferenceName.isAcceptableOrUnknown(
              data['preference_name']!, _preferenceNameMeta));
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value']!, _valueMeta));
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('domain')) {
      context.handle(_domainMeta,
          domain.isAcceptableOrUnknown(data['domain']!, _domainMeta));
    }
    if (data.containsKey('is_global')) {
      context.handle(_isGlobalMeta,
          isGlobal.isAcceptableOrUnknown(data['is_global']!, _isGlobalMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta));
    }
    if (data.containsKey('expired_date_time')) {
      context.handle(
          _expiredDateTimeMeta,
          expiredDateTime.isAcceptableOrUnknown(
              data['expired_date_time']!, _expiredDateTimeMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type']!, _dataTypeMeta));
    }
    if (data.containsKey('data_value')) {
      context.handle(_dataValueMeta,
          dataValue.isAcceptableOrUnknown(data['data_value']!, _dataValueMeta));
    }
    if (data.containsKey('groups')) {
      context.handle(_groupsMeta,
          groups.isAcceptableOrUnknown(data['groups']!, _groupsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  PreferenceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PreferenceData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tenant_id'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      preferenceName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}preference_name']),
      value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}value'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      domain: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}domain']),
      isGlobal: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_global'])!,
      syncError: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sync_error']),
      expiredDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}expired_date_time']),
      dataType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_type']),
      dataValue: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_value']),
      groups: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}groups']),
    );
  }

  @override
  $PreferenceTable createAlias(String alias) {
    return $PreferenceTable(attachedDatabase, alias);
  }
}

class PreferenceData extends DataClass implements Insertable<PreferenceData> {
  final int id;
  final int tenantId;
  final String code;
  final String? preferenceName;
  final String value;
  final String? description;
  final String? domain;
  final bool isGlobal;
  final String? syncError;
  final DateTime? expiredDateTime;
  final String? dataType;
  final String? dataValue;
  final String? groups;
  const PreferenceData(
      {required this.id,
      required this.tenantId,
      required this.code,
      this.preferenceName,
      required this.value,
      this.description,
      this.domain,
      required this.isGlobal,
      this.syncError,
      this.expiredDateTime,
      this.dataType,
      this.dataValue,
      this.groups});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['tenant_id'] = Variable<int>(tenantId);
    map['code'] = Variable<String>(code);
    if (!nullToAbsent || preferenceName != null) {
      map['preference_name'] = Variable<String>(preferenceName);
    }
    map['value'] = Variable<String>(value);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || domain != null) {
      map['domain'] = Variable<String>(domain);
    }
    map['is_global'] = Variable<bool>(isGlobal);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || expiredDateTime != null) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || dataValue != null) {
      map['data_value'] = Variable<String>(dataValue);
    }
    if (!nullToAbsent || groups != null) {
      map['groups'] = Variable<String>(groups);
    }
    return map;
  }

  PreferenceCompanion toCompanion(bool nullToAbsent) {
    return PreferenceCompanion(
      id: Value(id),
      tenantId: Value(tenantId),
      code: Value(code),
      preferenceName: preferenceName == null && nullToAbsent
          ? const Value.absent()
          : Value(preferenceName),
      value: Value(value),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      domain:
          domain == null && nullToAbsent ? const Value.absent() : Value(domain),
      isGlobal: Value(isGlobal),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      expiredDateTime: expiredDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(expiredDateTime),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      dataValue: dataValue == null && nullToAbsent
          ? const Value.absent()
          : Value(dataValue),
      groups:
          groups == null && nullToAbsent ? const Value.absent() : Value(groups),
    );
  }

  factory PreferenceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PreferenceData(
      id: serializer.fromJson<int>(json['id']),
      tenantId: serializer.fromJson<int>(json['tenantId']),
      code: serializer.fromJson<String>(json['code']),
      preferenceName: serializer.fromJson<String?>(json['preferenceName']),
      value: serializer.fromJson<String>(json['value']),
      description: serializer.fromJson<String?>(json['description']),
      domain: serializer.fromJson<String?>(json['domain']),
      isGlobal: serializer.fromJson<bool>(json['isGlobal']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      expiredDateTime: serializer.fromJson<DateTime?>(json['expiredDateTime']),
      dataType: serializer.fromJson<String?>(json['dataType']),
      dataValue: serializer.fromJson<String?>(json['dataValue']),
      groups: serializer.fromJson<String?>(json['groups']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'tenantId': serializer.toJson<int>(tenantId),
      'code': serializer.toJson<String>(code),
      'preferenceName': serializer.toJson<String?>(preferenceName),
      'value': serializer.toJson<String>(value),
      'description': serializer.toJson<String?>(description),
      'domain': serializer.toJson<String?>(domain),
      'isGlobal': serializer.toJson<bool>(isGlobal),
      'syncError': serializer.toJson<String?>(syncError),
      'expiredDateTime': serializer.toJson<DateTime?>(expiredDateTime),
      'dataType': serializer.toJson<String?>(dataType),
      'dataValue': serializer.toJson<String?>(dataValue),
      'groups': serializer.toJson<String?>(groups),
    };
  }

  PreferenceData copyWith(
          {int? id,
          int? tenantId,
          String? code,
          Value<String?> preferenceName = const Value.absent(),
          String? value,
          Value<String?> description = const Value.absent(),
          Value<String?> domain = const Value.absent(),
          bool? isGlobal,
          Value<String?> syncError = const Value.absent(),
          Value<DateTime?> expiredDateTime = const Value.absent(),
          Value<String?> dataType = const Value.absent(),
          Value<String?> dataValue = const Value.absent(),
          Value<String?> groups = const Value.absent()}) =>
      PreferenceData(
        id: id ?? this.id,
        tenantId: tenantId ?? this.tenantId,
        code: code ?? this.code,
        preferenceName:
            preferenceName.present ? preferenceName.value : this.preferenceName,
        value: value ?? this.value,
        description: description.present ? description.value : this.description,
        domain: domain.present ? domain.value : this.domain,
        isGlobal: isGlobal ?? this.isGlobal,
        syncError: syncError.present ? syncError.value : this.syncError,
        expiredDateTime: expiredDateTime.present
            ? expiredDateTime.value
            : this.expiredDateTime,
        dataType: dataType.present ? dataType.value : this.dataType,
        dataValue: dataValue.present ? dataValue.value : this.dataValue,
        groups: groups.present ? groups.value : this.groups,
      );
  @override
  String toString() {
    return (StringBuffer('PreferenceData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('preferenceName: $preferenceName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('domain: $domain, ')
          ..write('isGlobal: $isGlobal, ')
          ..write('syncError: $syncError, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      tenantId,
      code,
      preferenceName,
      value,
      description,
      domain,
      isGlobal,
      syncError,
      expiredDateTime,
      dataType,
      dataValue,
      groups);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PreferenceData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.code == this.code &&
          other.preferenceName == this.preferenceName &&
          other.value == this.value &&
          other.description == this.description &&
          other.domain == this.domain &&
          other.isGlobal == this.isGlobal &&
          other.syncError == this.syncError &&
          other.expiredDateTime == this.expiredDateTime &&
          other.dataType == this.dataType &&
          other.dataValue == this.dataValue &&
          other.groups == this.groups);
}

class PreferenceCompanion extends UpdateCompanion<PreferenceData> {
  final Value<int> id;
  final Value<int> tenantId;
  final Value<String> code;
  final Value<String?> preferenceName;
  final Value<String> value;
  final Value<String?> description;
  final Value<String?> domain;
  final Value<bool> isGlobal;
  final Value<String?> syncError;
  final Value<DateTime?> expiredDateTime;
  final Value<String?> dataType;
  final Value<String?> dataValue;
  final Value<String?> groups;
  final Value<int> rowid;
  const PreferenceCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.code = const Value.absent(),
    this.preferenceName = const Value.absent(),
    this.value = const Value.absent(),
    this.description = const Value.absent(),
    this.domain = const Value.absent(),
    this.isGlobal = const Value.absent(),
    this.syncError = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PreferenceCompanion.insert({
    required int id,
    required int tenantId,
    required String code,
    this.preferenceName = const Value.absent(),
    required String value,
    this.description = const Value.absent(),
    this.domain = const Value.absent(),
    this.isGlobal = const Value.absent(),
    this.syncError = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        tenantId = Value(tenantId),
        code = Value(code),
        value = Value(value);
  static Insertable<PreferenceData> custom({
    Expression<int>? id,
    Expression<int>? tenantId,
    Expression<String>? code,
    Expression<String>? preferenceName,
    Expression<String>? value,
    Expression<String>? description,
    Expression<String>? domain,
    Expression<bool>? isGlobal,
    Expression<String>? syncError,
    Expression<DateTime>? expiredDateTime,
    Expression<String>? dataType,
    Expression<String>? dataValue,
    Expression<String>? groups,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (code != null) 'code': code,
      if (preferenceName != null) 'preference_name': preferenceName,
      if (value != null) 'value': value,
      if (description != null) 'description': description,
      if (domain != null) 'domain': domain,
      if (isGlobal != null) 'is_global': isGlobal,
      if (syncError != null) 'sync_error': syncError,
      if (expiredDateTime != null) 'expired_date_time': expiredDateTime,
      if (dataType != null) 'data_type': dataType,
      if (dataValue != null) 'data_value': dataValue,
      if (groups != null) 'groups': groups,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PreferenceCompanion copyWith(
      {Value<int>? id,
      Value<int>? tenantId,
      Value<String>? code,
      Value<String?>? preferenceName,
      Value<String>? value,
      Value<String?>? description,
      Value<String?>? domain,
      Value<bool>? isGlobal,
      Value<String?>? syncError,
      Value<DateTime?>? expiredDateTime,
      Value<String?>? dataType,
      Value<String?>? dataValue,
      Value<String?>? groups,
      Value<int>? rowid}) {
    return PreferenceCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      code: code ?? this.code,
      preferenceName: preferenceName ?? this.preferenceName,
      value: value ?? this.value,
      description: description ?? this.description,
      domain: domain ?? this.domain,
      isGlobal: isGlobal ?? this.isGlobal,
      syncError: syncError ?? this.syncError,
      expiredDateTime: expiredDateTime ?? this.expiredDateTime,
      dataType: dataType ?? this.dataType,
      dataValue: dataValue ?? this.dataValue,
      groups: groups ?? this.groups,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (preferenceName.present) {
      map['preference_name'] = Variable<String>(preferenceName.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (domain.present) {
      map['domain'] = Variable<String>(domain.value);
    }
    if (isGlobal.present) {
      map['is_global'] = Variable<bool>(isGlobal.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (expiredDateTime.present) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (dataValue.present) {
      map['data_value'] = Variable<String>(dataValue.value);
    }
    if (groups.present) {
      map['groups'] = Variable<String>(groups.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PreferenceCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('preferenceName: $preferenceName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('domain: $domain, ')
          ..write('isGlobal: $isGlobal, ')
          ..write('syncError: $syncError, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MobileDeviceTable extends MobileDevice
    with TableInfo<$MobileDeviceTable, MobileDeviceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MobileDeviceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _creationTimeMeta =
      const VerificationMeta('creationTime');
  @override
  late final GeneratedColumn<DateTime> creationTime = GeneratedColumn<DateTime>(
      'creation_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deleteTimeMeta =
      const VerificationMeta('deleteTime');
  @override
  late final GeneratedColumn<DateTime> deleteTime = GeneratedColumn<DateTime>(
      'delete_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createUserIdMeta =
      const VerificationMeta('createUserId');
  @override
  late final GeneratedColumn<int> createUserId = GeneratedColumn<int>(
      'create_user_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _creatorUserMeta =
      const VerificationMeta('creatorUser');
  @override
  late final GeneratedColumn<String> creatorUser = GeneratedColumn<String>(
      'creator_user', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastModifierUserMeta =
      const VerificationMeta('lastModifierUser');
  @override
  late final GeneratedColumn<String> lastModifierUser = GeneratedColumn<String>(
      'last_modifier_user', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastModifierUserIdMeta =
      const VerificationMeta('lastModifierUserId');
  @override
  late final GeneratedColumn<int> lastModifierUserId = GeneratedColumn<int>(
      'last_modifier_user_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _deleteUserIdMeta =
      const VerificationMeta('deleteUserId');
  @override
  late final GeneratedColumn<int> deleteUserId = GeneratedColumn<int>(
      'delete_user_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _deleterUserIdMeta =
      const VerificationMeta('deleterUserId');
  @override
  late final GeneratedColumn<String> deleterUserId = GeneratedColumn<String>(
      'deleter_user_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _importDateTimeMeta =
      const VerificationMeta('importDateTime');
  @override
  late final GeneratedColumn<DateTime> importDateTime =
      GeneratedColumn<DateTime>('import_date_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _exportDateTimeMeta =
      const VerificationMeta('exportDateTime');
  @override
  late final GeneratedColumn<DateTime> exportDateTime =
      GeneratedColumn<DateTime>('export_date_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _exportStatusMeta =
      const VerificationMeta('exportStatus');
  @override
  late final GeneratedColumn<String> exportStatus = GeneratedColumn<String>(
      'export_status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: Constant('Pending'));
  static const VerificationMeta _importStatusMeta =
      const VerificationMeta('importStatus');
  @override
  late final GeneratedColumn<String> importStatus = GeneratedColumn<String>(
      'import_status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: Constant('Pending'));
  static const VerificationMeta _syncErrorMeta =
      const VerificationMeta('syncError');
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
      'sync_error', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceIdMeta =
      const VerificationMeta('deviceId');
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
      'device_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceNameMeta =
      const VerificationMeta('deviceName');
  @override
  late final GeneratedColumn<String> deviceName = GeneratedColumn<String>(
      'device_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _versionReleaseMeta =
      const VerificationMeta('versionRelease');
  @override
  late final GeneratedColumn<String> versionRelease = GeneratedColumn<String>(
      'version_release', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _versionEnvrementMeta =
      const VerificationMeta('versionEnvrement');
  @override
  late final GeneratedColumn<String> versionEnvrement = GeneratedColumn<String>(
      'version_envrement', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _bootLoaderMeta =
      const VerificationMeta('bootLoader');
  @override
  late final GeneratedColumn<String> bootLoader = GeneratedColumn<String>(
      'boot_loader', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _manufactureMeta =
      const VerificationMeta('manufacture');
  @override
  late final GeneratedColumn<String> manufacture = GeneratedColumn<String>(
      'manufacture', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _modelMeta = const VerificationMeta('model');
  @override
  late final GeneratedColumn<String> model = GeneratedColumn<String>(
      'model', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _sdkNumberMeta =
      const VerificationMeta('sdkNumber');
  @override
  late final GeneratedColumn<int> sdkNumber = GeneratedColumn<int>(
      'sdk_number', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _hardwareMeta =
      const VerificationMeta('hardware');
  @override
  late final GeneratedColumn<String> hardware = GeneratedColumn<String>(
      'hardware', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceHostMeta =
      const VerificationMeta('deviceHost');
  @override
  late final GeneratedColumn<String> deviceHost = GeneratedColumn<String>(
      'device_host', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceTimeMeta =
      const VerificationMeta('deviceTime');
  @override
  late final GeneratedColumn<DateTime> deviceTime = GeneratedColumn<DateTime>(
      'device_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deviceSerialMeta =
      const VerificationMeta('deviceSerial');
  @override
  late final GeneratedColumn<String> deviceSerial = GeneratedColumn<String>(
      'device_serial', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceMacMeta =
      const VerificationMeta('deviceMac');
  @override
  late final GeneratedColumn<String> deviceMac = GeneratedColumn<String>(
      'device_mac', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceIpMeta =
      const VerificationMeta('deviceIp');
  @override
  late final GeneratedColumn<String> deviceIp = GeneratedColumn<String>(
      'device_ip', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceModeMeta =
      const VerificationMeta('deviceMode');
  @override
  late final GeneratedColumn<String> deviceMode = GeneratedColumn<String>(
      'device_mode', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _activationDateMeta =
      const VerificationMeta('activationDate');
  @override
  late final GeneratedColumn<DateTime> activationDate =
      GeneratedColumn<DateTime>('activation_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _expirationDateMeta =
      const VerificationMeta('expirationDate');
  @override
  late final GeneratedColumn<DateTime> expirationDate =
      GeneratedColumn<DateTime>('expiration_date', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deviceStatusMeta =
      const VerificationMeta('deviceStatus');
  @override
  late final GeneratedColumn<int> deviceStatus = GeneratedColumn<int>(
      'device_status', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _companyNameMeta =
      const VerificationMeta('companyName');
  @override
  late final GeneratedColumn<String> companyName = GeneratedColumn<String>(
      'company_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceNickNameMeta =
      const VerificationMeta('deviceNickName');
  @override
  late final GeneratedColumn<String> deviceNickName = GeneratedColumn<String>(
      'device_nick_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        creationTime,
        deleteTime,
        createUserId,
        creatorUser,
        lastModifierUser,
        lastModifierUserId,
        deleteUserId,
        deleterUserId,
        isDeleted,
        importDateTime,
        exportDateTime,
        exportStatus,
        importStatus,
        syncError,
        deviceId,
        deviceName,
        versionRelease,
        versionEnvrement,
        bootLoader,
        manufacture,
        model,
        sdkNumber,
        hardware,
        deviceHost,
        deviceTime,
        deviceSerial,
        deviceMac,
        deviceIp,
        deviceMode,
        activationDate,
        expirationDate,
        deviceStatus,
        companyName,
        deviceNickName,
        latitude,
        longitude,
        tenantId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'mobile_device';
  @override
  VerificationContext validateIntegrity(Insertable<MobileDeviceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creation_time')) {
      context.handle(
          _creationTimeMeta,
          creationTime.isAcceptableOrUnknown(
              data['creation_time']!, _creationTimeMeta));
    }
    if (data.containsKey('delete_time')) {
      context.handle(
          _deleteTimeMeta,
          deleteTime.isAcceptableOrUnknown(
              data['delete_time']!, _deleteTimeMeta));
    }
    if (data.containsKey('create_user_id')) {
      context.handle(
          _createUserIdMeta,
          createUserId.isAcceptableOrUnknown(
              data['create_user_id']!, _createUserIdMeta));
    }
    if (data.containsKey('creator_user')) {
      context.handle(
          _creatorUserMeta,
          creatorUser.isAcceptableOrUnknown(
              data['creator_user']!, _creatorUserMeta));
    }
    if (data.containsKey('last_modifier_user')) {
      context.handle(
          _lastModifierUserMeta,
          lastModifierUser.isAcceptableOrUnknown(
              data['last_modifier_user']!, _lastModifierUserMeta));
    }
    if (data.containsKey('last_modifier_user_id')) {
      context.handle(
          _lastModifierUserIdMeta,
          lastModifierUserId.isAcceptableOrUnknown(
              data['last_modifier_user_id']!, _lastModifierUserIdMeta));
    }
    if (data.containsKey('delete_user_id')) {
      context.handle(
          _deleteUserIdMeta,
          deleteUserId.isAcceptableOrUnknown(
              data['delete_user_id']!, _deleteUserIdMeta));
    }
    if (data.containsKey('deleter_user_id')) {
      context.handle(
          _deleterUserIdMeta,
          deleterUserId.isAcceptableOrUnknown(
              data['deleter_user_id']!, _deleterUserIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('import_date_time')) {
      context.handle(
          _importDateTimeMeta,
          importDateTime.isAcceptableOrUnknown(
              data['import_date_time']!, _importDateTimeMeta));
    }
    if (data.containsKey('export_date_time')) {
      context.handle(
          _exportDateTimeMeta,
          exportDateTime.isAcceptableOrUnknown(
              data['export_date_time']!, _exportDateTimeMeta));
    }
    if (data.containsKey('export_status')) {
      context.handle(
          _exportStatusMeta,
          exportStatus.isAcceptableOrUnknown(
              data['export_status']!, _exportStatusMeta));
    }
    if (data.containsKey('import_status')) {
      context.handle(
          _importStatusMeta,
          importStatus.isAcceptableOrUnknown(
              data['import_status']!, _importStatusMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta));
    }
    if (data.containsKey('device_id')) {
      context.handle(_deviceIdMeta,
          deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta));
    }
    if (data.containsKey('device_name')) {
      context.handle(
          _deviceNameMeta,
          deviceName.isAcceptableOrUnknown(
              data['device_name']!, _deviceNameMeta));
    }
    if (data.containsKey('version_release')) {
      context.handle(
          _versionReleaseMeta,
          versionRelease.isAcceptableOrUnknown(
              data['version_release']!, _versionReleaseMeta));
    }
    if (data.containsKey('version_envrement')) {
      context.handle(
          _versionEnvrementMeta,
          versionEnvrement.isAcceptableOrUnknown(
              data['version_envrement']!, _versionEnvrementMeta));
    }
    if (data.containsKey('boot_loader')) {
      context.handle(
          _bootLoaderMeta,
          bootLoader.isAcceptableOrUnknown(
              data['boot_loader']!, _bootLoaderMeta));
    }
    if (data.containsKey('manufacture')) {
      context.handle(
          _manufactureMeta,
          manufacture.isAcceptableOrUnknown(
              data['manufacture']!, _manufactureMeta));
    }
    if (data.containsKey('model')) {
      context.handle(
          _modelMeta, model.isAcceptableOrUnknown(data['model']!, _modelMeta));
    }
    if (data.containsKey('sdk_number')) {
      context.handle(_sdkNumberMeta,
          sdkNumber.isAcceptableOrUnknown(data['sdk_number']!, _sdkNumberMeta));
    }
    if (data.containsKey('hardware')) {
      context.handle(_hardwareMeta,
          hardware.isAcceptableOrUnknown(data['hardware']!, _hardwareMeta));
    }
    if (data.containsKey('device_host')) {
      context.handle(
          _deviceHostMeta,
          deviceHost.isAcceptableOrUnknown(
              data['device_host']!, _deviceHostMeta));
    }
    if (data.containsKey('device_time')) {
      context.handle(
          _deviceTimeMeta,
          deviceTime.isAcceptableOrUnknown(
              data['device_time']!, _deviceTimeMeta));
    }
    if (data.containsKey('device_serial')) {
      context.handle(
          _deviceSerialMeta,
          deviceSerial.isAcceptableOrUnknown(
              data['device_serial']!, _deviceSerialMeta));
    }
    if (data.containsKey('device_mac')) {
      context.handle(_deviceMacMeta,
          deviceMac.isAcceptableOrUnknown(data['device_mac']!, _deviceMacMeta));
    }
    if (data.containsKey('device_ip')) {
      context.handle(_deviceIpMeta,
          deviceIp.isAcceptableOrUnknown(data['device_ip']!, _deviceIpMeta));
    }
    if (data.containsKey('device_mode')) {
      context.handle(
          _deviceModeMeta,
          deviceMode.isAcceptableOrUnknown(
              data['device_mode']!, _deviceModeMeta));
    }
    if (data.containsKey('activation_date')) {
      context.handle(
          _activationDateMeta,
          activationDate.isAcceptableOrUnknown(
              data['activation_date']!, _activationDateMeta));
    }
    if (data.containsKey('expiration_date')) {
      context.handle(
          _expirationDateMeta,
          expirationDate.isAcceptableOrUnknown(
              data['expiration_date']!, _expirationDateMeta));
    }
    if (data.containsKey('device_status')) {
      context.handle(
          _deviceStatusMeta,
          deviceStatus.isAcceptableOrUnknown(
              data['device_status']!, _deviceStatusMeta));
    }
    if (data.containsKey('company_name')) {
      context.handle(
          _companyNameMeta,
          companyName.isAcceptableOrUnknown(
              data['company_name']!, _companyNameMeta));
    }
    if (data.containsKey('device_nick_name')) {
      context.handle(
          _deviceNickNameMeta,
          deviceNickName.isAcceptableOrUnknown(
              data['device_nick_name']!, _deviceNickNameMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {deviceId};
  @override
  MobileDeviceData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MobileDeviceData(
      creationTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}creation_time']),
      deleteTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}delete_time']),
      createUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}create_user_id']),
      creatorUser: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}creator_user']),
      lastModifierUser: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}last_modifier_user']),
      lastModifierUserId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}last_modifier_user_id']),
      deleteUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}delete_user_id']),
      deleterUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}deleter_user_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      importDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}import_date_time']),
      exportDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}export_date_time']),
      exportStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}export_status'])!,
      importStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}import_status'])!,
      syncError: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sync_error']),
      deviceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_id']),
      deviceName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_name']),
      versionRelease: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}version_release']),
      versionEnvrement: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}version_envrement']),
      bootLoader: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}boot_loader']),
      manufacture: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}manufacture']),
      model: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}model']),
      sdkNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}sdk_number']),
      hardware: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}hardware']),
      deviceHost: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_host']),
      deviceTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}device_time']),
      deviceSerial: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_serial']),
      deviceMac: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_mac']),
      deviceIp: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_ip']),
      deviceMode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_mode']),
      activationDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}activation_date']),
      expirationDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}expiration_date']),
      deviceStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}device_status']),
      companyName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}company_name']),
      deviceNickName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}device_nick_name']),
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude']),
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
    );
  }

  @override
  $MobileDeviceTable createAlias(String alias) {
    return $MobileDeviceTable(attachedDatabase, alias);
  }
}

class MobileDeviceData extends DataClass
    implements Insertable<MobileDeviceData> {
  final DateTime? creationTime;
  final DateTime? deleteTime;
  final int? createUserId;
  final String? creatorUser;
  final String? lastModifierUser;
  final int? lastModifierUserId;
  final int? deleteUserId;
  final String? deleterUserId;
  final bool isDeleted;
  final DateTime? importDateTime;
  final DateTime? exportDateTime;
  final String exportStatus;
  final String importStatus;
  final String? syncError;
  final String? deviceId;
  final String? deviceName;
  final String? versionRelease;
  final String? versionEnvrement;
  final String? bootLoader;
  final String? manufacture;
  final String? model;
  final int? sdkNumber;
  final String? hardware;
  final String? deviceHost;
  final DateTime? deviceTime;
  final String? deviceSerial;
  final String? deviceMac;
  final String? deviceIp;
  final String? deviceMode;
  final DateTime? activationDate;
  final DateTime? expirationDate;
  final int? deviceStatus;
  final String? companyName;
  final String? deviceNickName;
  final double? latitude;
  final double? longitude;
  final String? tenantId;
  const MobileDeviceData(
      {this.creationTime,
      this.deleteTime,
      this.createUserId,
      this.creatorUser,
      this.lastModifierUser,
      this.lastModifierUserId,
      this.deleteUserId,
      this.deleterUserId,
      required this.isDeleted,
      this.importDateTime,
      this.exportDateTime,
      required this.exportStatus,
      required this.importStatus,
      this.syncError,
      this.deviceId,
      this.deviceName,
      this.versionRelease,
      this.versionEnvrement,
      this.bootLoader,
      this.manufacture,
      this.model,
      this.sdkNumber,
      this.hardware,
      this.deviceHost,
      this.deviceTime,
      this.deviceSerial,
      this.deviceMac,
      this.deviceIp,
      this.deviceMode,
      this.activationDate,
      this.expirationDate,
      this.deviceStatus,
      this.companyName,
      this.deviceNickName,
      this.latitude,
      this.longitude,
      this.tenantId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || creationTime != null) {
      map['creation_time'] = Variable<DateTime>(creationTime);
    }
    if (!nullToAbsent || deleteTime != null) {
      map['delete_time'] = Variable<DateTime>(deleteTime);
    }
    if (!nullToAbsent || createUserId != null) {
      map['create_user_id'] = Variable<int>(createUserId);
    }
    if (!nullToAbsent || creatorUser != null) {
      map['creator_user'] = Variable<String>(creatorUser);
    }
    if (!nullToAbsent || lastModifierUser != null) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser);
    }
    if (!nullToAbsent || lastModifierUserId != null) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId);
    }
    if (!nullToAbsent || deleteUserId != null) {
      map['delete_user_id'] = Variable<int>(deleteUserId);
    }
    if (!nullToAbsent || deleterUserId != null) {
      map['deleter_user_id'] = Variable<String>(deleterUserId);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || importDateTime != null) {
      map['import_date_time'] = Variable<DateTime>(importDateTime);
    }
    if (!nullToAbsent || exportDateTime != null) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime);
    }
    map['export_status'] = Variable<String>(exportStatus);
    map['import_status'] = Variable<String>(importStatus);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || deviceName != null) {
      map['device_name'] = Variable<String>(deviceName);
    }
    if (!nullToAbsent || versionRelease != null) {
      map['version_release'] = Variable<String>(versionRelease);
    }
    if (!nullToAbsent || versionEnvrement != null) {
      map['version_envrement'] = Variable<String>(versionEnvrement);
    }
    if (!nullToAbsent || bootLoader != null) {
      map['boot_loader'] = Variable<String>(bootLoader);
    }
    if (!nullToAbsent || manufacture != null) {
      map['manufacture'] = Variable<String>(manufacture);
    }
    if (!nullToAbsent || model != null) {
      map['model'] = Variable<String>(model);
    }
    if (!nullToAbsent || sdkNumber != null) {
      map['sdk_number'] = Variable<int>(sdkNumber);
    }
    if (!nullToAbsent || hardware != null) {
      map['hardware'] = Variable<String>(hardware);
    }
    if (!nullToAbsent || deviceHost != null) {
      map['device_host'] = Variable<String>(deviceHost);
    }
    if (!nullToAbsent || deviceTime != null) {
      map['device_time'] = Variable<DateTime>(deviceTime);
    }
    if (!nullToAbsent || deviceSerial != null) {
      map['device_serial'] = Variable<String>(deviceSerial);
    }
    if (!nullToAbsent || deviceMac != null) {
      map['device_mac'] = Variable<String>(deviceMac);
    }
    if (!nullToAbsent || deviceIp != null) {
      map['device_ip'] = Variable<String>(deviceIp);
    }
    if (!nullToAbsent || deviceMode != null) {
      map['device_mode'] = Variable<String>(deviceMode);
    }
    if (!nullToAbsent || activationDate != null) {
      map['activation_date'] = Variable<DateTime>(activationDate);
    }
    if (!nullToAbsent || expirationDate != null) {
      map['expiration_date'] = Variable<DateTime>(expirationDate);
    }
    if (!nullToAbsent || deviceStatus != null) {
      map['device_status'] = Variable<int>(deviceStatus);
    }
    if (!nullToAbsent || companyName != null) {
      map['company_name'] = Variable<String>(companyName);
    }
    if (!nullToAbsent || deviceNickName != null) {
      map['device_nick_name'] = Variable<String>(deviceNickName);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    return map;
  }

  MobileDeviceCompanion toCompanion(bool nullToAbsent) {
    return MobileDeviceCompanion(
      creationTime: creationTime == null && nullToAbsent
          ? const Value.absent()
          : Value(creationTime),
      deleteTime: deleteTime == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteTime),
      createUserId: createUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(createUserId),
      creatorUser: creatorUser == null && nullToAbsent
          ? const Value.absent()
          : Value(creatorUser),
      lastModifierUser: lastModifierUser == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUser),
      lastModifierUserId: lastModifierUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUserId),
      deleteUserId: deleteUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteUserId),
      deleterUserId: deleterUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleterUserId),
      isDeleted: Value(isDeleted),
      importDateTime: importDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(importDateTime),
      exportDateTime: exportDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(exportDateTime),
      exportStatus: Value(exportStatus),
      importStatus: Value(importStatus),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      deviceName: deviceName == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceName),
      versionRelease: versionRelease == null && nullToAbsent
          ? const Value.absent()
          : Value(versionRelease),
      versionEnvrement: versionEnvrement == null && nullToAbsent
          ? const Value.absent()
          : Value(versionEnvrement),
      bootLoader: bootLoader == null && nullToAbsent
          ? const Value.absent()
          : Value(bootLoader),
      manufacture: manufacture == null && nullToAbsent
          ? const Value.absent()
          : Value(manufacture),
      model:
          model == null && nullToAbsent ? const Value.absent() : Value(model),
      sdkNumber: sdkNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(sdkNumber),
      hardware: hardware == null && nullToAbsent
          ? const Value.absent()
          : Value(hardware),
      deviceHost: deviceHost == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceHost),
      deviceTime: deviceTime == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceTime),
      deviceSerial: deviceSerial == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceSerial),
      deviceMac: deviceMac == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceMac),
      deviceIp: deviceIp == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceIp),
      deviceMode: deviceMode == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceMode),
      activationDate: activationDate == null && nullToAbsent
          ? const Value.absent()
          : Value(activationDate),
      expirationDate: expirationDate == null && nullToAbsent
          ? const Value.absent()
          : Value(expirationDate),
      deviceStatus: deviceStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceStatus),
      companyName: companyName == null && nullToAbsent
          ? const Value.absent()
          : Value(companyName),
      deviceNickName: deviceNickName == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceNickName),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory MobileDeviceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MobileDeviceData(
      creationTime: serializer.fromJson<DateTime?>(json['creationTime']),
      deleteTime: serializer.fromJson<DateTime?>(json['deleteTime']),
      createUserId: serializer.fromJson<int?>(json['createUserId']),
      creatorUser: serializer.fromJson<String?>(json['creatorUser']),
      lastModifierUser: serializer.fromJson<String?>(json['lastModifierUser']),
      lastModifierUserId: serializer.fromJson<int?>(json['lastModifierUserId']),
      deleteUserId: serializer.fromJson<int?>(json['deleteUserId']),
      deleterUserId: serializer.fromJson<String?>(json['deleterUserId']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      importDateTime: serializer.fromJson<DateTime?>(json['importDateTime']),
      exportDateTime: serializer.fromJson<DateTime?>(json['exportDateTime']),
      exportStatus: serializer.fromJson<String>(json['exportStatus']),
      importStatus: serializer.fromJson<String>(json['importStatus']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      deviceId: serializer.fromJson<String?>(json['deviceId']),
      deviceName: serializer.fromJson<String?>(json['deviceName']),
      versionRelease: serializer.fromJson<String?>(json['versionRelease']),
      versionEnvrement: serializer.fromJson<String?>(json['versionEnvrement']),
      bootLoader: serializer.fromJson<String?>(json['bootLoader']),
      manufacture: serializer.fromJson<String?>(json['manufacture']),
      model: serializer.fromJson<String?>(json['model']),
      sdkNumber: serializer.fromJson<int?>(json['sdkNumber']),
      hardware: serializer.fromJson<String?>(json['hardware']),
      deviceHost: serializer.fromJson<String?>(json['deviceHost']),
      deviceTime: serializer.fromJson<DateTime?>(json['deviceTime']),
      deviceSerial: serializer.fromJson<String?>(json['deviceSerial']),
      deviceMac: serializer.fromJson<String?>(json['deviceMac']),
      deviceIp: serializer.fromJson<String?>(json['deviceIp']),
      deviceMode: serializer.fromJson<String?>(json['deviceMode']),
      activationDate: serializer.fromJson<DateTime?>(json['activationDate']),
      expirationDate: serializer.fromJson<DateTime?>(json['expirationDate']),
      deviceStatus: serializer.fromJson<int?>(json['deviceStatus']),
      companyName: serializer.fromJson<String?>(json['companyName']),
      deviceNickName: serializer.fromJson<String?>(json['deviceNickName']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creationTime': serializer.toJson<DateTime?>(creationTime),
      'deleteTime': serializer.toJson<DateTime?>(deleteTime),
      'createUserId': serializer.toJson<int?>(createUserId),
      'creatorUser': serializer.toJson<String?>(creatorUser),
      'lastModifierUser': serializer.toJson<String?>(lastModifierUser),
      'lastModifierUserId': serializer.toJson<int?>(lastModifierUserId),
      'deleteUserId': serializer.toJson<int?>(deleteUserId),
      'deleterUserId': serializer.toJson<String?>(deleterUserId),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'importDateTime': serializer.toJson<DateTime?>(importDateTime),
      'exportDateTime': serializer.toJson<DateTime?>(exportDateTime),
      'exportStatus': serializer.toJson<String>(exportStatus),
      'importStatus': serializer.toJson<String>(importStatus),
      'syncError': serializer.toJson<String?>(syncError),
      'deviceId': serializer.toJson<String?>(deviceId),
      'deviceName': serializer.toJson<String?>(deviceName),
      'versionRelease': serializer.toJson<String?>(versionRelease),
      'versionEnvrement': serializer.toJson<String?>(versionEnvrement),
      'bootLoader': serializer.toJson<String?>(bootLoader),
      'manufacture': serializer.toJson<String?>(manufacture),
      'model': serializer.toJson<String?>(model),
      'sdkNumber': serializer.toJson<int?>(sdkNumber),
      'hardware': serializer.toJson<String?>(hardware),
      'deviceHost': serializer.toJson<String?>(deviceHost),
      'deviceTime': serializer.toJson<DateTime?>(deviceTime),
      'deviceSerial': serializer.toJson<String?>(deviceSerial),
      'deviceMac': serializer.toJson<String?>(deviceMac),
      'deviceIp': serializer.toJson<String?>(deviceIp),
      'deviceMode': serializer.toJson<String?>(deviceMode),
      'activationDate': serializer.toJson<DateTime?>(activationDate),
      'expirationDate': serializer.toJson<DateTime?>(expirationDate),
      'deviceStatus': serializer.toJson<int?>(deviceStatus),
      'companyName': serializer.toJson<String?>(companyName),
      'deviceNickName': serializer.toJson<String?>(deviceNickName),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'tenantId': serializer.toJson<String?>(tenantId),
    };
  }

  MobileDeviceData copyWith(
          {Value<DateTime?> creationTime = const Value.absent(),
          Value<DateTime?> deleteTime = const Value.absent(),
          Value<int?> createUserId = const Value.absent(),
          Value<String?> creatorUser = const Value.absent(),
          Value<String?> lastModifierUser = const Value.absent(),
          Value<int?> lastModifierUserId = const Value.absent(),
          Value<int?> deleteUserId = const Value.absent(),
          Value<String?> deleterUserId = const Value.absent(),
          bool? isDeleted,
          Value<DateTime?> importDateTime = const Value.absent(),
          Value<DateTime?> exportDateTime = const Value.absent(),
          String? exportStatus,
          String? importStatus,
          Value<String?> syncError = const Value.absent(),
          Value<String?> deviceId = const Value.absent(),
          Value<String?> deviceName = const Value.absent(),
          Value<String?> versionRelease = const Value.absent(),
          Value<String?> versionEnvrement = const Value.absent(),
          Value<String?> bootLoader = const Value.absent(),
          Value<String?> manufacture = const Value.absent(),
          Value<String?> model = const Value.absent(),
          Value<int?> sdkNumber = const Value.absent(),
          Value<String?> hardware = const Value.absent(),
          Value<String?> deviceHost = const Value.absent(),
          Value<DateTime?> deviceTime = const Value.absent(),
          Value<String?> deviceSerial = const Value.absent(),
          Value<String?> deviceMac = const Value.absent(),
          Value<String?> deviceIp = const Value.absent(),
          Value<String?> deviceMode = const Value.absent(),
          Value<DateTime?> activationDate = const Value.absent(),
          Value<DateTime?> expirationDate = const Value.absent(),
          Value<int?> deviceStatus = const Value.absent(),
          Value<String?> companyName = const Value.absent(),
          Value<String?> deviceNickName = const Value.absent(),
          Value<double?> latitude = const Value.absent(),
          Value<double?> longitude = const Value.absent(),
          Value<String?> tenantId = const Value.absent()}) =>
      MobileDeviceData(
        creationTime:
            creationTime.present ? creationTime.value : this.creationTime,
        deleteTime: deleteTime.present ? deleteTime.value : this.deleteTime,
        createUserId:
            createUserId.present ? createUserId.value : this.createUserId,
        creatorUser: creatorUser.present ? creatorUser.value : this.creatorUser,
        lastModifierUser: lastModifierUser.present
            ? lastModifierUser.value
            : this.lastModifierUser,
        lastModifierUserId: lastModifierUserId.present
            ? lastModifierUserId.value
            : this.lastModifierUserId,
        deleteUserId:
            deleteUserId.present ? deleteUserId.value : this.deleteUserId,
        deleterUserId:
            deleterUserId.present ? deleterUserId.value : this.deleterUserId,
        isDeleted: isDeleted ?? this.isDeleted,
        importDateTime:
            importDateTime.present ? importDateTime.value : this.importDateTime,
        exportDateTime:
            exportDateTime.present ? exportDateTime.value : this.exportDateTime,
        exportStatus: exportStatus ?? this.exportStatus,
        importStatus: importStatus ?? this.importStatus,
        syncError: syncError.present ? syncError.value : this.syncError,
        deviceId: deviceId.present ? deviceId.value : this.deviceId,
        deviceName: deviceName.present ? deviceName.value : this.deviceName,
        versionRelease:
            versionRelease.present ? versionRelease.value : this.versionRelease,
        versionEnvrement: versionEnvrement.present
            ? versionEnvrement.value
            : this.versionEnvrement,
        bootLoader: bootLoader.present ? bootLoader.value : this.bootLoader,
        manufacture: manufacture.present ? manufacture.value : this.manufacture,
        model: model.present ? model.value : this.model,
        sdkNumber: sdkNumber.present ? sdkNumber.value : this.sdkNumber,
        hardware: hardware.present ? hardware.value : this.hardware,
        deviceHost: deviceHost.present ? deviceHost.value : this.deviceHost,
        deviceTime: deviceTime.present ? deviceTime.value : this.deviceTime,
        deviceSerial:
            deviceSerial.present ? deviceSerial.value : this.deviceSerial,
        deviceMac: deviceMac.present ? deviceMac.value : this.deviceMac,
        deviceIp: deviceIp.present ? deviceIp.value : this.deviceIp,
        deviceMode: deviceMode.present ? deviceMode.value : this.deviceMode,
        activationDate:
            activationDate.present ? activationDate.value : this.activationDate,
        expirationDate:
            expirationDate.present ? expirationDate.value : this.expirationDate,
        deviceStatus:
            deviceStatus.present ? deviceStatus.value : this.deviceStatus,
        companyName: companyName.present ? companyName.value : this.companyName,
        deviceNickName:
            deviceNickName.present ? deviceNickName.value : this.deviceNickName,
        latitude: latitude.present ? latitude.value : this.latitude,
        longitude: longitude.present ? longitude.value : this.longitude,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('MobileDeviceData(')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('createUserId: $createUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('importDateTime: $importDateTime, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('importStatus: $importStatus, ')
          ..write('syncError: $syncError, ')
          ..write('deviceId: $deviceId, ')
          ..write('deviceName: $deviceName, ')
          ..write('versionRelease: $versionRelease, ')
          ..write('versionEnvrement: $versionEnvrement, ')
          ..write('bootLoader: $bootLoader, ')
          ..write('manufacture: $manufacture, ')
          ..write('model: $model, ')
          ..write('sdkNumber: $sdkNumber, ')
          ..write('hardware: $hardware, ')
          ..write('deviceHost: $deviceHost, ')
          ..write('deviceTime: $deviceTime, ')
          ..write('deviceSerial: $deviceSerial, ')
          ..write('deviceMac: $deviceMac, ')
          ..write('deviceIp: $deviceIp, ')
          ..write('deviceMode: $deviceMode, ')
          ..write('activationDate: $activationDate, ')
          ..write('expirationDate: $expirationDate, ')
          ..write('deviceStatus: $deviceStatus, ')
          ..write('companyName: $companyName, ')
          ..write('deviceNickName: $deviceNickName, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        creationTime,
        deleteTime,
        createUserId,
        creatorUser,
        lastModifierUser,
        lastModifierUserId,
        deleteUserId,
        deleterUserId,
        isDeleted,
        importDateTime,
        exportDateTime,
        exportStatus,
        importStatus,
        syncError,
        deviceId,
        deviceName,
        versionRelease,
        versionEnvrement,
        bootLoader,
        manufacture,
        model,
        sdkNumber,
        hardware,
        deviceHost,
        deviceTime,
        deviceSerial,
        deviceMac,
        deviceIp,
        deviceMode,
        activationDate,
        expirationDate,
        deviceStatus,
        companyName,
        deviceNickName,
        latitude,
        longitude,
        tenantId
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MobileDeviceData &&
          other.creationTime == this.creationTime &&
          other.deleteTime == this.deleteTime &&
          other.createUserId == this.createUserId &&
          other.creatorUser == this.creatorUser &&
          other.lastModifierUser == this.lastModifierUser &&
          other.lastModifierUserId == this.lastModifierUserId &&
          other.deleteUserId == this.deleteUserId &&
          other.deleterUserId == this.deleterUserId &&
          other.isDeleted == this.isDeleted &&
          other.importDateTime == this.importDateTime &&
          other.exportDateTime == this.exportDateTime &&
          other.exportStatus == this.exportStatus &&
          other.importStatus == this.importStatus &&
          other.syncError == this.syncError &&
          other.deviceId == this.deviceId &&
          other.deviceName == this.deviceName &&
          other.versionRelease == this.versionRelease &&
          other.versionEnvrement == this.versionEnvrement &&
          other.bootLoader == this.bootLoader &&
          other.manufacture == this.manufacture &&
          other.model == this.model &&
          other.sdkNumber == this.sdkNumber &&
          other.hardware == this.hardware &&
          other.deviceHost == this.deviceHost &&
          other.deviceTime == this.deviceTime &&
          other.deviceSerial == this.deviceSerial &&
          other.deviceMac == this.deviceMac &&
          other.deviceIp == this.deviceIp &&
          other.deviceMode == this.deviceMode &&
          other.activationDate == this.activationDate &&
          other.expirationDate == this.expirationDate &&
          other.deviceStatus == this.deviceStatus &&
          other.companyName == this.companyName &&
          other.deviceNickName == this.deviceNickName &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.tenantId == this.tenantId);
}

class MobileDeviceCompanion extends UpdateCompanion<MobileDeviceData> {
  final Value<DateTime?> creationTime;
  final Value<DateTime?> deleteTime;
  final Value<int?> createUserId;
  final Value<String?> creatorUser;
  final Value<String?> lastModifierUser;
  final Value<int?> lastModifierUserId;
  final Value<int?> deleteUserId;
  final Value<String?> deleterUserId;
  final Value<bool> isDeleted;
  final Value<DateTime?> importDateTime;
  final Value<DateTime?> exportDateTime;
  final Value<String> exportStatus;
  final Value<String> importStatus;
  final Value<String?> syncError;
  final Value<String?> deviceId;
  final Value<String?> deviceName;
  final Value<String?> versionRelease;
  final Value<String?> versionEnvrement;
  final Value<String?> bootLoader;
  final Value<String?> manufacture;
  final Value<String?> model;
  final Value<int?> sdkNumber;
  final Value<String?> hardware;
  final Value<String?> deviceHost;
  final Value<DateTime?> deviceTime;
  final Value<String?> deviceSerial;
  final Value<String?> deviceMac;
  final Value<String?> deviceIp;
  final Value<String?> deviceMode;
  final Value<DateTime?> activationDate;
  final Value<DateTime?> expirationDate;
  final Value<int?> deviceStatus;
  final Value<String?> companyName;
  final Value<String?> deviceNickName;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<String?> tenantId;
  final Value<int> rowid;
  const MobileDeviceCompanion({
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.importDateTime = const Value.absent(),
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.importStatus = const Value.absent(),
    this.syncError = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.deviceName = const Value.absent(),
    this.versionRelease = const Value.absent(),
    this.versionEnvrement = const Value.absent(),
    this.bootLoader = const Value.absent(),
    this.manufacture = const Value.absent(),
    this.model = const Value.absent(),
    this.sdkNumber = const Value.absent(),
    this.hardware = const Value.absent(),
    this.deviceHost = const Value.absent(),
    this.deviceTime = const Value.absent(),
    this.deviceSerial = const Value.absent(),
    this.deviceMac = const Value.absent(),
    this.deviceIp = const Value.absent(),
    this.deviceMode = const Value.absent(),
    this.activationDate = const Value.absent(),
    this.expirationDate = const Value.absent(),
    this.deviceStatus = const Value.absent(),
    this.companyName = const Value.absent(),
    this.deviceNickName = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MobileDeviceCompanion.insert({
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.importDateTime = const Value.absent(),
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.importStatus = const Value.absent(),
    this.syncError = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.deviceName = const Value.absent(),
    this.versionRelease = const Value.absent(),
    this.versionEnvrement = const Value.absent(),
    this.bootLoader = const Value.absent(),
    this.manufacture = const Value.absent(),
    this.model = const Value.absent(),
    this.sdkNumber = const Value.absent(),
    this.hardware = const Value.absent(),
    this.deviceHost = const Value.absent(),
    this.deviceTime = const Value.absent(),
    this.deviceSerial = const Value.absent(),
    this.deviceMac = const Value.absent(),
    this.deviceIp = const Value.absent(),
    this.deviceMode = const Value.absent(),
    this.activationDate = const Value.absent(),
    this.expirationDate = const Value.absent(),
    this.deviceStatus = const Value.absent(),
    this.companyName = const Value.absent(),
    this.deviceNickName = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  static Insertable<MobileDeviceData> custom({
    Expression<DateTime>? creationTime,
    Expression<DateTime>? deleteTime,
    Expression<int>? createUserId,
    Expression<String>? creatorUser,
    Expression<String>? lastModifierUser,
    Expression<int>? lastModifierUserId,
    Expression<int>? deleteUserId,
    Expression<String>? deleterUserId,
    Expression<bool>? isDeleted,
    Expression<DateTime>? importDateTime,
    Expression<DateTime>? exportDateTime,
    Expression<String>? exportStatus,
    Expression<String>? importStatus,
    Expression<String>? syncError,
    Expression<String>? deviceId,
    Expression<String>? deviceName,
    Expression<String>? versionRelease,
    Expression<String>? versionEnvrement,
    Expression<String>? bootLoader,
    Expression<String>? manufacture,
    Expression<String>? model,
    Expression<int>? sdkNumber,
    Expression<String>? hardware,
    Expression<String>? deviceHost,
    Expression<DateTime>? deviceTime,
    Expression<String>? deviceSerial,
    Expression<String>? deviceMac,
    Expression<String>? deviceIp,
    Expression<String>? deviceMode,
    Expression<DateTime>? activationDate,
    Expression<DateTime>? expirationDate,
    Expression<int>? deviceStatus,
    Expression<String>? companyName,
    Expression<String>? deviceNickName,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? tenantId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (creationTime != null) 'creation_time': creationTime,
      if (deleteTime != null) 'delete_time': deleteTime,
      if (createUserId != null) 'create_user_id': createUserId,
      if (creatorUser != null) 'creator_user': creatorUser,
      if (lastModifierUser != null) 'last_modifier_user': lastModifierUser,
      if (lastModifierUserId != null)
        'last_modifier_user_id': lastModifierUserId,
      if (deleteUserId != null) 'delete_user_id': deleteUserId,
      if (deleterUserId != null) 'deleter_user_id': deleterUserId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (importDateTime != null) 'import_date_time': importDateTime,
      if (exportDateTime != null) 'export_date_time': exportDateTime,
      if (exportStatus != null) 'export_status': exportStatus,
      if (importStatus != null) 'import_status': importStatus,
      if (syncError != null) 'sync_error': syncError,
      if (deviceId != null) 'device_id': deviceId,
      if (deviceName != null) 'device_name': deviceName,
      if (versionRelease != null) 'version_release': versionRelease,
      if (versionEnvrement != null) 'version_envrement': versionEnvrement,
      if (bootLoader != null) 'boot_loader': bootLoader,
      if (manufacture != null) 'manufacture': manufacture,
      if (model != null) 'model': model,
      if (sdkNumber != null) 'sdk_number': sdkNumber,
      if (hardware != null) 'hardware': hardware,
      if (deviceHost != null) 'device_host': deviceHost,
      if (deviceTime != null) 'device_time': deviceTime,
      if (deviceSerial != null) 'device_serial': deviceSerial,
      if (deviceMac != null) 'device_mac': deviceMac,
      if (deviceIp != null) 'device_ip': deviceIp,
      if (deviceMode != null) 'device_mode': deviceMode,
      if (activationDate != null) 'activation_date': activationDate,
      if (expirationDate != null) 'expiration_date': expirationDate,
      if (deviceStatus != null) 'device_status': deviceStatus,
      if (companyName != null) 'company_name': companyName,
      if (deviceNickName != null) 'device_nick_name': deviceNickName,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (tenantId != null) 'tenant_id': tenantId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MobileDeviceCompanion copyWith(
      {Value<DateTime?>? creationTime,
      Value<DateTime?>? deleteTime,
      Value<int?>? createUserId,
      Value<String?>? creatorUser,
      Value<String?>? lastModifierUser,
      Value<int?>? lastModifierUserId,
      Value<int?>? deleteUserId,
      Value<String?>? deleterUserId,
      Value<bool>? isDeleted,
      Value<DateTime?>? importDateTime,
      Value<DateTime?>? exportDateTime,
      Value<String>? exportStatus,
      Value<String>? importStatus,
      Value<String?>? syncError,
      Value<String?>? deviceId,
      Value<String?>? deviceName,
      Value<String?>? versionRelease,
      Value<String?>? versionEnvrement,
      Value<String?>? bootLoader,
      Value<String?>? manufacture,
      Value<String?>? model,
      Value<int?>? sdkNumber,
      Value<String?>? hardware,
      Value<String?>? deviceHost,
      Value<DateTime?>? deviceTime,
      Value<String?>? deviceSerial,
      Value<String?>? deviceMac,
      Value<String?>? deviceIp,
      Value<String?>? deviceMode,
      Value<DateTime?>? activationDate,
      Value<DateTime?>? expirationDate,
      Value<int?>? deviceStatus,
      Value<String?>? companyName,
      Value<String?>? deviceNickName,
      Value<double?>? latitude,
      Value<double?>? longitude,
      Value<String?>? tenantId,
      Value<int>? rowid}) {
    return MobileDeviceCompanion(
      creationTime: creationTime ?? this.creationTime,
      deleteTime: deleteTime ?? this.deleteTime,
      createUserId: createUserId ?? this.createUserId,
      creatorUser: creatorUser ?? this.creatorUser,
      lastModifierUser: lastModifierUser ?? this.lastModifierUser,
      lastModifierUserId: lastModifierUserId ?? this.lastModifierUserId,
      deleteUserId: deleteUserId ?? this.deleteUserId,
      deleterUserId: deleterUserId ?? this.deleterUserId,
      isDeleted: isDeleted ?? this.isDeleted,
      importDateTime: importDateTime ?? this.importDateTime,
      exportDateTime: exportDateTime ?? this.exportDateTime,
      exportStatus: exportStatus ?? this.exportStatus,
      importStatus: importStatus ?? this.importStatus,
      syncError: syncError ?? this.syncError,
      deviceId: deviceId ?? this.deviceId,
      deviceName: deviceName ?? this.deviceName,
      versionRelease: versionRelease ?? this.versionRelease,
      versionEnvrement: versionEnvrement ?? this.versionEnvrement,
      bootLoader: bootLoader ?? this.bootLoader,
      manufacture: manufacture ?? this.manufacture,
      model: model ?? this.model,
      sdkNumber: sdkNumber ?? this.sdkNumber,
      hardware: hardware ?? this.hardware,
      deviceHost: deviceHost ?? this.deviceHost,
      deviceTime: deviceTime ?? this.deviceTime,
      deviceSerial: deviceSerial ?? this.deviceSerial,
      deviceMac: deviceMac ?? this.deviceMac,
      deviceIp: deviceIp ?? this.deviceIp,
      deviceMode: deviceMode ?? this.deviceMode,
      activationDate: activationDate ?? this.activationDate,
      expirationDate: expirationDate ?? this.expirationDate,
      deviceStatus: deviceStatus ?? this.deviceStatus,
      companyName: companyName ?? this.companyName,
      deviceNickName: deviceNickName ?? this.deviceNickName,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      tenantId: tenantId ?? this.tenantId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creationTime.present) {
      map['creation_time'] = Variable<DateTime>(creationTime.value);
    }
    if (deleteTime.present) {
      map['delete_time'] = Variable<DateTime>(deleteTime.value);
    }
    if (createUserId.present) {
      map['create_user_id'] = Variable<int>(createUserId.value);
    }
    if (creatorUser.present) {
      map['creator_user'] = Variable<String>(creatorUser.value);
    }
    if (lastModifierUser.present) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser.value);
    }
    if (lastModifierUserId.present) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId.value);
    }
    if (deleteUserId.present) {
      map['delete_user_id'] = Variable<int>(deleteUserId.value);
    }
    if (deleterUserId.present) {
      map['deleter_user_id'] = Variable<String>(deleterUserId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (importDateTime.present) {
      map['import_date_time'] = Variable<DateTime>(importDateTime.value);
    }
    if (exportDateTime.present) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime.value);
    }
    if (exportStatus.present) {
      map['export_status'] = Variable<String>(exportStatus.value);
    }
    if (importStatus.present) {
      map['import_status'] = Variable<String>(importStatus.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (deviceName.present) {
      map['device_name'] = Variable<String>(deviceName.value);
    }
    if (versionRelease.present) {
      map['version_release'] = Variable<String>(versionRelease.value);
    }
    if (versionEnvrement.present) {
      map['version_envrement'] = Variable<String>(versionEnvrement.value);
    }
    if (bootLoader.present) {
      map['boot_loader'] = Variable<String>(bootLoader.value);
    }
    if (manufacture.present) {
      map['manufacture'] = Variable<String>(manufacture.value);
    }
    if (model.present) {
      map['model'] = Variable<String>(model.value);
    }
    if (sdkNumber.present) {
      map['sdk_number'] = Variable<int>(sdkNumber.value);
    }
    if (hardware.present) {
      map['hardware'] = Variable<String>(hardware.value);
    }
    if (deviceHost.present) {
      map['device_host'] = Variable<String>(deviceHost.value);
    }
    if (deviceTime.present) {
      map['device_time'] = Variable<DateTime>(deviceTime.value);
    }
    if (deviceSerial.present) {
      map['device_serial'] = Variable<String>(deviceSerial.value);
    }
    if (deviceMac.present) {
      map['device_mac'] = Variable<String>(deviceMac.value);
    }
    if (deviceIp.present) {
      map['device_ip'] = Variable<String>(deviceIp.value);
    }
    if (deviceMode.present) {
      map['device_mode'] = Variable<String>(deviceMode.value);
    }
    if (activationDate.present) {
      map['activation_date'] = Variable<DateTime>(activationDate.value);
    }
    if (expirationDate.present) {
      map['expiration_date'] = Variable<DateTime>(expirationDate.value);
    }
    if (deviceStatus.present) {
      map['device_status'] = Variable<int>(deviceStatus.value);
    }
    if (companyName.present) {
      map['company_name'] = Variable<String>(companyName.value);
    }
    if (deviceNickName.present) {
      map['device_nick_name'] = Variable<String>(deviceNickName.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MobileDeviceCompanion(')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('createUserId: $createUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('importDateTime: $importDateTime, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('importStatus: $importStatus, ')
          ..write('syncError: $syncError, ')
          ..write('deviceId: $deviceId, ')
          ..write('deviceName: $deviceName, ')
          ..write('versionRelease: $versionRelease, ')
          ..write('versionEnvrement: $versionEnvrement, ')
          ..write('bootLoader: $bootLoader, ')
          ..write('manufacture: $manufacture, ')
          ..write('model: $model, ')
          ..write('sdkNumber: $sdkNumber, ')
          ..write('hardware: $hardware, ')
          ..write('deviceHost: $deviceHost, ')
          ..write('deviceTime: $deviceTime, ')
          ..write('deviceSerial: $deviceSerial, ')
          ..write('deviceMac: $deviceMac, ')
          ..write('deviceIp: $deviceIp, ')
          ..write('deviceMode: $deviceMode, ')
          ..write('activationDate: $activationDate, ')
          ..write('expirationDate: $expirationDate, ')
          ..write('deviceStatus: $deviceStatus, ')
          ..write('companyName: $companyName, ')
          ..write('deviceNickName: $deviceNickName, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('tenantId: $tenantId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BusinessRuleTable extends BusinessRule
    with TableInfo<$BusinessRuleTable, BusinessRuleData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BusinessRuleTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _ruleNameMeta =
      const VerificationMeta('ruleName');
  @override
  late final GeneratedColumn<String> ruleName = GeneratedColumn<String>(
      'rule_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
      'value', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isGlobalRuleMeta =
      const VerificationMeta('isGlobalRule');
  @override
  late final GeneratedColumn<bool> isGlobalRule = GeneratedColumn<bool>(
      'is_global_rule', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_global_rule" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _deviceRuleMeta =
      const VerificationMeta('deviceRule');
  @override
  late final GeneratedColumn<String> deviceRule = GeneratedColumn<String>(
      'device_rule', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userRuleMeta =
      const VerificationMeta('userRule');
  @override
  late final GeneratedColumn<String> userRule = GeneratedColumn<String>(
      'user_rule', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _domainMeta = const VerificationMeta('domain');
  @override
  late final GeneratedColumn<String> domain = GeneratedColumn<String>(
      'domain', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _expiredDateTimeMeta =
      const VerificationMeta('expiredDateTime');
  @override
  late final GeneratedColumn<DateTime> expiredDateTime =
      GeneratedColumn<DateTime>('expired_date_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _syncErrorMeta =
      const VerificationMeta('syncError');
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
      'sync_error', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dataTypeMeta =
      const VerificationMeta('dataType');
  @override
  late final GeneratedColumn<String> dataType = GeneratedColumn<String>(
      'data_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dataValueMeta =
      const VerificationMeta('dataValue');
  @override
  late final GeneratedColumn<String> dataValue = GeneratedColumn<String>(
      'data_value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _groupsMeta = const VerificationMeta('groups');
  @override
  late final GeneratedColumn<String> groups = GeneratedColumn<String>(
      'groups', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        code,
        ruleName,
        value,
        description,
        isGlobalRule,
        deviceRule,
        userRule,
        domain,
        expiredDateTime,
        tenantId,
        syncError,
        dataType,
        dataValue,
        groups
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'business_rule';
  @override
  VerificationContext validateIntegrity(Insertable<BusinessRuleData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('rule_name')) {
      context.handle(_ruleNameMeta,
          ruleName.isAcceptableOrUnknown(data['rule_name']!, _ruleNameMeta));
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value']!, _valueMeta));
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('is_global_rule')) {
      context.handle(
          _isGlobalRuleMeta,
          isGlobalRule.isAcceptableOrUnknown(
              data['is_global_rule']!, _isGlobalRuleMeta));
    }
    if (data.containsKey('device_rule')) {
      context.handle(
          _deviceRuleMeta,
          deviceRule.isAcceptableOrUnknown(
              data['device_rule']!, _deviceRuleMeta));
    }
    if (data.containsKey('user_rule')) {
      context.handle(_userRuleMeta,
          userRule.isAcceptableOrUnknown(data['user_rule']!, _userRuleMeta));
    }
    if (data.containsKey('domain')) {
      context.handle(_domainMeta,
          domain.isAcceptableOrUnknown(data['domain']!, _domainMeta));
    }
    if (data.containsKey('expired_date_time')) {
      context.handle(
          _expiredDateTimeMeta,
          expiredDateTime.isAcceptableOrUnknown(
              data['expired_date_time']!, _expiredDateTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type']!, _dataTypeMeta));
    }
    if (data.containsKey('data_value')) {
      context.handle(_dataValueMeta,
          dataValue.isAcceptableOrUnknown(data['data_value']!, _dataValueMeta));
    }
    if (data.containsKey('groups')) {
      context.handle(_groupsMeta,
          groups.isAcceptableOrUnknown(data['groups']!, _groupsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  BusinessRuleData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BusinessRuleData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      ruleName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}rule_name']),
      value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}value'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      isGlobalRule: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_global_rule'])!,
      deviceRule: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_rule']),
      userRule: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_rule']),
      domain: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}domain']),
      expiredDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}expired_date_time']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      syncError: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sync_error']),
      dataType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_type']),
      dataValue: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_value']),
      groups: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}groups']),
    );
  }

  @override
  $BusinessRuleTable createAlias(String alias) {
    return $BusinessRuleTable(attachedDatabase, alias);
  }
}

class BusinessRuleData extends DataClass
    implements Insertable<BusinessRuleData> {
  final String code;
  final String? ruleName;
  final String value;
  final String? description;
  final bool isGlobalRule;
  final String? deviceRule;
  final String? userRule;
  final String? domain;
  final DateTime? expiredDateTime;
  final String? tenantId;
  final String? syncError;
  final String? dataType;
  final String? dataValue;
  final String? groups;
  const BusinessRuleData(
      {required this.code,
      this.ruleName,
      required this.value,
      this.description,
      required this.isGlobalRule,
      this.deviceRule,
      this.userRule,
      this.domain,
      this.expiredDateTime,
      this.tenantId,
      this.syncError,
      this.dataType,
      this.dataValue,
      this.groups});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['code'] = Variable<String>(code);
    if (!nullToAbsent || ruleName != null) {
      map['rule_name'] = Variable<String>(ruleName);
    }
    map['value'] = Variable<String>(value);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['is_global_rule'] = Variable<bool>(isGlobalRule);
    if (!nullToAbsent || deviceRule != null) {
      map['device_rule'] = Variable<String>(deviceRule);
    }
    if (!nullToAbsent || userRule != null) {
      map['user_rule'] = Variable<String>(userRule);
    }
    if (!nullToAbsent || domain != null) {
      map['domain'] = Variable<String>(domain);
    }
    if (!nullToAbsent || expiredDateTime != null) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || dataValue != null) {
      map['data_value'] = Variable<String>(dataValue);
    }
    if (!nullToAbsent || groups != null) {
      map['groups'] = Variable<String>(groups);
    }
    return map;
  }

  BusinessRuleCompanion toCompanion(bool nullToAbsent) {
    return BusinessRuleCompanion(
      code: Value(code),
      ruleName: ruleName == null && nullToAbsent
          ? const Value.absent()
          : Value(ruleName),
      value: Value(value),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      isGlobalRule: Value(isGlobalRule),
      deviceRule: deviceRule == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceRule),
      userRule: userRule == null && nullToAbsent
          ? const Value.absent()
          : Value(userRule),
      domain:
          domain == null && nullToAbsent ? const Value.absent() : Value(domain),
      expiredDateTime: expiredDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(expiredDateTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      dataValue: dataValue == null && nullToAbsent
          ? const Value.absent()
          : Value(dataValue),
      groups:
          groups == null && nullToAbsent ? const Value.absent() : Value(groups),
    );
  }

  factory BusinessRuleData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BusinessRuleData(
      code: serializer.fromJson<String>(json['code']),
      ruleName: serializer.fromJson<String?>(json['ruleName']),
      value: serializer.fromJson<String>(json['value']),
      description: serializer.fromJson<String?>(json['description']),
      isGlobalRule: serializer.fromJson<bool>(json['isGlobalRule']),
      deviceRule: serializer.fromJson<String?>(json['deviceRule']),
      userRule: serializer.fromJson<String?>(json['userRule']),
      domain: serializer.fromJson<String?>(json['domain']),
      expiredDateTime: serializer.fromJson<DateTime?>(json['expiredDateTime']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      dataType: serializer.fromJson<String?>(json['dataType']),
      dataValue: serializer.fromJson<String?>(json['dataValue']),
      groups: serializer.fromJson<String?>(json['groups']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'ruleName': serializer.toJson<String?>(ruleName),
      'value': serializer.toJson<String>(value),
      'description': serializer.toJson<String?>(description),
      'isGlobalRule': serializer.toJson<bool>(isGlobalRule),
      'deviceRule': serializer.toJson<String?>(deviceRule),
      'userRule': serializer.toJson<String?>(userRule),
      'domain': serializer.toJson<String?>(domain),
      'expiredDateTime': serializer.toJson<DateTime?>(expiredDateTime),
      'tenantId': serializer.toJson<String?>(tenantId),
      'syncError': serializer.toJson<String?>(syncError),
      'dataType': serializer.toJson<String?>(dataType),
      'dataValue': serializer.toJson<String?>(dataValue),
      'groups': serializer.toJson<String?>(groups),
    };
  }

  BusinessRuleData copyWith(
          {String? code,
          Value<String?> ruleName = const Value.absent(),
          String? value,
          Value<String?> description = const Value.absent(),
          bool? isGlobalRule,
          Value<String?> deviceRule = const Value.absent(),
          Value<String?> userRule = const Value.absent(),
          Value<String?> domain = const Value.absent(),
          Value<DateTime?> expiredDateTime = const Value.absent(),
          Value<String?> tenantId = const Value.absent(),
          Value<String?> syncError = const Value.absent(),
          Value<String?> dataType = const Value.absent(),
          Value<String?> dataValue = const Value.absent(),
          Value<String?> groups = const Value.absent()}) =>
      BusinessRuleData(
        code: code ?? this.code,
        ruleName: ruleName.present ? ruleName.value : this.ruleName,
        value: value ?? this.value,
        description: description.present ? description.value : this.description,
        isGlobalRule: isGlobalRule ?? this.isGlobalRule,
        deviceRule: deviceRule.present ? deviceRule.value : this.deviceRule,
        userRule: userRule.present ? userRule.value : this.userRule,
        domain: domain.present ? domain.value : this.domain,
        expiredDateTime: expiredDateTime.present
            ? expiredDateTime.value
            : this.expiredDateTime,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        syncError: syncError.present ? syncError.value : this.syncError,
        dataType: dataType.present ? dataType.value : this.dataType,
        dataValue: dataValue.present ? dataValue.value : this.dataValue,
        groups: groups.present ? groups.value : this.groups,
      );
  @override
  String toString() {
    return (StringBuffer('BusinessRuleData(')
          ..write('code: $code, ')
          ..write('ruleName: $ruleName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('isGlobalRule: $isGlobalRule, ')
          ..write('deviceRule: $deviceRule, ')
          ..write('userRule: $userRule, ')
          ..write('domain: $domain, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('syncError: $syncError, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      code,
      ruleName,
      value,
      description,
      isGlobalRule,
      deviceRule,
      userRule,
      domain,
      expiredDateTime,
      tenantId,
      syncError,
      dataType,
      dataValue,
      groups);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BusinessRuleData &&
          other.code == this.code &&
          other.ruleName == this.ruleName &&
          other.value == this.value &&
          other.description == this.description &&
          other.isGlobalRule == this.isGlobalRule &&
          other.deviceRule == this.deviceRule &&
          other.userRule == this.userRule &&
          other.domain == this.domain &&
          other.expiredDateTime == this.expiredDateTime &&
          other.tenantId == this.tenantId &&
          other.syncError == this.syncError &&
          other.dataType == this.dataType &&
          other.dataValue == this.dataValue &&
          other.groups == this.groups);
}

class BusinessRuleCompanion extends UpdateCompanion<BusinessRuleData> {
  final Value<String> code;
  final Value<String?> ruleName;
  final Value<String> value;
  final Value<String?> description;
  final Value<bool> isGlobalRule;
  final Value<String?> deviceRule;
  final Value<String?> userRule;
  final Value<String?> domain;
  final Value<DateTime?> expiredDateTime;
  final Value<String?> tenantId;
  final Value<String?> syncError;
  final Value<String?> dataType;
  final Value<String?> dataValue;
  final Value<String?> groups;
  final Value<int> rowid;
  const BusinessRuleCompanion({
    this.code = const Value.absent(),
    this.ruleName = const Value.absent(),
    this.value = const Value.absent(),
    this.description = const Value.absent(),
    this.isGlobalRule = const Value.absent(),
    this.deviceRule = const Value.absent(),
    this.userRule = const Value.absent(),
    this.domain = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.syncError = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BusinessRuleCompanion.insert({
    required String code,
    this.ruleName = const Value.absent(),
    required String value,
    this.description = const Value.absent(),
    this.isGlobalRule = const Value.absent(),
    this.deviceRule = const Value.absent(),
    this.userRule = const Value.absent(),
    this.domain = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.syncError = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : code = Value(code),
        value = Value(value);
  static Insertable<BusinessRuleData> custom({
    Expression<String>? code,
    Expression<String>? ruleName,
    Expression<String>? value,
    Expression<String>? description,
    Expression<bool>? isGlobalRule,
    Expression<String>? deviceRule,
    Expression<String>? userRule,
    Expression<String>? domain,
    Expression<DateTime>? expiredDateTime,
    Expression<String>? tenantId,
    Expression<String>? syncError,
    Expression<String>? dataType,
    Expression<String>? dataValue,
    Expression<String>? groups,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (code != null) 'code': code,
      if (ruleName != null) 'rule_name': ruleName,
      if (value != null) 'value': value,
      if (description != null) 'description': description,
      if (isGlobalRule != null) 'is_global_rule': isGlobalRule,
      if (deviceRule != null) 'device_rule': deviceRule,
      if (userRule != null) 'user_rule': userRule,
      if (domain != null) 'domain': domain,
      if (expiredDateTime != null) 'expired_date_time': expiredDateTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (syncError != null) 'sync_error': syncError,
      if (dataType != null) 'data_type': dataType,
      if (dataValue != null) 'data_value': dataValue,
      if (groups != null) 'groups': groups,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BusinessRuleCompanion copyWith(
      {Value<String>? code,
      Value<String?>? ruleName,
      Value<String>? value,
      Value<String?>? description,
      Value<bool>? isGlobalRule,
      Value<String?>? deviceRule,
      Value<String?>? userRule,
      Value<String?>? domain,
      Value<DateTime?>? expiredDateTime,
      Value<String?>? tenantId,
      Value<String?>? syncError,
      Value<String?>? dataType,
      Value<String?>? dataValue,
      Value<String?>? groups,
      Value<int>? rowid}) {
    return BusinessRuleCompanion(
      code: code ?? this.code,
      ruleName: ruleName ?? this.ruleName,
      value: value ?? this.value,
      description: description ?? this.description,
      isGlobalRule: isGlobalRule ?? this.isGlobalRule,
      deviceRule: deviceRule ?? this.deviceRule,
      userRule: userRule ?? this.userRule,
      domain: domain ?? this.domain,
      expiredDateTime: expiredDateTime ?? this.expiredDateTime,
      tenantId: tenantId ?? this.tenantId,
      syncError: syncError ?? this.syncError,
      dataType: dataType ?? this.dataType,
      dataValue: dataValue ?? this.dataValue,
      groups: groups ?? this.groups,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (ruleName.present) {
      map['rule_name'] = Variable<String>(ruleName.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (isGlobalRule.present) {
      map['is_global_rule'] = Variable<bool>(isGlobalRule.value);
    }
    if (deviceRule.present) {
      map['device_rule'] = Variable<String>(deviceRule.value);
    }
    if (userRule.present) {
      map['user_rule'] = Variable<String>(userRule.value);
    }
    if (domain.present) {
      map['domain'] = Variable<String>(domain.value);
    }
    if (expiredDateTime.present) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (dataValue.present) {
      map['data_value'] = Variable<String>(dataValue.value);
    }
    if (groups.present) {
      map['groups'] = Variable<String>(groups.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BusinessRuleCompanion(')
          ..write('code: $code, ')
          ..write('ruleName: $ruleName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('isGlobalRule: $isGlobalRule, ')
          ..write('deviceRule: $deviceRule, ')
          ..write('userRule: $userRule, ')
          ..write('domain: $domain, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('syncError: $syncError, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $NonGlobalBusinessRuleTable extends NonGlobalBusinessRule
    with TableInfo<$NonGlobalBusinessRuleTable, NonGlobalBusinessRuleData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NonGlobalBusinessRuleTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _parentCodeMeta =
      const VerificationMeta('parentCode');
  @override
  late final GeneratedColumn<String> parentCode = GeneratedColumn<String>(
      'parent_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _ruleNameMeta =
      const VerificationMeta('ruleName');
  @override
  late final GeneratedColumn<String> ruleName = GeneratedColumn<String>(
      'rule_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
      'value', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceRuleMeta =
      const VerificationMeta('deviceRule');
  @override
  late final GeneratedColumn<String> deviceRule = GeneratedColumn<String>(
      'device_rule', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userRuleMeta =
      const VerificationMeta('userRule');
  @override
  late final GeneratedColumn<String> userRule = GeneratedColumn<String>(
      'user_rule', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _domainMeta = const VerificationMeta('domain');
  @override
  late final GeneratedColumn<String> domain = GeneratedColumn<String>(
      'domain', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceIdMeta =
      const VerificationMeta('deviceId');
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
      'device_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _screenMeta = const VerificationMeta('screen');
  @override
  late final GeneratedColumn<String> screen = GeneratedColumn<String>(
      'screen', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isApplyMeta =
      const VerificationMeta('isApply');
  @override
  late final GeneratedColumn<bool> isApply = GeneratedColumn<bool>(
      'is_apply', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_apply" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _syncErrorMeta =
      const VerificationMeta('syncError');
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
      'sync_error', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _expiredDateTimeMeta =
      const VerificationMeta('expiredDateTime');
  @override
  late final GeneratedColumn<DateTime> expiredDateTime =
      GeneratedColumn<DateTime>('expired_date_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _dataTypeMeta =
      const VerificationMeta('dataType');
  @override
  late final GeneratedColumn<String> dataType = GeneratedColumn<String>(
      'data_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dataValueMeta =
      const VerificationMeta('dataValue');
  @override
  late final GeneratedColumn<String> dataValue = GeneratedColumn<String>(
      'data_value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _groupsMeta = const VerificationMeta('groups');
  @override
  late final GeneratedColumn<String> groups = GeneratedColumn<String>(
      'groups', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        code,
        parentCode,
        ruleName,
        value,
        description,
        deviceRule,
        userRule,
        domain,
        deviceId,
        userName,
        screen,
        isApply,
        syncError,
        expiredDateTime,
        dataType,
        dataValue,
        groups,
        tenantId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'non_global_business_rule';
  @override
  VerificationContext validateIntegrity(
      Insertable<NonGlobalBusinessRuleData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('parent_code')) {
      context.handle(
          _parentCodeMeta,
          parentCode.isAcceptableOrUnknown(
              data['parent_code']!, _parentCodeMeta));
    } else if (isInserting) {
      context.missing(_parentCodeMeta);
    }
    if (data.containsKey('rule_name')) {
      context.handle(_ruleNameMeta,
          ruleName.isAcceptableOrUnknown(data['rule_name']!, _ruleNameMeta));
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value']!, _valueMeta));
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('device_rule')) {
      context.handle(
          _deviceRuleMeta,
          deviceRule.isAcceptableOrUnknown(
              data['device_rule']!, _deviceRuleMeta));
    }
    if (data.containsKey('user_rule')) {
      context.handle(_userRuleMeta,
          userRule.isAcceptableOrUnknown(data['user_rule']!, _userRuleMeta));
    }
    if (data.containsKey('domain')) {
      context.handle(_domainMeta,
          domain.isAcceptableOrUnknown(data['domain']!, _domainMeta));
    }
    if (data.containsKey('device_id')) {
      context.handle(_deviceIdMeta,
          deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('screen')) {
      context.handle(_screenMeta,
          screen.isAcceptableOrUnknown(data['screen']!, _screenMeta));
    }
    if (data.containsKey('is_apply')) {
      context.handle(_isApplyMeta,
          isApply.isAcceptableOrUnknown(data['is_apply']!, _isApplyMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta));
    }
    if (data.containsKey('expired_date_time')) {
      context.handle(
          _expiredDateTimeMeta,
          expiredDateTime.isAcceptableOrUnknown(
              data['expired_date_time']!, _expiredDateTimeMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type']!, _dataTypeMeta));
    }
    if (data.containsKey('data_value')) {
      context.handle(_dataValueMeta,
          dataValue.isAcceptableOrUnknown(data['data_value']!, _dataValueMeta));
    }
    if (data.containsKey('groups')) {
      context.handle(_groupsMeta,
          groups.isAcceptableOrUnknown(data['groups']!, _groupsMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  NonGlobalBusinessRuleData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return NonGlobalBusinessRuleData(
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      parentCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}parent_code'])!,
      ruleName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}rule_name']),
      value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}value'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      deviceRule: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_rule']),
      userRule: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_rule']),
      domain: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}domain']),
      deviceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_id']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      screen: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}screen']),
      isApply: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_apply'])!,
      syncError: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sync_error']),
      expiredDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}expired_date_time']),
      dataType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_type']),
      dataValue: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_value']),
      groups: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}groups']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
    );
  }

  @override
  $NonGlobalBusinessRuleTable createAlias(String alias) {
    return $NonGlobalBusinessRuleTable(attachedDatabase, alias);
  }
}

class NonGlobalBusinessRuleData extends DataClass
    implements Insertable<NonGlobalBusinessRuleData> {
  final String code;
  final String parentCode;
  final String? ruleName;
  final String value;
  final String? description;
  final String? deviceRule;
  final String? userRule;
  final String? domain;
  final String? deviceId;
  final String? userName;
  final String? screen;
  final bool isApply;
  final String? syncError;
  final DateTime? expiredDateTime;
  final String? dataType;
  final String? dataValue;
  final String? groups;
  final String? tenantId;
  const NonGlobalBusinessRuleData(
      {required this.code,
      required this.parentCode,
      this.ruleName,
      required this.value,
      this.description,
      this.deviceRule,
      this.userRule,
      this.domain,
      this.deviceId,
      this.userName,
      this.screen,
      required this.isApply,
      this.syncError,
      this.expiredDateTime,
      this.dataType,
      this.dataValue,
      this.groups,
      this.tenantId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['code'] = Variable<String>(code);
    map['parent_code'] = Variable<String>(parentCode);
    if (!nullToAbsent || ruleName != null) {
      map['rule_name'] = Variable<String>(ruleName);
    }
    map['value'] = Variable<String>(value);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || deviceRule != null) {
      map['device_rule'] = Variable<String>(deviceRule);
    }
    if (!nullToAbsent || userRule != null) {
      map['user_rule'] = Variable<String>(userRule);
    }
    if (!nullToAbsent || domain != null) {
      map['domain'] = Variable<String>(domain);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || screen != null) {
      map['screen'] = Variable<String>(screen);
    }
    map['is_apply'] = Variable<bool>(isApply);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || expiredDateTime != null) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || dataValue != null) {
      map['data_value'] = Variable<String>(dataValue);
    }
    if (!nullToAbsent || groups != null) {
      map['groups'] = Variable<String>(groups);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    return map;
  }

  NonGlobalBusinessRuleCompanion toCompanion(bool nullToAbsent) {
    return NonGlobalBusinessRuleCompanion(
      code: Value(code),
      parentCode: Value(parentCode),
      ruleName: ruleName == null && nullToAbsent
          ? const Value.absent()
          : Value(ruleName),
      value: Value(value),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      deviceRule: deviceRule == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceRule),
      userRule: userRule == null && nullToAbsent
          ? const Value.absent()
          : Value(userRule),
      domain:
          domain == null && nullToAbsent ? const Value.absent() : Value(domain),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      screen:
          screen == null && nullToAbsent ? const Value.absent() : Value(screen),
      isApply: Value(isApply),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      expiredDateTime: expiredDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(expiredDateTime),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      dataValue: dataValue == null && nullToAbsent
          ? const Value.absent()
          : Value(dataValue),
      groups:
          groups == null && nullToAbsent ? const Value.absent() : Value(groups),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory NonGlobalBusinessRuleData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NonGlobalBusinessRuleData(
      code: serializer.fromJson<String>(json['code']),
      parentCode: serializer.fromJson<String>(json['parentCode']),
      ruleName: serializer.fromJson<String?>(json['ruleName']),
      value: serializer.fromJson<String>(json['value']),
      description: serializer.fromJson<String?>(json['description']),
      deviceRule: serializer.fromJson<String?>(json['deviceRule']),
      userRule: serializer.fromJson<String?>(json['userRule']),
      domain: serializer.fromJson<String?>(json['domain']),
      deviceId: serializer.fromJson<String?>(json['deviceId']),
      userName: serializer.fromJson<String?>(json['userName']),
      screen: serializer.fromJson<String?>(json['screen']),
      isApply: serializer.fromJson<bool>(json['isApply']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      expiredDateTime: serializer.fromJson<DateTime?>(json['expiredDateTime']),
      dataType: serializer.fromJson<String?>(json['dataType']),
      dataValue: serializer.fromJson<String?>(json['dataValue']),
      groups: serializer.fromJson<String?>(json['groups']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'parentCode': serializer.toJson<String>(parentCode),
      'ruleName': serializer.toJson<String?>(ruleName),
      'value': serializer.toJson<String>(value),
      'description': serializer.toJson<String?>(description),
      'deviceRule': serializer.toJson<String?>(deviceRule),
      'userRule': serializer.toJson<String?>(userRule),
      'domain': serializer.toJson<String?>(domain),
      'deviceId': serializer.toJson<String?>(deviceId),
      'userName': serializer.toJson<String?>(userName),
      'screen': serializer.toJson<String?>(screen),
      'isApply': serializer.toJson<bool>(isApply),
      'syncError': serializer.toJson<String?>(syncError),
      'expiredDateTime': serializer.toJson<DateTime?>(expiredDateTime),
      'dataType': serializer.toJson<String?>(dataType),
      'dataValue': serializer.toJson<String?>(dataValue),
      'groups': serializer.toJson<String?>(groups),
      'tenantId': serializer.toJson<String?>(tenantId),
    };
  }

  NonGlobalBusinessRuleData copyWith(
          {String? code,
          String? parentCode,
          Value<String?> ruleName = const Value.absent(),
          String? value,
          Value<String?> description = const Value.absent(),
          Value<String?> deviceRule = const Value.absent(),
          Value<String?> userRule = const Value.absent(),
          Value<String?> domain = const Value.absent(),
          Value<String?> deviceId = const Value.absent(),
          Value<String?> userName = const Value.absent(),
          Value<String?> screen = const Value.absent(),
          bool? isApply,
          Value<String?> syncError = const Value.absent(),
          Value<DateTime?> expiredDateTime = const Value.absent(),
          Value<String?> dataType = const Value.absent(),
          Value<String?> dataValue = const Value.absent(),
          Value<String?> groups = const Value.absent(),
          Value<String?> tenantId = const Value.absent()}) =>
      NonGlobalBusinessRuleData(
        code: code ?? this.code,
        parentCode: parentCode ?? this.parentCode,
        ruleName: ruleName.present ? ruleName.value : this.ruleName,
        value: value ?? this.value,
        description: description.present ? description.value : this.description,
        deviceRule: deviceRule.present ? deviceRule.value : this.deviceRule,
        userRule: userRule.present ? userRule.value : this.userRule,
        domain: domain.present ? domain.value : this.domain,
        deviceId: deviceId.present ? deviceId.value : this.deviceId,
        userName: userName.present ? userName.value : this.userName,
        screen: screen.present ? screen.value : this.screen,
        isApply: isApply ?? this.isApply,
        syncError: syncError.present ? syncError.value : this.syncError,
        expiredDateTime: expiredDateTime.present
            ? expiredDateTime.value
            : this.expiredDateTime,
        dataType: dataType.present ? dataType.value : this.dataType,
        dataValue: dataValue.present ? dataValue.value : this.dataValue,
        groups: groups.present ? groups.value : this.groups,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('NonGlobalBusinessRuleData(')
          ..write('code: $code, ')
          ..write('parentCode: $parentCode, ')
          ..write('ruleName: $ruleName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('deviceRule: $deviceRule, ')
          ..write('userRule: $userRule, ')
          ..write('domain: $domain, ')
          ..write('deviceId: $deviceId, ')
          ..write('userName: $userName, ')
          ..write('screen: $screen, ')
          ..write('isApply: $isApply, ')
          ..write('syncError: $syncError, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      code,
      parentCode,
      ruleName,
      value,
      description,
      deviceRule,
      userRule,
      domain,
      deviceId,
      userName,
      screen,
      isApply,
      syncError,
      expiredDateTime,
      dataType,
      dataValue,
      groups,
      tenantId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NonGlobalBusinessRuleData &&
          other.code == this.code &&
          other.parentCode == this.parentCode &&
          other.ruleName == this.ruleName &&
          other.value == this.value &&
          other.description == this.description &&
          other.deviceRule == this.deviceRule &&
          other.userRule == this.userRule &&
          other.domain == this.domain &&
          other.deviceId == this.deviceId &&
          other.userName == this.userName &&
          other.screen == this.screen &&
          other.isApply == this.isApply &&
          other.syncError == this.syncError &&
          other.expiredDateTime == this.expiredDateTime &&
          other.dataType == this.dataType &&
          other.dataValue == this.dataValue &&
          other.groups == this.groups &&
          other.tenantId == this.tenantId);
}

class NonGlobalBusinessRuleCompanion
    extends UpdateCompanion<NonGlobalBusinessRuleData> {
  final Value<String> code;
  final Value<String> parentCode;
  final Value<String?> ruleName;
  final Value<String> value;
  final Value<String?> description;
  final Value<String?> deviceRule;
  final Value<String?> userRule;
  final Value<String?> domain;
  final Value<String?> deviceId;
  final Value<String?> userName;
  final Value<String?> screen;
  final Value<bool> isApply;
  final Value<String?> syncError;
  final Value<DateTime?> expiredDateTime;
  final Value<String?> dataType;
  final Value<String?> dataValue;
  final Value<String?> groups;
  final Value<String?> tenantId;
  final Value<int> rowid;
  const NonGlobalBusinessRuleCompanion({
    this.code = const Value.absent(),
    this.parentCode = const Value.absent(),
    this.ruleName = const Value.absent(),
    this.value = const Value.absent(),
    this.description = const Value.absent(),
    this.deviceRule = const Value.absent(),
    this.userRule = const Value.absent(),
    this.domain = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userName = const Value.absent(),
    this.screen = const Value.absent(),
    this.isApply = const Value.absent(),
    this.syncError = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  NonGlobalBusinessRuleCompanion.insert({
    required String code,
    required String parentCode,
    this.ruleName = const Value.absent(),
    required String value,
    this.description = const Value.absent(),
    this.deviceRule = const Value.absent(),
    this.userRule = const Value.absent(),
    this.domain = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userName = const Value.absent(),
    this.screen = const Value.absent(),
    this.isApply = const Value.absent(),
    this.syncError = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : code = Value(code),
        parentCode = Value(parentCode),
        value = Value(value);
  static Insertable<NonGlobalBusinessRuleData> custom({
    Expression<String>? code,
    Expression<String>? parentCode,
    Expression<String>? ruleName,
    Expression<String>? value,
    Expression<String>? description,
    Expression<String>? deviceRule,
    Expression<String>? userRule,
    Expression<String>? domain,
    Expression<String>? deviceId,
    Expression<String>? userName,
    Expression<String>? screen,
    Expression<bool>? isApply,
    Expression<String>? syncError,
    Expression<DateTime>? expiredDateTime,
    Expression<String>? dataType,
    Expression<String>? dataValue,
    Expression<String>? groups,
    Expression<String>? tenantId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (code != null) 'code': code,
      if (parentCode != null) 'parent_code': parentCode,
      if (ruleName != null) 'rule_name': ruleName,
      if (value != null) 'value': value,
      if (description != null) 'description': description,
      if (deviceRule != null) 'device_rule': deviceRule,
      if (userRule != null) 'user_rule': userRule,
      if (domain != null) 'domain': domain,
      if (deviceId != null) 'device_id': deviceId,
      if (userName != null) 'user_name': userName,
      if (screen != null) 'screen': screen,
      if (isApply != null) 'is_apply': isApply,
      if (syncError != null) 'sync_error': syncError,
      if (expiredDateTime != null) 'expired_date_time': expiredDateTime,
      if (dataType != null) 'data_type': dataType,
      if (dataValue != null) 'data_value': dataValue,
      if (groups != null) 'groups': groups,
      if (tenantId != null) 'tenant_id': tenantId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  NonGlobalBusinessRuleCompanion copyWith(
      {Value<String>? code,
      Value<String>? parentCode,
      Value<String?>? ruleName,
      Value<String>? value,
      Value<String?>? description,
      Value<String?>? deviceRule,
      Value<String?>? userRule,
      Value<String?>? domain,
      Value<String?>? deviceId,
      Value<String?>? userName,
      Value<String?>? screen,
      Value<bool>? isApply,
      Value<String?>? syncError,
      Value<DateTime?>? expiredDateTime,
      Value<String?>? dataType,
      Value<String?>? dataValue,
      Value<String?>? groups,
      Value<String?>? tenantId,
      Value<int>? rowid}) {
    return NonGlobalBusinessRuleCompanion(
      code: code ?? this.code,
      parentCode: parentCode ?? this.parentCode,
      ruleName: ruleName ?? this.ruleName,
      value: value ?? this.value,
      description: description ?? this.description,
      deviceRule: deviceRule ?? this.deviceRule,
      userRule: userRule ?? this.userRule,
      domain: domain ?? this.domain,
      deviceId: deviceId ?? this.deviceId,
      userName: userName ?? this.userName,
      screen: screen ?? this.screen,
      isApply: isApply ?? this.isApply,
      syncError: syncError ?? this.syncError,
      expiredDateTime: expiredDateTime ?? this.expiredDateTime,
      dataType: dataType ?? this.dataType,
      dataValue: dataValue ?? this.dataValue,
      groups: groups ?? this.groups,
      tenantId: tenantId ?? this.tenantId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (parentCode.present) {
      map['parent_code'] = Variable<String>(parentCode.value);
    }
    if (ruleName.present) {
      map['rule_name'] = Variable<String>(ruleName.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (deviceRule.present) {
      map['device_rule'] = Variable<String>(deviceRule.value);
    }
    if (userRule.present) {
      map['user_rule'] = Variable<String>(userRule.value);
    }
    if (domain.present) {
      map['domain'] = Variable<String>(domain.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (screen.present) {
      map['screen'] = Variable<String>(screen.value);
    }
    if (isApply.present) {
      map['is_apply'] = Variable<bool>(isApply.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (expiredDateTime.present) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (dataValue.present) {
      map['data_value'] = Variable<String>(dataValue.value);
    }
    if (groups.present) {
      map['groups'] = Variable<String>(groups.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NonGlobalBusinessRuleCompanion(')
          ..write('code: $code, ')
          ..write('parentCode: $parentCode, ')
          ..write('ruleName: $ruleName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('deviceRule: $deviceRule, ')
          ..write('userRule: $userRule, ')
          ..write('domain: $domain, ')
          ..write('deviceId: $deviceId, ')
          ..write('userName: $userName, ')
          ..write('screen: $screen, ')
          ..write('isApply: $isApply, ')
          ..write('syncError: $syncError, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups, ')
          ..write('tenantId: $tenantId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ApplicationLoggerTable extends ApplicationLogger
    with TableInfo<$ApplicationLoggerTable, ApplicationLoggerData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ApplicationLoggerTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _functionNameMeta =
      const VerificationMeta('functionName');
  @override
  late final GeneratedColumn<String> functionName = GeneratedColumn<String>(
      'function_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _logDateTimeMeta =
      const VerificationMeta('logDateTime');
  @override
  late final GeneratedColumn<DateTime> logDateTime = GeneratedColumn<DateTime>(
      'log_date_time', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _syncFrequencyMeta =
      const VerificationMeta('syncFrequency');
  @override
  late final GeneratedColumn<String> syncFrequency = GeneratedColumn<String>(
      'sync_frequency', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _logDescriptionMeta =
      const VerificationMeta('logDescription');
  @override
  late final GeneratedColumn<String> logDescription = GeneratedColumn<String>(
      'log_description', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _documentNoMeta =
      const VerificationMeta('documentNo');
  @override
  late final GeneratedColumn<String> documentNo = GeneratedColumn<String>(
      'document_no', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _deviceIdMeta =
      const VerificationMeta('deviceId');
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
      'device_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _logCodeMeta =
      const VerificationMeta('logCode');
  @override
  late final GeneratedColumn<String> logCode = GeneratedColumn<String>(
      'log_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _logSeverityMeta =
      const VerificationMeta('logSeverity');
  @override
  late final GeneratedColumn<String> logSeverity = GeneratedColumn<String>(
      'log_severity', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _exportDateTimeMeta =
      const VerificationMeta('exportDateTime');
  @override
  late final GeneratedColumn<DateTime> exportDateTime =
      GeneratedColumn<DateTime>('export_date_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _exportStatusMeta =
      const VerificationMeta('exportStatus');
  @override
  late final GeneratedColumn<String> exportStatus = GeneratedColumn<String>(
      'export_status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: Constant('Pending'));
  static const VerificationMeta _syncErrorMeta =
      const VerificationMeta('syncError');
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
      'sync_error', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        userName,
        userId,
        id,
        functionName,
        logDateTime,
        syncFrequency,
        logDescription,
        documentNo,
        deviceId,
        logCode,
        logSeverity,
        exportDateTime,
        exportStatus,
        syncError
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'application_logger';
  @override
  VerificationContext validateIntegrity(
      Insertable<ApplicationLoggerData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('function_name')) {
      context.handle(
          _functionNameMeta,
          functionName.isAcceptableOrUnknown(
              data['function_name']!, _functionNameMeta));
    } else if (isInserting) {
      context.missing(_functionNameMeta);
    }
    if (data.containsKey('log_date_time')) {
      context.handle(
          _logDateTimeMeta,
          logDateTime.isAcceptableOrUnknown(
              data['log_date_time']!, _logDateTimeMeta));
    } else if (isInserting) {
      context.missing(_logDateTimeMeta);
    }
    if (data.containsKey('sync_frequency')) {
      context.handle(
          _syncFrequencyMeta,
          syncFrequency.isAcceptableOrUnknown(
              data['sync_frequency']!, _syncFrequencyMeta));
    } else if (isInserting) {
      context.missing(_syncFrequencyMeta);
    }
    if (data.containsKey('log_description')) {
      context.handle(
          _logDescriptionMeta,
          logDescription.isAcceptableOrUnknown(
              data['log_description']!, _logDescriptionMeta));
    } else if (isInserting) {
      context.missing(_logDescriptionMeta);
    }
    if (data.containsKey('document_no')) {
      context.handle(
          _documentNoMeta,
          documentNo.isAcceptableOrUnknown(
              data['document_no']!, _documentNoMeta));
    } else if (isInserting) {
      context.missing(_documentNoMeta);
    }
    if (data.containsKey('device_id')) {
      context.handle(_deviceIdMeta,
          deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta));
    } else if (isInserting) {
      context.missing(_deviceIdMeta);
    }
    if (data.containsKey('log_code')) {
      context.handle(_logCodeMeta,
          logCode.isAcceptableOrUnknown(data['log_code']!, _logCodeMeta));
    } else if (isInserting) {
      context.missing(_logCodeMeta);
    }
    if (data.containsKey('log_severity')) {
      context.handle(
          _logSeverityMeta,
          logSeverity.isAcceptableOrUnknown(
              data['log_severity']!, _logSeverityMeta));
    } else if (isInserting) {
      context.missing(_logSeverityMeta);
    }
    if (data.containsKey('export_date_time')) {
      context.handle(
          _exportDateTimeMeta,
          exportDateTime.isAcceptableOrUnknown(
              data['export_date_time']!, _exportDateTimeMeta));
    }
    if (data.containsKey('export_status')) {
      context.handle(
          _exportStatusMeta,
          exportStatus.isAcceptableOrUnknown(
              data['export_status']!, _exportStatusMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ApplicationLoggerData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ApplicationLoggerData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      functionName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}function_name'])!,
      logDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}log_date_time'])!,
      syncFrequency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sync_frequency'])!,
      logDescription: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}log_description'])!,
      documentNo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}document_no'])!,
      deviceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_id'])!,
      logCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}log_code'])!,
      logSeverity: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}log_severity'])!,
      exportDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}export_date_time']),
      exportStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}export_status'])!,
      syncError: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sync_error']),
    );
  }

  @override
  $ApplicationLoggerTable createAlias(String alias) {
    return $ApplicationLoggerTable(attachedDatabase, alias);
  }
}

class ApplicationLoggerData extends DataClass
    implements Insertable<ApplicationLoggerData> {
  final String? tenantId;
  final String? userName;
  final int? userId;
  final int id;
  final String functionName;
  final DateTime logDateTime;
  final String syncFrequency;
  final String logDescription;
  final String documentNo;
  final String deviceId;
  final String logCode;
  final String logSeverity;
  final DateTime? exportDateTime;
  final String exportStatus;
  final String? syncError;
  const ApplicationLoggerData(
      {this.tenantId,
      this.userName,
      this.userId,
      required this.id,
      required this.functionName,
      required this.logDateTime,
      required this.syncFrequency,
      required this.logDescription,
      required this.documentNo,
      required this.deviceId,
      required this.logCode,
      required this.logSeverity,
      this.exportDateTime,
      required this.exportStatus,
      this.syncError});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<int>(userId);
    }
    map['id'] = Variable<int>(id);
    map['function_name'] = Variable<String>(functionName);
    map['log_date_time'] = Variable<DateTime>(logDateTime);
    map['sync_frequency'] = Variable<String>(syncFrequency);
    map['log_description'] = Variable<String>(logDescription);
    map['document_no'] = Variable<String>(documentNo);
    map['device_id'] = Variable<String>(deviceId);
    map['log_code'] = Variable<String>(logCode);
    map['log_severity'] = Variable<String>(logSeverity);
    if (!nullToAbsent || exportDateTime != null) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime);
    }
    map['export_status'] = Variable<String>(exportStatus);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    return map;
  }

  ApplicationLoggerCompanion toCompanion(bool nullToAbsent) {
    return ApplicationLoggerCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      id: Value(id),
      functionName: Value(functionName),
      logDateTime: Value(logDateTime),
      syncFrequency: Value(syncFrequency),
      logDescription: Value(logDescription),
      documentNo: Value(documentNo),
      deviceId: Value(deviceId),
      logCode: Value(logCode),
      logSeverity: Value(logSeverity),
      exportDateTime: exportDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(exportDateTime),
      exportStatus: Value(exportStatus),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
    );
  }

  factory ApplicationLoggerData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ApplicationLoggerData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      userName: serializer.fromJson<String?>(json['userName']),
      userId: serializer.fromJson<int?>(json['userId']),
      id: serializer.fromJson<int>(json['id']),
      functionName: serializer.fromJson<String>(json['functionName']),
      logDateTime: serializer.fromJson<DateTime>(json['logDateTime']),
      syncFrequency: serializer.fromJson<String>(json['syncFrequency']),
      logDescription: serializer.fromJson<String>(json['logDescription']),
      documentNo: serializer.fromJson<String>(json['documentNo']),
      deviceId: serializer.fromJson<String>(json['deviceId']),
      logCode: serializer.fromJson<String>(json['logCode']),
      logSeverity: serializer.fromJson<String>(json['logSeverity']),
      exportDateTime: serializer.fromJson<DateTime?>(json['exportDateTime']),
      exportStatus: serializer.fromJson<String>(json['exportStatus']),
      syncError: serializer.fromJson<String?>(json['syncError']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'userName': serializer.toJson<String?>(userName),
      'userId': serializer.toJson<int?>(userId),
      'id': serializer.toJson<int>(id),
      'functionName': serializer.toJson<String>(functionName),
      'logDateTime': serializer.toJson<DateTime>(logDateTime),
      'syncFrequency': serializer.toJson<String>(syncFrequency),
      'logDescription': serializer.toJson<String>(logDescription),
      'documentNo': serializer.toJson<String>(documentNo),
      'deviceId': serializer.toJson<String>(deviceId),
      'logCode': serializer.toJson<String>(logCode),
      'logSeverity': serializer.toJson<String>(logSeverity),
      'exportDateTime': serializer.toJson<DateTime?>(exportDateTime),
      'exportStatus': serializer.toJson<String>(exportStatus),
      'syncError': serializer.toJson<String?>(syncError),
    };
  }

  ApplicationLoggerData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          Value<String?> userName = const Value.absent(),
          Value<int?> userId = const Value.absent(),
          int? id,
          String? functionName,
          DateTime? logDateTime,
          String? syncFrequency,
          String? logDescription,
          String? documentNo,
          String? deviceId,
          String? logCode,
          String? logSeverity,
          Value<DateTime?> exportDateTime = const Value.absent(),
          String? exportStatus,
          Value<String?> syncError = const Value.absent()}) =>
      ApplicationLoggerData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        userName: userName.present ? userName.value : this.userName,
        userId: userId.present ? userId.value : this.userId,
        id: id ?? this.id,
        functionName: functionName ?? this.functionName,
        logDateTime: logDateTime ?? this.logDateTime,
        syncFrequency: syncFrequency ?? this.syncFrequency,
        logDescription: logDescription ?? this.logDescription,
        documentNo: documentNo ?? this.documentNo,
        deviceId: deviceId ?? this.deviceId,
        logCode: logCode ?? this.logCode,
        logSeverity: logSeverity ?? this.logSeverity,
        exportDateTime:
            exportDateTime.present ? exportDateTime.value : this.exportDateTime,
        exportStatus: exportStatus ?? this.exportStatus,
        syncError: syncError.present ? syncError.value : this.syncError,
      );
  @override
  String toString() {
    return (StringBuffer('ApplicationLoggerData(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('functionName: $functionName, ')
          ..write('logDateTime: $logDateTime, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('logDescription: $logDescription, ')
          ..write('documentNo: $documentNo, ')
          ..write('deviceId: $deviceId, ')
          ..write('logCode: $logCode, ')
          ..write('logSeverity: $logSeverity, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('syncError: $syncError')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      userName,
      userId,
      id,
      functionName,
      logDateTime,
      syncFrequency,
      logDescription,
      documentNo,
      deviceId,
      logCode,
      logSeverity,
      exportDateTime,
      exportStatus,
      syncError);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ApplicationLoggerData &&
          other.tenantId == this.tenantId &&
          other.userName == this.userName &&
          other.userId == this.userId &&
          other.id == this.id &&
          other.functionName == this.functionName &&
          other.logDateTime == this.logDateTime &&
          other.syncFrequency == this.syncFrequency &&
          other.logDescription == this.logDescription &&
          other.documentNo == this.documentNo &&
          other.deviceId == this.deviceId &&
          other.logCode == this.logCode &&
          other.logSeverity == this.logSeverity &&
          other.exportDateTime == this.exportDateTime &&
          other.exportStatus == this.exportStatus &&
          other.syncError == this.syncError);
}

class ApplicationLoggerCompanion
    extends UpdateCompanion<ApplicationLoggerData> {
  final Value<String?> tenantId;
  final Value<String?> userName;
  final Value<int?> userId;
  final Value<int> id;
  final Value<String> functionName;
  final Value<DateTime> logDateTime;
  final Value<String> syncFrequency;
  final Value<String> logDescription;
  final Value<String> documentNo;
  final Value<String> deviceId;
  final Value<String> logCode;
  final Value<String> logSeverity;
  final Value<DateTime?> exportDateTime;
  final Value<String> exportStatus;
  final Value<String?> syncError;
  const ApplicationLoggerCompanion({
    this.tenantId = const Value.absent(),
    this.userName = const Value.absent(),
    this.userId = const Value.absent(),
    this.id = const Value.absent(),
    this.functionName = const Value.absent(),
    this.logDateTime = const Value.absent(),
    this.syncFrequency = const Value.absent(),
    this.logDescription = const Value.absent(),
    this.documentNo = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.logCode = const Value.absent(),
    this.logSeverity = const Value.absent(),
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.syncError = const Value.absent(),
  });
  ApplicationLoggerCompanion.insert({
    this.tenantId = const Value.absent(),
    this.userName = const Value.absent(),
    this.userId = const Value.absent(),
    this.id = const Value.absent(),
    required String functionName,
    required DateTime logDateTime,
    required String syncFrequency,
    required String logDescription,
    required String documentNo,
    required String deviceId,
    required String logCode,
    required String logSeverity,
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.syncError = const Value.absent(),
  })  : functionName = Value(functionName),
        logDateTime = Value(logDateTime),
        syncFrequency = Value(syncFrequency),
        logDescription = Value(logDescription),
        documentNo = Value(documentNo),
        deviceId = Value(deviceId),
        logCode = Value(logCode),
        logSeverity = Value(logSeverity);
  static Insertable<ApplicationLoggerData> custom({
    Expression<String>? tenantId,
    Expression<String>? userName,
    Expression<int>? userId,
    Expression<int>? id,
    Expression<String>? functionName,
    Expression<DateTime>? logDateTime,
    Expression<String>? syncFrequency,
    Expression<String>? logDescription,
    Expression<String>? documentNo,
    Expression<String>? deviceId,
    Expression<String>? logCode,
    Expression<String>? logSeverity,
    Expression<DateTime>? exportDateTime,
    Expression<String>? exportStatus,
    Expression<String>? syncError,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (userName != null) 'user_name': userName,
      if (userId != null) 'user_id': userId,
      if (id != null) 'id': id,
      if (functionName != null) 'function_name': functionName,
      if (logDateTime != null) 'log_date_time': logDateTime,
      if (syncFrequency != null) 'sync_frequency': syncFrequency,
      if (logDescription != null) 'log_description': logDescription,
      if (documentNo != null) 'document_no': documentNo,
      if (deviceId != null) 'device_id': deviceId,
      if (logCode != null) 'log_code': logCode,
      if (logSeverity != null) 'log_severity': logSeverity,
      if (exportDateTime != null) 'export_date_time': exportDateTime,
      if (exportStatus != null) 'export_status': exportStatus,
      if (syncError != null) 'sync_error': syncError,
    });
  }

  ApplicationLoggerCompanion copyWith(
      {Value<String?>? tenantId,
      Value<String?>? userName,
      Value<int?>? userId,
      Value<int>? id,
      Value<String>? functionName,
      Value<DateTime>? logDateTime,
      Value<String>? syncFrequency,
      Value<String>? logDescription,
      Value<String>? documentNo,
      Value<String>? deviceId,
      Value<String>? logCode,
      Value<String>? logSeverity,
      Value<DateTime?>? exportDateTime,
      Value<String>? exportStatus,
      Value<String?>? syncError}) {
    return ApplicationLoggerCompanion(
      tenantId: tenantId ?? this.tenantId,
      userName: userName ?? this.userName,
      userId: userId ?? this.userId,
      id: id ?? this.id,
      functionName: functionName ?? this.functionName,
      logDateTime: logDateTime ?? this.logDateTime,
      syncFrequency: syncFrequency ?? this.syncFrequency,
      logDescription: logDescription ?? this.logDescription,
      documentNo: documentNo ?? this.documentNo,
      deviceId: deviceId ?? this.deviceId,
      logCode: logCode ?? this.logCode,
      logSeverity: logSeverity ?? this.logSeverity,
      exportDateTime: exportDateTime ?? this.exportDateTime,
      exportStatus: exportStatus ?? this.exportStatus,
      syncError: syncError ?? this.syncError,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (functionName.present) {
      map['function_name'] = Variable<String>(functionName.value);
    }
    if (logDateTime.present) {
      map['log_date_time'] = Variable<DateTime>(logDateTime.value);
    }
    if (syncFrequency.present) {
      map['sync_frequency'] = Variable<String>(syncFrequency.value);
    }
    if (logDescription.present) {
      map['log_description'] = Variable<String>(logDescription.value);
    }
    if (documentNo.present) {
      map['document_no'] = Variable<String>(documentNo.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (logCode.present) {
      map['log_code'] = Variable<String>(logCode.value);
    }
    if (logSeverity.present) {
      map['log_severity'] = Variable<String>(logSeverity.value);
    }
    if (exportDateTime.present) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime.value);
    }
    if (exportStatus.present) {
      map['export_status'] = Variable<String>(exportStatus.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ApplicationLoggerCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('functionName: $functionName, ')
          ..write('logDateTime: $logDateTime, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('logDescription: $logDescription, ')
          ..write('documentNo: $documentNo, ')
          ..write('deviceId: $deviceId, ')
          ..write('logCode: $logCode, ')
          ..write('logSeverity: $logSeverity, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('syncError: $syncError')
          ..write(')'))
        .toString();
  }
}

class $TenantTable extends Tenant with TableInfo<$TenantTable, TenantData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TenantTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantNameMeta =
      const VerificationMeta('tenantName');
  @override
  late final GeneratedColumn<String> tenantName = GeneratedColumn<String>(
      'tenant_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantStateMeta =
      const VerificationMeta('tenantState');
  @override
  late final GeneratedColumn<int> tenantState = GeneratedColumn<int>(
      'tenant_state', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
      'user_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [tenantId, tenantName, tenantState, userId, userName];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tenant';
  @override
  VerificationContext validateIntegrity(Insertable<TenantData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('tenant_name')) {
      context.handle(
          _tenantNameMeta,
          tenantName.isAcceptableOrUnknown(
              data['tenant_name']!, _tenantNameMeta));
    }
    if (data.containsKey('tenant_state')) {
      context.handle(
          _tenantStateMeta,
          tenantState.isAcceptableOrUnknown(
              data['tenant_state']!, _tenantStateMeta));
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {tenantId};
  @override
  TenantData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TenantData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id'])!,
      tenantName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_name']),
      tenantState: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}tenant_state']),
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_id']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
    );
  }

  @override
  $TenantTable createAlias(String alias) {
    return $TenantTable(attachedDatabase, alias);
  }
}

class TenantData extends DataClass implements Insertable<TenantData> {
  final String tenantId;
  final String? tenantName;
  final int? tenantState;
  final String? userId;
  final String? userName;
  const TenantData(
      {required this.tenantId,
      this.tenantName,
      this.tenantState,
      this.userId,
      this.userName});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['tenant_id'] = Variable<String>(tenantId);
    if (!nullToAbsent || tenantName != null) {
      map['tenant_name'] = Variable<String>(tenantName);
    }
    if (!nullToAbsent || tenantState != null) {
      map['tenant_state'] = Variable<int>(tenantState);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<String>(userId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    return map;
  }

  TenantCompanion toCompanion(bool nullToAbsent) {
    return TenantCompanion(
      tenantId: Value(tenantId),
      tenantName: tenantName == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantName),
      tenantState: tenantState == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantState),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
    );
  }

  factory TenantData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TenantData(
      tenantId: serializer.fromJson<String>(json['tenantId']),
      tenantName: serializer.fromJson<String?>(json['tenantName']),
      tenantState: serializer.fromJson<int?>(json['tenantState']),
      userId: serializer.fromJson<String?>(json['userId']),
      userName: serializer.fromJson<String?>(json['userName']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String>(tenantId),
      'tenantName': serializer.toJson<String?>(tenantName),
      'tenantState': serializer.toJson<int?>(tenantState),
      'userId': serializer.toJson<String?>(userId),
      'userName': serializer.toJson<String?>(userName),
    };
  }

  TenantData copyWith(
          {String? tenantId,
          Value<String?> tenantName = const Value.absent(),
          Value<int?> tenantState = const Value.absent(),
          Value<String?> userId = const Value.absent(),
          Value<String?> userName = const Value.absent()}) =>
      TenantData(
        tenantId: tenantId ?? this.tenantId,
        tenantName: tenantName.present ? tenantName.value : this.tenantName,
        tenantState: tenantState.present ? tenantState.value : this.tenantState,
        userId: userId.present ? userId.value : this.userId,
        userName: userName.present ? userName.value : this.userName,
      );
  @override
  String toString() {
    return (StringBuffer('TenantData(')
          ..write('tenantId: $tenantId, ')
          ..write('tenantName: $tenantName, ')
          ..write('tenantState: $tenantState, ')
          ..write('userId: $userId, ')
          ..write('userName: $userName')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(tenantId, tenantName, tenantState, userId, userName);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TenantData &&
          other.tenantId == this.tenantId &&
          other.tenantName == this.tenantName &&
          other.tenantState == this.tenantState &&
          other.userId == this.userId &&
          other.userName == this.userName);
}

class TenantCompanion extends UpdateCompanion<TenantData> {
  final Value<String> tenantId;
  final Value<String?> tenantName;
  final Value<int?> tenantState;
  final Value<String?> userId;
  final Value<String?> userName;
  final Value<int> rowid;
  const TenantCompanion({
    this.tenantId = const Value.absent(),
    this.tenantName = const Value.absent(),
    this.tenantState = const Value.absent(),
    this.userId = const Value.absent(),
    this.userName = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TenantCompanion.insert({
    required String tenantId,
    this.tenantName = const Value.absent(),
    this.tenantState = const Value.absent(),
    this.userId = const Value.absent(),
    this.userName = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : tenantId = Value(tenantId);
  static Insertable<TenantData> custom({
    Expression<String>? tenantId,
    Expression<String>? tenantName,
    Expression<int>? tenantState,
    Expression<String>? userId,
    Expression<String>? userName,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (tenantName != null) 'tenant_name': tenantName,
      if (tenantState != null) 'tenant_state': tenantState,
      if (userId != null) 'user_id': userId,
      if (userName != null) 'user_name': userName,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TenantCompanion copyWith(
      {Value<String>? tenantId,
      Value<String?>? tenantName,
      Value<int?>? tenantState,
      Value<String?>? userId,
      Value<String?>? userName,
      Value<int>? rowid}) {
    return TenantCompanion(
      tenantId: tenantId ?? this.tenantId,
      tenantName: tenantName ?? this.tenantName,
      tenantState: tenantState ?? this.tenantState,
      userId: userId ?? this.userId,
      userName: userName ?? this.userName,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (tenantName.present) {
      map['tenant_name'] = Variable<String>(tenantName.value);
    }
    if (tenantState.present) {
      map['tenant_state'] = Variable<int>(tenantState.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TenantCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('tenantName: $tenantName, ')
          ..write('tenantState: $tenantState, ')
          ..write('userId: $userId, ')
          ..write('userName: $userName, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $NonGlobalPreferenceTable extends NonGlobalPreference
    with TableInfo<$NonGlobalPreferenceTable, NonGlobalPreferenceData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $NonGlobalPreferenceTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _parentCodeMeta =
      const VerificationMeta('parentCode');
  @override
  late final GeneratedColumn<String> parentCode = GeneratedColumn<String>(
      'parent_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
      'value', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _settingTypeMeta =
      const VerificationMeta('settingType');
  @override
  late final GeneratedColumn<String> settingType = GeneratedColumn<String>(
      'setting_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceIdMeta =
      const VerificationMeta('deviceId');
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
      'device_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _screenMeta = const VerificationMeta('screen');
  @override
  late final GeneratedColumn<String> screen = GeneratedColumn<String>(
      'screen', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isApplyMeta =
      const VerificationMeta('isApply');
  @override
  late final GeneratedColumn<bool> isApply = GeneratedColumn<bool>(
      'is_apply', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_apply" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _expiredDateTimeMeta =
      const VerificationMeta('expiredDateTime');
  @override
  late final GeneratedColumn<DateTime> expiredDateTime =
      GeneratedColumn<DateTime>('expired_date_time', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _syncErrorMeta =
      const VerificationMeta('syncError');
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
      'sync_error', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dataTypeMeta =
      const VerificationMeta('dataType');
  @override
  late final GeneratedColumn<String> dataType = GeneratedColumn<String>(
      'data_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _dataValueMeta =
      const VerificationMeta('dataValue');
  @override
  late final GeneratedColumn<String> dataValue = GeneratedColumn<String>(
      'data_value', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _groupsMeta = const VerificationMeta('groups');
  @override
  late final GeneratedColumn<String> groups = GeneratedColumn<String>(
      'groups', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        parentCode,
        code,
        value,
        settingType,
        deviceId,
        userName,
        screen,
        isApply,
        expiredDateTime,
        syncError,
        dataType,
        dataValue,
        groups,
        tenantId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'non_global_preference';
  @override
  VerificationContext validateIntegrity(
      Insertable<NonGlobalPreferenceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('parent_code')) {
      context.handle(
          _parentCodeMeta,
          parentCode.isAcceptableOrUnknown(
              data['parent_code']!, _parentCodeMeta));
    } else if (isInserting) {
      context.missing(_parentCodeMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value']!, _valueMeta));
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('setting_type')) {
      context.handle(
          _settingTypeMeta,
          settingType.isAcceptableOrUnknown(
              data['setting_type']!, _settingTypeMeta));
    }
    if (data.containsKey('device_id')) {
      context.handle(_deviceIdMeta,
          deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('screen')) {
      context.handle(_screenMeta,
          screen.isAcceptableOrUnknown(data['screen']!, _screenMeta));
    }
    if (data.containsKey('is_apply')) {
      context.handle(_isApplyMeta,
          isApply.isAcceptableOrUnknown(data['is_apply']!, _isApplyMeta));
    }
    if (data.containsKey('expired_date_time')) {
      context.handle(
          _expiredDateTimeMeta,
          expiredDateTime.isAcceptableOrUnknown(
              data['expired_date_time']!, _expiredDateTimeMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type']!, _dataTypeMeta));
    }
    if (data.containsKey('data_value')) {
      context.handle(_dataValueMeta,
          dataValue.isAcceptableOrUnknown(data['data_value']!, _dataValueMeta));
    }
    if (data.containsKey('groups')) {
      context.handle(_groupsMeta,
          groups.isAcceptableOrUnknown(data['groups']!, _groupsMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  NonGlobalPreferenceData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return NonGlobalPreferenceData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      parentCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}parent_code'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      value: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}value'])!,
      settingType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}setting_type']),
      deviceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_id']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      screen: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}screen']),
      isApply: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_apply'])!,
      expiredDateTime: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}expired_date_time']),
      syncError: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sync_error']),
      dataType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_type']),
      dataValue: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}data_value']),
      groups: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}groups']),
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
    );
  }

  @override
  $NonGlobalPreferenceTable createAlias(String alias) {
    return $NonGlobalPreferenceTable(attachedDatabase, alias);
  }
}

class NonGlobalPreferenceData extends DataClass
    implements Insertable<NonGlobalPreferenceData> {
  final int id;
  final String parentCode;
  final String code;
  final String value;
  final String? settingType;
  final String? deviceId;
  final String? userName;
  final String? screen;
  final bool isApply;
  final DateTime? expiredDateTime;
  final String? syncError;
  final String? dataType;
  final String? dataValue;
  final String? groups;
  final String? tenantId;
  const NonGlobalPreferenceData(
      {required this.id,
      required this.parentCode,
      required this.code,
      required this.value,
      this.settingType,
      this.deviceId,
      this.userName,
      this.screen,
      required this.isApply,
      this.expiredDateTime,
      this.syncError,
      this.dataType,
      this.dataValue,
      this.groups,
      this.tenantId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['parent_code'] = Variable<String>(parentCode);
    map['code'] = Variable<String>(code);
    map['value'] = Variable<String>(value);
    if (!nullToAbsent || settingType != null) {
      map['setting_type'] = Variable<String>(settingType);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || screen != null) {
      map['screen'] = Variable<String>(screen);
    }
    map['is_apply'] = Variable<bool>(isApply);
    if (!nullToAbsent || expiredDateTime != null) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime);
    }
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || dataValue != null) {
      map['data_value'] = Variable<String>(dataValue);
    }
    if (!nullToAbsent || groups != null) {
      map['groups'] = Variable<String>(groups);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    return map;
  }

  NonGlobalPreferenceCompanion toCompanion(bool nullToAbsent) {
    return NonGlobalPreferenceCompanion(
      id: Value(id),
      parentCode: Value(parentCode),
      code: Value(code),
      value: Value(value),
      settingType: settingType == null && nullToAbsent
          ? const Value.absent()
          : Value(settingType),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      screen:
          screen == null && nullToAbsent ? const Value.absent() : Value(screen),
      isApply: Value(isApply),
      expiredDateTime: expiredDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(expiredDateTime),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      dataValue: dataValue == null && nullToAbsent
          ? const Value.absent()
          : Value(dataValue),
      groups:
          groups == null && nullToAbsent ? const Value.absent() : Value(groups),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory NonGlobalPreferenceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NonGlobalPreferenceData(
      id: serializer.fromJson<int>(json['id']),
      parentCode: serializer.fromJson<String>(json['parentCode']),
      code: serializer.fromJson<String>(json['code']),
      value: serializer.fromJson<String>(json['value']),
      settingType: serializer.fromJson<String?>(json['settingType']),
      deviceId: serializer.fromJson<String?>(json['deviceId']),
      userName: serializer.fromJson<String?>(json['userName']),
      screen: serializer.fromJson<String?>(json['screen']),
      isApply: serializer.fromJson<bool>(json['isApply']),
      expiredDateTime: serializer.fromJson<DateTime?>(json['expiredDateTime']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      dataType: serializer.fromJson<String?>(json['dataType']),
      dataValue: serializer.fromJson<String?>(json['dataValue']),
      groups: serializer.fromJson<String?>(json['groups']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'parentCode': serializer.toJson<String>(parentCode),
      'code': serializer.toJson<String>(code),
      'value': serializer.toJson<String>(value),
      'settingType': serializer.toJson<String?>(settingType),
      'deviceId': serializer.toJson<String?>(deviceId),
      'userName': serializer.toJson<String?>(userName),
      'screen': serializer.toJson<String?>(screen),
      'isApply': serializer.toJson<bool>(isApply),
      'expiredDateTime': serializer.toJson<DateTime?>(expiredDateTime),
      'syncError': serializer.toJson<String?>(syncError),
      'dataType': serializer.toJson<String?>(dataType),
      'dataValue': serializer.toJson<String?>(dataValue),
      'groups': serializer.toJson<String?>(groups),
      'tenantId': serializer.toJson<String?>(tenantId),
    };
  }

  NonGlobalPreferenceData copyWith(
          {int? id,
          String? parentCode,
          String? code,
          String? value,
          Value<String?> settingType = const Value.absent(),
          Value<String?> deviceId = const Value.absent(),
          Value<String?> userName = const Value.absent(),
          Value<String?> screen = const Value.absent(),
          bool? isApply,
          Value<DateTime?> expiredDateTime = const Value.absent(),
          Value<String?> syncError = const Value.absent(),
          Value<String?> dataType = const Value.absent(),
          Value<String?> dataValue = const Value.absent(),
          Value<String?> groups = const Value.absent(),
          Value<String?> tenantId = const Value.absent()}) =>
      NonGlobalPreferenceData(
        id: id ?? this.id,
        parentCode: parentCode ?? this.parentCode,
        code: code ?? this.code,
        value: value ?? this.value,
        settingType: settingType.present ? settingType.value : this.settingType,
        deviceId: deviceId.present ? deviceId.value : this.deviceId,
        userName: userName.present ? userName.value : this.userName,
        screen: screen.present ? screen.value : this.screen,
        isApply: isApply ?? this.isApply,
        expiredDateTime: expiredDateTime.present
            ? expiredDateTime.value
            : this.expiredDateTime,
        syncError: syncError.present ? syncError.value : this.syncError,
        dataType: dataType.present ? dataType.value : this.dataType,
        dataValue: dataValue.present ? dataValue.value : this.dataValue,
        groups: groups.present ? groups.value : this.groups,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('NonGlobalPreferenceData(')
          ..write('id: $id, ')
          ..write('parentCode: $parentCode, ')
          ..write('code: $code, ')
          ..write('value: $value, ')
          ..write('settingType: $settingType, ')
          ..write('deviceId: $deviceId, ')
          ..write('userName: $userName, ')
          ..write('screen: $screen, ')
          ..write('isApply: $isApply, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('syncError: $syncError, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      parentCode,
      code,
      value,
      settingType,
      deviceId,
      userName,
      screen,
      isApply,
      expiredDateTime,
      syncError,
      dataType,
      dataValue,
      groups,
      tenantId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NonGlobalPreferenceData &&
          other.id == this.id &&
          other.parentCode == this.parentCode &&
          other.code == this.code &&
          other.value == this.value &&
          other.settingType == this.settingType &&
          other.deviceId == this.deviceId &&
          other.userName == this.userName &&
          other.screen == this.screen &&
          other.isApply == this.isApply &&
          other.expiredDateTime == this.expiredDateTime &&
          other.syncError == this.syncError &&
          other.dataType == this.dataType &&
          other.dataValue == this.dataValue &&
          other.groups == this.groups &&
          other.tenantId == this.tenantId);
}

class NonGlobalPreferenceCompanion
    extends UpdateCompanion<NonGlobalPreferenceData> {
  final Value<int> id;
  final Value<String> parentCode;
  final Value<String> code;
  final Value<String> value;
  final Value<String?> settingType;
  final Value<String?> deviceId;
  final Value<String?> userName;
  final Value<String?> screen;
  final Value<bool> isApply;
  final Value<DateTime?> expiredDateTime;
  final Value<String?> syncError;
  final Value<String?> dataType;
  final Value<String?> dataValue;
  final Value<String?> groups;
  final Value<String?> tenantId;
  final Value<int> rowid;
  const NonGlobalPreferenceCompanion({
    this.id = const Value.absent(),
    this.parentCode = const Value.absent(),
    this.code = const Value.absent(),
    this.value = const Value.absent(),
    this.settingType = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userName = const Value.absent(),
    this.screen = const Value.absent(),
    this.isApply = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.syncError = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  NonGlobalPreferenceCompanion.insert({
    required int id,
    required String parentCode,
    required String code,
    required String value,
    this.settingType = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userName = const Value.absent(),
    this.screen = const Value.absent(),
    this.isApply = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.syncError = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        parentCode = Value(parentCode),
        code = Value(code),
        value = Value(value);
  static Insertable<NonGlobalPreferenceData> custom({
    Expression<int>? id,
    Expression<String>? parentCode,
    Expression<String>? code,
    Expression<String>? value,
    Expression<String>? settingType,
    Expression<String>? deviceId,
    Expression<String>? userName,
    Expression<String>? screen,
    Expression<bool>? isApply,
    Expression<DateTime>? expiredDateTime,
    Expression<String>? syncError,
    Expression<String>? dataType,
    Expression<String>? dataValue,
    Expression<String>? groups,
    Expression<String>? tenantId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (parentCode != null) 'parent_code': parentCode,
      if (code != null) 'code': code,
      if (value != null) 'value': value,
      if (settingType != null) 'setting_type': settingType,
      if (deviceId != null) 'device_id': deviceId,
      if (userName != null) 'user_name': userName,
      if (screen != null) 'screen': screen,
      if (isApply != null) 'is_apply': isApply,
      if (expiredDateTime != null) 'expired_date_time': expiredDateTime,
      if (syncError != null) 'sync_error': syncError,
      if (dataType != null) 'data_type': dataType,
      if (dataValue != null) 'data_value': dataValue,
      if (groups != null) 'groups': groups,
      if (tenantId != null) 'tenant_id': tenantId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  NonGlobalPreferenceCompanion copyWith(
      {Value<int>? id,
      Value<String>? parentCode,
      Value<String>? code,
      Value<String>? value,
      Value<String?>? settingType,
      Value<String?>? deviceId,
      Value<String?>? userName,
      Value<String?>? screen,
      Value<bool>? isApply,
      Value<DateTime?>? expiredDateTime,
      Value<String?>? syncError,
      Value<String?>? dataType,
      Value<String?>? dataValue,
      Value<String?>? groups,
      Value<String?>? tenantId,
      Value<int>? rowid}) {
    return NonGlobalPreferenceCompanion(
      id: id ?? this.id,
      parentCode: parentCode ?? this.parentCode,
      code: code ?? this.code,
      value: value ?? this.value,
      settingType: settingType ?? this.settingType,
      deviceId: deviceId ?? this.deviceId,
      userName: userName ?? this.userName,
      screen: screen ?? this.screen,
      isApply: isApply ?? this.isApply,
      expiredDateTime: expiredDateTime ?? this.expiredDateTime,
      syncError: syncError ?? this.syncError,
      dataType: dataType ?? this.dataType,
      dataValue: dataValue ?? this.dataValue,
      groups: groups ?? this.groups,
      tenantId: tenantId ?? this.tenantId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (parentCode.present) {
      map['parent_code'] = Variable<String>(parentCode.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (settingType.present) {
      map['setting_type'] = Variable<String>(settingType.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (screen.present) {
      map['screen'] = Variable<String>(screen.value);
    }
    if (isApply.present) {
      map['is_apply'] = Variable<bool>(isApply.value);
    }
    if (expiredDateTime.present) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (dataValue.present) {
      map['data_value'] = Variable<String>(dataValue.value);
    }
    if (groups.present) {
      map['groups'] = Variable<String>(groups.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NonGlobalPreferenceCompanion(')
          ..write('id: $id, ')
          ..write('parentCode: $parentCode, ')
          ..write('code: $code, ')
          ..write('value: $value, ')
          ..write('settingType: $settingType, ')
          ..write('deviceId: $deviceId, ')
          ..write('userName: $userName, ')
          ..write('screen: $screen, ')
          ..write('isApply: $isApply, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('syncError: $syncError, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups, ')
          ..write('tenantId: $tenantId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $DesktopTable extends Desktop with TableInfo<$DesktopTable, DesktopData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DesktopTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _featureCodeMeta =
      const VerificationMeta('featureCode');
  @override
  late final GeneratedColumn<String> featureCode = GeneratedColumn<String>(
      'feature_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _showInLocationMeta =
      const VerificationMeta('showInLocation');
  @override
  late final GeneratedColumn<String> showInLocation = GeneratedColumn<String>(
      'show_in_location', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _iconNameMeta =
      const VerificationMeta('iconName');
  @override
  late final GeneratedColumn<String> iconName = GeneratedColumn<String>(
      'icon_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _iconCodeMeta =
      const VerificationMeta('iconCode');
  @override
  late final GeneratedColumn<String> iconCode = GeneratedColumn<String>(
      'icon_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _iconColourMeta =
      const VerificationMeta('iconColour');
  @override
  late final GeneratedColumn<String> iconColour = GeneratedColumn<String>(
      'icon_colour', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _iconFamilyMeta =
      const VerificationMeta('iconFamily');
  @override
  late final GeneratedColumn<String> iconFamily = GeneratedColumn<String>(
      'icon_family', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _navigationRouteMeta =
      const VerificationMeta('navigationRoute');
  @override
  late final GeneratedColumn<String> navigationRoute = GeneratedColumn<String>(
      'navigation_route', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _iconGroupMeta =
      const VerificationMeta('iconGroup');
  @override
  late final GeneratedColumn<String> iconGroup = GeneratedColumn<String>(
      'icon_group', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _isFavoritMeta =
      const VerificationMeta('isFavorit');
  @override
  late final GeneratedColumn<bool> isFavorit = GeneratedColumn<bool>(
      'is_favorit', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_favorit" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _userPermissionMeta =
      const VerificationMeta('userPermission');
  @override
  late final GeneratedColumn<String> userPermission = GeneratedColumn<String>(
      'user_permission', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _tagMeta = const VerificationMeta('tag');
  @override
  late final GeneratedColumn<String> tag = GeneratedColumn<String>(
      'tag', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isFreeTrialMeta =
      const VerificationMeta('isFreeTrial');
  @override
  late final GeneratedColumn<bool> isFreeTrial = GeneratedColumn<bool>(
      'is_free_trial', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_free_trial" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _validFromMeta =
      const VerificationMeta('validFrom');
  @override
  late final GeneratedColumn<DateTime> validFrom = GeneratedColumn<DateTime>(
      'valid_from', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _validToMeta =
      const VerificationMeta('validTo');
  @override
  late final GeneratedColumn<DateTime> validTo = GeneratedColumn<DateTime>(
      'valid_to', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        featureCode,
        showInLocation,
        iconName,
        iconCode,
        iconColour,
        iconFamily,
        navigationRoute,
        iconGroup,
        isFavorit,
        userPermission,
        tenantId,
        tag,
        isDeleted,
        isFreeTrial,
        validFrom,
        validTo
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'desktop';
  @override
  VerificationContext validateIntegrity(Insertable<DesktopData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('feature_code')) {
      context.handle(
          _featureCodeMeta,
          featureCode.isAcceptableOrUnknown(
              data['feature_code']!, _featureCodeMeta));
    } else if (isInserting) {
      context.missing(_featureCodeMeta);
    }
    if (data.containsKey('show_in_location')) {
      context.handle(
          _showInLocationMeta,
          showInLocation.isAcceptableOrUnknown(
              data['show_in_location']!, _showInLocationMeta));
    }
    if (data.containsKey('icon_name')) {
      context.handle(_iconNameMeta,
          iconName.isAcceptableOrUnknown(data['icon_name']!, _iconNameMeta));
    } else if (isInserting) {
      context.missing(_iconNameMeta);
    }
    if (data.containsKey('icon_code')) {
      context.handle(_iconCodeMeta,
          iconCode.isAcceptableOrUnknown(data['icon_code']!, _iconCodeMeta));
    } else if (isInserting) {
      context.missing(_iconCodeMeta);
    }
    if (data.containsKey('icon_colour')) {
      context.handle(
          _iconColourMeta,
          iconColour.isAcceptableOrUnknown(
              data['icon_colour']!, _iconColourMeta));
    } else if (isInserting) {
      context.missing(_iconColourMeta);
    }
    if (data.containsKey('icon_family')) {
      context.handle(
          _iconFamilyMeta,
          iconFamily.isAcceptableOrUnknown(
              data['icon_family']!, _iconFamilyMeta));
    } else if (isInserting) {
      context.missing(_iconFamilyMeta);
    }
    if (data.containsKey('navigation_route')) {
      context.handle(
          _navigationRouteMeta,
          navigationRoute.isAcceptableOrUnknown(
              data['navigation_route']!, _navigationRouteMeta));
    } else if (isInserting) {
      context.missing(_navigationRouteMeta);
    }
    if (data.containsKey('icon_group')) {
      context.handle(_iconGroupMeta,
          iconGroup.isAcceptableOrUnknown(data['icon_group']!, _iconGroupMeta));
    } else if (isInserting) {
      context.missing(_iconGroupMeta);
    }
    if (data.containsKey('is_favorit')) {
      context.handle(_isFavoritMeta,
          isFavorit.isAcceptableOrUnknown(data['is_favorit']!, _isFavoritMeta));
    }
    if (data.containsKey('user_permission')) {
      context.handle(
          _userPermissionMeta,
          userPermission.isAcceptableOrUnknown(
              data['user_permission']!, _userPermissionMeta));
    } else if (isInserting) {
      context.missing(_userPermissionMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('tag')) {
      context.handle(
          _tagMeta, tag.isAcceptableOrUnknown(data['tag']!, _tagMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('is_free_trial')) {
      context.handle(
          _isFreeTrialMeta,
          isFreeTrial.isAcceptableOrUnknown(
              data['is_free_trial']!, _isFreeTrialMeta));
    }
    if (data.containsKey('valid_from')) {
      context.handle(_validFromMeta,
          validFrom.isAcceptableOrUnknown(data['valid_from']!, _validFromMeta));
    }
    if (data.containsKey('valid_to')) {
      context.handle(_validToMeta,
          validTo.isAcceptableOrUnknown(data['valid_to']!, _validToMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DesktopData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DesktopData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      featureCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}feature_code'])!,
      showInLocation: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}show_in_location']),
      iconName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}icon_name'])!,
      iconCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}icon_code'])!,
      iconColour: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}icon_colour'])!,
      iconFamily: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}icon_family'])!,
      navigationRoute: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}navigation_route'])!,
      iconGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}icon_group'])!,
      isFavorit: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_favorit'])!,
      userPermission: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}user_permission'])!,
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      tag: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tag']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      isFreeTrial: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_free_trial'])!,
      validFrom: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_from']),
      validTo: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_to']),
    );
  }

  @override
  $DesktopTable createAlias(String alias) {
    return $DesktopTable(attachedDatabase, alias);
  }
}

class DesktopData extends DataClass implements Insertable<DesktopData> {
  final int id;
  final String featureCode;
  final String? showInLocation;
  final String iconName;
  final String iconCode;
  final String iconColour;
  final String iconFamily;
  final String navigationRoute;
  final String iconGroup;
  final bool isFavorit;
  final String userPermission;
  final String? tenantId;
  final String? tag;
  final bool isDeleted;
  final bool isFreeTrial;
  final DateTime? validFrom;
  final DateTime? validTo;
  const DesktopData(
      {required this.id,
      required this.featureCode,
      this.showInLocation,
      required this.iconName,
      required this.iconCode,
      required this.iconColour,
      required this.iconFamily,
      required this.navigationRoute,
      required this.iconGroup,
      required this.isFavorit,
      required this.userPermission,
      this.tenantId,
      this.tag,
      required this.isDeleted,
      required this.isFreeTrial,
      this.validFrom,
      this.validTo});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['feature_code'] = Variable<String>(featureCode);
    if (!nullToAbsent || showInLocation != null) {
      map['show_in_location'] = Variable<String>(showInLocation);
    }
    map['icon_name'] = Variable<String>(iconName);
    map['icon_code'] = Variable<String>(iconCode);
    map['icon_colour'] = Variable<String>(iconColour);
    map['icon_family'] = Variable<String>(iconFamily);
    map['navigation_route'] = Variable<String>(navigationRoute);
    map['icon_group'] = Variable<String>(iconGroup);
    map['is_favorit'] = Variable<bool>(isFavorit);
    map['user_permission'] = Variable<String>(userPermission);
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    if (!nullToAbsent || tag != null) {
      map['tag'] = Variable<String>(tag);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['is_free_trial'] = Variable<bool>(isFreeTrial);
    if (!nullToAbsent || validFrom != null) {
      map['valid_from'] = Variable<DateTime>(validFrom);
    }
    if (!nullToAbsent || validTo != null) {
      map['valid_to'] = Variable<DateTime>(validTo);
    }
    return map;
  }

  DesktopCompanion toCompanion(bool nullToAbsent) {
    return DesktopCompanion(
      id: Value(id),
      featureCode: Value(featureCode),
      showInLocation: showInLocation == null && nullToAbsent
          ? const Value.absent()
          : Value(showInLocation),
      iconName: Value(iconName),
      iconCode: Value(iconCode),
      iconColour: Value(iconColour),
      iconFamily: Value(iconFamily),
      navigationRoute: Value(navigationRoute),
      iconGroup: Value(iconGroup),
      isFavorit: Value(isFavorit),
      userPermission: Value(userPermission),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      tag: tag == null && nullToAbsent ? const Value.absent() : Value(tag),
      isDeleted: Value(isDeleted),
      isFreeTrial: Value(isFreeTrial),
      validFrom: validFrom == null && nullToAbsent
          ? const Value.absent()
          : Value(validFrom),
      validTo: validTo == null && nullToAbsent
          ? const Value.absent()
          : Value(validTo),
    );
  }

  factory DesktopData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DesktopData(
      id: serializer.fromJson<int>(json['id']),
      featureCode: serializer.fromJson<String>(json['featureCode']),
      showInLocation: serializer.fromJson<String?>(json['showInLocation']),
      iconName: serializer.fromJson<String>(json['iconName']),
      iconCode: serializer.fromJson<String>(json['iconCode']),
      iconColour: serializer.fromJson<String>(json['iconColour']),
      iconFamily: serializer.fromJson<String>(json['iconFamily']),
      navigationRoute: serializer.fromJson<String>(json['navigationRoute']),
      iconGroup: serializer.fromJson<String>(json['iconGroup']),
      isFavorit: serializer.fromJson<bool>(json['isFavorit']),
      userPermission: serializer.fromJson<String>(json['userPermission']),
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      tag: serializer.fromJson<String?>(json['tag']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      isFreeTrial: serializer.fromJson<bool>(json['isFreeTrial']),
      validFrom: serializer.fromJson<DateTime?>(json['validFrom']),
      validTo: serializer.fromJson<DateTime?>(json['validTo']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'featureCode': serializer.toJson<String>(featureCode),
      'showInLocation': serializer.toJson<String?>(showInLocation),
      'iconName': serializer.toJson<String>(iconName),
      'iconCode': serializer.toJson<String>(iconCode),
      'iconColour': serializer.toJson<String>(iconColour),
      'iconFamily': serializer.toJson<String>(iconFamily),
      'navigationRoute': serializer.toJson<String>(navigationRoute),
      'iconGroup': serializer.toJson<String>(iconGroup),
      'isFavorit': serializer.toJson<bool>(isFavorit),
      'userPermission': serializer.toJson<String>(userPermission),
      'tenantId': serializer.toJson<String?>(tenantId),
      'tag': serializer.toJson<String?>(tag),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'isFreeTrial': serializer.toJson<bool>(isFreeTrial),
      'validFrom': serializer.toJson<DateTime?>(validFrom),
      'validTo': serializer.toJson<DateTime?>(validTo),
    };
  }

  DesktopData copyWith(
          {int? id,
          String? featureCode,
          Value<String?> showInLocation = const Value.absent(),
          String? iconName,
          String? iconCode,
          String? iconColour,
          String? iconFamily,
          String? navigationRoute,
          String? iconGroup,
          bool? isFavorit,
          String? userPermission,
          Value<String?> tenantId = const Value.absent(),
          Value<String?> tag = const Value.absent(),
          bool? isDeleted,
          bool? isFreeTrial,
          Value<DateTime?> validFrom = const Value.absent(),
          Value<DateTime?> validTo = const Value.absent()}) =>
      DesktopData(
        id: id ?? this.id,
        featureCode: featureCode ?? this.featureCode,
        showInLocation:
            showInLocation.present ? showInLocation.value : this.showInLocation,
        iconName: iconName ?? this.iconName,
        iconCode: iconCode ?? this.iconCode,
        iconColour: iconColour ?? this.iconColour,
        iconFamily: iconFamily ?? this.iconFamily,
        navigationRoute: navigationRoute ?? this.navigationRoute,
        iconGroup: iconGroup ?? this.iconGroup,
        isFavorit: isFavorit ?? this.isFavorit,
        userPermission: userPermission ?? this.userPermission,
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        tag: tag.present ? tag.value : this.tag,
        isDeleted: isDeleted ?? this.isDeleted,
        isFreeTrial: isFreeTrial ?? this.isFreeTrial,
        validFrom: validFrom.present ? validFrom.value : this.validFrom,
        validTo: validTo.present ? validTo.value : this.validTo,
      );
  @override
  String toString() {
    return (StringBuffer('DesktopData(')
          ..write('id: $id, ')
          ..write('featureCode: $featureCode, ')
          ..write('showInLocation: $showInLocation, ')
          ..write('iconName: $iconName, ')
          ..write('iconCode: $iconCode, ')
          ..write('iconColour: $iconColour, ')
          ..write('iconFamily: $iconFamily, ')
          ..write('navigationRoute: $navigationRoute, ')
          ..write('iconGroup: $iconGroup, ')
          ..write('isFavorit: $isFavorit, ')
          ..write('userPermission: $userPermission, ')
          ..write('tenantId: $tenantId, ')
          ..write('tag: $tag, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('isFreeTrial: $isFreeTrial, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      featureCode,
      showInLocation,
      iconName,
      iconCode,
      iconColour,
      iconFamily,
      navigationRoute,
      iconGroup,
      isFavorit,
      userPermission,
      tenantId,
      tag,
      isDeleted,
      isFreeTrial,
      validFrom,
      validTo);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DesktopData &&
          other.id == this.id &&
          other.featureCode == this.featureCode &&
          other.showInLocation == this.showInLocation &&
          other.iconName == this.iconName &&
          other.iconCode == this.iconCode &&
          other.iconColour == this.iconColour &&
          other.iconFamily == this.iconFamily &&
          other.navigationRoute == this.navigationRoute &&
          other.iconGroup == this.iconGroup &&
          other.isFavorit == this.isFavorit &&
          other.userPermission == this.userPermission &&
          other.tenantId == this.tenantId &&
          other.tag == this.tag &&
          other.isDeleted == this.isDeleted &&
          other.isFreeTrial == this.isFreeTrial &&
          other.validFrom == this.validFrom &&
          other.validTo == this.validTo);
}

class DesktopCompanion extends UpdateCompanion<DesktopData> {
  final Value<int> id;
  final Value<String> featureCode;
  final Value<String?> showInLocation;
  final Value<String> iconName;
  final Value<String> iconCode;
  final Value<String> iconColour;
  final Value<String> iconFamily;
  final Value<String> navigationRoute;
  final Value<String> iconGroup;
  final Value<bool> isFavorit;
  final Value<String> userPermission;
  final Value<String?> tenantId;
  final Value<String?> tag;
  final Value<bool> isDeleted;
  final Value<bool> isFreeTrial;
  final Value<DateTime?> validFrom;
  final Value<DateTime?> validTo;
  const DesktopCompanion({
    this.id = const Value.absent(),
    this.featureCode = const Value.absent(),
    this.showInLocation = const Value.absent(),
    this.iconName = const Value.absent(),
    this.iconCode = const Value.absent(),
    this.iconColour = const Value.absent(),
    this.iconFamily = const Value.absent(),
    this.navigationRoute = const Value.absent(),
    this.iconGroup = const Value.absent(),
    this.isFavorit = const Value.absent(),
    this.userPermission = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.tag = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.isFreeTrial = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  });
  DesktopCompanion.insert({
    this.id = const Value.absent(),
    required String featureCode,
    this.showInLocation = const Value.absent(),
    required String iconName,
    required String iconCode,
    required String iconColour,
    required String iconFamily,
    required String navigationRoute,
    required String iconGroup,
    this.isFavorit = const Value.absent(),
    required String userPermission,
    this.tenantId = const Value.absent(),
    this.tag = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.isFreeTrial = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  })  : featureCode = Value(featureCode),
        iconName = Value(iconName),
        iconCode = Value(iconCode),
        iconColour = Value(iconColour),
        iconFamily = Value(iconFamily),
        navigationRoute = Value(navigationRoute),
        iconGroup = Value(iconGroup),
        userPermission = Value(userPermission);
  static Insertable<DesktopData> custom({
    Expression<int>? id,
    Expression<String>? featureCode,
    Expression<String>? showInLocation,
    Expression<String>? iconName,
    Expression<String>? iconCode,
    Expression<String>? iconColour,
    Expression<String>? iconFamily,
    Expression<String>? navigationRoute,
    Expression<String>? iconGroup,
    Expression<bool>? isFavorit,
    Expression<String>? userPermission,
    Expression<String>? tenantId,
    Expression<String>? tag,
    Expression<bool>? isDeleted,
    Expression<bool>? isFreeTrial,
    Expression<DateTime>? validFrom,
    Expression<DateTime>? validTo,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (featureCode != null) 'feature_code': featureCode,
      if (showInLocation != null) 'show_in_location': showInLocation,
      if (iconName != null) 'icon_name': iconName,
      if (iconCode != null) 'icon_code': iconCode,
      if (iconColour != null) 'icon_colour': iconColour,
      if (iconFamily != null) 'icon_family': iconFamily,
      if (navigationRoute != null) 'navigation_route': navigationRoute,
      if (iconGroup != null) 'icon_group': iconGroup,
      if (isFavorit != null) 'is_favorit': isFavorit,
      if (userPermission != null) 'user_permission': userPermission,
      if (tenantId != null) 'tenant_id': tenantId,
      if (tag != null) 'tag': tag,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (isFreeTrial != null) 'is_free_trial': isFreeTrial,
      if (validFrom != null) 'valid_from': validFrom,
      if (validTo != null) 'valid_to': validTo,
    });
  }

  DesktopCompanion copyWith(
      {Value<int>? id,
      Value<String>? featureCode,
      Value<String?>? showInLocation,
      Value<String>? iconName,
      Value<String>? iconCode,
      Value<String>? iconColour,
      Value<String>? iconFamily,
      Value<String>? navigationRoute,
      Value<String>? iconGroup,
      Value<bool>? isFavorit,
      Value<String>? userPermission,
      Value<String?>? tenantId,
      Value<String?>? tag,
      Value<bool>? isDeleted,
      Value<bool>? isFreeTrial,
      Value<DateTime?>? validFrom,
      Value<DateTime?>? validTo}) {
    return DesktopCompanion(
      id: id ?? this.id,
      featureCode: featureCode ?? this.featureCode,
      showInLocation: showInLocation ?? this.showInLocation,
      iconName: iconName ?? this.iconName,
      iconCode: iconCode ?? this.iconCode,
      iconColour: iconColour ?? this.iconColour,
      iconFamily: iconFamily ?? this.iconFamily,
      navigationRoute: navigationRoute ?? this.navigationRoute,
      iconGroup: iconGroup ?? this.iconGroup,
      isFavorit: isFavorit ?? this.isFavorit,
      userPermission: userPermission ?? this.userPermission,
      tenantId: tenantId ?? this.tenantId,
      tag: tag ?? this.tag,
      isDeleted: isDeleted ?? this.isDeleted,
      isFreeTrial: isFreeTrial ?? this.isFreeTrial,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo ?? this.validTo,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (featureCode.present) {
      map['feature_code'] = Variable<String>(featureCode.value);
    }
    if (showInLocation.present) {
      map['show_in_location'] = Variable<String>(showInLocation.value);
    }
    if (iconName.present) {
      map['icon_name'] = Variable<String>(iconName.value);
    }
    if (iconCode.present) {
      map['icon_code'] = Variable<String>(iconCode.value);
    }
    if (iconColour.present) {
      map['icon_colour'] = Variable<String>(iconColour.value);
    }
    if (iconFamily.present) {
      map['icon_family'] = Variable<String>(iconFamily.value);
    }
    if (navigationRoute.present) {
      map['navigation_route'] = Variable<String>(navigationRoute.value);
    }
    if (iconGroup.present) {
      map['icon_group'] = Variable<String>(iconGroup.value);
    }
    if (isFavorit.present) {
      map['is_favorit'] = Variable<bool>(isFavorit.value);
    }
    if (userPermission.present) {
      map['user_permission'] = Variable<String>(userPermission.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (tag.present) {
      map['tag'] = Variable<String>(tag.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (isFreeTrial.present) {
      map['is_free_trial'] = Variable<bool>(isFreeTrial.value);
    }
    if (validFrom.present) {
      map['valid_from'] = Variable<DateTime>(validFrom.value);
    }
    if (validTo.present) {
      map['valid_to'] = Variable<DateTime>(validTo.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DesktopCompanion(')
          ..write('id: $id, ')
          ..write('featureCode: $featureCode, ')
          ..write('showInLocation: $showInLocation, ')
          ..write('iconName: $iconName, ')
          ..write('iconCode: $iconCode, ')
          ..write('iconColour: $iconColour, ')
          ..write('iconFamily: $iconFamily, ')
          ..write('navigationRoute: $navigationRoute, ')
          ..write('iconGroup: $iconGroup, ')
          ..write('isFavorit: $isFavorit, ')
          ..write('userPermission: $userPermission, ')
          ..write('tenantId: $tenantId, ')
          ..write('tag: $tag, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('isFreeTrial: $isFreeTrial, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }
}

class $SalesOrderHeaderTable extends SalesOrderHeader
    with TableInfo<$SalesOrderHeaderTable, SalesOrderHeaderData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SalesOrderHeaderTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _transactionNumberMeta =
      const VerificationMeta('transactionNumber');
  @override
  late final GeneratedColumn<String> transactionNumber =
      GeneratedColumn<String>('transaction_number', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _transactionStatusMeta =
      const VerificationMeta('transactionStatus');
  @override
  late final GeneratedColumn<String> transactionStatus =
      GeneratedColumn<String>('transaction_status', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _inventoryCycleNumberMeta =
      const VerificationMeta('inventoryCycleNumber');
  @override
  late final GeneratedColumn<String> inventoryCycleNumber =
      GeneratedColumn<String>('inventory_cycle_number', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _daySessionNumberMeta =
      const VerificationMeta('daySessionNumber');
  @override
  late final GeneratedColumn<String> daySessionNumber = GeneratedColumn<String>(
      'day_session_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _customerIdMeta =
      const VerificationMeta('customerId');
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
      'customer_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _soldToMeta = const VerificationMeta('soldTo');
  @override
  late final GeneratedColumn<String> soldTo = GeneratedColumn<String>(
      'sold_to', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _orderDateMeta =
      const VerificationMeta('orderDate');
  @override
  late final GeneratedColumn<DateTime> orderDate = GeneratedColumn<DateTime>(
      'order_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _deliveryDateMeta =
      const VerificationMeta('deliveryDate');
  @override
  late final GeneratedColumn<DateTime> deliveryDate = GeneratedColumn<DateTime>(
      'delivery_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _orderTypeMeta =
      const VerificationMeta('orderType');
  @override
  late final GeneratedColumn<String> orderType = GeneratedColumn<String>(
      'order_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _orderStatusMeta =
      const VerificationMeta('orderStatus');
  @override
  late final GeneratedColumn<String> orderStatus = GeneratedColumn<String>(
      'order_status', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _purchaseOrderNoMeta =
      const VerificationMeta('purchaseOrderNo');
  @override
  late final GeneratedColumn<String> purchaseOrderNo = GeneratedColumn<String>(
      'purchase_order_no', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _currencyMeta =
      const VerificationMeta('currency');
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
      'currency', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  @override
  late final GeneratedColumn<double> exchangeRate = GeneratedColumn<double>(
      'exchange_rate', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _couponCodeMeta =
      const VerificationMeta('couponCode');
  @override
  late final GeneratedColumn<int> couponCode = GeneratedColumn<int>(
      'coupon_code', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _billingAddressNameMeta =
      const VerificationMeta('billingAddressName');
  @override
  late final GeneratedColumn<String> billingAddressName =
      GeneratedColumn<String>('billing_address_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _shippingAddressNameMeta =
      const VerificationMeta('shippingAddressName');
  @override
  late final GeneratedColumn<String> shippingAddressName =
      GeneratedColumn<String>('shipping_address_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _yourInitialMeta =
      const VerificationMeta('yourInitial');
  @override
  late final GeneratedColumn<String> yourInitial = GeneratedColumn<String>(
      'your_initial', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _subTotalMeta =
      const VerificationMeta('subTotal');
  @override
  late final GeneratedColumn<double> subTotal = GeneratedColumn<double>(
      'sub_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _taxTotalMeta =
      const VerificationMeta('taxTotal');
  @override
  late final GeneratedColumn<double> taxTotal = GeneratedColumn<double>(
      'tax_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _depositTotalMeta =
      const VerificationMeta('depositTotal');
  @override
  late final GeneratedColumn<double> depositTotal = GeneratedColumn<double>(
      'deposit_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _discountTotalMeta =
      const VerificationMeta('discountTotal');
  @override
  late final GeneratedColumn<double> discountTotal = GeneratedColumn<double>(
      'discount_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _shippingTotalMeta =
      const VerificationMeta('shippingTotal');
  @override
  late final GeneratedColumn<double> shippingTotal = GeneratedColumn<double>(
      'shipping_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _itemCountMeta =
      const VerificationMeta('itemCount');
  @override
  late final GeneratedColumn<int> itemCount = GeneratedColumn<int>(
      'item_count', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _grandTotalMeta =
      const VerificationMeta('grandTotal');
  @override
  late final GeneratedColumn<double> grandTotal = GeneratedColumn<double>(
      'grand_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _discountTypeMeta =
      const VerificationMeta('discountType');
  @override
  late final GeneratedColumn<String> discountType = GeneratedColumn<String>(
      'discount_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _discountPercentageMeta =
      const VerificationMeta('discountPercentage');
  @override
  late final GeneratedColumn<double> discountPercentage =
      GeneratedColumn<double>('discount_percentage', aliasedName, false,
          type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _discountAmountMeta =
      const VerificationMeta('discountAmount');
  @override
  late final GeneratedColumn<double> discountAmount = GeneratedColumn<double>(
      'discount_amount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _transactionStartMeta =
      const VerificationMeta('transactionStart');
  @override
  late final GeneratedColumn<DateTime> transactionStart =
      GeneratedColumn<DateTime>('transaction_start', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _transactionEndMeta =
      const VerificationMeta('transactionEnd');
  @override
  late final GeneratedColumn<DateTime> transactionEnd =
      GeneratedColumn<DateTime>('transaction_end', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        transactionStatus,
        inventoryCycleNumber,
        daySessionNumber,
        customerId,
        soldTo,
        orderDate,
        deliveryDate,
        orderType,
        orderStatus,
        purchaseOrderNo,
        currency,
        exchangeRate,
        couponCode,
        billingAddressName,
        shippingAddressName,
        yourInitial,
        subTotal,
        taxTotal,
        depositTotal,
        discountTotal,
        shippingTotal,
        itemCount,
        grandTotal,
        discountType,
        discountPercentage,
        discountAmount,
        latitude,
        longitude,
        transactionStart,
        transactionEnd
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sales_order_header';
  @override
  VerificationContext validateIntegrity(
      Insertable<SalesOrderHeaderData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    } else if (isInserting) {
      context.missing(_userNameMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('transaction_number')) {
      context.handle(
          _transactionNumberMeta,
          transactionNumber.isAcceptableOrUnknown(
              data['transaction_number']!, _transactionNumberMeta));
    } else if (isInserting) {
      context.missing(_transactionNumberMeta);
    }
    if (data.containsKey('transaction_status')) {
      context.handle(
          _transactionStatusMeta,
          transactionStatus.isAcceptableOrUnknown(
              data['transaction_status']!, _transactionStatusMeta));
    }
    if (data.containsKey('inventory_cycle_number')) {
      context.handle(
          _inventoryCycleNumberMeta,
          inventoryCycleNumber.isAcceptableOrUnknown(
              data['inventory_cycle_number']!, _inventoryCycleNumberMeta));
    } else if (isInserting) {
      context.missing(_inventoryCycleNumberMeta);
    }
    if (data.containsKey('day_session_number')) {
      context.handle(
          _daySessionNumberMeta,
          daySessionNumber.isAcceptableOrUnknown(
              data['day_session_number']!, _daySessionNumberMeta));
    } else if (isInserting) {
      context.missing(_daySessionNumberMeta);
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id']!, _customerIdMeta));
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('sold_to')) {
      context.handle(_soldToMeta,
          soldTo.isAcceptableOrUnknown(data['sold_to']!, _soldToMeta));
    }
    if (data.containsKey('order_date')) {
      context.handle(_orderDateMeta,
          orderDate.isAcceptableOrUnknown(data['order_date']!, _orderDateMeta));
    } else if (isInserting) {
      context.missing(_orderDateMeta);
    }
    if (data.containsKey('delivery_date')) {
      context.handle(
          _deliveryDateMeta,
          deliveryDate.isAcceptableOrUnknown(
              data['delivery_date']!, _deliveryDateMeta));
    } else if (isInserting) {
      context.missing(_deliveryDateMeta);
    }
    if (data.containsKey('order_type')) {
      context.handle(_orderTypeMeta,
          orderType.isAcceptableOrUnknown(data['order_type']!, _orderTypeMeta));
    } else if (isInserting) {
      context.missing(_orderTypeMeta);
    }
    if (data.containsKey('order_status')) {
      context.handle(
          _orderStatusMeta,
          orderStatus.isAcceptableOrUnknown(
              data['order_status']!, _orderStatusMeta));
    } else if (isInserting) {
      context.missing(_orderStatusMeta);
    }
    if (data.containsKey('purchase_order_no')) {
      context.handle(
          _purchaseOrderNoMeta,
          purchaseOrderNo.isAcceptableOrUnknown(
              data['purchase_order_no']!, _purchaseOrderNoMeta));
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta));
    } else if (isInserting) {
      context.missing(_currencyMeta);
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate']!, _exchangeRateMeta));
    } else if (isInserting) {
      context.missing(_exchangeRateMeta);
    }
    if (data.containsKey('coupon_code')) {
      context.handle(
          _couponCodeMeta,
          couponCode.isAcceptableOrUnknown(
              data['coupon_code']!, _couponCodeMeta));
    }
    if (data.containsKey('billing_address_name')) {
      context.handle(
          _billingAddressNameMeta,
          billingAddressName.isAcceptableOrUnknown(
              data['billing_address_name']!, _billingAddressNameMeta));
    }
    if (data.containsKey('shipping_address_name')) {
      context.handle(
          _shippingAddressNameMeta,
          shippingAddressName.isAcceptableOrUnknown(
              data['shipping_address_name']!, _shippingAddressNameMeta));
    }
    if (data.containsKey('your_initial')) {
      context.handle(
          _yourInitialMeta,
          yourInitial.isAcceptableOrUnknown(
              data['your_initial']!, _yourInitialMeta));
    }
    if (data.containsKey('sub_total')) {
      context.handle(_subTotalMeta,
          subTotal.isAcceptableOrUnknown(data['sub_total']!, _subTotalMeta));
    } else if (isInserting) {
      context.missing(_subTotalMeta);
    }
    if (data.containsKey('tax_total')) {
      context.handle(_taxTotalMeta,
          taxTotal.isAcceptableOrUnknown(data['tax_total']!, _taxTotalMeta));
    } else if (isInserting) {
      context.missing(_taxTotalMeta);
    }
    if (data.containsKey('deposit_total')) {
      context.handle(
          _depositTotalMeta,
          depositTotal.isAcceptableOrUnknown(
              data['deposit_total']!, _depositTotalMeta));
    } else if (isInserting) {
      context.missing(_depositTotalMeta);
    }
    if (data.containsKey('discount_total')) {
      context.handle(
          _discountTotalMeta,
          discountTotal.isAcceptableOrUnknown(
              data['discount_total']!, _discountTotalMeta));
    } else if (isInserting) {
      context.missing(_discountTotalMeta);
    }
    if (data.containsKey('shipping_total')) {
      context.handle(
          _shippingTotalMeta,
          shippingTotal.isAcceptableOrUnknown(
              data['shipping_total']!, _shippingTotalMeta));
    } else if (isInserting) {
      context.missing(_shippingTotalMeta);
    }
    if (data.containsKey('item_count')) {
      context.handle(_itemCountMeta,
          itemCount.isAcceptableOrUnknown(data['item_count']!, _itemCountMeta));
    } else if (isInserting) {
      context.missing(_itemCountMeta);
    }
    if (data.containsKey('grand_total')) {
      context.handle(
          _grandTotalMeta,
          grandTotal.isAcceptableOrUnknown(
              data['grand_total']!, _grandTotalMeta));
    } else if (isInserting) {
      context.missing(_grandTotalMeta);
    }
    if (data.containsKey('discount_type')) {
      context.handle(
          _discountTypeMeta,
          discountType.isAcceptableOrUnknown(
              data['discount_type']!, _discountTypeMeta));
    } else if (isInserting) {
      context.missing(_discountTypeMeta);
    }
    if (data.containsKey('discount_percentage')) {
      context.handle(
          _discountPercentageMeta,
          discountPercentage.isAcceptableOrUnknown(
              data['discount_percentage']!, _discountPercentageMeta));
    } else if (isInserting) {
      context.missing(_discountPercentageMeta);
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
          _discountAmountMeta,
          discountAmount.isAcceptableOrUnknown(
              data['discount_amount']!, _discountAmountMeta));
    } else if (isInserting) {
      context.missing(_discountAmountMeta);
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    }
    if (data.containsKey('transaction_start')) {
      context.handle(
          _transactionStartMeta,
          transactionStart.isAcceptableOrUnknown(
              data['transaction_start']!, _transactionStartMeta));
    }
    if (data.containsKey('transaction_end')) {
      context.handle(
          _transactionEndMeta,
          transactionEnd.isAcceptableOrUnknown(
              data['transaction_end']!, _transactionEndMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SalesOrderHeaderData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SalesOrderHeaderData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      transactionNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_number'])!,
      transactionStatus: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_status']),
      inventoryCycleNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}inventory_cycle_number'])!,
      daySessionNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}day_session_number'])!,
      customerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_id'])!,
      soldTo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sold_to']),
      orderDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}order_date'])!,
      deliveryDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}delivery_date'])!,
      orderType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_type'])!,
      orderStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}order_status'])!,
      purchaseOrderNo: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}purchase_order_no']),
      currency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}currency'])!,
      exchangeRate: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}exchange_rate'])!,
      couponCode: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}coupon_code']),
      billingAddressName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}billing_address_name']),
      shippingAddressName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}shipping_address_name']),
      yourInitial: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}your_initial']),
      subTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}sub_total'])!,
      taxTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tax_total'])!,
      depositTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}deposit_total'])!,
      discountTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}discount_total'])!,
      shippingTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}shipping_total'])!,
      itemCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_count'])!,
      grandTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}grand_total'])!,
      discountType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}discount_type'])!,
      discountPercentage: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}discount_percentage'])!,
      discountAmount: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}discount_amount'])!,
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude']),
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude']),
      transactionStart: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}transaction_start']),
      transactionEnd: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}transaction_end']),
    );
  }

  @override
  $SalesOrderHeaderTable createAlias(String alias) {
    return $SalesOrderHeaderTable(attachedDatabase, alias);
  }
}

class SalesOrderHeaderData extends DataClass
    implements Insertable<SalesOrderHeaderData> {
  final String? tenantId;
  final String userName;
  final int userId;
  final int id;
  final String transactionNumber;
  final String? transactionStatus;
  final String inventoryCycleNumber;
  final String daySessionNumber;
  final String customerId;
  final String? soldTo;
  final DateTime orderDate;
  final DateTime deliveryDate;
  final String orderType;
  final String orderStatus;
  final String? purchaseOrderNo;
  final String currency;
  final double exchangeRate;
  final int? couponCode;
  final String? billingAddressName;
  final String? shippingAddressName;
  final String? yourInitial;
  final double subTotal;
  final double taxTotal;
  final double depositTotal;
  final double discountTotal;
  final double shippingTotal;
  final int itemCount;
  final double grandTotal;
  final String discountType;
  final double discountPercentage;
  final double discountAmount;
  final double? latitude;
  final double? longitude;
  final DateTime? transactionStart;
  final DateTime? transactionEnd;
  const SalesOrderHeaderData(
      {this.tenantId,
      required this.userName,
      required this.userId,
      required this.id,
      required this.transactionNumber,
      this.transactionStatus,
      required this.inventoryCycleNumber,
      required this.daySessionNumber,
      required this.customerId,
      this.soldTo,
      required this.orderDate,
      required this.deliveryDate,
      required this.orderType,
      required this.orderStatus,
      this.purchaseOrderNo,
      required this.currency,
      required this.exchangeRate,
      this.couponCode,
      this.billingAddressName,
      this.shippingAddressName,
      this.yourInitial,
      required this.subTotal,
      required this.taxTotal,
      required this.depositTotal,
      required this.discountTotal,
      required this.shippingTotal,
      required this.itemCount,
      required this.grandTotal,
      required this.discountType,
      required this.discountPercentage,
      required this.discountAmount,
      this.latitude,
      this.longitude,
      this.transactionStart,
      this.transactionEnd});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['user_name'] = Variable<String>(userName);
    map['user_id'] = Variable<int>(userId);
    map['id'] = Variable<int>(id);
    map['transaction_number'] = Variable<String>(transactionNumber);
    if (!nullToAbsent || transactionStatus != null) {
      map['transaction_status'] = Variable<String>(transactionStatus);
    }
    map['inventory_cycle_number'] = Variable<String>(inventoryCycleNumber);
    map['day_session_number'] = Variable<String>(daySessionNumber);
    map['customer_id'] = Variable<String>(customerId);
    if (!nullToAbsent || soldTo != null) {
      map['sold_to'] = Variable<String>(soldTo);
    }
    map['order_date'] = Variable<DateTime>(orderDate);
    map['delivery_date'] = Variable<DateTime>(deliveryDate);
    map['order_type'] = Variable<String>(orderType);
    map['order_status'] = Variable<String>(orderStatus);
    if (!nullToAbsent || purchaseOrderNo != null) {
      map['purchase_order_no'] = Variable<String>(purchaseOrderNo);
    }
    map['currency'] = Variable<String>(currency);
    map['exchange_rate'] = Variable<double>(exchangeRate);
    if (!nullToAbsent || couponCode != null) {
      map['coupon_code'] = Variable<int>(couponCode);
    }
    if (!nullToAbsent || billingAddressName != null) {
      map['billing_address_name'] = Variable<String>(billingAddressName);
    }
    if (!nullToAbsent || shippingAddressName != null) {
      map['shipping_address_name'] = Variable<String>(shippingAddressName);
    }
    if (!nullToAbsent || yourInitial != null) {
      map['your_initial'] = Variable<String>(yourInitial);
    }
    map['sub_total'] = Variable<double>(subTotal);
    map['tax_total'] = Variable<double>(taxTotal);
    map['deposit_total'] = Variable<double>(depositTotal);
    map['discount_total'] = Variable<double>(discountTotal);
    map['shipping_total'] = Variable<double>(shippingTotal);
    map['item_count'] = Variable<int>(itemCount);
    map['grand_total'] = Variable<double>(grandTotal);
    map['discount_type'] = Variable<String>(discountType);
    map['discount_percentage'] = Variable<double>(discountPercentage);
    map['discount_amount'] = Variable<double>(discountAmount);
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || transactionStart != null) {
      map['transaction_start'] = Variable<DateTime>(transactionStart);
    }
    if (!nullToAbsent || transactionEnd != null) {
      map['transaction_end'] = Variable<DateTime>(transactionEnd);
    }
    return map;
  }

  SalesOrderHeaderCompanion toCompanion(bool nullToAbsent) {
    return SalesOrderHeaderCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      userName: Value(userName),
      userId: Value(userId),
      id: Value(id),
      transactionNumber: Value(transactionNumber),
      transactionStatus: transactionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionStatus),
      inventoryCycleNumber: Value(inventoryCycleNumber),
      daySessionNumber: Value(daySessionNumber),
      customerId: Value(customerId),
      soldTo:
          soldTo == null && nullToAbsent ? const Value.absent() : Value(soldTo),
      orderDate: Value(orderDate),
      deliveryDate: Value(deliveryDate),
      orderType: Value(orderType),
      orderStatus: Value(orderStatus),
      purchaseOrderNo: purchaseOrderNo == null && nullToAbsent
          ? const Value.absent()
          : Value(purchaseOrderNo),
      currency: Value(currency),
      exchangeRate: Value(exchangeRate),
      couponCode: couponCode == null && nullToAbsent
          ? const Value.absent()
          : Value(couponCode),
      billingAddressName: billingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(billingAddressName),
      shippingAddressName: shippingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(shippingAddressName),
      yourInitial: yourInitial == null && nullToAbsent
          ? const Value.absent()
          : Value(yourInitial),
      subTotal: Value(subTotal),
      taxTotal: Value(taxTotal),
      depositTotal: Value(depositTotal),
      discountTotal: Value(discountTotal),
      shippingTotal: Value(shippingTotal),
      itemCount: Value(itemCount),
      grandTotal: Value(grandTotal),
      discountType: Value(discountType),
      discountPercentage: Value(discountPercentage),
      discountAmount: Value(discountAmount),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      transactionStart: transactionStart == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionStart),
      transactionEnd: transactionEnd == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionEnd),
    );
  }

  factory SalesOrderHeaderData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesOrderHeaderData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      userName: serializer.fromJson<String>(json['userName']),
      userId: serializer.fromJson<int>(json['userId']),
      id: serializer.fromJson<int>(json['id']),
      transactionNumber: serializer.fromJson<String>(json['transactionNumber']),
      transactionStatus:
          serializer.fromJson<String?>(json['transactionStatus']),
      inventoryCycleNumber:
          serializer.fromJson<String>(json['inventoryCycleNumber']),
      daySessionNumber: serializer.fromJson<String>(json['daySessionNumber']),
      customerId: serializer.fromJson<String>(json['customerId']),
      soldTo: serializer.fromJson<String?>(json['soldTo']),
      orderDate: serializer.fromJson<DateTime>(json['orderDate']),
      deliveryDate: serializer.fromJson<DateTime>(json['deliveryDate']),
      orderType: serializer.fromJson<String>(json['orderType']),
      orderStatus: serializer.fromJson<String>(json['orderStatus']),
      purchaseOrderNo: serializer.fromJson<String?>(json['purchaseOrderNo']),
      currency: serializer.fromJson<String>(json['currency']),
      exchangeRate: serializer.fromJson<double>(json['exchangeRate']),
      couponCode: serializer.fromJson<int?>(json['couponCode']),
      billingAddressName:
          serializer.fromJson<String?>(json['billingAddressName']),
      shippingAddressName:
          serializer.fromJson<String?>(json['shippingAddressName']),
      yourInitial: serializer.fromJson<String?>(json['yourInitial']),
      subTotal: serializer.fromJson<double>(json['subTotal']),
      taxTotal: serializer.fromJson<double>(json['taxTotal']),
      depositTotal: serializer.fromJson<double>(json['depositTotal']),
      discountTotal: serializer.fromJson<double>(json['discountTotal']),
      shippingTotal: serializer.fromJson<double>(json['shippingTotal']),
      itemCount: serializer.fromJson<int>(json['itemCount']),
      grandTotal: serializer.fromJson<double>(json['grandTotal']),
      discountType: serializer.fromJson<String>(json['discountType']),
      discountPercentage:
          serializer.fromJson<double>(json['discountPercentage']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      transactionStart:
          serializer.fromJson<DateTime?>(json['transactionStart']),
      transactionEnd: serializer.fromJson<DateTime?>(json['transactionEnd']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'userName': serializer.toJson<String>(userName),
      'userId': serializer.toJson<int>(userId),
      'id': serializer.toJson<int>(id),
      'transactionNumber': serializer.toJson<String>(transactionNumber),
      'transactionStatus': serializer.toJson<String?>(transactionStatus),
      'inventoryCycleNumber': serializer.toJson<String>(inventoryCycleNumber),
      'daySessionNumber': serializer.toJson<String>(daySessionNumber),
      'customerId': serializer.toJson<String>(customerId),
      'soldTo': serializer.toJson<String?>(soldTo),
      'orderDate': serializer.toJson<DateTime>(orderDate),
      'deliveryDate': serializer.toJson<DateTime>(deliveryDate),
      'orderType': serializer.toJson<String>(orderType),
      'orderStatus': serializer.toJson<String>(orderStatus),
      'purchaseOrderNo': serializer.toJson<String?>(purchaseOrderNo),
      'currency': serializer.toJson<String>(currency),
      'exchangeRate': serializer.toJson<double>(exchangeRate),
      'couponCode': serializer.toJson<int?>(couponCode),
      'billingAddressName': serializer.toJson<String?>(billingAddressName),
      'shippingAddressName': serializer.toJson<String?>(shippingAddressName),
      'yourInitial': serializer.toJson<String?>(yourInitial),
      'subTotal': serializer.toJson<double>(subTotal),
      'taxTotal': serializer.toJson<double>(taxTotal),
      'depositTotal': serializer.toJson<double>(depositTotal),
      'discountTotal': serializer.toJson<double>(discountTotal),
      'shippingTotal': serializer.toJson<double>(shippingTotal),
      'itemCount': serializer.toJson<int>(itemCount),
      'grandTotal': serializer.toJson<double>(grandTotal),
      'discountType': serializer.toJson<String>(discountType),
      'discountPercentage': serializer.toJson<double>(discountPercentage),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'transactionStart': serializer.toJson<DateTime?>(transactionStart),
      'transactionEnd': serializer.toJson<DateTime?>(transactionEnd),
    };
  }

  SalesOrderHeaderData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          String? userName,
          int? userId,
          int? id,
          String? transactionNumber,
          Value<String?> transactionStatus = const Value.absent(),
          String? inventoryCycleNumber,
          String? daySessionNumber,
          String? customerId,
          Value<String?> soldTo = const Value.absent(),
          DateTime? orderDate,
          DateTime? deliveryDate,
          String? orderType,
          String? orderStatus,
          Value<String?> purchaseOrderNo = const Value.absent(),
          String? currency,
          double? exchangeRate,
          Value<int?> couponCode = const Value.absent(),
          Value<String?> billingAddressName = const Value.absent(),
          Value<String?> shippingAddressName = const Value.absent(),
          Value<String?> yourInitial = const Value.absent(),
          double? subTotal,
          double? taxTotal,
          double? depositTotal,
          double? discountTotal,
          double? shippingTotal,
          int? itemCount,
          double? grandTotal,
          String? discountType,
          double? discountPercentage,
          double? discountAmount,
          Value<double?> latitude = const Value.absent(),
          Value<double?> longitude = const Value.absent(),
          Value<DateTime?> transactionStart = const Value.absent(),
          Value<DateTime?> transactionEnd = const Value.absent()}) =>
      SalesOrderHeaderData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        userName: userName ?? this.userName,
        userId: userId ?? this.userId,
        id: id ?? this.id,
        transactionNumber: transactionNumber ?? this.transactionNumber,
        transactionStatus: transactionStatus.present
            ? transactionStatus.value
            : this.transactionStatus,
        inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
        daySessionNumber: daySessionNumber ?? this.daySessionNumber,
        customerId: customerId ?? this.customerId,
        soldTo: soldTo.present ? soldTo.value : this.soldTo,
        orderDate: orderDate ?? this.orderDate,
        deliveryDate: deliveryDate ?? this.deliveryDate,
        orderType: orderType ?? this.orderType,
        orderStatus: orderStatus ?? this.orderStatus,
        purchaseOrderNo: purchaseOrderNo.present
            ? purchaseOrderNo.value
            : this.purchaseOrderNo,
        currency: currency ?? this.currency,
        exchangeRate: exchangeRate ?? this.exchangeRate,
        couponCode: couponCode.present ? couponCode.value : this.couponCode,
        billingAddressName: billingAddressName.present
            ? billingAddressName.value
            : this.billingAddressName,
        shippingAddressName: shippingAddressName.present
            ? shippingAddressName.value
            : this.shippingAddressName,
        yourInitial: yourInitial.present ? yourInitial.value : this.yourInitial,
        subTotal: subTotal ?? this.subTotal,
        taxTotal: taxTotal ?? this.taxTotal,
        depositTotal: depositTotal ?? this.depositTotal,
        discountTotal: discountTotal ?? this.discountTotal,
        shippingTotal: shippingTotal ?? this.shippingTotal,
        itemCount: itemCount ?? this.itemCount,
        grandTotal: grandTotal ?? this.grandTotal,
        discountType: discountType ?? this.discountType,
        discountPercentage: discountPercentage ?? this.discountPercentage,
        discountAmount: discountAmount ?? this.discountAmount,
        latitude: latitude.present ? latitude.value : this.latitude,
        longitude: longitude.present ? longitude.value : this.longitude,
        transactionStart: transactionStart.present
            ? transactionStart.value
            : this.transactionStart,
        transactionEnd:
            transactionEnd.present ? transactionEnd.value : this.transactionEnd,
      );
  @override
  String toString() {
    return (StringBuffer('SalesOrderHeaderData(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('customerId: $customerId, ')
          ..write('soldTo: $soldTo, ')
          ..write('orderDate: $orderDate, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('orderType: $orderType, ')
          ..write('orderStatus: $orderStatus, ')
          ..write('purchaseOrderNo: $purchaseOrderNo, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('couponCode: $couponCode, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('yourInitial: $yourInitial, ')
          ..write('subTotal: $subTotal, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('discountTotal: $discountTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('transactionStart: $transactionStart, ')
          ..write('transactionEnd: $transactionEnd')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        transactionStatus,
        inventoryCycleNumber,
        daySessionNumber,
        customerId,
        soldTo,
        orderDate,
        deliveryDate,
        orderType,
        orderStatus,
        purchaseOrderNo,
        currency,
        exchangeRate,
        couponCode,
        billingAddressName,
        shippingAddressName,
        yourInitial,
        subTotal,
        taxTotal,
        depositTotal,
        discountTotal,
        shippingTotal,
        itemCount,
        grandTotal,
        discountType,
        discountPercentage,
        discountAmount,
        latitude,
        longitude,
        transactionStart,
        transactionEnd
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesOrderHeaderData &&
          other.tenantId == this.tenantId &&
          other.userName == this.userName &&
          other.userId == this.userId &&
          other.id == this.id &&
          other.transactionNumber == this.transactionNumber &&
          other.transactionStatus == this.transactionStatus &&
          other.inventoryCycleNumber == this.inventoryCycleNumber &&
          other.daySessionNumber == this.daySessionNumber &&
          other.customerId == this.customerId &&
          other.soldTo == this.soldTo &&
          other.orderDate == this.orderDate &&
          other.deliveryDate == this.deliveryDate &&
          other.orderType == this.orderType &&
          other.orderStatus == this.orderStatus &&
          other.purchaseOrderNo == this.purchaseOrderNo &&
          other.currency == this.currency &&
          other.exchangeRate == this.exchangeRate &&
          other.couponCode == this.couponCode &&
          other.billingAddressName == this.billingAddressName &&
          other.shippingAddressName == this.shippingAddressName &&
          other.yourInitial == this.yourInitial &&
          other.subTotal == this.subTotal &&
          other.taxTotal == this.taxTotal &&
          other.depositTotal == this.depositTotal &&
          other.discountTotal == this.discountTotal &&
          other.shippingTotal == this.shippingTotal &&
          other.itemCount == this.itemCount &&
          other.grandTotal == this.grandTotal &&
          other.discountType == this.discountType &&
          other.discountPercentage == this.discountPercentage &&
          other.discountAmount == this.discountAmount &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.transactionStart == this.transactionStart &&
          other.transactionEnd == this.transactionEnd);
}

class SalesOrderHeaderCompanion extends UpdateCompanion<SalesOrderHeaderData> {
  final Value<String?> tenantId;
  final Value<String> userName;
  final Value<int> userId;
  final Value<int> id;
  final Value<String> transactionNumber;
  final Value<String?> transactionStatus;
  final Value<String> inventoryCycleNumber;
  final Value<String> daySessionNumber;
  final Value<String> customerId;
  final Value<String?> soldTo;
  final Value<DateTime> orderDate;
  final Value<DateTime> deliveryDate;
  final Value<String> orderType;
  final Value<String> orderStatus;
  final Value<String?> purchaseOrderNo;
  final Value<String> currency;
  final Value<double> exchangeRate;
  final Value<int?> couponCode;
  final Value<String?> billingAddressName;
  final Value<String?> shippingAddressName;
  final Value<String?> yourInitial;
  final Value<double> subTotal;
  final Value<double> taxTotal;
  final Value<double> depositTotal;
  final Value<double> discountTotal;
  final Value<double> shippingTotal;
  final Value<int> itemCount;
  final Value<double> grandTotal;
  final Value<String> discountType;
  final Value<double> discountPercentage;
  final Value<double> discountAmount;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<DateTime?> transactionStart;
  final Value<DateTime?> transactionEnd;
  const SalesOrderHeaderCompanion({
    this.tenantId = const Value.absent(),
    this.userName = const Value.absent(),
    this.userId = const Value.absent(),
    this.id = const Value.absent(),
    this.transactionNumber = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.inventoryCycleNumber = const Value.absent(),
    this.daySessionNumber = const Value.absent(),
    this.customerId = const Value.absent(),
    this.soldTo = const Value.absent(),
    this.orderDate = const Value.absent(),
    this.deliveryDate = const Value.absent(),
    this.orderType = const Value.absent(),
    this.orderStatus = const Value.absent(),
    this.purchaseOrderNo = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.couponCode = const Value.absent(),
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.yourInitial = const Value.absent(),
    this.subTotal = const Value.absent(),
    this.taxTotal = const Value.absent(),
    this.depositTotal = const Value.absent(),
    this.discountTotal = const Value.absent(),
    this.shippingTotal = const Value.absent(),
    this.itemCount = const Value.absent(),
    this.grandTotal = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.transactionStart = const Value.absent(),
    this.transactionEnd = const Value.absent(),
  });
  SalesOrderHeaderCompanion.insert({
    this.tenantId = const Value.absent(),
    required String userName,
    required int userId,
    this.id = const Value.absent(),
    required String transactionNumber,
    this.transactionStatus = const Value.absent(),
    required String inventoryCycleNumber,
    required String daySessionNumber,
    required String customerId,
    this.soldTo = const Value.absent(),
    required DateTime orderDate,
    required DateTime deliveryDate,
    required String orderType,
    required String orderStatus,
    this.purchaseOrderNo = const Value.absent(),
    required String currency,
    required double exchangeRate,
    this.couponCode = const Value.absent(),
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.yourInitial = const Value.absent(),
    required double subTotal,
    required double taxTotal,
    required double depositTotal,
    required double discountTotal,
    required double shippingTotal,
    required int itemCount,
    required double grandTotal,
    required String discountType,
    required double discountPercentage,
    required double discountAmount,
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.transactionStart = const Value.absent(),
    this.transactionEnd = const Value.absent(),
  })  : userName = Value(userName),
        userId = Value(userId),
        transactionNumber = Value(transactionNumber),
        inventoryCycleNumber = Value(inventoryCycleNumber),
        daySessionNumber = Value(daySessionNumber),
        customerId = Value(customerId),
        orderDate = Value(orderDate),
        deliveryDate = Value(deliveryDate),
        orderType = Value(orderType),
        orderStatus = Value(orderStatus),
        currency = Value(currency),
        exchangeRate = Value(exchangeRate),
        subTotal = Value(subTotal),
        taxTotal = Value(taxTotal),
        depositTotal = Value(depositTotal),
        discountTotal = Value(discountTotal),
        shippingTotal = Value(shippingTotal),
        itemCount = Value(itemCount),
        grandTotal = Value(grandTotal),
        discountType = Value(discountType),
        discountPercentage = Value(discountPercentage),
        discountAmount = Value(discountAmount);
  static Insertable<SalesOrderHeaderData> custom({
    Expression<String>? tenantId,
    Expression<String>? userName,
    Expression<int>? userId,
    Expression<int>? id,
    Expression<String>? transactionNumber,
    Expression<String>? transactionStatus,
    Expression<String>? inventoryCycleNumber,
    Expression<String>? daySessionNumber,
    Expression<String>? customerId,
    Expression<String>? soldTo,
    Expression<DateTime>? orderDate,
    Expression<DateTime>? deliveryDate,
    Expression<String>? orderType,
    Expression<String>? orderStatus,
    Expression<String>? purchaseOrderNo,
    Expression<String>? currency,
    Expression<double>? exchangeRate,
    Expression<int>? couponCode,
    Expression<String>? billingAddressName,
    Expression<String>? shippingAddressName,
    Expression<String>? yourInitial,
    Expression<double>? subTotal,
    Expression<double>? taxTotal,
    Expression<double>? depositTotal,
    Expression<double>? discountTotal,
    Expression<double>? shippingTotal,
    Expression<int>? itemCount,
    Expression<double>? grandTotal,
    Expression<String>? discountType,
    Expression<double>? discountPercentage,
    Expression<double>? discountAmount,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<DateTime>? transactionStart,
    Expression<DateTime>? transactionEnd,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (userName != null) 'user_name': userName,
      if (userId != null) 'user_id': userId,
      if (id != null) 'id': id,
      if (transactionNumber != null) 'transaction_number': transactionNumber,
      if (transactionStatus != null) 'transaction_status': transactionStatus,
      if (inventoryCycleNumber != null)
        'inventory_cycle_number': inventoryCycleNumber,
      if (daySessionNumber != null) 'day_session_number': daySessionNumber,
      if (customerId != null) 'customer_id': customerId,
      if (soldTo != null) 'sold_to': soldTo,
      if (orderDate != null) 'order_date': orderDate,
      if (deliveryDate != null) 'delivery_date': deliveryDate,
      if (orderType != null) 'order_type': orderType,
      if (orderStatus != null) 'order_status': orderStatus,
      if (purchaseOrderNo != null) 'purchase_order_no': purchaseOrderNo,
      if (currency != null) 'currency': currency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (couponCode != null) 'coupon_code': couponCode,
      if (billingAddressName != null)
        'billing_address_name': billingAddressName,
      if (shippingAddressName != null)
        'shipping_address_name': shippingAddressName,
      if (yourInitial != null) 'your_initial': yourInitial,
      if (subTotal != null) 'sub_total': subTotal,
      if (taxTotal != null) 'tax_total': taxTotal,
      if (depositTotal != null) 'deposit_total': depositTotal,
      if (discountTotal != null) 'discount_total': discountTotal,
      if (shippingTotal != null) 'shipping_total': shippingTotal,
      if (itemCount != null) 'item_count': itemCount,
      if (grandTotal != null) 'grand_total': grandTotal,
      if (discountType != null) 'discount_type': discountType,
      if (discountPercentage != null) 'discount_percentage': discountPercentage,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (transactionStart != null) 'transaction_start': transactionStart,
      if (transactionEnd != null) 'transaction_end': transactionEnd,
    });
  }

  SalesOrderHeaderCompanion copyWith(
      {Value<String?>? tenantId,
      Value<String>? userName,
      Value<int>? userId,
      Value<int>? id,
      Value<String>? transactionNumber,
      Value<String?>? transactionStatus,
      Value<String>? inventoryCycleNumber,
      Value<String>? daySessionNumber,
      Value<String>? customerId,
      Value<String?>? soldTo,
      Value<DateTime>? orderDate,
      Value<DateTime>? deliveryDate,
      Value<String>? orderType,
      Value<String>? orderStatus,
      Value<String?>? purchaseOrderNo,
      Value<String>? currency,
      Value<double>? exchangeRate,
      Value<int?>? couponCode,
      Value<String?>? billingAddressName,
      Value<String?>? shippingAddressName,
      Value<String?>? yourInitial,
      Value<double>? subTotal,
      Value<double>? taxTotal,
      Value<double>? depositTotal,
      Value<double>? discountTotal,
      Value<double>? shippingTotal,
      Value<int>? itemCount,
      Value<double>? grandTotal,
      Value<String>? discountType,
      Value<double>? discountPercentage,
      Value<double>? discountAmount,
      Value<double?>? latitude,
      Value<double?>? longitude,
      Value<DateTime?>? transactionStart,
      Value<DateTime?>? transactionEnd}) {
    return SalesOrderHeaderCompanion(
      tenantId: tenantId ?? this.tenantId,
      userName: userName ?? this.userName,
      userId: userId ?? this.userId,
      id: id ?? this.id,
      transactionNumber: transactionNumber ?? this.transactionNumber,
      transactionStatus: transactionStatus ?? this.transactionStatus,
      inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
      daySessionNumber: daySessionNumber ?? this.daySessionNumber,
      customerId: customerId ?? this.customerId,
      soldTo: soldTo ?? this.soldTo,
      orderDate: orderDate ?? this.orderDate,
      deliveryDate: deliveryDate ?? this.deliveryDate,
      orderType: orderType ?? this.orderType,
      orderStatus: orderStatus ?? this.orderStatus,
      purchaseOrderNo: purchaseOrderNo ?? this.purchaseOrderNo,
      currency: currency ?? this.currency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      couponCode: couponCode ?? this.couponCode,
      billingAddressName: billingAddressName ?? this.billingAddressName,
      shippingAddressName: shippingAddressName ?? this.shippingAddressName,
      yourInitial: yourInitial ?? this.yourInitial,
      subTotal: subTotal ?? this.subTotal,
      taxTotal: taxTotal ?? this.taxTotal,
      depositTotal: depositTotal ?? this.depositTotal,
      discountTotal: discountTotal ?? this.discountTotal,
      shippingTotal: shippingTotal ?? this.shippingTotal,
      itemCount: itemCount ?? this.itemCount,
      grandTotal: grandTotal ?? this.grandTotal,
      discountType: discountType ?? this.discountType,
      discountPercentage: discountPercentage ?? this.discountPercentage,
      discountAmount: discountAmount ?? this.discountAmount,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      transactionStart: transactionStart ?? this.transactionStart,
      transactionEnd: transactionEnd ?? this.transactionEnd,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (transactionNumber.present) {
      map['transaction_number'] = Variable<String>(transactionNumber.value);
    }
    if (transactionStatus.present) {
      map['transaction_status'] = Variable<String>(transactionStatus.value);
    }
    if (inventoryCycleNumber.present) {
      map['inventory_cycle_number'] =
          Variable<String>(inventoryCycleNumber.value);
    }
    if (daySessionNumber.present) {
      map['day_session_number'] = Variable<String>(daySessionNumber.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (soldTo.present) {
      map['sold_to'] = Variable<String>(soldTo.value);
    }
    if (orderDate.present) {
      map['order_date'] = Variable<DateTime>(orderDate.value);
    }
    if (deliveryDate.present) {
      map['delivery_date'] = Variable<DateTime>(deliveryDate.value);
    }
    if (orderType.present) {
      map['order_type'] = Variable<String>(orderType.value);
    }
    if (orderStatus.present) {
      map['order_status'] = Variable<String>(orderStatus.value);
    }
    if (purchaseOrderNo.present) {
      map['purchase_order_no'] = Variable<String>(purchaseOrderNo.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (couponCode.present) {
      map['coupon_code'] = Variable<int>(couponCode.value);
    }
    if (billingAddressName.present) {
      map['billing_address_name'] = Variable<String>(billingAddressName.value);
    }
    if (shippingAddressName.present) {
      map['shipping_address_name'] =
          Variable<String>(shippingAddressName.value);
    }
    if (yourInitial.present) {
      map['your_initial'] = Variable<String>(yourInitial.value);
    }
    if (subTotal.present) {
      map['sub_total'] = Variable<double>(subTotal.value);
    }
    if (taxTotal.present) {
      map['tax_total'] = Variable<double>(taxTotal.value);
    }
    if (depositTotal.present) {
      map['deposit_total'] = Variable<double>(depositTotal.value);
    }
    if (discountTotal.present) {
      map['discount_total'] = Variable<double>(discountTotal.value);
    }
    if (shippingTotal.present) {
      map['shipping_total'] = Variable<double>(shippingTotal.value);
    }
    if (itemCount.present) {
      map['item_count'] = Variable<int>(itemCount.value);
    }
    if (grandTotal.present) {
      map['grand_total'] = Variable<double>(grandTotal.value);
    }
    if (discountType.present) {
      map['discount_type'] = Variable<String>(discountType.value);
    }
    if (discountPercentage.present) {
      map['discount_percentage'] = Variable<double>(discountPercentage.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (transactionStart.present) {
      map['transaction_start'] = Variable<DateTime>(transactionStart.value);
    }
    if (transactionEnd.present) {
      map['transaction_end'] = Variable<DateTime>(transactionEnd.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesOrderHeaderCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('customerId: $customerId, ')
          ..write('soldTo: $soldTo, ')
          ..write('orderDate: $orderDate, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('orderType: $orderType, ')
          ..write('orderStatus: $orderStatus, ')
          ..write('purchaseOrderNo: $purchaseOrderNo, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('couponCode: $couponCode, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('yourInitial: $yourInitial, ')
          ..write('subTotal: $subTotal, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('discountTotal: $discountTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('transactionStart: $transactionStart, ')
          ..write('transactionEnd: $transactionEnd')
          ..write(')'))
        .toString();
  }
}

class $SalesOrderDetailTable extends SalesOrderDetail
    with TableInfo<$SalesOrderDetailTable, SalesOrderDetailData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SalesOrderDetailTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _transactionNumberMeta =
      const VerificationMeta('transactionNumber');
  @override
  late final GeneratedColumn<String> transactionNumber =
      GeneratedColumn<String>('transaction_number', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _inventoryCycleNumberMeta =
      const VerificationMeta('inventoryCycleNumber');
  @override
  late final GeneratedColumn<String> inventoryCycleNumber =
      GeneratedColumn<String>('inventory_cycle_number', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _daySessionNumberMeta =
      const VerificationMeta('daySessionNumber');
  @override
  late final GeneratedColumn<String> daySessionNumber = GeneratedColumn<String>(
      'day_session_number', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _deliveryDateMeta =
      const VerificationMeta('deliveryDate');
  @override
  late final GeneratedColumn<DateTime> deliveryDate = GeneratedColumn<DateTime>(
      'delivery_date', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _currencyMeta =
      const VerificationMeta('currency');
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
      'currency', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  @override
  late final GeneratedColumn<double> exchangeRate = GeneratedColumn<double>(
      'exchange_rate', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _transactionStatusMeta =
      const VerificationMeta('transactionStatus');
  @override
  late final GeneratedColumn<String> transactionStatus =
      GeneratedColumn<String>('transaction_status', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
      'item_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemCodeMeta =
      const VerificationMeta('itemCode');
  @override
  late final GeneratedColumn<String> itemCode = GeneratedColumn<String>(
      'item_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _upcCodeMeta =
      const VerificationMeta('upcCode');
  @override
  late final GeneratedColumn<String> upcCode = GeneratedColumn<String>(
      'upc_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _itemGroupMeta =
      const VerificationMeta('itemGroup');
  @override
  late final GeneratedColumn<String> itemGroup = GeneratedColumn<String>(
      'item_group', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _categoryMeta =
      const VerificationMeta('category');
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
      'category', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _salesUOMMeta =
      const VerificationMeta('salesUOM');
  @override
  late final GeneratedColumn<String> salesUOM = GeneratedColumn<String>(
      'sales_u_o_m', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _stockUOMMeta =
      const VerificationMeta('stockUOM');
  @override
  late final GeneratedColumn<String> stockUOM = GeneratedColumn<String>(
      'stock_u_o_m', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _taxGroupMeta =
      const VerificationMeta('taxGroup');
  @override
  late final GeneratedColumn<String> taxGroup = GeneratedColumn<String>(
      'tax_group', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _warehouseMeta =
      const VerificationMeta('warehouse');
  @override
  late final GeneratedColumn<String> warehouse = GeneratedColumn<String>(
      'warehouse', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _discountTypeMeta =
      const VerificationMeta('discountType');
  @override
  late final GeneratedColumn<String> discountType = GeneratedColumn<String>(
      'discount_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _discountPercentageMeta =
      const VerificationMeta('discountPercentage');
  @override
  late final GeneratedColumn<double> discountPercentage =
      GeneratedColumn<double>('discount_percentage', aliasedName, false,
          type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _discountAmountMeta =
      const VerificationMeta('discountAmount');
  @override
  late final GeneratedColumn<double> discountAmount = GeneratedColumn<double>(
      'discount_amount', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _lineDiscountTotalMeta =
      const VerificationMeta('lineDiscountTotal');
  @override
  late final GeneratedColumn<double> lineDiscountTotal =
      GeneratedColumn<double>('line_discount_total', aliasedName, false,
          type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _taxIndicatorMeta =
      const VerificationMeta('taxIndicator');
  @override
  late final GeneratedColumn<String> taxIndicator = GeneratedColumn<String>(
      'tax_indicator', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _unitPriceMeta =
      const VerificationMeta('unitPrice');
  @override
  late final GeneratedColumn<double> unitPrice = GeneratedColumn<double>(
      'unit_price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _costPriceMeta =
      const VerificationMeta('costPrice');
  @override
  late final GeneratedColumn<double> costPrice = GeneratedColumn<double>(
      'cost_price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _listPriceMeta =
      const VerificationMeta('listPrice');
  @override
  late final GeneratedColumn<double> listPrice = GeneratedColumn<double>(
      'list_price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _subTotalMeta =
      const VerificationMeta('subTotal');
  @override
  late final GeneratedColumn<double> subTotal = GeneratedColumn<double>(
      'sub_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _grandTotalMeta =
      const VerificationMeta('grandTotal');
  @override
  late final GeneratedColumn<double> grandTotal = GeneratedColumn<double>(
      'grand_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _fxGrandTotalMeta =
      const VerificationMeta('fxGrandTotal');
  @override
  late final GeneratedColumn<double> fxGrandTotal = GeneratedColumn<double>(
      'fx_grand_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _itemCountMeta =
      const VerificationMeta('itemCount');
  @override
  late final GeneratedColumn<int> itemCount = GeneratedColumn<int>(
      'item_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _depositTotalMeta =
      const VerificationMeta('depositTotal');
  @override
  late final GeneratedColumn<double> depositTotal = GeneratedColumn<double>(
      'deposit_total', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _lineIdMeta = const VerificationMeta('lineId');
  @override
  late final GeneratedColumn<int> lineId = GeneratedColumn<int>(
      'line_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _taxTotalMeta =
      const VerificationMeta('taxTotal');
  @override
  late final GeneratedColumn<double> taxTotal = GeneratedColumn<double>(
      'tax_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _shippingTotalMeta =
      const VerificationMeta('shippingTotal');
  @override
  late final GeneratedColumn<double> shippingTotal = GeneratedColumn<double>(
      'shipping_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _conversionFactorMeta =
      const VerificationMeta('conversionFactor');
  @override
  late final GeneratedColumn<double> conversionFactor = GeneratedColumn<double>(
      'conversion_factor', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        inventoryCycleNumber,
        daySessionNumber,
        deliveryDate,
        currency,
        exchangeRate,
        transactionStatus,
        itemId,
        itemCode,
        upcCode,
        description,
        itemGroup,
        category,
        salesUOM,
        stockUOM,
        taxGroup,
        warehouse,
        discountType,
        discountPercentage,
        discountAmount,
        lineDiscountTotal,
        taxIndicator,
        unitPrice,
        costPrice,
        listPrice,
        quantity,
        subTotal,
        grandTotal,
        fxGrandTotal,
        itemCount,
        depositTotal,
        lineId,
        taxTotal,
        shippingTotal,
        conversionFactor
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sales_order_detail';
  @override
  VerificationContext validateIntegrity(
      Insertable<SalesOrderDetailData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    } else if (isInserting) {
      context.missing(_userNameMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('transaction_number')) {
      context.handle(
          _transactionNumberMeta,
          transactionNumber.isAcceptableOrUnknown(
              data['transaction_number']!, _transactionNumberMeta));
    } else if (isInserting) {
      context.missing(_transactionNumberMeta);
    }
    if (data.containsKey('inventory_cycle_number')) {
      context.handle(
          _inventoryCycleNumberMeta,
          inventoryCycleNumber.isAcceptableOrUnknown(
              data['inventory_cycle_number']!, _inventoryCycleNumberMeta));
    } else if (isInserting) {
      context.missing(_inventoryCycleNumberMeta);
    }
    if (data.containsKey('day_session_number')) {
      context.handle(
          _daySessionNumberMeta,
          daySessionNumber.isAcceptableOrUnknown(
              data['day_session_number']!, _daySessionNumberMeta));
    } else if (isInserting) {
      context.missing(_daySessionNumberMeta);
    }
    if (data.containsKey('delivery_date')) {
      context.handle(
          _deliveryDateMeta,
          deliveryDate.isAcceptableOrUnknown(
              data['delivery_date']!, _deliveryDateMeta));
    } else if (isInserting) {
      context.missing(_deliveryDateMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta));
    } else if (isInserting) {
      context.missing(_currencyMeta);
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate']!, _exchangeRateMeta));
    } else if (isInserting) {
      context.missing(_exchangeRateMeta);
    }
    if (data.containsKey('transaction_status')) {
      context.handle(
          _transactionStatusMeta,
          transactionStatus.isAcceptableOrUnknown(
              data['transaction_status']!, _transactionStatusMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code']!, _itemCodeMeta));
    } else if (isInserting) {
      context.missing(_itemCodeMeta);
    }
    if (data.containsKey('upc_code')) {
      context.handle(_upcCodeMeta,
          upcCode.isAcceptableOrUnknown(data['upc_code']!, _upcCodeMeta));
    } else if (isInserting) {
      context.missing(_upcCodeMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    } else if (isInserting) {
      context.missing(_descriptionMeta);
    }
    if (data.containsKey('item_group')) {
      context.handle(_itemGroupMeta,
          itemGroup.isAcceptableOrUnknown(data['item_group']!, _itemGroupMeta));
    } else if (isInserting) {
      context.missing(_itemGroupMeta);
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category']!, _categoryMeta));
    } else if (isInserting) {
      context.missing(_categoryMeta);
    }
    if (data.containsKey('sales_u_o_m')) {
      context.handle(_salesUOMMeta,
          salesUOM.isAcceptableOrUnknown(data['sales_u_o_m']!, _salesUOMMeta));
    } else if (isInserting) {
      context.missing(_salesUOMMeta);
    }
    if (data.containsKey('stock_u_o_m')) {
      context.handle(_stockUOMMeta,
          stockUOM.isAcceptableOrUnknown(data['stock_u_o_m']!, _stockUOMMeta));
    } else if (isInserting) {
      context.missing(_stockUOMMeta);
    }
    if (data.containsKey('tax_group')) {
      context.handle(_taxGroupMeta,
          taxGroup.isAcceptableOrUnknown(data['tax_group']!, _taxGroupMeta));
    } else if (isInserting) {
      context.missing(_taxGroupMeta);
    }
    if (data.containsKey('warehouse')) {
      context.handle(_warehouseMeta,
          warehouse.isAcceptableOrUnknown(data['warehouse']!, _warehouseMeta));
    } else if (isInserting) {
      context.missing(_warehouseMeta);
    }
    if (data.containsKey('discount_type')) {
      context.handle(
          _discountTypeMeta,
          discountType.isAcceptableOrUnknown(
              data['discount_type']!, _discountTypeMeta));
    } else if (isInserting) {
      context.missing(_discountTypeMeta);
    }
    if (data.containsKey('discount_percentage')) {
      context.handle(
          _discountPercentageMeta,
          discountPercentage.isAcceptableOrUnknown(
              data['discount_percentage']!, _discountPercentageMeta));
    } else if (isInserting) {
      context.missing(_discountPercentageMeta);
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
          _discountAmountMeta,
          discountAmount.isAcceptableOrUnknown(
              data['discount_amount']!, _discountAmountMeta));
    } else if (isInserting) {
      context.missing(_discountAmountMeta);
    }
    if (data.containsKey('line_discount_total')) {
      context.handle(
          _lineDiscountTotalMeta,
          lineDiscountTotal.isAcceptableOrUnknown(
              data['line_discount_total']!, _lineDiscountTotalMeta));
    } else if (isInserting) {
      context.missing(_lineDiscountTotalMeta);
    }
    if (data.containsKey('tax_indicator')) {
      context.handle(
          _taxIndicatorMeta,
          taxIndicator.isAcceptableOrUnknown(
              data['tax_indicator']!, _taxIndicatorMeta));
    }
    if (data.containsKey('unit_price')) {
      context.handle(_unitPriceMeta,
          unitPrice.isAcceptableOrUnknown(data['unit_price']!, _unitPriceMeta));
    } else if (isInserting) {
      context.missing(_unitPriceMeta);
    }
    if (data.containsKey('cost_price')) {
      context.handle(_costPriceMeta,
          costPrice.isAcceptableOrUnknown(data['cost_price']!, _costPriceMeta));
    } else if (isInserting) {
      context.missing(_costPriceMeta);
    }
    if (data.containsKey('list_price')) {
      context.handle(_listPriceMeta,
          listPrice.isAcceptableOrUnknown(data['list_price']!, _listPriceMeta));
    } else if (isInserting) {
      context.missing(_listPriceMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('sub_total')) {
      context.handle(_subTotalMeta,
          subTotal.isAcceptableOrUnknown(data['sub_total']!, _subTotalMeta));
    } else if (isInserting) {
      context.missing(_subTotalMeta);
    }
    if (data.containsKey('grand_total')) {
      context.handle(
          _grandTotalMeta,
          grandTotal.isAcceptableOrUnknown(
              data['grand_total']!, _grandTotalMeta));
    } else if (isInserting) {
      context.missing(_grandTotalMeta);
    }
    if (data.containsKey('fx_grand_total')) {
      context.handle(
          _fxGrandTotalMeta,
          fxGrandTotal.isAcceptableOrUnknown(
              data['fx_grand_total']!, _fxGrandTotalMeta));
    } else if (isInserting) {
      context.missing(_fxGrandTotalMeta);
    }
    if (data.containsKey('item_count')) {
      context.handle(_itemCountMeta,
          itemCount.isAcceptableOrUnknown(data['item_count']!, _itemCountMeta));
    }
    if (data.containsKey('deposit_total')) {
      context.handle(
          _depositTotalMeta,
          depositTotal.isAcceptableOrUnknown(
              data['deposit_total']!, _depositTotalMeta));
    }
    if (data.containsKey('line_id')) {
      context.handle(_lineIdMeta,
          lineId.isAcceptableOrUnknown(data['line_id']!, _lineIdMeta));
    }
    if (data.containsKey('tax_total')) {
      context.handle(_taxTotalMeta,
          taxTotal.isAcceptableOrUnknown(data['tax_total']!, _taxTotalMeta));
    } else if (isInserting) {
      context.missing(_taxTotalMeta);
    }
    if (data.containsKey('shipping_total')) {
      context.handle(
          _shippingTotalMeta,
          shippingTotal.isAcceptableOrUnknown(
              data['shipping_total']!, _shippingTotalMeta));
    } else if (isInserting) {
      context.missing(_shippingTotalMeta);
    }
    if (data.containsKey('conversion_factor')) {
      context.handle(
          _conversionFactorMeta,
          conversionFactor.isAcceptableOrUnknown(
              data['conversion_factor']!, _conversionFactorMeta));
    } else if (isInserting) {
      context.missing(_conversionFactorMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SalesOrderDetailData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SalesOrderDetailData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      transactionNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_number'])!,
      inventoryCycleNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}inventory_cycle_number'])!,
      daySessionNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}day_session_number'])!,
      deliveryDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}delivery_date'])!,
      currency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}currency'])!,
      exchangeRate: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}exchange_rate'])!,
      transactionStatus: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_status']),
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_id']),
      itemCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_code'])!,
      upcCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}upc_code'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description'])!,
      itemGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_group'])!,
      category: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}category'])!,
      salesUOM: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sales_u_o_m'])!,
      stockUOM: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stock_u_o_m'])!,
      taxGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tax_group'])!,
      warehouse: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse'])!,
      discountType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}discount_type'])!,
      discountPercentage: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}discount_percentage'])!,
      discountAmount: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}discount_amount'])!,
      lineDiscountTotal: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}line_discount_total'])!,
      taxIndicator: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tax_indicator']),
      unitPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}unit_price'])!,
      costPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cost_price'])!,
      listPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}list_price'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      subTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}sub_total'])!,
      grandTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}grand_total'])!,
      fxGrandTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}fx_grand_total'])!,
      itemCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_count']),
      depositTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}deposit_total']),
      lineId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}line_id']),
      taxTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tax_total'])!,
      shippingTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}shipping_total'])!,
      conversionFactor: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}conversion_factor'])!,
    );
  }

  @override
  $SalesOrderDetailTable createAlias(String alias) {
    return $SalesOrderDetailTable(attachedDatabase, alias);
  }
}

class SalesOrderDetailData extends DataClass
    implements Insertable<SalesOrderDetailData> {
  final String? tenantId;
  final String userName;
  final int userId;
  final int id;
  final String transactionNumber;
  final String inventoryCycleNumber;
  final String daySessionNumber;
  final DateTime deliveryDate;
  final String currency;
  final double exchangeRate;
  final String? transactionStatus;
  final String? itemId;
  final String itemCode;
  final String upcCode;
  final String description;
  final String itemGroup;
  final String category;
  final String salesUOM;
  final String stockUOM;
  final String taxGroup;
  final String warehouse;
  final String discountType;
  final double discountPercentage;
  final double discountAmount;
  final double lineDiscountTotal;
  final String? taxIndicator;
  final double unitPrice;
  final double costPrice;
  final double listPrice;
  final double quantity;
  final double subTotal;
  final double grandTotal;
  final double fxGrandTotal;
  final int? itemCount;
  final double? depositTotal;
  final int? lineId;
  final double taxTotal;
  final double shippingTotal;
  final double conversionFactor;
  const SalesOrderDetailData(
      {this.tenantId,
      required this.userName,
      required this.userId,
      required this.id,
      required this.transactionNumber,
      required this.inventoryCycleNumber,
      required this.daySessionNumber,
      required this.deliveryDate,
      required this.currency,
      required this.exchangeRate,
      this.transactionStatus,
      this.itemId,
      required this.itemCode,
      required this.upcCode,
      required this.description,
      required this.itemGroup,
      required this.category,
      required this.salesUOM,
      required this.stockUOM,
      required this.taxGroup,
      required this.warehouse,
      required this.discountType,
      required this.discountPercentage,
      required this.discountAmount,
      required this.lineDiscountTotal,
      this.taxIndicator,
      required this.unitPrice,
      required this.costPrice,
      required this.listPrice,
      required this.quantity,
      required this.subTotal,
      required this.grandTotal,
      required this.fxGrandTotal,
      this.itemCount,
      this.depositTotal,
      this.lineId,
      required this.taxTotal,
      required this.shippingTotal,
      required this.conversionFactor});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['user_name'] = Variable<String>(userName);
    map['user_id'] = Variable<int>(userId);
    map['id'] = Variable<int>(id);
    map['transaction_number'] = Variable<String>(transactionNumber);
    map['inventory_cycle_number'] = Variable<String>(inventoryCycleNumber);
    map['day_session_number'] = Variable<String>(daySessionNumber);
    map['delivery_date'] = Variable<DateTime>(deliveryDate);
    map['currency'] = Variable<String>(currency);
    map['exchange_rate'] = Variable<double>(exchangeRate);
    if (!nullToAbsent || transactionStatus != null) {
      map['transaction_status'] = Variable<String>(transactionStatus);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    map['item_code'] = Variable<String>(itemCode);
    map['upc_code'] = Variable<String>(upcCode);
    map['description'] = Variable<String>(description);
    map['item_group'] = Variable<String>(itemGroup);
    map['category'] = Variable<String>(category);
    map['sales_u_o_m'] = Variable<String>(salesUOM);
    map['stock_u_o_m'] = Variable<String>(stockUOM);
    map['tax_group'] = Variable<String>(taxGroup);
    map['warehouse'] = Variable<String>(warehouse);
    map['discount_type'] = Variable<String>(discountType);
    map['discount_percentage'] = Variable<double>(discountPercentage);
    map['discount_amount'] = Variable<double>(discountAmount);
    map['line_discount_total'] = Variable<double>(lineDiscountTotal);
    if (!nullToAbsent || taxIndicator != null) {
      map['tax_indicator'] = Variable<String>(taxIndicator);
    }
    map['unit_price'] = Variable<double>(unitPrice);
    map['cost_price'] = Variable<double>(costPrice);
    map['list_price'] = Variable<double>(listPrice);
    map['quantity'] = Variable<double>(quantity);
    map['sub_total'] = Variable<double>(subTotal);
    map['grand_total'] = Variable<double>(grandTotal);
    map['fx_grand_total'] = Variable<double>(fxGrandTotal);
    if (!nullToAbsent || itemCount != null) {
      map['item_count'] = Variable<int>(itemCount);
    }
    if (!nullToAbsent || depositTotal != null) {
      map['deposit_total'] = Variable<double>(depositTotal);
    }
    if (!nullToAbsent || lineId != null) {
      map['line_id'] = Variable<int>(lineId);
    }
    map['tax_total'] = Variable<double>(taxTotal);
    map['shipping_total'] = Variable<double>(shippingTotal);
    map['conversion_factor'] = Variable<double>(conversionFactor);
    return map;
  }

  SalesOrderDetailCompanion toCompanion(bool nullToAbsent) {
    return SalesOrderDetailCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      userName: Value(userName),
      userId: Value(userId),
      id: Value(id),
      transactionNumber: Value(transactionNumber),
      inventoryCycleNumber: Value(inventoryCycleNumber),
      daySessionNumber: Value(daySessionNumber),
      deliveryDate: Value(deliveryDate),
      currency: Value(currency),
      exchangeRate: Value(exchangeRate),
      transactionStatus: transactionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionStatus),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      itemCode: Value(itemCode),
      upcCode: Value(upcCode),
      description: Value(description),
      itemGroup: Value(itemGroup),
      category: Value(category),
      salesUOM: Value(salesUOM),
      stockUOM: Value(stockUOM),
      taxGroup: Value(taxGroup),
      warehouse: Value(warehouse),
      discountType: Value(discountType),
      discountPercentage: Value(discountPercentage),
      discountAmount: Value(discountAmount),
      lineDiscountTotal: Value(lineDiscountTotal),
      taxIndicator: taxIndicator == null && nullToAbsent
          ? const Value.absent()
          : Value(taxIndicator),
      unitPrice: Value(unitPrice),
      costPrice: Value(costPrice),
      listPrice: Value(listPrice),
      quantity: Value(quantity),
      subTotal: Value(subTotal),
      grandTotal: Value(grandTotal),
      fxGrandTotal: Value(fxGrandTotal),
      itemCount: itemCount == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCount),
      depositTotal: depositTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(depositTotal),
      lineId:
          lineId == null && nullToAbsent ? const Value.absent() : Value(lineId),
      taxTotal: Value(taxTotal),
      shippingTotal: Value(shippingTotal),
      conversionFactor: Value(conversionFactor),
    );
  }

  factory SalesOrderDetailData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesOrderDetailData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      userName: serializer.fromJson<String>(json['userName']),
      userId: serializer.fromJson<int>(json['userId']),
      id: serializer.fromJson<int>(json['id']),
      transactionNumber: serializer.fromJson<String>(json['transactionNumber']),
      inventoryCycleNumber:
          serializer.fromJson<String>(json['inventoryCycleNumber']),
      daySessionNumber: serializer.fromJson<String>(json['daySessionNumber']),
      deliveryDate: serializer.fromJson<DateTime>(json['deliveryDate']),
      currency: serializer.fromJson<String>(json['currency']),
      exchangeRate: serializer.fromJson<double>(json['exchangeRate']),
      transactionStatus:
          serializer.fromJson<String?>(json['transactionStatus']),
      itemId: serializer.fromJson<String?>(json['itemId']),
      itemCode: serializer.fromJson<String>(json['itemCode']),
      upcCode: serializer.fromJson<String>(json['upcCode']),
      description: serializer.fromJson<String>(json['description']),
      itemGroup: serializer.fromJson<String>(json['itemGroup']),
      category: serializer.fromJson<String>(json['category']),
      salesUOM: serializer.fromJson<String>(json['salesUOM']),
      stockUOM: serializer.fromJson<String>(json['stockUOM']),
      taxGroup: serializer.fromJson<String>(json['taxGroup']),
      warehouse: serializer.fromJson<String>(json['warehouse']),
      discountType: serializer.fromJson<String>(json['discountType']),
      discountPercentage:
          serializer.fromJson<double>(json['discountPercentage']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      lineDiscountTotal: serializer.fromJson<double>(json['lineDiscountTotal']),
      taxIndicator: serializer.fromJson<String?>(json['taxIndicator']),
      unitPrice: serializer.fromJson<double>(json['unitPrice']),
      costPrice: serializer.fromJson<double>(json['costPrice']),
      listPrice: serializer.fromJson<double>(json['listPrice']),
      quantity: serializer.fromJson<double>(json['quantity']),
      subTotal: serializer.fromJson<double>(json['subTotal']),
      grandTotal: serializer.fromJson<double>(json['grandTotal']),
      fxGrandTotal: serializer.fromJson<double>(json['fxGrandTotal']),
      itemCount: serializer.fromJson<int?>(json['itemCount']),
      depositTotal: serializer.fromJson<double?>(json['depositTotal']),
      lineId: serializer.fromJson<int?>(json['lineId']),
      taxTotal: serializer.fromJson<double>(json['taxTotal']),
      shippingTotal: serializer.fromJson<double>(json['shippingTotal']),
      conversionFactor: serializer.fromJson<double>(json['conversionFactor']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'userName': serializer.toJson<String>(userName),
      'userId': serializer.toJson<int>(userId),
      'id': serializer.toJson<int>(id),
      'transactionNumber': serializer.toJson<String>(transactionNumber),
      'inventoryCycleNumber': serializer.toJson<String>(inventoryCycleNumber),
      'daySessionNumber': serializer.toJson<String>(daySessionNumber),
      'deliveryDate': serializer.toJson<DateTime>(deliveryDate),
      'currency': serializer.toJson<String>(currency),
      'exchangeRate': serializer.toJson<double>(exchangeRate),
      'transactionStatus': serializer.toJson<String?>(transactionStatus),
      'itemId': serializer.toJson<String?>(itemId),
      'itemCode': serializer.toJson<String>(itemCode),
      'upcCode': serializer.toJson<String>(upcCode),
      'description': serializer.toJson<String>(description),
      'itemGroup': serializer.toJson<String>(itemGroup),
      'category': serializer.toJson<String>(category),
      'salesUOM': serializer.toJson<String>(salesUOM),
      'stockUOM': serializer.toJson<String>(stockUOM),
      'taxGroup': serializer.toJson<String>(taxGroup),
      'warehouse': serializer.toJson<String>(warehouse),
      'discountType': serializer.toJson<String>(discountType),
      'discountPercentage': serializer.toJson<double>(discountPercentage),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'lineDiscountTotal': serializer.toJson<double>(lineDiscountTotal),
      'taxIndicator': serializer.toJson<String?>(taxIndicator),
      'unitPrice': serializer.toJson<double>(unitPrice),
      'costPrice': serializer.toJson<double>(costPrice),
      'listPrice': serializer.toJson<double>(listPrice),
      'quantity': serializer.toJson<double>(quantity),
      'subTotal': serializer.toJson<double>(subTotal),
      'grandTotal': serializer.toJson<double>(grandTotal),
      'fxGrandTotal': serializer.toJson<double>(fxGrandTotal),
      'itemCount': serializer.toJson<int?>(itemCount),
      'depositTotal': serializer.toJson<double?>(depositTotal),
      'lineId': serializer.toJson<int?>(lineId),
      'taxTotal': serializer.toJson<double>(taxTotal),
      'shippingTotal': serializer.toJson<double>(shippingTotal),
      'conversionFactor': serializer.toJson<double>(conversionFactor),
    };
  }

  SalesOrderDetailData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          String? userName,
          int? userId,
          int? id,
          String? transactionNumber,
          String? inventoryCycleNumber,
          String? daySessionNumber,
          DateTime? deliveryDate,
          String? currency,
          double? exchangeRate,
          Value<String?> transactionStatus = const Value.absent(),
          Value<String?> itemId = const Value.absent(),
          String? itemCode,
          String? upcCode,
          String? description,
          String? itemGroup,
          String? category,
          String? salesUOM,
          String? stockUOM,
          String? taxGroup,
          String? warehouse,
          String? discountType,
          double? discountPercentage,
          double? discountAmount,
          double? lineDiscountTotal,
          Value<String?> taxIndicator = const Value.absent(),
          double? unitPrice,
          double? costPrice,
          double? listPrice,
          double? quantity,
          double? subTotal,
          double? grandTotal,
          double? fxGrandTotal,
          Value<int?> itemCount = const Value.absent(),
          Value<double?> depositTotal = const Value.absent(),
          Value<int?> lineId = const Value.absent(),
          double? taxTotal,
          double? shippingTotal,
          double? conversionFactor}) =>
      SalesOrderDetailData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        userName: userName ?? this.userName,
        userId: userId ?? this.userId,
        id: id ?? this.id,
        transactionNumber: transactionNumber ?? this.transactionNumber,
        inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
        daySessionNumber: daySessionNumber ?? this.daySessionNumber,
        deliveryDate: deliveryDate ?? this.deliveryDate,
        currency: currency ?? this.currency,
        exchangeRate: exchangeRate ?? this.exchangeRate,
        transactionStatus: transactionStatus.present
            ? transactionStatus.value
            : this.transactionStatus,
        itemId: itemId.present ? itemId.value : this.itemId,
        itemCode: itemCode ?? this.itemCode,
        upcCode: upcCode ?? this.upcCode,
        description: description ?? this.description,
        itemGroup: itemGroup ?? this.itemGroup,
        category: category ?? this.category,
        salesUOM: salesUOM ?? this.salesUOM,
        stockUOM: stockUOM ?? this.stockUOM,
        taxGroup: taxGroup ?? this.taxGroup,
        warehouse: warehouse ?? this.warehouse,
        discountType: discountType ?? this.discountType,
        discountPercentage: discountPercentage ?? this.discountPercentage,
        discountAmount: discountAmount ?? this.discountAmount,
        lineDiscountTotal: lineDiscountTotal ?? this.lineDiscountTotal,
        taxIndicator:
            taxIndicator.present ? taxIndicator.value : this.taxIndicator,
        unitPrice: unitPrice ?? this.unitPrice,
        costPrice: costPrice ?? this.costPrice,
        listPrice: listPrice ?? this.listPrice,
        quantity: quantity ?? this.quantity,
        subTotal: subTotal ?? this.subTotal,
        grandTotal: grandTotal ?? this.grandTotal,
        fxGrandTotal: fxGrandTotal ?? this.fxGrandTotal,
        itemCount: itemCount.present ? itemCount.value : this.itemCount,
        depositTotal:
            depositTotal.present ? depositTotal.value : this.depositTotal,
        lineId: lineId.present ? lineId.value : this.lineId,
        taxTotal: taxTotal ?? this.taxTotal,
        shippingTotal: shippingTotal ?? this.shippingTotal,
        conversionFactor: conversionFactor ?? this.conversionFactor,
      );
  @override
  String toString() {
    return (StringBuffer('SalesOrderDetailData(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('upcCode: $upcCode, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('salesUOM: $salesUOM, ')
          ..write('stockUOM: $stockUOM, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('warehouse: $warehouse, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('lineDiscountTotal: $lineDiscountTotal, ')
          ..write('taxIndicator: $taxIndicator, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('costPrice: $costPrice, ')
          ..write('listPrice: $listPrice, ')
          ..write('quantity: $quantity, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('fxGrandTotal: $fxGrandTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('lineId: $lineId, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('conversionFactor: $conversionFactor')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        inventoryCycleNumber,
        daySessionNumber,
        deliveryDate,
        currency,
        exchangeRate,
        transactionStatus,
        itemId,
        itemCode,
        upcCode,
        description,
        itemGroup,
        category,
        salesUOM,
        stockUOM,
        taxGroup,
        warehouse,
        discountType,
        discountPercentage,
        discountAmount,
        lineDiscountTotal,
        taxIndicator,
        unitPrice,
        costPrice,
        listPrice,
        quantity,
        subTotal,
        grandTotal,
        fxGrandTotal,
        itemCount,
        depositTotal,
        lineId,
        taxTotal,
        shippingTotal,
        conversionFactor
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesOrderDetailData &&
          other.tenantId == this.tenantId &&
          other.userName == this.userName &&
          other.userId == this.userId &&
          other.id == this.id &&
          other.transactionNumber == this.transactionNumber &&
          other.inventoryCycleNumber == this.inventoryCycleNumber &&
          other.daySessionNumber == this.daySessionNumber &&
          other.deliveryDate == this.deliveryDate &&
          other.currency == this.currency &&
          other.exchangeRate == this.exchangeRate &&
          other.transactionStatus == this.transactionStatus &&
          other.itemId == this.itemId &&
          other.itemCode == this.itemCode &&
          other.upcCode == this.upcCode &&
          other.description == this.description &&
          other.itemGroup == this.itemGroup &&
          other.category == this.category &&
          other.salesUOM == this.salesUOM &&
          other.stockUOM == this.stockUOM &&
          other.taxGroup == this.taxGroup &&
          other.warehouse == this.warehouse &&
          other.discountType == this.discountType &&
          other.discountPercentage == this.discountPercentage &&
          other.discountAmount == this.discountAmount &&
          other.lineDiscountTotal == this.lineDiscountTotal &&
          other.taxIndicator == this.taxIndicator &&
          other.unitPrice == this.unitPrice &&
          other.costPrice == this.costPrice &&
          other.listPrice == this.listPrice &&
          other.quantity == this.quantity &&
          other.subTotal == this.subTotal &&
          other.grandTotal == this.grandTotal &&
          other.fxGrandTotal == this.fxGrandTotal &&
          other.itemCount == this.itemCount &&
          other.depositTotal == this.depositTotal &&
          other.lineId == this.lineId &&
          other.taxTotal == this.taxTotal &&
          other.shippingTotal == this.shippingTotal &&
          other.conversionFactor == this.conversionFactor);
}

class SalesOrderDetailCompanion extends UpdateCompanion<SalesOrderDetailData> {
  final Value<String?> tenantId;
  final Value<String> userName;
  final Value<int> userId;
  final Value<int> id;
  final Value<String> transactionNumber;
  final Value<String> inventoryCycleNumber;
  final Value<String> daySessionNumber;
  final Value<DateTime> deliveryDate;
  final Value<String> currency;
  final Value<double> exchangeRate;
  final Value<String?> transactionStatus;
  final Value<String?> itemId;
  final Value<String> itemCode;
  final Value<String> upcCode;
  final Value<String> description;
  final Value<String> itemGroup;
  final Value<String> category;
  final Value<String> salesUOM;
  final Value<String> stockUOM;
  final Value<String> taxGroup;
  final Value<String> warehouse;
  final Value<String> discountType;
  final Value<double> discountPercentage;
  final Value<double> discountAmount;
  final Value<double> lineDiscountTotal;
  final Value<String?> taxIndicator;
  final Value<double> unitPrice;
  final Value<double> costPrice;
  final Value<double> listPrice;
  final Value<double> quantity;
  final Value<double> subTotal;
  final Value<double> grandTotal;
  final Value<double> fxGrandTotal;
  final Value<int?> itemCount;
  final Value<double?> depositTotal;
  final Value<int?> lineId;
  final Value<double> taxTotal;
  final Value<double> shippingTotal;
  final Value<double> conversionFactor;
  const SalesOrderDetailCompanion({
    this.tenantId = const Value.absent(),
    this.userName = const Value.absent(),
    this.userId = const Value.absent(),
    this.id = const Value.absent(),
    this.transactionNumber = const Value.absent(),
    this.inventoryCycleNumber = const Value.absent(),
    this.daySessionNumber = const Value.absent(),
    this.deliveryDate = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.itemId = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.upcCode = const Value.absent(),
    this.description = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.category = const Value.absent(),
    this.salesUOM = const Value.absent(),
    this.stockUOM = const Value.absent(),
    this.taxGroup = const Value.absent(),
    this.warehouse = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.lineDiscountTotal = const Value.absent(),
    this.taxIndicator = const Value.absent(),
    this.unitPrice = const Value.absent(),
    this.costPrice = const Value.absent(),
    this.listPrice = const Value.absent(),
    this.quantity = const Value.absent(),
    this.subTotal = const Value.absent(),
    this.grandTotal = const Value.absent(),
    this.fxGrandTotal = const Value.absent(),
    this.itemCount = const Value.absent(),
    this.depositTotal = const Value.absent(),
    this.lineId = const Value.absent(),
    this.taxTotal = const Value.absent(),
    this.shippingTotal = const Value.absent(),
    this.conversionFactor = const Value.absent(),
  });
  SalesOrderDetailCompanion.insert({
    this.tenantId = const Value.absent(),
    required String userName,
    required int userId,
    this.id = const Value.absent(),
    required String transactionNumber,
    required String inventoryCycleNumber,
    required String daySessionNumber,
    required DateTime deliveryDate,
    required String currency,
    required double exchangeRate,
    this.transactionStatus = const Value.absent(),
    this.itemId = const Value.absent(),
    required String itemCode,
    required String upcCode,
    required String description,
    required String itemGroup,
    required String category,
    required String salesUOM,
    required String stockUOM,
    required String taxGroup,
    required String warehouse,
    required String discountType,
    required double discountPercentage,
    required double discountAmount,
    required double lineDiscountTotal,
    this.taxIndicator = const Value.absent(),
    required double unitPrice,
    required double costPrice,
    required double listPrice,
    required double quantity,
    required double subTotal,
    required double grandTotal,
    required double fxGrandTotal,
    this.itemCount = const Value.absent(),
    this.depositTotal = const Value.absent(),
    this.lineId = const Value.absent(),
    required double taxTotal,
    required double shippingTotal,
    required double conversionFactor,
  })  : userName = Value(userName),
        userId = Value(userId),
        transactionNumber = Value(transactionNumber),
        inventoryCycleNumber = Value(inventoryCycleNumber),
        daySessionNumber = Value(daySessionNumber),
        deliveryDate = Value(deliveryDate),
        currency = Value(currency),
        exchangeRate = Value(exchangeRate),
        itemCode = Value(itemCode),
        upcCode = Value(upcCode),
        description = Value(description),
        itemGroup = Value(itemGroup),
        category = Value(category),
        salesUOM = Value(salesUOM),
        stockUOM = Value(stockUOM),
        taxGroup = Value(taxGroup),
        warehouse = Value(warehouse),
        discountType = Value(discountType),
        discountPercentage = Value(discountPercentage),
        discountAmount = Value(discountAmount),
        lineDiscountTotal = Value(lineDiscountTotal),
        unitPrice = Value(unitPrice),
        costPrice = Value(costPrice),
        listPrice = Value(listPrice),
        quantity = Value(quantity),
        subTotal = Value(subTotal),
        grandTotal = Value(grandTotal),
        fxGrandTotal = Value(fxGrandTotal),
        taxTotal = Value(taxTotal),
        shippingTotal = Value(shippingTotal),
        conversionFactor = Value(conversionFactor);
  static Insertable<SalesOrderDetailData> custom({
    Expression<String>? tenantId,
    Expression<String>? userName,
    Expression<int>? userId,
    Expression<int>? id,
    Expression<String>? transactionNumber,
    Expression<String>? inventoryCycleNumber,
    Expression<String>? daySessionNumber,
    Expression<DateTime>? deliveryDate,
    Expression<String>? currency,
    Expression<double>? exchangeRate,
    Expression<String>? transactionStatus,
    Expression<String>? itemId,
    Expression<String>? itemCode,
    Expression<String>? upcCode,
    Expression<String>? description,
    Expression<String>? itemGroup,
    Expression<String>? category,
    Expression<String>? salesUOM,
    Expression<String>? stockUOM,
    Expression<String>? taxGroup,
    Expression<String>? warehouse,
    Expression<String>? discountType,
    Expression<double>? discountPercentage,
    Expression<double>? discountAmount,
    Expression<double>? lineDiscountTotal,
    Expression<String>? taxIndicator,
    Expression<double>? unitPrice,
    Expression<double>? costPrice,
    Expression<double>? listPrice,
    Expression<double>? quantity,
    Expression<double>? subTotal,
    Expression<double>? grandTotal,
    Expression<double>? fxGrandTotal,
    Expression<int>? itemCount,
    Expression<double>? depositTotal,
    Expression<int>? lineId,
    Expression<double>? taxTotal,
    Expression<double>? shippingTotal,
    Expression<double>? conversionFactor,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (userName != null) 'user_name': userName,
      if (userId != null) 'user_id': userId,
      if (id != null) 'id': id,
      if (transactionNumber != null) 'transaction_number': transactionNumber,
      if (inventoryCycleNumber != null)
        'inventory_cycle_number': inventoryCycleNumber,
      if (daySessionNumber != null) 'day_session_number': daySessionNumber,
      if (deliveryDate != null) 'delivery_date': deliveryDate,
      if (currency != null) 'currency': currency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (transactionStatus != null) 'transaction_status': transactionStatus,
      if (itemId != null) 'item_id': itemId,
      if (itemCode != null) 'item_code': itemCode,
      if (upcCode != null) 'upc_code': upcCode,
      if (description != null) 'description': description,
      if (itemGroup != null) 'item_group': itemGroup,
      if (category != null) 'category': category,
      if (salesUOM != null) 'sales_u_o_m': salesUOM,
      if (stockUOM != null) 'stock_u_o_m': stockUOM,
      if (taxGroup != null) 'tax_group': taxGroup,
      if (warehouse != null) 'warehouse': warehouse,
      if (discountType != null) 'discount_type': discountType,
      if (discountPercentage != null) 'discount_percentage': discountPercentage,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (lineDiscountTotal != null) 'line_discount_total': lineDiscountTotal,
      if (taxIndicator != null) 'tax_indicator': taxIndicator,
      if (unitPrice != null) 'unit_price': unitPrice,
      if (costPrice != null) 'cost_price': costPrice,
      if (listPrice != null) 'list_price': listPrice,
      if (quantity != null) 'quantity': quantity,
      if (subTotal != null) 'sub_total': subTotal,
      if (grandTotal != null) 'grand_total': grandTotal,
      if (fxGrandTotal != null) 'fx_grand_total': fxGrandTotal,
      if (itemCount != null) 'item_count': itemCount,
      if (depositTotal != null) 'deposit_total': depositTotal,
      if (lineId != null) 'line_id': lineId,
      if (taxTotal != null) 'tax_total': taxTotal,
      if (shippingTotal != null) 'shipping_total': shippingTotal,
      if (conversionFactor != null) 'conversion_factor': conversionFactor,
    });
  }

  SalesOrderDetailCompanion copyWith(
      {Value<String?>? tenantId,
      Value<String>? userName,
      Value<int>? userId,
      Value<int>? id,
      Value<String>? transactionNumber,
      Value<String>? inventoryCycleNumber,
      Value<String>? daySessionNumber,
      Value<DateTime>? deliveryDate,
      Value<String>? currency,
      Value<double>? exchangeRate,
      Value<String?>? transactionStatus,
      Value<String?>? itemId,
      Value<String>? itemCode,
      Value<String>? upcCode,
      Value<String>? description,
      Value<String>? itemGroup,
      Value<String>? category,
      Value<String>? salesUOM,
      Value<String>? stockUOM,
      Value<String>? taxGroup,
      Value<String>? warehouse,
      Value<String>? discountType,
      Value<double>? discountPercentage,
      Value<double>? discountAmount,
      Value<double>? lineDiscountTotal,
      Value<String?>? taxIndicator,
      Value<double>? unitPrice,
      Value<double>? costPrice,
      Value<double>? listPrice,
      Value<double>? quantity,
      Value<double>? subTotal,
      Value<double>? grandTotal,
      Value<double>? fxGrandTotal,
      Value<int?>? itemCount,
      Value<double?>? depositTotal,
      Value<int?>? lineId,
      Value<double>? taxTotal,
      Value<double>? shippingTotal,
      Value<double>? conversionFactor}) {
    return SalesOrderDetailCompanion(
      tenantId: tenantId ?? this.tenantId,
      userName: userName ?? this.userName,
      userId: userId ?? this.userId,
      id: id ?? this.id,
      transactionNumber: transactionNumber ?? this.transactionNumber,
      inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
      daySessionNumber: daySessionNumber ?? this.daySessionNumber,
      deliveryDate: deliveryDate ?? this.deliveryDate,
      currency: currency ?? this.currency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      transactionStatus: transactionStatus ?? this.transactionStatus,
      itemId: itemId ?? this.itemId,
      itemCode: itemCode ?? this.itemCode,
      upcCode: upcCode ?? this.upcCode,
      description: description ?? this.description,
      itemGroup: itemGroup ?? this.itemGroup,
      category: category ?? this.category,
      salesUOM: salesUOM ?? this.salesUOM,
      stockUOM: stockUOM ?? this.stockUOM,
      taxGroup: taxGroup ?? this.taxGroup,
      warehouse: warehouse ?? this.warehouse,
      discountType: discountType ?? this.discountType,
      discountPercentage: discountPercentage ?? this.discountPercentage,
      discountAmount: discountAmount ?? this.discountAmount,
      lineDiscountTotal: lineDiscountTotal ?? this.lineDiscountTotal,
      taxIndicator: taxIndicator ?? this.taxIndicator,
      unitPrice: unitPrice ?? this.unitPrice,
      costPrice: costPrice ?? this.costPrice,
      listPrice: listPrice ?? this.listPrice,
      quantity: quantity ?? this.quantity,
      subTotal: subTotal ?? this.subTotal,
      grandTotal: grandTotal ?? this.grandTotal,
      fxGrandTotal: fxGrandTotal ?? this.fxGrandTotal,
      itemCount: itemCount ?? this.itemCount,
      depositTotal: depositTotal ?? this.depositTotal,
      lineId: lineId ?? this.lineId,
      taxTotal: taxTotal ?? this.taxTotal,
      shippingTotal: shippingTotal ?? this.shippingTotal,
      conversionFactor: conversionFactor ?? this.conversionFactor,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (transactionNumber.present) {
      map['transaction_number'] = Variable<String>(transactionNumber.value);
    }
    if (inventoryCycleNumber.present) {
      map['inventory_cycle_number'] =
          Variable<String>(inventoryCycleNumber.value);
    }
    if (daySessionNumber.present) {
      map['day_session_number'] = Variable<String>(daySessionNumber.value);
    }
    if (deliveryDate.present) {
      map['delivery_date'] = Variable<DateTime>(deliveryDate.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (transactionStatus.present) {
      map['transaction_status'] = Variable<String>(transactionStatus.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (upcCode.present) {
      map['upc_code'] = Variable<String>(upcCode.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (itemGroup.present) {
      map['item_group'] = Variable<String>(itemGroup.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (salesUOM.present) {
      map['sales_u_o_m'] = Variable<String>(salesUOM.value);
    }
    if (stockUOM.present) {
      map['stock_u_o_m'] = Variable<String>(stockUOM.value);
    }
    if (taxGroup.present) {
      map['tax_group'] = Variable<String>(taxGroup.value);
    }
    if (warehouse.present) {
      map['warehouse'] = Variable<String>(warehouse.value);
    }
    if (discountType.present) {
      map['discount_type'] = Variable<String>(discountType.value);
    }
    if (discountPercentage.present) {
      map['discount_percentage'] = Variable<double>(discountPercentage.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (lineDiscountTotal.present) {
      map['line_discount_total'] = Variable<double>(lineDiscountTotal.value);
    }
    if (taxIndicator.present) {
      map['tax_indicator'] = Variable<String>(taxIndicator.value);
    }
    if (unitPrice.present) {
      map['unit_price'] = Variable<double>(unitPrice.value);
    }
    if (costPrice.present) {
      map['cost_price'] = Variable<double>(costPrice.value);
    }
    if (listPrice.present) {
      map['list_price'] = Variable<double>(listPrice.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (subTotal.present) {
      map['sub_total'] = Variable<double>(subTotal.value);
    }
    if (grandTotal.present) {
      map['grand_total'] = Variable<double>(grandTotal.value);
    }
    if (fxGrandTotal.present) {
      map['fx_grand_total'] = Variable<double>(fxGrandTotal.value);
    }
    if (itemCount.present) {
      map['item_count'] = Variable<int>(itemCount.value);
    }
    if (depositTotal.present) {
      map['deposit_total'] = Variable<double>(depositTotal.value);
    }
    if (lineId.present) {
      map['line_id'] = Variable<int>(lineId.value);
    }
    if (taxTotal.present) {
      map['tax_total'] = Variable<double>(taxTotal.value);
    }
    if (shippingTotal.present) {
      map['shipping_total'] = Variable<double>(shippingTotal.value);
    }
    if (conversionFactor.present) {
      map['conversion_factor'] = Variable<double>(conversionFactor.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesOrderDetailCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('upcCode: $upcCode, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('salesUOM: $salesUOM, ')
          ..write('stockUOM: $stockUOM, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('warehouse: $warehouse, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('lineDiscountTotal: $lineDiscountTotal, ')
          ..write('taxIndicator: $taxIndicator, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('costPrice: $costPrice, ')
          ..write('listPrice: $listPrice, ')
          ..write('quantity: $quantity, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('fxGrandTotal: $fxGrandTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('lineId: $lineId, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('conversionFactor: $conversionFactor')
          ..write(')'))
        .toString();
  }
}

class $SalesOrderDetailTempTable extends SalesOrderDetailTemp
    with TableInfo<$SalesOrderDetailTempTable, SalesOrderDetailTempData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SalesOrderDetailTempTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _transactionNumberMeta =
      const VerificationMeta('transactionNumber');
  @override
  late final GeneratedColumn<String> transactionNumber =
      GeneratedColumn<String>('transaction_number', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _inventoryCycleNumberMeta =
      const VerificationMeta('inventoryCycleNumber');
  @override
  late final GeneratedColumn<String> inventoryCycleNumber =
      GeneratedColumn<String>('inventory_cycle_number', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _daySessionNumberMeta =
      const VerificationMeta('daySessionNumber');
  @override
  late final GeneratedColumn<String> daySessionNumber = GeneratedColumn<String>(
      'day_session_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deliveryDateMeta =
      const VerificationMeta('deliveryDate');
  @override
  late final GeneratedColumn<DateTime> deliveryDate = GeneratedColumn<DateTime>(
      'delivery_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _currencyMeta =
      const VerificationMeta('currency');
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
      'currency', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  @override
  late final GeneratedColumn<double> exchangeRate = GeneratedColumn<double>(
      'exchange_rate', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _transactionStatusMeta =
      const VerificationMeta('transactionStatus');
  @override
  late final GeneratedColumn<String> transactionStatus =
      GeneratedColumn<String>('transaction_status', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
      'item_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemCodeMeta =
      const VerificationMeta('itemCode');
  @override
  late final GeneratedColumn<String> itemCode = GeneratedColumn<String>(
      'item_code', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _upcCodeMeta =
      const VerificationMeta('upcCode');
  @override
  late final GeneratedColumn<String> upcCode = GeneratedColumn<String>(
      'upc_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _itemGroupMeta =
      const VerificationMeta('itemGroup');
  @override
  late final GeneratedColumn<String> itemGroup = GeneratedColumn<String>(
      'item_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _categoryMeta =
      const VerificationMeta('category');
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
      'category', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _salesUOMMeta =
      const VerificationMeta('salesUOM');
  @override
  late final GeneratedColumn<String> salesUOM = GeneratedColumn<String>(
      'sales_u_o_m', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _stockUOMMeta =
      const VerificationMeta('stockUOM');
  @override
  late final GeneratedColumn<String> stockUOM = GeneratedColumn<String>(
      'stock_u_o_m', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _taxGroupMeta =
      const VerificationMeta('taxGroup');
  @override
  late final GeneratedColumn<String> taxGroup = GeneratedColumn<String>(
      'tax_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _warehouseMeta =
      const VerificationMeta('warehouse');
  @override
  late final GeneratedColumn<String> warehouse = GeneratedColumn<String>(
      'warehouse', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _discountTypeMeta =
      const VerificationMeta('discountType');
  @override
  late final GeneratedColumn<String> discountType = GeneratedColumn<String>(
      'discount_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _discountPercentageMeta =
      const VerificationMeta('discountPercentage');
  @override
  late final GeneratedColumn<double> discountPercentage =
      GeneratedColumn<double>('discount_percentage', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _discountAmountMeta =
      const VerificationMeta('discountAmount');
  @override
  late final GeneratedColumn<double> discountAmount = GeneratedColumn<double>(
      'discount_amount', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _lineDiscountTotalMeta =
      const VerificationMeta('lineDiscountTotal');
  @override
  late final GeneratedColumn<double> lineDiscountTotal =
      GeneratedColumn<double>('line_discount_total', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _taxIndicatorMeta =
      const VerificationMeta('taxIndicator');
  @override
  late final GeneratedColumn<String> taxIndicator = GeneratedColumn<String>(
      'tax_indicator', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _unitPriceMeta =
      const VerificationMeta('unitPrice');
  @override
  late final GeneratedColumn<double> unitPrice = GeneratedColumn<double>(
      'unit_price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _costPriceMeta =
      const VerificationMeta('costPrice');
  @override
  late final GeneratedColumn<double> costPrice = GeneratedColumn<double>(
      'cost_price', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _listPriceMeta =
      const VerificationMeta('listPrice');
  @override
  late final GeneratedColumn<double> listPrice = GeneratedColumn<double>(
      'list_price', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  @override
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _subTotalMeta =
      const VerificationMeta('subTotal');
  @override
  late final GeneratedColumn<double> subTotal = GeneratedColumn<double>(
      'sub_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _grandTotalMeta =
      const VerificationMeta('grandTotal');
  @override
  late final GeneratedColumn<double> grandTotal = GeneratedColumn<double>(
      'grand_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _itemCountMeta =
      const VerificationMeta('itemCount');
  @override
  late final GeneratedColumn<int> itemCount = GeneratedColumn<int>(
      'item_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _depositTotalMeta =
      const VerificationMeta('depositTotal');
  @override
  late final GeneratedColumn<double> depositTotal = GeneratedColumn<double>(
      'deposit_total', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _lineIdMeta = const VerificationMeta('lineId');
  @override
  late final GeneratedColumn<int> lineId = GeneratedColumn<int>(
      'line_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _taxTotalMeta =
      const VerificationMeta('taxTotal');
  @override
  late final GeneratedColumn<double> taxTotal = GeneratedColumn<double>(
      'tax_total', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _shippingTotalMeta =
      const VerificationMeta('shippingTotal');
  @override
  late final GeneratedColumn<double> shippingTotal = GeneratedColumn<double>(
      'shipping_total', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _conversionFactorMeta =
      const VerificationMeta('conversionFactor');
  @override
  late final GeneratedColumn<double> conversionFactor = GeneratedColumn<double>(
      'conversion_factor', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        inventoryCycleNumber,
        daySessionNumber,
        deliveryDate,
        currency,
        exchangeRate,
        transactionStatus,
        itemId,
        itemCode,
        upcCode,
        description,
        itemGroup,
        category,
        salesUOM,
        stockUOM,
        taxGroup,
        warehouse,
        discountType,
        discountPercentage,
        discountAmount,
        lineDiscountTotal,
        taxIndicator,
        unitPrice,
        costPrice,
        listPrice,
        quantity,
        subTotal,
        grandTotal,
        itemCount,
        depositTotal,
        lineId,
        taxTotal,
        shippingTotal,
        conversionFactor
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sales_order_detail_temp';
  @override
  VerificationContext validateIntegrity(
      Insertable<SalesOrderDetailTempData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    } else if (isInserting) {
      context.missing(_userNameMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('transaction_number')) {
      context.handle(
          _transactionNumberMeta,
          transactionNumber.isAcceptableOrUnknown(
              data['transaction_number']!, _transactionNumberMeta));
    } else if (isInserting) {
      context.missing(_transactionNumberMeta);
    }
    if (data.containsKey('inventory_cycle_number')) {
      context.handle(
          _inventoryCycleNumberMeta,
          inventoryCycleNumber.isAcceptableOrUnknown(
              data['inventory_cycle_number']!, _inventoryCycleNumberMeta));
    }
    if (data.containsKey('day_session_number')) {
      context.handle(
          _daySessionNumberMeta,
          daySessionNumber.isAcceptableOrUnknown(
              data['day_session_number']!, _daySessionNumberMeta));
    }
    if (data.containsKey('delivery_date')) {
      context.handle(
          _deliveryDateMeta,
          deliveryDate.isAcceptableOrUnknown(
              data['delivery_date']!, _deliveryDateMeta));
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta));
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate']!, _exchangeRateMeta));
    }
    if (data.containsKey('transaction_status')) {
      context.handle(
          _transactionStatusMeta,
          transactionStatus.isAcceptableOrUnknown(
              data['transaction_status']!, _transactionStatusMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code']!, _itemCodeMeta));
    } else if (isInserting) {
      context.missing(_itemCodeMeta);
    }
    if (data.containsKey('upc_code')) {
      context.handle(_upcCodeMeta,
          upcCode.isAcceptableOrUnknown(data['upc_code']!, _upcCodeMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    } else if (isInserting) {
      context.missing(_descriptionMeta);
    }
    if (data.containsKey('item_group')) {
      context.handle(_itemGroupMeta,
          itemGroup.isAcceptableOrUnknown(data['item_group']!, _itemGroupMeta));
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category']!, _categoryMeta));
    }
    if (data.containsKey('sales_u_o_m')) {
      context.handle(_salesUOMMeta,
          salesUOM.isAcceptableOrUnknown(data['sales_u_o_m']!, _salesUOMMeta));
    }
    if (data.containsKey('stock_u_o_m')) {
      context.handle(_stockUOMMeta,
          stockUOM.isAcceptableOrUnknown(data['stock_u_o_m']!, _stockUOMMeta));
    }
    if (data.containsKey('tax_group')) {
      context.handle(_taxGroupMeta,
          taxGroup.isAcceptableOrUnknown(data['tax_group']!, _taxGroupMeta));
    }
    if (data.containsKey('warehouse')) {
      context.handle(_warehouseMeta,
          warehouse.isAcceptableOrUnknown(data['warehouse']!, _warehouseMeta));
    }
    if (data.containsKey('discount_type')) {
      context.handle(
          _discountTypeMeta,
          discountType.isAcceptableOrUnknown(
              data['discount_type']!, _discountTypeMeta));
    }
    if (data.containsKey('discount_percentage')) {
      context.handle(
          _discountPercentageMeta,
          discountPercentage.isAcceptableOrUnknown(
              data['discount_percentage']!, _discountPercentageMeta));
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
          _discountAmountMeta,
          discountAmount.isAcceptableOrUnknown(
              data['discount_amount']!, _discountAmountMeta));
    }
    if (data.containsKey('line_discount_total')) {
      context.handle(
          _lineDiscountTotalMeta,
          lineDiscountTotal.isAcceptableOrUnknown(
              data['line_discount_total']!, _lineDiscountTotalMeta));
    }
    if (data.containsKey('tax_indicator')) {
      context.handle(
          _taxIndicatorMeta,
          taxIndicator.isAcceptableOrUnknown(
              data['tax_indicator']!, _taxIndicatorMeta));
    }
    if (data.containsKey('unit_price')) {
      context.handle(_unitPriceMeta,
          unitPrice.isAcceptableOrUnknown(data['unit_price']!, _unitPriceMeta));
    } else if (isInserting) {
      context.missing(_unitPriceMeta);
    }
    if (data.containsKey('cost_price')) {
      context.handle(_costPriceMeta,
          costPrice.isAcceptableOrUnknown(data['cost_price']!, _costPriceMeta));
    }
    if (data.containsKey('list_price')) {
      context.handle(_listPriceMeta,
          listPrice.isAcceptableOrUnknown(data['list_price']!, _listPriceMeta));
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('sub_total')) {
      context.handle(_subTotalMeta,
          subTotal.isAcceptableOrUnknown(data['sub_total']!, _subTotalMeta));
    } else if (isInserting) {
      context.missing(_subTotalMeta);
    }
    if (data.containsKey('grand_total')) {
      context.handle(
          _grandTotalMeta,
          grandTotal.isAcceptableOrUnknown(
              data['grand_total']!, _grandTotalMeta));
    } else if (isInserting) {
      context.missing(_grandTotalMeta);
    }
    if (data.containsKey('item_count')) {
      context.handle(_itemCountMeta,
          itemCount.isAcceptableOrUnknown(data['item_count']!, _itemCountMeta));
    }
    if (data.containsKey('deposit_total')) {
      context.handle(
          _depositTotalMeta,
          depositTotal.isAcceptableOrUnknown(
              data['deposit_total']!, _depositTotalMeta));
    }
    if (data.containsKey('line_id')) {
      context.handle(_lineIdMeta,
          lineId.isAcceptableOrUnknown(data['line_id']!, _lineIdMeta));
    }
    if (data.containsKey('tax_total')) {
      context.handle(_taxTotalMeta,
          taxTotal.isAcceptableOrUnknown(data['tax_total']!, _taxTotalMeta));
    }
    if (data.containsKey('shipping_total')) {
      context.handle(
          _shippingTotalMeta,
          shippingTotal.isAcceptableOrUnknown(
              data['shipping_total']!, _shippingTotalMeta));
    } else if (isInserting) {
      context.missing(_shippingTotalMeta);
    }
    if (data.containsKey('conversion_factor')) {
      context.handle(
          _conversionFactorMeta,
          conversionFactor.isAcceptableOrUnknown(
              data['conversion_factor']!, _conversionFactorMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SalesOrderDetailTempData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SalesOrderDetailTempData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      transactionNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_number'])!,
      inventoryCycleNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}inventory_cycle_number']),
      daySessionNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}day_session_number']),
      deliveryDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}delivery_date']),
      currency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}currency']),
      exchangeRate: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}exchange_rate']),
      transactionStatus: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_status']),
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_id']),
      itemCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_code'])!,
      upcCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}upc_code']),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description'])!,
      itemGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_group']),
      category: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}category']),
      salesUOM: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sales_u_o_m']),
      stockUOM: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stock_u_o_m']),
      taxGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tax_group']),
      warehouse: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse']),
      discountType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}discount_type']),
      discountPercentage: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}discount_percentage']),
      discountAmount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}discount_amount']),
      lineDiscountTotal: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}line_discount_total']),
      taxIndicator: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tax_indicator']),
      unitPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}unit_price'])!,
      costPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cost_price']),
      listPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}list_price']),
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      subTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}sub_total'])!,
      grandTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}grand_total'])!,
      itemCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_count']),
      depositTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}deposit_total']),
      lineId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}line_id']),
      taxTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tax_total']),
      shippingTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}shipping_total'])!,
      conversionFactor: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}conversion_factor']),
    );
  }

  @override
  $SalesOrderDetailTempTable createAlias(String alias) {
    return $SalesOrderDetailTempTable(attachedDatabase, alias);
  }
}

class SalesOrderDetailTempData extends DataClass
    implements Insertable<SalesOrderDetailTempData> {
  final String? tenantId;
  final String userName;
  final int userId;
  final int id;
  final String transactionNumber;
  final String? inventoryCycleNumber;
  final String? daySessionNumber;
  final DateTime? deliveryDate;
  final String? currency;
  final double? exchangeRate;
  final String? transactionStatus;
  final String? itemId;
  final String itemCode;
  final String? upcCode;
  final String description;
  final String? itemGroup;
  final String? category;
  final String? salesUOM;
  final String? stockUOM;
  final String? taxGroup;
  final String? warehouse;
  final String? discountType;
  final double? discountPercentage;
  final double? discountAmount;
  final double? lineDiscountTotal;
  final String? taxIndicator;
  final double unitPrice;
  final double? costPrice;
  final double? listPrice;
  final double quantity;
  final double subTotal;
  final double grandTotal;
  final int? itemCount;
  final double? depositTotal;
  final int? lineId;
  final double? taxTotal;
  final double shippingTotal;
  final double? conversionFactor;
  const SalesOrderDetailTempData(
      {this.tenantId,
      required this.userName,
      required this.userId,
      required this.id,
      required this.transactionNumber,
      this.inventoryCycleNumber,
      this.daySessionNumber,
      this.deliveryDate,
      this.currency,
      this.exchangeRate,
      this.transactionStatus,
      this.itemId,
      required this.itemCode,
      this.upcCode,
      required this.description,
      this.itemGroup,
      this.category,
      this.salesUOM,
      this.stockUOM,
      this.taxGroup,
      this.warehouse,
      this.discountType,
      this.discountPercentage,
      this.discountAmount,
      this.lineDiscountTotal,
      this.taxIndicator,
      required this.unitPrice,
      this.costPrice,
      this.listPrice,
      required this.quantity,
      required this.subTotal,
      required this.grandTotal,
      this.itemCount,
      this.depositTotal,
      this.lineId,
      this.taxTotal,
      required this.shippingTotal,
      this.conversionFactor});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['user_name'] = Variable<String>(userName);
    map['user_id'] = Variable<int>(userId);
    map['id'] = Variable<int>(id);
    map['transaction_number'] = Variable<String>(transactionNumber);
    if (!nullToAbsent || inventoryCycleNumber != null) {
      map['inventory_cycle_number'] = Variable<String>(inventoryCycleNumber);
    }
    if (!nullToAbsent || daySessionNumber != null) {
      map['day_session_number'] = Variable<String>(daySessionNumber);
    }
    if (!nullToAbsent || deliveryDate != null) {
      map['delivery_date'] = Variable<DateTime>(deliveryDate);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    if (!nullToAbsent || exchangeRate != null) {
      map['exchange_rate'] = Variable<double>(exchangeRate);
    }
    if (!nullToAbsent || transactionStatus != null) {
      map['transaction_status'] = Variable<String>(transactionStatus);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    map['item_code'] = Variable<String>(itemCode);
    if (!nullToAbsent || upcCode != null) {
      map['upc_code'] = Variable<String>(upcCode);
    }
    map['description'] = Variable<String>(description);
    if (!nullToAbsent || itemGroup != null) {
      map['item_group'] = Variable<String>(itemGroup);
    }
    if (!nullToAbsent || category != null) {
      map['category'] = Variable<String>(category);
    }
    if (!nullToAbsent || salesUOM != null) {
      map['sales_u_o_m'] = Variable<String>(salesUOM);
    }
    if (!nullToAbsent || stockUOM != null) {
      map['stock_u_o_m'] = Variable<String>(stockUOM);
    }
    if (!nullToAbsent || taxGroup != null) {
      map['tax_group'] = Variable<String>(taxGroup);
    }
    if (!nullToAbsent || warehouse != null) {
      map['warehouse'] = Variable<String>(warehouse);
    }
    if (!nullToAbsent || discountType != null) {
      map['discount_type'] = Variable<String>(discountType);
    }
    if (!nullToAbsent || discountPercentage != null) {
      map['discount_percentage'] = Variable<double>(discountPercentage);
    }
    if (!nullToAbsent || discountAmount != null) {
      map['discount_amount'] = Variable<double>(discountAmount);
    }
    if (!nullToAbsent || lineDiscountTotal != null) {
      map['line_discount_total'] = Variable<double>(lineDiscountTotal);
    }
    if (!nullToAbsent || taxIndicator != null) {
      map['tax_indicator'] = Variable<String>(taxIndicator);
    }
    map['unit_price'] = Variable<double>(unitPrice);
    if (!nullToAbsent || costPrice != null) {
      map['cost_price'] = Variable<double>(costPrice);
    }
    if (!nullToAbsent || listPrice != null) {
      map['list_price'] = Variable<double>(listPrice);
    }
    map['quantity'] = Variable<double>(quantity);
    map['sub_total'] = Variable<double>(subTotal);
    map['grand_total'] = Variable<double>(grandTotal);
    if (!nullToAbsent || itemCount != null) {
      map['item_count'] = Variable<int>(itemCount);
    }
    if (!nullToAbsent || depositTotal != null) {
      map['deposit_total'] = Variable<double>(depositTotal);
    }
    if (!nullToAbsent || lineId != null) {
      map['line_id'] = Variable<int>(lineId);
    }
    if (!nullToAbsent || taxTotal != null) {
      map['tax_total'] = Variable<double>(taxTotal);
    }
    map['shipping_total'] = Variable<double>(shippingTotal);
    if (!nullToAbsent || conversionFactor != null) {
      map['conversion_factor'] = Variable<double>(conversionFactor);
    }
    return map;
  }

  SalesOrderDetailTempCompanion toCompanion(bool nullToAbsent) {
    return SalesOrderDetailTempCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      userName: Value(userName),
      userId: Value(userId),
      id: Value(id),
      transactionNumber: Value(transactionNumber),
      inventoryCycleNumber: inventoryCycleNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(inventoryCycleNumber),
      daySessionNumber: daySessionNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(daySessionNumber),
      deliveryDate: deliveryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(deliveryDate),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      exchangeRate: exchangeRate == null && nullToAbsent
          ? const Value.absent()
          : Value(exchangeRate),
      transactionStatus: transactionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionStatus),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      itemCode: Value(itemCode),
      upcCode: upcCode == null && nullToAbsent
          ? const Value.absent()
          : Value(upcCode),
      description: Value(description),
      itemGroup: itemGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(itemGroup),
      category: category == null && nullToAbsent
          ? const Value.absent()
          : Value(category),
      salesUOM: salesUOM == null && nullToAbsent
          ? const Value.absent()
          : Value(salesUOM),
      stockUOM: stockUOM == null && nullToAbsent
          ? const Value.absent()
          : Value(stockUOM),
      taxGroup: taxGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(taxGroup),
      warehouse: warehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(warehouse),
      discountType: discountType == null && nullToAbsent
          ? const Value.absent()
          : Value(discountType),
      discountPercentage: discountPercentage == null && nullToAbsent
          ? const Value.absent()
          : Value(discountPercentage),
      discountAmount: discountAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(discountAmount),
      lineDiscountTotal: lineDiscountTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(lineDiscountTotal),
      taxIndicator: taxIndicator == null && nullToAbsent
          ? const Value.absent()
          : Value(taxIndicator),
      unitPrice: Value(unitPrice),
      costPrice: costPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(costPrice),
      listPrice: listPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(listPrice),
      quantity: Value(quantity),
      subTotal: Value(subTotal),
      grandTotal: Value(grandTotal),
      itemCount: itemCount == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCount),
      depositTotal: depositTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(depositTotal),
      lineId:
          lineId == null && nullToAbsent ? const Value.absent() : Value(lineId),
      taxTotal: taxTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(taxTotal),
      shippingTotal: Value(shippingTotal),
      conversionFactor: conversionFactor == null && nullToAbsent
          ? const Value.absent()
          : Value(conversionFactor),
    );
  }

  factory SalesOrderDetailTempData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesOrderDetailTempData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      userName: serializer.fromJson<String>(json['userName']),
      userId: serializer.fromJson<int>(json['userId']),
      id: serializer.fromJson<int>(json['id']),
      transactionNumber: serializer.fromJson<String>(json['transactionNumber']),
      inventoryCycleNumber:
          serializer.fromJson<String?>(json['inventoryCycleNumber']),
      daySessionNumber: serializer.fromJson<String?>(json['daySessionNumber']),
      deliveryDate: serializer.fromJson<DateTime?>(json['deliveryDate']),
      currency: serializer.fromJson<String?>(json['currency']),
      exchangeRate: serializer.fromJson<double?>(json['exchangeRate']),
      transactionStatus:
          serializer.fromJson<String?>(json['transactionStatus']),
      itemId: serializer.fromJson<String?>(json['itemId']),
      itemCode: serializer.fromJson<String>(json['itemCode']),
      upcCode: serializer.fromJson<String?>(json['upcCode']),
      description: serializer.fromJson<String>(json['description']),
      itemGroup: serializer.fromJson<String?>(json['itemGroup']),
      category: serializer.fromJson<String?>(json['category']),
      salesUOM: serializer.fromJson<String?>(json['salesUOM']),
      stockUOM: serializer.fromJson<String?>(json['stockUOM']),
      taxGroup: serializer.fromJson<String?>(json['taxGroup']),
      warehouse: serializer.fromJson<String?>(json['warehouse']),
      discountType: serializer.fromJson<String?>(json['discountType']),
      discountPercentage:
          serializer.fromJson<double?>(json['discountPercentage']),
      discountAmount: serializer.fromJson<double?>(json['discountAmount']),
      lineDiscountTotal:
          serializer.fromJson<double?>(json['lineDiscountTotal']),
      taxIndicator: serializer.fromJson<String?>(json['taxIndicator']),
      unitPrice: serializer.fromJson<double>(json['unitPrice']),
      costPrice: serializer.fromJson<double?>(json['costPrice']),
      listPrice: serializer.fromJson<double?>(json['listPrice']),
      quantity: serializer.fromJson<double>(json['quantity']),
      subTotal: serializer.fromJson<double>(json['subTotal']),
      grandTotal: serializer.fromJson<double>(json['grandTotal']),
      itemCount: serializer.fromJson<int?>(json['itemCount']),
      depositTotal: serializer.fromJson<double?>(json['depositTotal']),
      lineId: serializer.fromJson<int?>(json['lineId']),
      taxTotal: serializer.fromJson<double?>(json['taxTotal']),
      shippingTotal: serializer.fromJson<double>(json['shippingTotal']),
      conversionFactor: serializer.fromJson<double?>(json['conversionFactor']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'userName': serializer.toJson<String>(userName),
      'userId': serializer.toJson<int>(userId),
      'id': serializer.toJson<int>(id),
      'transactionNumber': serializer.toJson<String>(transactionNumber),
      'inventoryCycleNumber': serializer.toJson<String?>(inventoryCycleNumber),
      'daySessionNumber': serializer.toJson<String?>(daySessionNumber),
      'deliveryDate': serializer.toJson<DateTime?>(deliveryDate),
      'currency': serializer.toJson<String?>(currency),
      'exchangeRate': serializer.toJson<double?>(exchangeRate),
      'transactionStatus': serializer.toJson<String?>(transactionStatus),
      'itemId': serializer.toJson<String?>(itemId),
      'itemCode': serializer.toJson<String>(itemCode),
      'upcCode': serializer.toJson<String?>(upcCode),
      'description': serializer.toJson<String>(description),
      'itemGroup': serializer.toJson<String?>(itemGroup),
      'category': serializer.toJson<String?>(category),
      'salesUOM': serializer.toJson<String?>(salesUOM),
      'stockUOM': serializer.toJson<String?>(stockUOM),
      'taxGroup': serializer.toJson<String?>(taxGroup),
      'warehouse': serializer.toJson<String?>(warehouse),
      'discountType': serializer.toJson<String?>(discountType),
      'discountPercentage': serializer.toJson<double?>(discountPercentage),
      'discountAmount': serializer.toJson<double?>(discountAmount),
      'lineDiscountTotal': serializer.toJson<double?>(lineDiscountTotal),
      'taxIndicator': serializer.toJson<String?>(taxIndicator),
      'unitPrice': serializer.toJson<double>(unitPrice),
      'costPrice': serializer.toJson<double?>(costPrice),
      'listPrice': serializer.toJson<double?>(listPrice),
      'quantity': serializer.toJson<double>(quantity),
      'subTotal': serializer.toJson<double>(subTotal),
      'grandTotal': serializer.toJson<double>(grandTotal),
      'itemCount': serializer.toJson<int?>(itemCount),
      'depositTotal': serializer.toJson<double?>(depositTotal),
      'lineId': serializer.toJson<int?>(lineId),
      'taxTotal': serializer.toJson<double?>(taxTotal),
      'shippingTotal': serializer.toJson<double>(shippingTotal),
      'conversionFactor': serializer.toJson<double?>(conversionFactor),
    };
  }

  SalesOrderDetailTempData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          String? userName,
          int? userId,
          int? id,
          String? transactionNumber,
          Value<String?> inventoryCycleNumber = const Value.absent(),
          Value<String?> daySessionNumber = const Value.absent(),
          Value<DateTime?> deliveryDate = const Value.absent(),
          Value<String?> currency = const Value.absent(),
          Value<double?> exchangeRate = const Value.absent(),
          Value<String?> transactionStatus = const Value.absent(),
          Value<String?> itemId = const Value.absent(),
          String? itemCode,
          Value<String?> upcCode = const Value.absent(),
          String? description,
          Value<String?> itemGroup = const Value.absent(),
          Value<String?> category = const Value.absent(),
          Value<String?> salesUOM = const Value.absent(),
          Value<String?> stockUOM = const Value.absent(),
          Value<String?> taxGroup = const Value.absent(),
          Value<String?> warehouse = const Value.absent(),
          Value<String?> discountType = const Value.absent(),
          Value<double?> discountPercentage = const Value.absent(),
          Value<double?> discountAmount = const Value.absent(),
          Value<double?> lineDiscountTotal = const Value.absent(),
          Value<String?> taxIndicator = const Value.absent(),
          double? unitPrice,
          Value<double?> costPrice = const Value.absent(),
          Value<double?> listPrice = const Value.absent(),
          double? quantity,
          double? subTotal,
          double? grandTotal,
          Value<int?> itemCount = const Value.absent(),
          Value<double?> depositTotal = const Value.absent(),
          Value<int?> lineId = const Value.absent(),
          Value<double?> taxTotal = const Value.absent(),
          double? shippingTotal,
          Value<double?> conversionFactor = const Value.absent()}) =>
      SalesOrderDetailTempData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        userName: userName ?? this.userName,
        userId: userId ?? this.userId,
        id: id ?? this.id,
        transactionNumber: transactionNumber ?? this.transactionNumber,
        inventoryCycleNumber: inventoryCycleNumber.present
            ? inventoryCycleNumber.value
            : this.inventoryCycleNumber,
        daySessionNumber: daySessionNumber.present
            ? daySessionNumber.value
            : this.daySessionNumber,
        deliveryDate:
            deliveryDate.present ? deliveryDate.value : this.deliveryDate,
        currency: currency.present ? currency.value : this.currency,
        exchangeRate:
            exchangeRate.present ? exchangeRate.value : this.exchangeRate,
        transactionStatus: transactionStatus.present
            ? transactionStatus.value
            : this.transactionStatus,
        itemId: itemId.present ? itemId.value : this.itemId,
        itemCode: itemCode ?? this.itemCode,
        upcCode: upcCode.present ? upcCode.value : this.upcCode,
        description: description ?? this.description,
        itemGroup: itemGroup.present ? itemGroup.value : this.itemGroup,
        category: category.present ? category.value : this.category,
        salesUOM: salesUOM.present ? salesUOM.value : this.salesUOM,
        stockUOM: stockUOM.present ? stockUOM.value : this.stockUOM,
        taxGroup: taxGroup.present ? taxGroup.value : this.taxGroup,
        warehouse: warehouse.present ? warehouse.value : this.warehouse,
        discountType:
            discountType.present ? discountType.value : this.discountType,
        discountPercentage: discountPercentage.present
            ? discountPercentage.value
            : this.discountPercentage,
        discountAmount:
            discountAmount.present ? discountAmount.value : this.discountAmount,
        lineDiscountTotal: lineDiscountTotal.present
            ? lineDiscountTotal.value
            : this.lineDiscountTotal,
        taxIndicator:
            taxIndicator.present ? taxIndicator.value : this.taxIndicator,
        unitPrice: unitPrice ?? this.unitPrice,
        costPrice: costPrice.present ? costPrice.value : this.costPrice,
        listPrice: listPrice.present ? listPrice.value : this.listPrice,
        quantity: quantity ?? this.quantity,
        subTotal: subTotal ?? this.subTotal,
        grandTotal: grandTotal ?? this.grandTotal,
        itemCount: itemCount.present ? itemCount.value : this.itemCount,
        depositTotal:
            depositTotal.present ? depositTotal.value : this.depositTotal,
        lineId: lineId.present ? lineId.value : this.lineId,
        taxTotal: taxTotal.present ? taxTotal.value : this.taxTotal,
        shippingTotal: shippingTotal ?? this.shippingTotal,
        conversionFactor: conversionFactor.present
            ? conversionFactor.value
            : this.conversionFactor,
      );
  @override
  String toString() {
    return (StringBuffer('SalesOrderDetailTempData(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('upcCode: $upcCode, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('salesUOM: $salesUOM, ')
          ..write('stockUOM: $stockUOM, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('warehouse: $warehouse, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('lineDiscountTotal: $lineDiscountTotal, ')
          ..write('taxIndicator: $taxIndicator, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('costPrice: $costPrice, ')
          ..write('listPrice: $listPrice, ')
          ..write('quantity: $quantity, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('lineId: $lineId, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('conversionFactor: $conversionFactor')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        inventoryCycleNumber,
        daySessionNumber,
        deliveryDate,
        currency,
        exchangeRate,
        transactionStatus,
        itemId,
        itemCode,
        upcCode,
        description,
        itemGroup,
        category,
        salesUOM,
        stockUOM,
        taxGroup,
        warehouse,
        discountType,
        discountPercentage,
        discountAmount,
        lineDiscountTotal,
        taxIndicator,
        unitPrice,
        costPrice,
        listPrice,
        quantity,
        subTotal,
        grandTotal,
        itemCount,
        depositTotal,
        lineId,
        taxTotal,
        shippingTotal,
        conversionFactor
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesOrderDetailTempData &&
          other.tenantId == this.tenantId &&
          other.userName == this.userName &&
          other.userId == this.userId &&
          other.id == this.id &&
          other.transactionNumber == this.transactionNumber &&
          other.inventoryCycleNumber == this.inventoryCycleNumber &&
          other.daySessionNumber == this.daySessionNumber &&
          other.deliveryDate == this.deliveryDate &&
          other.currency == this.currency &&
          other.exchangeRate == this.exchangeRate &&
          other.transactionStatus == this.transactionStatus &&
          other.itemId == this.itemId &&
          other.itemCode == this.itemCode &&
          other.upcCode == this.upcCode &&
          other.description == this.description &&
          other.itemGroup == this.itemGroup &&
          other.category == this.category &&
          other.salesUOM == this.salesUOM &&
          other.stockUOM == this.stockUOM &&
          other.taxGroup == this.taxGroup &&
          other.warehouse == this.warehouse &&
          other.discountType == this.discountType &&
          other.discountPercentage == this.discountPercentage &&
          other.discountAmount == this.discountAmount &&
          other.lineDiscountTotal == this.lineDiscountTotal &&
          other.taxIndicator == this.taxIndicator &&
          other.unitPrice == this.unitPrice &&
          other.costPrice == this.costPrice &&
          other.listPrice == this.listPrice &&
          other.quantity == this.quantity &&
          other.subTotal == this.subTotal &&
          other.grandTotal == this.grandTotal &&
          other.itemCount == this.itemCount &&
          other.depositTotal == this.depositTotal &&
          other.lineId == this.lineId &&
          other.taxTotal == this.taxTotal &&
          other.shippingTotal == this.shippingTotal &&
          other.conversionFactor == this.conversionFactor);
}

class SalesOrderDetailTempCompanion
    extends UpdateCompanion<SalesOrderDetailTempData> {
  final Value<String?> tenantId;
  final Value<String> userName;
  final Value<int> userId;
  final Value<int> id;
  final Value<String> transactionNumber;
  final Value<String?> inventoryCycleNumber;
  final Value<String?> daySessionNumber;
  final Value<DateTime?> deliveryDate;
  final Value<String?> currency;
  final Value<double?> exchangeRate;
  final Value<String?> transactionStatus;
  final Value<String?> itemId;
  final Value<String> itemCode;
  final Value<String?> upcCode;
  final Value<String> description;
  final Value<String?> itemGroup;
  final Value<String?> category;
  final Value<String?> salesUOM;
  final Value<String?> stockUOM;
  final Value<String?> taxGroup;
  final Value<String?> warehouse;
  final Value<String?> discountType;
  final Value<double?> discountPercentage;
  final Value<double?> discountAmount;
  final Value<double?> lineDiscountTotal;
  final Value<String?> taxIndicator;
  final Value<double> unitPrice;
  final Value<double?> costPrice;
  final Value<double?> listPrice;
  final Value<double> quantity;
  final Value<double> subTotal;
  final Value<double> grandTotal;
  final Value<int?> itemCount;
  final Value<double?> depositTotal;
  final Value<int?> lineId;
  final Value<double?> taxTotal;
  final Value<double> shippingTotal;
  final Value<double?> conversionFactor;
  const SalesOrderDetailTempCompanion({
    this.tenantId = const Value.absent(),
    this.userName = const Value.absent(),
    this.userId = const Value.absent(),
    this.id = const Value.absent(),
    this.transactionNumber = const Value.absent(),
    this.inventoryCycleNumber = const Value.absent(),
    this.daySessionNumber = const Value.absent(),
    this.deliveryDate = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.itemId = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.upcCode = const Value.absent(),
    this.description = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.category = const Value.absent(),
    this.salesUOM = const Value.absent(),
    this.stockUOM = const Value.absent(),
    this.taxGroup = const Value.absent(),
    this.warehouse = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.lineDiscountTotal = const Value.absent(),
    this.taxIndicator = const Value.absent(),
    this.unitPrice = const Value.absent(),
    this.costPrice = const Value.absent(),
    this.listPrice = const Value.absent(),
    this.quantity = const Value.absent(),
    this.subTotal = const Value.absent(),
    this.grandTotal = const Value.absent(),
    this.itemCount = const Value.absent(),
    this.depositTotal = const Value.absent(),
    this.lineId = const Value.absent(),
    this.taxTotal = const Value.absent(),
    this.shippingTotal = const Value.absent(),
    this.conversionFactor = const Value.absent(),
  });
  SalesOrderDetailTempCompanion.insert({
    this.tenantId = const Value.absent(),
    required String userName,
    required int userId,
    this.id = const Value.absent(),
    required String transactionNumber,
    this.inventoryCycleNumber = const Value.absent(),
    this.daySessionNumber = const Value.absent(),
    this.deliveryDate = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.itemId = const Value.absent(),
    required String itemCode,
    this.upcCode = const Value.absent(),
    required String description,
    this.itemGroup = const Value.absent(),
    this.category = const Value.absent(),
    this.salesUOM = const Value.absent(),
    this.stockUOM = const Value.absent(),
    this.taxGroup = const Value.absent(),
    this.warehouse = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.lineDiscountTotal = const Value.absent(),
    this.taxIndicator = const Value.absent(),
    required double unitPrice,
    this.costPrice = const Value.absent(),
    this.listPrice = const Value.absent(),
    required double quantity,
    required double subTotal,
    required double grandTotal,
    this.itemCount = const Value.absent(),
    this.depositTotal = const Value.absent(),
    this.lineId = const Value.absent(),
    this.taxTotal = const Value.absent(),
    required double shippingTotal,
    this.conversionFactor = const Value.absent(),
  })  : userName = Value(userName),
        userId = Value(userId),
        transactionNumber = Value(transactionNumber),
        itemCode = Value(itemCode),
        description = Value(description),
        unitPrice = Value(unitPrice),
        quantity = Value(quantity),
        subTotal = Value(subTotal),
        grandTotal = Value(grandTotal),
        shippingTotal = Value(shippingTotal);
  static Insertable<SalesOrderDetailTempData> custom({
    Expression<String>? tenantId,
    Expression<String>? userName,
    Expression<int>? userId,
    Expression<int>? id,
    Expression<String>? transactionNumber,
    Expression<String>? inventoryCycleNumber,
    Expression<String>? daySessionNumber,
    Expression<DateTime>? deliveryDate,
    Expression<String>? currency,
    Expression<double>? exchangeRate,
    Expression<String>? transactionStatus,
    Expression<String>? itemId,
    Expression<String>? itemCode,
    Expression<String>? upcCode,
    Expression<String>? description,
    Expression<String>? itemGroup,
    Expression<String>? category,
    Expression<String>? salesUOM,
    Expression<String>? stockUOM,
    Expression<String>? taxGroup,
    Expression<String>? warehouse,
    Expression<String>? discountType,
    Expression<double>? discountPercentage,
    Expression<double>? discountAmount,
    Expression<double>? lineDiscountTotal,
    Expression<String>? taxIndicator,
    Expression<double>? unitPrice,
    Expression<double>? costPrice,
    Expression<double>? listPrice,
    Expression<double>? quantity,
    Expression<double>? subTotal,
    Expression<double>? grandTotal,
    Expression<int>? itemCount,
    Expression<double>? depositTotal,
    Expression<int>? lineId,
    Expression<double>? taxTotal,
    Expression<double>? shippingTotal,
    Expression<double>? conversionFactor,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (userName != null) 'user_name': userName,
      if (userId != null) 'user_id': userId,
      if (id != null) 'id': id,
      if (transactionNumber != null) 'transaction_number': transactionNumber,
      if (inventoryCycleNumber != null)
        'inventory_cycle_number': inventoryCycleNumber,
      if (daySessionNumber != null) 'day_session_number': daySessionNumber,
      if (deliveryDate != null) 'delivery_date': deliveryDate,
      if (currency != null) 'currency': currency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (transactionStatus != null) 'transaction_status': transactionStatus,
      if (itemId != null) 'item_id': itemId,
      if (itemCode != null) 'item_code': itemCode,
      if (upcCode != null) 'upc_code': upcCode,
      if (description != null) 'description': description,
      if (itemGroup != null) 'item_group': itemGroup,
      if (category != null) 'category': category,
      if (salesUOM != null) 'sales_u_o_m': salesUOM,
      if (stockUOM != null) 'stock_u_o_m': stockUOM,
      if (taxGroup != null) 'tax_group': taxGroup,
      if (warehouse != null) 'warehouse': warehouse,
      if (discountType != null) 'discount_type': discountType,
      if (discountPercentage != null) 'discount_percentage': discountPercentage,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (lineDiscountTotal != null) 'line_discount_total': lineDiscountTotal,
      if (taxIndicator != null) 'tax_indicator': taxIndicator,
      if (unitPrice != null) 'unit_price': unitPrice,
      if (costPrice != null) 'cost_price': costPrice,
      if (listPrice != null) 'list_price': listPrice,
      if (quantity != null) 'quantity': quantity,
      if (subTotal != null) 'sub_total': subTotal,
      if (grandTotal != null) 'grand_total': grandTotal,
      if (itemCount != null) 'item_count': itemCount,
      if (depositTotal != null) 'deposit_total': depositTotal,
      if (lineId != null) 'line_id': lineId,
      if (taxTotal != null) 'tax_total': taxTotal,
      if (shippingTotal != null) 'shipping_total': shippingTotal,
      if (conversionFactor != null) 'conversion_factor': conversionFactor,
    });
  }

  SalesOrderDetailTempCompanion copyWith(
      {Value<String?>? tenantId,
      Value<String>? userName,
      Value<int>? userId,
      Value<int>? id,
      Value<String>? transactionNumber,
      Value<String?>? inventoryCycleNumber,
      Value<String?>? daySessionNumber,
      Value<DateTime?>? deliveryDate,
      Value<String?>? currency,
      Value<double?>? exchangeRate,
      Value<String?>? transactionStatus,
      Value<String?>? itemId,
      Value<String>? itemCode,
      Value<String?>? upcCode,
      Value<String>? description,
      Value<String?>? itemGroup,
      Value<String?>? category,
      Value<String?>? salesUOM,
      Value<String?>? stockUOM,
      Value<String?>? taxGroup,
      Value<String?>? warehouse,
      Value<String?>? discountType,
      Value<double?>? discountPercentage,
      Value<double?>? discountAmount,
      Value<double?>? lineDiscountTotal,
      Value<String?>? taxIndicator,
      Value<double>? unitPrice,
      Value<double?>? costPrice,
      Value<double?>? listPrice,
      Value<double>? quantity,
      Value<double>? subTotal,
      Value<double>? grandTotal,
      Value<int?>? itemCount,
      Value<double?>? depositTotal,
      Value<int?>? lineId,
      Value<double?>? taxTotal,
      Value<double>? shippingTotal,
      Value<double?>? conversionFactor}) {
    return SalesOrderDetailTempCompanion(
      tenantId: tenantId ?? this.tenantId,
      userName: userName ?? this.userName,
      userId: userId ?? this.userId,
      id: id ?? this.id,
      transactionNumber: transactionNumber ?? this.transactionNumber,
      inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
      daySessionNumber: daySessionNumber ?? this.daySessionNumber,
      deliveryDate: deliveryDate ?? this.deliveryDate,
      currency: currency ?? this.currency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      transactionStatus: transactionStatus ?? this.transactionStatus,
      itemId: itemId ?? this.itemId,
      itemCode: itemCode ?? this.itemCode,
      upcCode: upcCode ?? this.upcCode,
      description: description ?? this.description,
      itemGroup: itemGroup ?? this.itemGroup,
      category: category ?? this.category,
      salesUOM: salesUOM ?? this.salesUOM,
      stockUOM: stockUOM ?? this.stockUOM,
      taxGroup: taxGroup ?? this.taxGroup,
      warehouse: warehouse ?? this.warehouse,
      discountType: discountType ?? this.discountType,
      discountPercentage: discountPercentage ?? this.discountPercentage,
      discountAmount: discountAmount ?? this.discountAmount,
      lineDiscountTotal: lineDiscountTotal ?? this.lineDiscountTotal,
      taxIndicator: taxIndicator ?? this.taxIndicator,
      unitPrice: unitPrice ?? this.unitPrice,
      costPrice: costPrice ?? this.costPrice,
      listPrice: listPrice ?? this.listPrice,
      quantity: quantity ?? this.quantity,
      subTotal: subTotal ?? this.subTotal,
      grandTotal: grandTotal ?? this.grandTotal,
      itemCount: itemCount ?? this.itemCount,
      depositTotal: depositTotal ?? this.depositTotal,
      lineId: lineId ?? this.lineId,
      taxTotal: taxTotal ?? this.taxTotal,
      shippingTotal: shippingTotal ?? this.shippingTotal,
      conversionFactor: conversionFactor ?? this.conversionFactor,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (transactionNumber.present) {
      map['transaction_number'] = Variable<String>(transactionNumber.value);
    }
    if (inventoryCycleNumber.present) {
      map['inventory_cycle_number'] =
          Variable<String>(inventoryCycleNumber.value);
    }
    if (daySessionNumber.present) {
      map['day_session_number'] = Variable<String>(daySessionNumber.value);
    }
    if (deliveryDate.present) {
      map['delivery_date'] = Variable<DateTime>(deliveryDate.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (transactionStatus.present) {
      map['transaction_status'] = Variable<String>(transactionStatus.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (upcCode.present) {
      map['upc_code'] = Variable<String>(upcCode.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (itemGroup.present) {
      map['item_group'] = Variable<String>(itemGroup.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (salesUOM.present) {
      map['sales_u_o_m'] = Variable<String>(salesUOM.value);
    }
    if (stockUOM.present) {
      map['stock_u_o_m'] = Variable<String>(stockUOM.value);
    }
    if (taxGroup.present) {
      map['tax_group'] = Variable<String>(taxGroup.value);
    }
    if (warehouse.present) {
      map['warehouse'] = Variable<String>(warehouse.value);
    }
    if (discountType.present) {
      map['discount_type'] = Variable<String>(discountType.value);
    }
    if (discountPercentage.present) {
      map['discount_percentage'] = Variable<double>(discountPercentage.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (lineDiscountTotal.present) {
      map['line_discount_total'] = Variable<double>(lineDiscountTotal.value);
    }
    if (taxIndicator.present) {
      map['tax_indicator'] = Variable<String>(taxIndicator.value);
    }
    if (unitPrice.present) {
      map['unit_price'] = Variable<double>(unitPrice.value);
    }
    if (costPrice.present) {
      map['cost_price'] = Variable<double>(costPrice.value);
    }
    if (listPrice.present) {
      map['list_price'] = Variable<double>(listPrice.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (subTotal.present) {
      map['sub_total'] = Variable<double>(subTotal.value);
    }
    if (grandTotal.present) {
      map['grand_total'] = Variable<double>(grandTotal.value);
    }
    if (itemCount.present) {
      map['item_count'] = Variable<int>(itemCount.value);
    }
    if (depositTotal.present) {
      map['deposit_total'] = Variable<double>(depositTotal.value);
    }
    if (lineId.present) {
      map['line_id'] = Variable<int>(lineId.value);
    }
    if (taxTotal.present) {
      map['tax_total'] = Variable<double>(taxTotal.value);
    }
    if (shippingTotal.present) {
      map['shipping_total'] = Variable<double>(shippingTotal.value);
    }
    if (conversionFactor.present) {
      map['conversion_factor'] = Variable<double>(conversionFactor.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesOrderDetailTempCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('upcCode: $upcCode, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('salesUOM: $salesUOM, ')
          ..write('stockUOM: $stockUOM, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('warehouse: $warehouse, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('lineDiscountTotal: $lineDiscountTotal, ')
          ..write('taxIndicator: $taxIndicator, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('costPrice: $costPrice, ')
          ..write('listPrice: $listPrice, ')
          ..write('quantity: $quantity, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('lineId: $lineId, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('conversionFactor: $conversionFactor')
          ..write(')'))
        .toString();
  }
}

class $SeriesNumberGeneratorTable extends SeriesNumberGenerator
    with TableInfo<$SeriesNumberGeneratorTable, SeriesNumberGeneratorData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SeriesNumberGeneratorTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _numberPrefixMeta =
      const VerificationMeta('numberPrefix');
  @override
  late final GeneratedColumn<String> numberPrefix = GeneratedColumn<String>(
      'number_prefix', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _includePrefixMeta =
      const VerificationMeta('includePrefix');
  @override
  late final GeneratedColumn<bool> includePrefix = GeneratedColumn<bool>(
      'include_prefix', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("include_prefix" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _includeJulianDateMeta =
      const VerificationMeta('includeJulianDate');
  @override
  late final GeneratedColumn<bool> includeJulianDate = GeneratedColumn<bool>(
      'include_julian_date', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("include_julian_date" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _includeUserIDMeta =
      const VerificationMeta('includeUserID');
  @override
  late final GeneratedColumn<bool> includeUserID = GeneratedColumn<bool>(
      'include_user_i_d', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("include_user_i_d" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _includeTenantIdMeta =
      const VerificationMeta('includeTenantId');
  @override
  late final GeneratedColumn<bool> includeTenantId = GeneratedColumn<bool>(
      'include_tenant_id', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("include_tenant_id" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _usedAutoNumberMeta =
      const VerificationMeta('usedAutoNumber');
  @override
  late final GeneratedColumn<bool> usedAutoNumber = GeneratedColumn<bool>(
      'used_auto_number', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("used_auto_number" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _endingLengthMeta =
      const VerificationMeta('endingLength');
  @override
  late final GeneratedColumn<int> endingLength = GeneratedColumn<int>(
      'ending_length', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _typeOfNumberMeta =
      const VerificationMeta('typeOfNumber');
  @override
  late final GeneratedColumn<String> typeOfNumber = GeneratedColumn<String>(
      'type_of_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        numberPrefix,
        includePrefix,
        includeJulianDate,
        includeUserID,
        includeTenantId,
        usedAutoNumber,
        endingLength,
        typeOfNumber
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'series_number_generator';
  @override
  VerificationContext validateIntegrity(
      Insertable<SeriesNumberGeneratorData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('number_prefix')) {
      context.handle(
          _numberPrefixMeta,
          numberPrefix.isAcceptableOrUnknown(
              data['number_prefix']!, _numberPrefixMeta));
    }
    if (data.containsKey('include_prefix')) {
      context.handle(
          _includePrefixMeta,
          includePrefix.isAcceptableOrUnknown(
              data['include_prefix']!, _includePrefixMeta));
    }
    if (data.containsKey('include_julian_date')) {
      context.handle(
          _includeJulianDateMeta,
          includeJulianDate.isAcceptableOrUnknown(
              data['include_julian_date']!, _includeJulianDateMeta));
    }
    if (data.containsKey('include_user_i_d')) {
      context.handle(
          _includeUserIDMeta,
          includeUserID.isAcceptableOrUnknown(
              data['include_user_i_d']!, _includeUserIDMeta));
    }
    if (data.containsKey('include_tenant_id')) {
      context.handle(
          _includeTenantIdMeta,
          includeTenantId.isAcceptableOrUnknown(
              data['include_tenant_id']!, _includeTenantIdMeta));
    }
    if (data.containsKey('used_auto_number')) {
      context.handle(
          _usedAutoNumberMeta,
          usedAutoNumber.isAcceptableOrUnknown(
              data['used_auto_number']!, _usedAutoNumberMeta));
    }
    if (data.containsKey('ending_length')) {
      context.handle(
          _endingLengthMeta,
          endingLength.isAcceptableOrUnknown(
              data['ending_length']!, _endingLengthMeta));
    }
    if (data.containsKey('type_of_number')) {
      context.handle(
          _typeOfNumberMeta,
          typeOfNumber.isAcceptableOrUnknown(
              data['type_of_number']!, _typeOfNumberMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SeriesNumberGeneratorData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SeriesNumberGeneratorData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      numberPrefix: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}number_prefix']),
      includePrefix: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}include_prefix'])!,
      includeJulianDate: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}include_julian_date'])!,
      includeUserID: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}include_user_i_d'])!,
      includeTenantId: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}include_tenant_id'])!,
      usedAutoNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}used_auto_number'])!,
      endingLength: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}ending_length']),
      typeOfNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type_of_number']),
    );
  }

  @override
  $SeriesNumberGeneratorTable createAlias(String alias) {
    return $SeriesNumberGeneratorTable(attachedDatabase, alias);
  }
}

class SeriesNumberGeneratorData extends DataClass
    implements Insertable<SeriesNumberGeneratorData> {
  final String? tenantId;
  final int id;
  final String? numberPrefix;
  final bool includePrefix;
  final bool includeJulianDate;
  final bool includeUserID;
  final bool includeTenantId;
  final bool usedAutoNumber;
  final int? endingLength;
  final String? typeOfNumber;
  const SeriesNumberGeneratorData(
      {this.tenantId,
      required this.id,
      this.numberPrefix,
      required this.includePrefix,
      required this.includeJulianDate,
      required this.includeUserID,
      required this.includeTenantId,
      required this.usedAutoNumber,
      this.endingLength,
      this.typeOfNumber});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || numberPrefix != null) {
      map['number_prefix'] = Variable<String>(numberPrefix);
    }
    map['include_prefix'] = Variable<bool>(includePrefix);
    map['include_julian_date'] = Variable<bool>(includeJulianDate);
    map['include_user_i_d'] = Variable<bool>(includeUserID);
    map['include_tenant_id'] = Variable<bool>(includeTenantId);
    map['used_auto_number'] = Variable<bool>(usedAutoNumber);
    if (!nullToAbsent || endingLength != null) {
      map['ending_length'] = Variable<int>(endingLength);
    }
    if (!nullToAbsent || typeOfNumber != null) {
      map['type_of_number'] = Variable<String>(typeOfNumber);
    }
    return map;
  }

  SeriesNumberGeneratorCompanion toCompanion(bool nullToAbsent) {
    return SeriesNumberGeneratorCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      numberPrefix: numberPrefix == null && nullToAbsent
          ? const Value.absent()
          : Value(numberPrefix),
      includePrefix: Value(includePrefix),
      includeJulianDate: Value(includeJulianDate),
      includeUserID: Value(includeUserID),
      includeTenantId: Value(includeTenantId),
      usedAutoNumber: Value(usedAutoNumber),
      endingLength: endingLength == null && nullToAbsent
          ? const Value.absent()
          : Value(endingLength),
      typeOfNumber: typeOfNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(typeOfNumber),
    );
  }

  factory SeriesNumberGeneratorData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SeriesNumberGeneratorData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      numberPrefix: serializer.fromJson<String?>(json['numberPrefix']),
      includePrefix: serializer.fromJson<bool>(json['includePrefix']),
      includeJulianDate: serializer.fromJson<bool>(json['includeJulianDate']),
      includeUserID: serializer.fromJson<bool>(json['includeUserID']),
      includeTenantId: serializer.fromJson<bool>(json['includeTenantId']),
      usedAutoNumber: serializer.fromJson<bool>(json['usedAutoNumber']),
      endingLength: serializer.fromJson<int?>(json['endingLength']),
      typeOfNumber: serializer.fromJson<String?>(json['typeOfNumber']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'numberPrefix': serializer.toJson<String?>(numberPrefix),
      'includePrefix': serializer.toJson<bool>(includePrefix),
      'includeJulianDate': serializer.toJson<bool>(includeJulianDate),
      'includeUserID': serializer.toJson<bool>(includeUserID),
      'includeTenantId': serializer.toJson<bool>(includeTenantId),
      'usedAutoNumber': serializer.toJson<bool>(usedAutoNumber),
      'endingLength': serializer.toJson<int?>(endingLength),
      'typeOfNumber': serializer.toJson<String?>(typeOfNumber),
    };
  }

  SeriesNumberGeneratorData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> numberPrefix = const Value.absent(),
          bool? includePrefix,
          bool? includeJulianDate,
          bool? includeUserID,
          bool? includeTenantId,
          bool? usedAutoNumber,
          Value<int?> endingLength = const Value.absent(),
          Value<String?> typeOfNumber = const Value.absent()}) =>
      SeriesNumberGeneratorData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        numberPrefix:
            numberPrefix.present ? numberPrefix.value : this.numberPrefix,
        includePrefix: includePrefix ?? this.includePrefix,
        includeJulianDate: includeJulianDate ?? this.includeJulianDate,
        includeUserID: includeUserID ?? this.includeUserID,
        includeTenantId: includeTenantId ?? this.includeTenantId,
        usedAutoNumber: usedAutoNumber ?? this.usedAutoNumber,
        endingLength:
            endingLength.present ? endingLength.value : this.endingLength,
        typeOfNumber:
            typeOfNumber.present ? typeOfNumber.value : this.typeOfNumber,
      );
  @override
  String toString() {
    return (StringBuffer('SeriesNumberGeneratorData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('numberPrefix: $numberPrefix, ')
          ..write('includePrefix: $includePrefix, ')
          ..write('includeJulianDate: $includeJulianDate, ')
          ..write('includeUserID: $includeUserID, ')
          ..write('includeTenantId: $includeTenantId, ')
          ..write('usedAutoNumber: $usedAutoNumber, ')
          ..write('endingLength: $endingLength, ')
          ..write('typeOfNumber: $typeOfNumber')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      numberPrefix,
      includePrefix,
      includeJulianDate,
      includeUserID,
      includeTenantId,
      usedAutoNumber,
      endingLength,
      typeOfNumber);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SeriesNumberGeneratorData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.numberPrefix == this.numberPrefix &&
          other.includePrefix == this.includePrefix &&
          other.includeJulianDate == this.includeJulianDate &&
          other.includeUserID == this.includeUserID &&
          other.includeTenantId == this.includeTenantId &&
          other.usedAutoNumber == this.usedAutoNumber &&
          other.endingLength == this.endingLength &&
          other.typeOfNumber == this.typeOfNumber);
}

class SeriesNumberGeneratorCompanion
    extends UpdateCompanion<SeriesNumberGeneratorData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> numberPrefix;
  final Value<bool> includePrefix;
  final Value<bool> includeJulianDate;
  final Value<bool> includeUserID;
  final Value<bool> includeTenantId;
  final Value<bool> usedAutoNumber;
  final Value<int?> endingLength;
  final Value<String?> typeOfNumber;
  const SeriesNumberGeneratorCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.numberPrefix = const Value.absent(),
    this.includePrefix = const Value.absent(),
    this.includeJulianDate = const Value.absent(),
    this.includeUserID = const Value.absent(),
    this.includeTenantId = const Value.absent(),
    this.usedAutoNumber = const Value.absent(),
    this.endingLength = const Value.absent(),
    this.typeOfNumber = const Value.absent(),
  });
  SeriesNumberGeneratorCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.numberPrefix = const Value.absent(),
    this.includePrefix = const Value.absent(),
    this.includeJulianDate = const Value.absent(),
    this.includeUserID = const Value.absent(),
    this.includeTenantId = const Value.absent(),
    this.usedAutoNumber = const Value.absent(),
    this.endingLength = const Value.absent(),
    this.typeOfNumber = const Value.absent(),
  });
  static Insertable<SeriesNumberGeneratorData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? numberPrefix,
    Expression<bool>? includePrefix,
    Expression<bool>? includeJulianDate,
    Expression<bool>? includeUserID,
    Expression<bool>? includeTenantId,
    Expression<bool>? usedAutoNumber,
    Expression<int>? endingLength,
    Expression<String>? typeOfNumber,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (numberPrefix != null) 'number_prefix': numberPrefix,
      if (includePrefix != null) 'include_prefix': includePrefix,
      if (includeJulianDate != null) 'include_julian_date': includeJulianDate,
      if (includeUserID != null) 'include_user_i_d': includeUserID,
      if (includeTenantId != null) 'include_tenant_id': includeTenantId,
      if (usedAutoNumber != null) 'used_auto_number': usedAutoNumber,
      if (endingLength != null) 'ending_length': endingLength,
      if (typeOfNumber != null) 'type_of_number': typeOfNumber,
    });
  }

  SeriesNumberGeneratorCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? numberPrefix,
      Value<bool>? includePrefix,
      Value<bool>? includeJulianDate,
      Value<bool>? includeUserID,
      Value<bool>? includeTenantId,
      Value<bool>? usedAutoNumber,
      Value<int?>? endingLength,
      Value<String?>? typeOfNumber}) {
    return SeriesNumberGeneratorCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      numberPrefix: numberPrefix ?? this.numberPrefix,
      includePrefix: includePrefix ?? this.includePrefix,
      includeJulianDate: includeJulianDate ?? this.includeJulianDate,
      includeUserID: includeUserID ?? this.includeUserID,
      includeTenantId: includeTenantId ?? this.includeTenantId,
      usedAutoNumber: usedAutoNumber ?? this.usedAutoNumber,
      endingLength: endingLength ?? this.endingLength,
      typeOfNumber: typeOfNumber ?? this.typeOfNumber,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (numberPrefix.present) {
      map['number_prefix'] = Variable<String>(numberPrefix.value);
    }
    if (includePrefix.present) {
      map['include_prefix'] = Variable<bool>(includePrefix.value);
    }
    if (includeJulianDate.present) {
      map['include_julian_date'] = Variable<bool>(includeJulianDate.value);
    }
    if (includeUserID.present) {
      map['include_user_i_d'] = Variable<bool>(includeUserID.value);
    }
    if (includeTenantId.present) {
      map['include_tenant_id'] = Variable<bool>(includeTenantId.value);
    }
    if (usedAutoNumber.present) {
      map['used_auto_number'] = Variable<bool>(usedAutoNumber.value);
    }
    if (endingLength.present) {
      map['ending_length'] = Variable<int>(endingLength.value);
    }
    if (typeOfNumber.present) {
      map['type_of_number'] = Variable<String>(typeOfNumber.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SeriesNumberGeneratorCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('numberPrefix: $numberPrefix, ')
          ..write('includePrefix: $includePrefix, ')
          ..write('includeJulianDate: $includeJulianDate, ')
          ..write('includeUserID: $includeUserID, ')
          ..write('includeTenantId: $includeTenantId, ')
          ..write('usedAutoNumber: $usedAutoNumber, ')
          ..write('endingLength: $endingLength, ')
          ..write('typeOfNumber: $typeOfNumber')
          ..write(')'))
        .toString();
  }
}

class $SalesTaxTable extends SalesTax
    with TableInfo<$SalesTaxTable, SalesTaxData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SalesTaxTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _taxAccountMeta =
      const VerificationMeta('taxAccount');
  @override
  late final GeneratedColumn<String> taxAccount = GeneratedColumn<String>(
      'tax_account', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _accountRateMeta =
      const VerificationMeta('accountRate');
  @override
  late final GeneratedColumn<double> accountRate = GeneratedColumn<double>(
      'account_rate', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _effectiveDateMeta =
      const VerificationMeta('effectiveDate');
  @override
  late final GeneratedColumn<DateTime> effectiveDate =
      GeneratedColumn<DateTime>('effective_date', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
      'amount', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _taxIndicatorMeta =
      const VerificationMeta('taxIndicator');
  @override
  late final GeneratedColumn<String> taxIndicator = GeneratedColumn<String>(
      'tax_indicator', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        type,
        taxAccount,
        accountRate,
        effectiveDate,
        amount,
        taxIndicator
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sales_tax';
  @override
  VerificationContext validateIntegrity(Insertable<SalesTaxData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('tax_account')) {
      context.handle(
          _taxAccountMeta,
          taxAccount.isAcceptableOrUnknown(
              data['tax_account']!, _taxAccountMeta));
    }
    if (data.containsKey('account_rate')) {
      context.handle(
          _accountRateMeta,
          accountRate.isAcceptableOrUnknown(
              data['account_rate']!, _accountRateMeta));
    }
    if (data.containsKey('effective_date')) {
      context.handle(
          _effectiveDateMeta,
          effectiveDate.isAcceptableOrUnknown(
              data['effective_date']!, _effectiveDateMeta));
    } else if (isInserting) {
      context.missing(_effectiveDateMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(_amountMeta,
          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
    }
    if (data.containsKey('tax_indicator')) {
      context.handle(
          _taxIndicatorMeta,
          taxIndicator.isAcceptableOrUnknown(
              data['tax_indicator']!, _taxIndicatorMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SalesTaxData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SalesTaxData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      taxAccount: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tax_account']),
      accountRate: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}account_rate']),
      effectiveDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}effective_date'])!,
      amount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}amount']),
      taxIndicator: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tax_indicator']),
    );
  }

  @override
  $SalesTaxTable createAlias(String alias) {
    return $SalesTaxTable(attachedDatabase, alias);
  }
}

class SalesTaxData extends DataClass implements Insertable<SalesTaxData> {
  final String? tenantId;
  final int id;
  final String? type;
  final String? taxAccount;
  final double? accountRate;
  final DateTime effectiveDate;
  final double? amount;
  final String? taxIndicator;
  const SalesTaxData(
      {this.tenantId,
      required this.id,
      this.type,
      this.taxAccount,
      this.accountRate,
      required this.effectiveDate,
      this.amount,
      this.taxIndicator});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || taxAccount != null) {
      map['tax_account'] = Variable<String>(taxAccount);
    }
    if (!nullToAbsent || accountRate != null) {
      map['account_rate'] = Variable<double>(accountRate);
    }
    map['effective_date'] = Variable<DateTime>(effectiveDate);
    if (!nullToAbsent || amount != null) {
      map['amount'] = Variable<double>(amount);
    }
    if (!nullToAbsent || taxIndicator != null) {
      map['tax_indicator'] = Variable<String>(taxIndicator);
    }
    return map;
  }

  SalesTaxCompanion toCompanion(bool nullToAbsent) {
    return SalesTaxCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      taxAccount: taxAccount == null && nullToAbsent
          ? const Value.absent()
          : Value(taxAccount),
      accountRate: accountRate == null && nullToAbsent
          ? const Value.absent()
          : Value(accountRate),
      effectiveDate: Value(effectiveDate),
      amount:
          amount == null && nullToAbsent ? const Value.absent() : Value(amount),
      taxIndicator: taxIndicator == null && nullToAbsent
          ? const Value.absent()
          : Value(taxIndicator),
    );
  }

  factory SalesTaxData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesTaxData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      type: serializer.fromJson<String?>(json['type']),
      taxAccount: serializer.fromJson<String?>(json['taxAccount']),
      accountRate: serializer.fromJson<double?>(json['accountRate']),
      effectiveDate: serializer.fromJson<DateTime>(json['effectiveDate']),
      amount: serializer.fromJson<double?>(json['amount']),
      taxIndicator: serializer.fromJson<String?>(json['taxIndicator']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'type': serializer.toJson<String?>(type),
      'taxAccount': serializer.toJson<String?>(taxAccount),
      'accountRate': serializer.toJson<double?>(accountRate),
      'effectiveDate': serializer.toJson<DateTime>(effectiveDate),
      'amount': serializer.toJson<double?>(amount),
      'taxIndicator': serializer.toJson<String?>(taxIndicator),
    };
  }

  SalesTaxData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> type = const Value.absent(),
          Value<String?> taxAccount = const Value.absent(),
          Value<double?> accountRate = const Value.absent(),
          DateTime? effectiveDate,
          Value<double?> amount = const Value.absent(),
          Value<String?> taxIndicator = const Value.absent()}) =>
      SalesTaxData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        type: type.present ? type.value : this.type,
        taxAccount: taxAccount.present ? taxAccount.value : this.taxAccount,
        accountRate: accountRate.present ? accountRate.value : this.accountRate,
        effectiveDate: effectiveDate ?? this.effectiveDate,
        amount: amount.present ? amount.value : this.amount,
        taxIndicator:
            taxIndicator.present ? taxIndicator.value : this.taxIndicator,
      );
  @override
  String toString() {
    return (StringBuffer('SalesTaxData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('taxAccount: $taxAccount, ')
          ..write('accountRate: $accountRate, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('amount: $amount, ')
          ..write('taxIndicator: $taxIndicator')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, type, taxAccount, accountRate,
      effectiveDate, amount, taxIndicator);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesTaxData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.type == this.type &&
          other.taxAccount == this.taxAccount &&
          other.accountRate == this.accountRate &&
          other.effectiveDate == this.effectiveDate &&
          other.amount == this.amount &&
          other.taxIndicator == this.taxIndicator);
}

class SalesTaxCompanion extends UpdateCompanion<SalesTaxData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> type;
  final Value<String?> taxAccount;
  final Value<double?> accountRate;
  final Value<DateTime> effectiveDate;
  final Value<double?> amount;
  final Value<String?> taxIndicator;
  const SalesTaxCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.taxAccount = const Value.absent(),
    this.accountRate = const Value.absent(),
    this.effectiveDate = const Value.absent(),
    this.amount = const Value.absent(),
    this.taxIndicator = const Value.absent(),
  });
  SalesTaxCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.taxAccount = const Value.absent(),
    this.accountRate = const Value.absent(),
    required DateTime effectiveDate,
    this.amount = const Value.absent(),
    this.taxIndicator = const Value.absent(),
  }) : effectiveDate = Value(effectiveDate);
  static Insertable<SalesTaxData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? type,
    Expression<String>? taxAccount,
    Expression<double>? accountRate,
    Expression<DateTime>? effectiveDate,
    Expression<double>? amount,
    Expression<String>? taxIndicator,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (type != null) 'type': type,
      if (taxAccount != null) 'tax_account': taxAccount,
      if (accountRate != null) 'account_rate': accountRate,
      if (effectiveDate != null) 'effective_date': effectiveDate,
      if (amount != null) 'amount': amount,
      if (taxIndicator != null) 'tax_indicator': taxIndicator,
    });
  }

  SalesTaxCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? type,
      Value<String?>? taxAccount,
      Value<double?>? accountRate,
      Value<DateTime>? effectiveDate,
      Value<double?>? amount,
      Value<String?>? taxIndicator}) {
    return SalesTaxCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      type: type ?? this.type,
      taxAccount: taxAccount ?? this.taxAccount,
      accountRate: accountRate ?? this.accountRate,
      effectiveDate: effectiveDate ?? this.effectiveDate,
      amount: amount ?? this.amount,
      taxIndicator: taxIndicator ?? this.taxIndicator,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (taxAccount.present) {
      map['tax_account'] = Variable<String>(taxAccount.value);
    }
    if (accountRate.present) {
      map['account_rate'] = Variable<double>(accountRate.value);
    }
    if (effectiveDate.present) {
      map['effective_date'] = Variable<DateTime>(effectiveDate.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (taxIndicator.present) {
      map['tax_indicator'] = Variable<String>(taxIndicator.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesTaxCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('taxAccount: $taxAccount, ')
          ..write('accountRate: $accountRate, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('amount: $amount, ')
          ..write('taxIndicator: $taxIndicator')
          ..write(')'))
        .toString();
  }
}

class $TempNumberLogsTable extends TempNumberLogs
    with TableInfo<$TempNumberLogsTable, TempNumberLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TempNumberLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _nextSeriesNumberMeta =
      const VerificationMeta('nextSeriesNumber');
  @override
  late final GeneratedColumn<String> nextSeriesNumber = GeneratedColumn<String>(
      'next_series_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastSeriesNumberMeta =
      const VerificationMeta('lastSeriesNumber');
  @override
  late final GeneratedColumn<String> lastSeriesNumber = GeneratedColumn<String>(
      'last_series_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastUsageDateMeta =
      const VerificationMeta('lastUsageDate');
  @override
  late final GeneratedColumn<DateTime> lastUsageDate =
      GeneratedColumn<DateTime>('last_usage_date', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeOfNumberMeta =
      const VerificationMeta('typeOfNumber');
  @override
  late final GeneratedColumn<String> typeOfNumber = GeneratedColumn<String>(
      'type_of_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        nextSeriesNumber,
        lastSeriesNumber,
        lastUsageDate,
        userName,
        typeOfNumber
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'temp_number_logs';
  @override
  VerificationContext validateIntegrity(Insertable<TempNumberLog> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('next_series_number')) {
      context.handle(
          _nextSeriesNumberMeta,
          nextSeriesNumber.isAcceptableOrUnknown(
              data['next_series_number']!, _nextSeriesNumberMeta));
    }
    if (data.containsKey('last_series_number')) {
      context.handle(
          _lastSeriesNumberMeta,
          lastSeriesNumber.isAcceptableOrUnknown(
              data['last_series_number']!, _lastSeriesNumberMeta));
    }
    if (data.containsKey('last_usage_date')) {
      context.handle(
          _lastUsageDateMeta,
          lastUsageDate.isAcceptableOrUnknown(
              data['last_usage_date']!, _lastUsageDateMeta));
    } else if (isInserting) {
      context.missing(_lastUsageDateMeta);
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('type_of_number')) {
      context.handle(
          _typeOfNumberMeta,
          typeOfNumber.isAcceptableOrUnknown(
              data['type_of_number']!, _typeOfNumberMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {typeOfNumber};
  @override
  TempNumberLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TempNumberLog(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      nextSeriesNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}next_series_number']),
      lastSeriesNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}last_series_number']),
      lastUsageDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_usage_date'])!,
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      typeOfNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type_of_number']),
    );
  }

  @override
  $TempNumberLogsTable createAlias(String alias) {
    return $TempNumberLogsTable(attachedDatabase, alias);
  }
}

class TempNumberLog extends DataClass implements Insertable<TempNumberLog> {
  final String? tenantId;
  final int id;
  final String? nextSeriesNumber;
  final String? lastSeriesNumber;
  final DateTime lastUsageDate;
  final String? userName;
  final String? typeOfNumber;
  const TempNumberLog(
      {this.tenantId,
      required this.id,
      this.nextSeriesNumber,
      this.lastSeriesNumber,
      required this.lastUsageDate,
      this.userName,
      this.typeOfNumber});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || nextSeriesNumber != null) {
      map['next_series_number'] = Variable<String>(nextSeriesNumber);
    }
    if (!nullToAbsent || lastSeriesNumber != null) {
      map['last_series_number'] = Variable<String>(lastSeriesNumber);
    }
    map['last_usage_date'] = Variable<DateTime>(lastUsageDate);
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || typeOfNumber != null) {
      map['type_of_number'] = Variable<String>(typeOfNumber);
    }
    return map;
  }

  TempNumberLogsCompanion toCompanion(bool nullToAbsent) {
    return TempNumberLogsCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      nextSeriesNumber: nextSeriesNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(nextSeriesNumber),
      lastSeriesNumber: lastSeriesNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSeriesNumber),
      lastUsageDate: Value(lastUsageDate),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      typeOfNumber: typeOfNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(typeOfNumber),
    );
  }

  factory TempNumberLog.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TempNumberLog(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      nextSeriesNumber: serializer.fromJson<String?>(json['nextSeriesNumber']),
      lastSeriesNumber: serializer.fromJson<String?>(json['lastSeriesNumber']),
      lastUsageDate: serializer.fromJson<DateTime>(json['lastUsageDate']),
      userName: serializer.fromJson<String?>(json['userName']),
      typeOfNumber: serializer.fromJson<String?>(json['typeOfNumber']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'nextSeriesNumber': serializer.toJson<String?>(nextSeriesNumber),
      'lastSeriesNumber': serializer.toJson<String?>(lastSeriesNumber),
      'lastUsageDate': serializer.toJson<DateTime>(lastUsageDate),
      'userName': serializer.toJson<String?>(userName),
      'typeOfNumber': serializer.toJson<String?>(typeOfNumber),
    };
  }

  TempNumberLog copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> nextSeriesNumber = const Value.absent(),
          Value<String?> lastSeriesNumber = const Value.absent(),
          DateTime? lastUsageDate,
          Value<String?> userName = const Value.absent(),
          Value<String?> typeOfNumber = const Value.absent()}) =>
      TempNumberLog(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        nextSeriesNumber: nextSeriesNumber.present
            ? nextSeriesNumber.value
            : this.nextSeriesNumber,
        lastSeriesNumber: lastSeriesNumber.present
            ? lastSeriesNumber.value
            : this.lastSeriesNumber,
        lastUsageDate: lastUsageDate ?? this.lastUsageDate,
        userName: userName.present ? userName.value : this.userName,
        typeOfNumber:
            typeOfNumber.present ? typeOfNumber.value : this.typeOfNumber,
      );
  @override
  String toString() {
    return (StringBuffer('TempNumberLog(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('nextSeriesNumber: $nextSeriesNumber, ')
          ..write('lastSeriesNumber: $lastSeriesNumber, ')
          ..write('lastUsageDate: $lastUsageDate, ')
          ..write('userName: $userName, ')
          ..write('typeOfNumber: $typeOfNumber')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, nextSeriesNumber,
      lastSeriesNumber, lastUsageDate, userName, typeOfNumber);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TempNumberLog &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.nextSeriesNumber == this.nextSeriesNumber &&
          other.lastSeriesNumber == this.lastSeriesNumber &&
          other.lastUsageDate == this.lastUsageDate &&
          other.userName == this.userName &&
          other.typeOfNumber == this.typeOfNumber);
}

class TempNumberLogsCompanion extends UpdateCompanion<TempNumberLog> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> nextSeriesNumber;
  final Value<String?> lastSeriesNumber;
  final Value<DateTime> lastUsageDate;
  final Value<String?> userName;
  final Value<String?> typeOfNumber;
  final Value<int> rowid;
  const TempNumberLogsCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.nextSeriesNumber = const Value.absent(),
    this.lastSeriesNumber = const Value.absent(),
    this.lastUsageDate = const Value.absent(),
    this.userName = const Value.absent(),
    this.typeOfNumber = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TempNumberLogsCompanion.insert({
    this.tenantId = const Value.absent(),
    required int id,
    this.nextSeriesNumber = const Value.absent(),
    this.lastSeriesNumber = const Value.absent(),
    required DateTime lastUsageDate,
    this.userName = const Value.absent(),
    this.typeOfNumber = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        lastUsageDate = Value(lastUsageDate);
  static Insertable<TempNumberLog> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? nextSeriesNumber,
    Expression<String>? lastSeriesNumber,
    Expression<DateTime>? lastUsageDate,
    Expression<String>? userName,
    Expression<String>? typeOfNumber,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (nextSeriesNumber != null) 'next_series_number': nextSeriesNumber,
      if (lastSeriesNumber != null) 'last_series_number': lastSeriesNumber,
      if (lastUsageDate != null) 'last_usage_date': lastUsageDate,
      if (userName != null) 'user_name': userName,
      if (typeOfNumber != null) 'type_of_number': typeOfNumber,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TempNumberLogsCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? nextSeriesNumber,
      Value<String?>? lastSeriesNumber,
      Value<DateTime>? lastUsageDate,
      Value<String?>? userName,
      Value<String?>? typeOfNumber,
      Value<int>? rowid}) {
    return TempNumberLogsCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      nextSeriesNumber: nextSeriesNumber ?? this.nextSeriesNumber,
      lastSeriesNumber: lastSeriesNumber ?? this.lastSeriesNumber,
      lastUsageDate: lastUsageDate ?? this.lastUsageDate,
      userName: userName ?? this.userName,
      typeOfNumber: typeOfNumber ?? this.typeOfNumber,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (nextSeriesNumber.present) {
      map['next_series_number'] = Variable<String>(nextSeriesNumber.value);
    }
    if (lastSeriesNumber.present) {
      map['last_series_number'] = Variable<String>(lastSeriesNumber.value);
    }
    if (lastUsageDate.present) {
      map['last_usage_date'] = Variable<DateTime>(lastUsageDate.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (typeOfNumber.present) {
      map['type_of_number'] = Variable<String>(typeOfNumber.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TempNumberLogsCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('nextSeriesNumber: $nextSeriesNumber, ')
          ..write('lastSeriesNumber: $lastSeriesNumber, ')
          ..write('lastUsageDate: $lastUsageDate, ')
          ..write('userName: $userName, ')
          ..write('typeOfNumber: $typeOfNumber, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CustomerTable extends Customer
    with TableInfo<$CustomerTable, CustomerData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CustomerTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _customerIdMeta =
      const VerificationMeta('customerId');
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
      'customer_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerNameMeta =
      const VerificationMeta('customerName');
  @override
  late final GeneratedColumn<String> customerName = GeneratedColumn<String>(
      'customer_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _companyNameMeta =
      const VerificationMeta('companyName');
  @override
  late final GeneratedColumn<String> companyName = GeneratedColumn<String>(
      'company_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerTypeMeta =
      const VerificationMeta('customerType');
  @override
  late final GeneratedColumn<String> customerType = GeneratedColumn<String>(
      'customer_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerGroupMeta =
      const VerificationMeta('customerGroup');
  @override
  late final GeneratedColumn<String> customerGroup = GeneratedColumn<String>(
      'customer_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerTerritoryMeta =
      const VerificationMeta('customerTerritory');
  @override
  late final GeneratedColumn<String> customerTerritory =
      GeneratedColumn<String>('customer_territory', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _defaultCurrencyMeta =
      const VerificationMeta('defaultCurrency');
  @override
  late final GeneratedColumn<String> defaultCurrency = GeneratedColumn<String>(
      'default_currency', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _paymentTermsMeta =
      const VerificationMeta('paymentTerms');
  @override
  late final GeneratedColumn<String> paymentTerms = GeneratedColumn<String>(
      'payment_terms', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _languageMeta =
      const VerificationMeta('language');
  @override
  late final GeneratedColumn<String> language = GeneratedColumn<String>(
      'language', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _creditLimitMeta =
      const VerificationMeta('creditLimit');
  @override
  late final GeneratedColumn<double> creditLimit = GeneratedColumn<double>(
      'credit_limit', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _billingAddressNameMeta =
      const VerificationMeta('billingAddressName');
  @override
  late final GeneratedColumn<String> billingAddressName =
      GeneratedColumn<String>('billing_address_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _shippingAddressNameMeta =
      const VerificationMeta('shippingAddressName');
  @override
  late final GeneratedColumn<String> shippingAddressName =
      GeneratedColumn<String>('shipping_address_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _contactNameMeta =
      const VerificationMeta('contactName');
  @override
  late final GeneratedColumn<String> contactName = GeneratedColumn<String>(
      'contact_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _priceListMeta =
      const VerificationMeta('priceList');
  @override
  late final GeneratedColumn<String> priceList = GeneratedColumn<String>(
      'price_list', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _minQuantityMeta =
      const VerificationMeta('minQuantity');
  @override
  late final GeneratedColumn<double> minQuantity = GeneratedColumn<double>(
      'min_quantity', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _maxQuantityMeta =
      const VerificationMeta('maxQuantity');
  @override
  late final GeneratedColumn<double> maxQuantity = GeneratedColumn<double>(
      'max_quantity', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _discountTypeMeta =
      const VerificationMeta('discountType');
  @override
  late final GeneratedColumn<String> discountType = GeneratedColumn<String>(
      'discount_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _discountPercentageMeta =
      const VerificationMeta('discountPercentage');
  @override
  late final GeneratedColumn<double> discountPercentage =
      GeneratedColumn<double>('discount_percentage', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _discountAmountMeta =
      const VerificationMeta('discountAmount');
  @override
  late final GeneratedColumn<double> discountAmount = GeneratedColumn<double>(
      'discount_amount', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _enableHeaderDiscountMeta =
      const VerificationMeta('enableHeaderDiscount');
  @override
  late final GeneratedColumn<bool> enableHeaderDiscount = GeneratedColumn<bool>(
      'enable_header_discount', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("enable_header_discount" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _accumulatedPurchaseMeta =
      const VerificationMeta('accumulatedPurchase');
  @override
  late final GeneratedColumn<double> accumulatedPurchase =
      GeneratedColumn<double>('accumulated_purchase', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _validFromMeta =
      const VerificationMeta('validFrom');
  @override
  late final GeneratedColumn<DateTime> validFrom = GeneratedColumn<DateTime>(
      'valid_from', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _validToMeta =
      const VerificationMeta('validTo');
  @override
  late final GeneratedColumn<DateTime> validTo = GeneratedColumn<DateTime>(
      'valid_to', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _taxIdMeta = const VerificationMeta('taxId');
  @override
  late final GeneratedColumn<String> taxId = GeneratedColumn<String>(
      'tax_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _taxGroupMeta =
      const VerificationMeta('taxGroup');
  @override
  late final GeneratedColumn<String> taxGroup = GeneratedColumn<String>(
      'tax_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        customerId,
        customerName,
        companyName,
        customerType,
        customerGroup,
        customerTerritory,
        defaultCurrency,
        paymentTerms,
        language,
        creditLimit,
        billingAddressName,
        shippingAddressName,
        contactName,
        priceList,
        minQuantity,
        maxQuantity,
        discountType,
        discountPercentage,
        discountAmount,
        enableHeaderDiscount,
        accumulatedPurchase,
        validFrom,
        validTo,
        taxId,
        taxGroup
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'customer';
  @override
  VerificationContext validateIntegrity(Insertable<CustomerData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id']!, _customerIdMeta));
    }
    if (data.containsKey('customer_name')) {
      context.handle(
          _customerNameMeta,
          customerName.isAcceptableOrUnknown(
              data['customer_name']!, _customerNameMeta));
    }
    if (data.containsKey('company_name')) {
      context.handle(
          _companyNameMeta,
          companyName.isAcceptableOrUnknown(
              data['company_name']!, _companyNameMeta));
    }
    if (data.containsKey('customer_type')) {
      context.handle(
          _customerTypeMeta,
          customerType.isAcceptableOrUnknown(
              data['customer_type']!, _customerTypeMeta));
    }
    if (data.containsKey('customer_group')) {
      context.handle(
          _customerGroupMeta,
          customerGroup.isAcceptableOrUnknown(
              data['customer_group']!, _customerGroupMeta));
    }
    if (data.containsKey('customer_territory')) {
      context.handle(
          _customerTerritoryMeta,
          customerTerritory.isAcceptableOrUnknown(
              data['customer_territory']!, _customerTerritoryMeta));
    }
    if (data.containsKey('default_currency')) {
      context.handle(
          _defaultCurrencyMeta,
          defaultCurrency.isAcceptableOrUnknown(
              data['default_currency']!, _defaultCurrencyMeta));
    }
    if (data.containsKey('payment_terms')) {
      context.handle(
          _paymentTermsMeta,
          paymentTerms.isAcceptableOrUnknown(
              data['payment_terms']!, _paymentTermsMeta));
    }
    if (data.containsKey('language')) {
      context.handle(_languageMeta,
          language.isAcceptableOrUnknown(data['language']!, _languageMeta));
    }
    if (data.containsKey('credit_limit')) {
      context.handle(
          _creditLimitMeta,
          creditLimit.isAcceptableOrUnknown(
              data['credit_limit']!, _creditLimitMeta));
    }
    if (data.containsKey('billing_address_name')) {
      context.handle(
          _billingAddressNameMeta,
          billingAddressName.isAcceptableOrUnknown(
              data['billing_address_name']!, _billingAddressNameMeta));
    }
    if (data.containsKey('shipping_address_name')) {
      context.handle(
          _shippingAddressNameMeta,
          shippingAddressName.isAcceptableOrUnknown(
              data['shipping_address_name']!, _shippingAddressNameMeta));
    }
    if (data.containsKey('contact_name')) {
      context.handle(
          _contactNameMeta,
          contactName.isAcceptableOrUnknown(
              data['contact_name']!, _contactNameMeta));
    }
    if (data.containsKey('price_list')) {
      context.handle(_priceListMeta,
          priceList.isAcceptableOrUnknown(data['price_list']!, _priceListMeta));
    }
    if (data.containsKey('min_quantity')) {
      context.handle(
          _minQuantityMeta,
          minQuantity.isAcceptableOrUnknown(
              data['min_quantity']!, _minQuantityMeta));
    }
    if (data.containsKey('max_quantity')) {
      context.handle(
          _maxQuantityMeta,
          maxQuantity.isAcceptableOrUnknown(
              data['max_quantity']!, _maxQuantityMeta));
    }
    if (data.containsKey('discount_type')) {
      context.handle(
          _discountTypeMeta,
          discountType.isAcceptableOrUnknown(
              data['discount_type']!, _discountTypeMeta));
    }
    if (data.containsKey('discount_percentage')) {
      context.handle(
          _discountPercentageMeta,
          discountPercentage.isAcceptableOrUnknown(
              data['discount_percentage']!, _discountPercentageMeta));
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
          _discountAmountMeta,
          discountAmount.isAcceptableOrUnknown(
              data['discount_amount']!, _discountAmountMeta));
    }
    if (data.containsKey('enable_header_discount')) {
      context.handle(
          _enableHeaderDiscountMeta,
          enableHeaderDiscount.isAcceptableOrUnknown(
              data['enable_header_discount']!, _enableHeaderDiscountMeta));
    }
    if (data.containsKey('accumulated_purchase')) {
      context.handle(
          _accumulatedPurchaseMeta,
          accumulatedPurchase.isAcceptableOrUnknown(
              data['accumulated_purchase']!, _accumulatedPurchaseMeta));
    }
    if (data.containsKey('valid_from')) {
      context.handle(_validFromMeta,
          validFrom.isAcceptableOrUnknown(data['valid_from']!, _validFromMeta));
    }
    if (data.containsKey('valid_to')) {
      context.handle(_validToMeta,
          validTo.isAcceptableOrUnknown(data['valid_to']!, _validToMeta));
    }
    if (data.containsKey('tax_id')) {
      context.handle(
          _taxIdMeta, taxId.isAcceptableOrUnknown(data['tax_id']!, _taxIdMeta));
    }
    if (data.containsKey('tax_group')) {
      context.handle(_taxGroupMeta,
          taxGroup.isAcceptableOrUnknown(data['tax_group']!, _taxGroupMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CustomerData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CustomerData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      customerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_id']),
      customerName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_name']),
      companyName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}company_name']),
      customerType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_type']),
      customerGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_group']),
      customerTerritory: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}customer_territory']),
      defaultCurrency: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}default_currency']),
      paymentTerms: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}payment_terms']),
      language: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}language']),
      creditLimit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}credit_limit']),
      billingAddressName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}billing_address_name']),
      shippingAddressName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}shipping_address_name']),
      contactName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contact_name']),
      priceList: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}price_list']),
      minQuantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}min_quantity']),
      maxQuantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}max_quantity']),
      discountType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}discount_type']),
      discountPercentage: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}discount_percentage']),
      discountAmount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}discount_amount']),
      enableHeaderDiscount: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}enable_header_discount']),
      accumulatedPurchase: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}accumulated_purchase']),
      validFrom: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_from']),
      validTo: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_to']),
      taxId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tax_id']),
      taxGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tax_group']),
    );
  }

  @override
  $CustomerTable createAlias(String alias) {
    return $CustomerTable(attachedDatabase, alias);
  }
}

class CustomerData extends DataClass implements Insertable<CustomerData> {
  final String? tenantId;
  final int id;
  final String? customerId;
  final String? customerName;
  final String? companyName;
  final String? customerType;
  final String? customerGroup;
  final String? customerTerritory;
  final String? defaultCurrency;
  final String? paymentTerms;
  final String? language;
  final double? creditLimit;
  final String? billingAddressName;
  final String? shippingAddressName;
  final String? contactName;
  final String? priceList;
  final double? minQuantity;
  final double? maxQuantity;
  final String? discountType;
  final double? discountPercentage;
  final double? discountAmount;
  final bool? enableHeaderDiscount;
  final double? accumulatedPurchase;
  final DateTime? validFrom;
  final DateTime? validTo;
  final String? taxId;
  final String? taxGroup;
  const CustomerData(
      {this.tenantId,
      required this.id,
      this.customerId,
      this.customerName,
      this.companyName,
      this.customerType,
      this.customerGroup,
      this.customerTerritory,
      this.defaultCurrency,
      this.paymentTerms,
      this.language,
      this.creditLimit,
      this.billingAddressName,
      this.shippingAddressName,
      this.contactName,
      this.priceList,
      this.minQuantity,
      this.maxQuantity,
      this.discountType,
      this.discountPercentage,
      this.discountAmount,
      this.enableHeaderDiscount,
      this.accumulatedPurchase,
      this.validFrom,
      this.validTo,
      this.taxId,
      this.taxGroup});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || customerName != null) {
      map['customer_name'] = Variable<String>(customerName);
    }
    if (!nullToAbsent || companyName != null) {
      map['company_name'] = Variable<String>(companyName);
    }
    if (!nullToAbsent || customerType != null) {
      map['customer_type'] = Variable<String>(customerType);
    }
    if (!nullToAbsent || customerGroup != null) {
      map['customer_group'] = Variable<String>(customerGroup);
    }
    if (!nullToAbsent || customerTerritory != null) {
      map['customer_territory'] = Variable<String>(customerTerritory);
    }
    if (!nullToAbsent || defaultCurrency != null) {
      map['default_currency'] = Variable<String>(defaultCurrency);
    }
    if (!nullToAbsent || paymentTerms != null) {
      map['payment_terms'] = Variable<String>(paymentTerms);
    }
    if (!nullToAbsent || language != null) {
      map['language'] = Variable<String>(language);
    }
    if (!nullToAbsent || creditLimit != null) {
      map['credit_limit'] = Variable<double>(creditLimit);
    }
    if (!nullToAbsent || billingAddressName != null) {
      map['billing_address_name'] = Variable<String>(billingAddressName);
    }
    if (!nullToAbsent || shippingAddressName != null) {
      map['shipping_address_name'] = Variable<String>(shippingAddressName);
    }
    if (!nullToAbsent || contactName != null) {
      map['contact_name'] = Variable<String>(contactName);
    }
    if (!nullToAbsent || priceList != null) {
      map['price_list'] = Variable<String>(priceList);
    }
    if (!nullToAbsent || minQuantity != null) {
      map['min_quantity'] = Variable<double>(minQuantity);
    }
    if (!nullToAbsent || maxQuantity != null) {
      map['max_quantity'] = Variable<double>(maxQuantity);
    }
    if (!nullToAbsent || discountType != null) {
      map['discount_type'] = Variable<String>(discountType);
    }
    if (!nullToAbsent || discountPercentage != null) {
      map['discount_percentage'] = Variable<double>(discountPercentage);
    }
    if (!nullToAbsent || discountAmount != null) {
      map['discount_amount'] = Variable<double>(discountAmount);
    }
    if (!nullToAbsent || enableHeaderDiscount != null) {
      map['enable_header_discount'] = Variable<bool>(enableHeaderDiscount);
    }
    if (!nullToAbsent || accumulatedPurchase != null) {
      map['accumulated_purchase'] = Variable<double>(accumulatedPurchase);
    }
    if (!nullToAbsent || validFrom != null) {
      map['valid_from'] = Variable<DateTime>(validFrom);
    }
    if (!nullToAbsent || validTo != null) {
      map['valid_to'] = Variable<DateTime>(validTo);
    }
    if (!nullToAbsent || taxId != null) {
      map['tax_id'] = Variable<String>(taxId);
    }
    if (!nullToAbsent || taxGroup != null) {
      map['tax_group'] = Variable<String>(taxGroup);
    }
    return map;
  }

  CustomerCompanion toCompanion(bool nullToAbsent) {
    return CustomerCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      customerName: customerName == null && nullToAbsent
          ? const Value.absent()
          : Value(customerName),
      companyName: companyName == null && nullToAbsent
          ? const Value.absent()
          : Value(companyName),
      customerType: customerType == null && nullToAbsent
          ? const Value.absent()
          : Value(customerType),
      customerGroup: customerGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(customerGroup),
      customerTerritory: customerTerritory == null && nullToAbsent
          ? const Value.absent()
          : Value(customerTerritory),
      defaultCurrency: defaultCurrency == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultCurrency),
      paymentTerms: paymentTerms == null && nullToAbsent
          ? const Value.absent()
          : Value(paymentTerms),
      language: language == null && nullToAbsent
          ? const Value.absent()
          : Value(language),
      creditLimit: creditLimit == null && nullToAbsent
          ? const Value.absent()
          : Value(creditLimit),
      billingAddressName: billingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(billingAddressName),
      shippingAddressName: shippingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(shippingAddressName),
      contactName: contactName == null && nullToAbsent
          ? const Value.absent()
          : Value(contactName),
      priceList: priceList == null && nullToAbsent
          ? const Value.absent()
          : Value(priceList),
      minQuantity: minQuantity == null && nullToAbsent
          ? const Value.absent()
          : Value(minQuantity),
      maxQuantity: maxQuantity == null && nullToAbsent
          ? const Value.absent()
          : Value(maxQuantity),
      discountType: discountType == null && nullToAbsent
          ? const Value.absent()
          : Value(discountType),
      discountPercentage: discountPercentage == null && nullToAbsent
          ? const Value.absent()
          : Value(discountPercentage),
      discountAmount: discountAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(discountAmount),
      enableHeaderDiscount: enableHeaderDiscount == null && nullToAbsent
          ? const Value.absent()
          : Value(enableHeaderDiscount),
      accumulatedPurchase: accumulatedPurchase == null && nullToAbsent
          ? const Value.absent()
          : Value(accumulatedPurchase),
      validFrom: validFrom == null && nullToAbsent
          ? const Value.absent()
          : Value(validFrom),
      validTo: validTo == null && nullToAbsent
          ? const Value.absent()
          : Value(validTo),
      taxId:
          taxId == null && nullToAbsent ? const Value.absent() : Value(taxId),
      taxGroup: taxGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(taxGroup),
    );
  }

  factory CustomerData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CustomerData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      customerId: serializer.fromJson<String?>(json['customerId']),
      customerName: serializer.fromJson<String?>(json['customerName']),
      companyName: serializer.fromJson<String?>(json['companyName']),
      customerType: serializer.fromJson<String?>(json['customerType']),
      customerGroup: serializer.fromJson<String?>(json['customerGroup']),
      customerTerritory:
          serializer.fromJson<String?>(json['customerTerritory']),
      defaultCurrency: serializer.fromJson<String?>(json['defaultCurrency']),
      paymentTerms: serializer.fromJson<String?>(json['paymentTerms']),
      language: serializer.fromJson<String?>(json['language']),
      creditLimit: serializer.fromJson<double?>(json['creditLimit']),
      billingAddressName:
          serializer.fromJson<String?>(json['billingAddressName']),
      shippingAddressName:
          serializer.fromJson<String?>(json['shippingAddressName']),
      contactName: serializer.fromJson<String?>(json['contactName']),
      priceList: serializer.fromJson<String?>(json['priceList']),
      minQuantity: serializer.fromJson<double?>(json['minQuantity']),
      maxQuantity: serializer.fromJson<double?>(json['maxQuantity']),
      discountType: serializer.fromJson<String?>(json['discountType']),
      discountPercentage:
          serializer.fromJson<double?>(json['discountPercentage']),
      discountAmount: serializer.fromJson<double?>(json['discountAmount']),
      enableHeaderDiscount:
          serializer.fromJson<bool?>(json['enableHeaderDiscount']),
      accumulatedPurchase:
          serializer.fromJson<double?>(json['accumulatedPurchase']),
      validFrom: serializer.fromJson<DateTime?>(json['validFrom']),
      validTo: serializer.fromJson<DateTime?>(json['validTo']),
      taxId: serializer.fromJson<String?>(json['taxId']),
      taxGroup: serializer.fromJson<String?>(json['taxGroup']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'customerId': serializer.toJson<String?>(customerId),
      'customerName': serializer.toJson<String?>(customerName),
      'companyName': serializer.toJson<String?>(companyName),
      'customerType': serializer.toJson<String?>(customerType),
      'customerGroup': serializer.toJson<String?>(customerGroup),
      'customerTerritory': serializer.toJson<String?>(customerTerritory),
      'defaultCurrency': serializer.toJson<String?>(defaultCurrency),
      'paymentTerms': serializer.toJson<String?>(paymentTerms),
      'language': serializer.toJson<String?>(language),
      'creditLimit': serializer.toJson<double?>(creditLimit),
      'billingAddressName': serializer.toJson<String?>(billingAddressName),
      'shippingAddressName': serializer.toJson<String?>(shippingAddressName),
      'contactName': serializer.toJson<String?>(contactName),
      'priceList': serializer.toJson<String?>(priceList),
      'minQuantity': serializer.toJson<double?>(minQuantity),
      'maxQuantity': serializer.toJson<double?>(maxQuantity),
      'discountType': serializer.toJson<String?>(discountType),
      'discountPercentage': serializer.toJson<double?>(discountPercentage),
      'discountAmount': serializer.toJson<double?>(discountAmount),
      'enableHeaderDiscount': serializer.toJson<bool?>(enableHeaderDiscount),
      'accumulatedPurchase': serializer.toJson<double?>(accumulatedPurchase),
      'validFrom': serializer.toJson<DateTime?>(validFrom),
      'validTo': serializer.toJson<DateTime?>(validTo),
      'taxId': serializer.toJson<String?>(taxId),
      'taxGroup': serializer.toJson<String?>(taxGroup),
    };
  }

  CustomerData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> customerId = const Value.absent(),
          Value<String?> customerName = const Value.absent(),
          Value<String?> companyName = const Value.absent(),
          Value<String?> customerType = const Value.absent(),
          Value<String?> customerGroup = const Value.absent(),
          Value<String?> customerTerritory = const Value.absent(),
          Value<String?> defaultCurrency = const Value.absent(),
          Value<String?> paymentTerms = const Value.absent(),
          Value<String?> language = const Value.absent(),
          Value<double?> creditLimit = const Value.absent(),
          Value<String?> billingAddressName = const Value.absent(),
          Value<String?> shippingAddressName = const Value.absent(),
          Value<String?> contactName = const Value.absent(),
          Value<String?> priceList = const Value.absent(),
          Value<double?> minQuantity = const Value.absent(),
          Value<double?> maxQuantity = const Value.absent(),
          Value<String?> discountType = const Value.absent(),
          Value<double?> discountPercentage = const Value.absent(),
          Value<double?> discountAmount = const Value.absent(),
          Value<bool?> enableHeaderDiscount = const Value.absent(),
          Value<double?> accumulatedPurchase = const Value.absent(),
          Value<DateTime?> validFrom = const Value.absent(),
          Value<DateTime?> validTo = const Value.absent(),
          Value<String?> taxId = const Value.absent(),
          Value<String?> taxGroup = const Value.absent()}) =>
      CustomerData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        customerId: customerId.present ? customerId.value : this.customerId,
        customerName:
            customerName.present ? customerName.value : this.customerName,
        companyName: companyName.present ? companyName.value : this.companyName,
        customerType:
            customerType.present ? customerType.value : this.customerType,
        customerGroup:
            customerGroup.present ? customerGroup.value : this.customerGroup,
        customerTerritory: customerTerritory.present
            ? customerTerritory.value
            : this.customerTerritory,
        defaultCurrency: defaultCurrency.present
            ? defaultCurrency.value
            : this.defaultCurrency,
        paymentTerms:
            paymentTerms.present ? paymentTerms.value : this.paymentTerms,
        language: language.present ? language.value : this.language,
        creditLimit: creditLimit.present ? creditLimit.value : this.creditLimit,
        billingAddressName: billingAddressName.present
            ? billingAddressName.value
            : this.billingAddressName,
        shippingAddressName: shippingAddressName.present
            ? shippingAddressName.value
            : this.shippingAddressName,
        contactName: contactName.present ? contactName.value : this.contactName,
        priceList: priceList.present ? priceList.value : this.priceList,
        minQuantity: minQuantity.present ? minQuantity.value : this.minQuantity,
        maxQuantity: maxQuantity.present ? maxQuantity.value : this.maxQuantity,
        discountType:
            discountType.present ? discountType.value : this.discountType,
        discountPercentage: discountPercentage.present
            ? discountPercentage.value
            : this.discountPercentage,
        discountAmount:
            discountAmount.present ? discountAmount.value : this.discountAmount,
        enableHeaderDiscount: enableHeaderDiscount.present
            ? enableHeaderDiscount.value
            : this.enableHeaderDiscount,
        accumulatedPurchase: accumulatedPurchase.present
            ? accumulatedPurchase.value
            : this.accumulatedPurchase,
        validFrom: validFrom.present ? validFrom.value : this.validFrom,
        validTo: validTo.present ? validTo.value : this.validTo,
        taxId: taxId.present ? taxId.value : this.taxId,
        taxGroup: taxGroup.present ? taxGroup.value : this.taxGroup,
      );
  @override
  String toString() {
    return (StringBuffer('CustomerData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('companyName: $companyName, ')
          ..write('customerType: $customerType, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('customerTerritory: $customerTerritory, ')
          ..write('defaultCurrency: $defaultCurrency, ')
          ..write('paymentTerms: $paymentTerms, ')
          ..write('language: $language, ')
          ..write('creditLimit: $creditLimit, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('contactName: $contactName, ')
          ..write('priceList: $priceList, ')
          ..write('minQuantity: $minQuantity, ')
          ..write('maxQuantity: $maxQuantity, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('enableHeaderDiscount: $enableHeaderDiscount, ')
          ..write('accumulatedPurchase: $accumulatedPurchase, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo, ')
          ..write('taxId: $taxId, ')
          ..write('taxGroup: $taxGroup')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        id,
        customerId,
        customerName,
        companyName,
        customerType,
        customerGroup,
        customerTerritory,
        defaultCurrency,
        paymentTerms,
        language,
        creditLimit,
        billingAddressName,
        shippingAddressName,
        contactName,
        priceList,
        minQuantity,
        maxQuantity,
        discountType,
        discountPercentage,
        discountAmount,
        enableHeaderDiscount,
        accumulatedPurchase,
        validFrom,
        validTo,
        taxId,
        taxGroup
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CustomerData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.customerId == this.customerId &&
          other.customerName == this.customerName &&
          other.companyName == this.companyName &&
          other.customerType == this.customerType &&
          other.customerGroup == this.customerGroup &&
          other.customerTerritory == this.customerTerritory &&
          other.defaultCurrency == this.defaultCurrency &&
          other.paymentTerms == this.paymentTerms &&
          other.language == this.language &&
          other.creditLimit == this.creditLimit &&
          other.billingAddressName == this.billingAddressName &&
          other.shippingAddressName == this.shippingAddressName &&
          other.contactName == this.contactName &&
          other.priceList == this.priceList &&
          other.minQuantity == this.minQuantity &&
          other.maxQuantity == this.maxQuantity &&
          other.discountType == this.discountType &&
          other.discountPercentage == this.discountPercentage &&
          other.discountAmount == this.discountAmount &&
          other.enableHeaderDiscount == this.enableHeaderDiscount &&
          other.accumulatedPurchase == this.accumulatedPurchase &&
          other.validFrom == this.validFrom &&
          other.validTo == this.validTo &&
          other.taxId == this.taxId &&
          other.taxGroup == this.taxGroup);
}

class CustomerCompanion extends UpdateCompanion<CustomerData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> customerId;
  final Value<String?> customerName;
  final Value<String?> companyName;
  final Value<String?> customerType;
  final Value<String?> customerGroup;
  final Value<String?> customerTerritory;
  final Value<String?> defaultCurrency;
  final Value<String?> paymentTerms;
  final Value<String?> language;
  final Value<double?> creditLimit;
  final Value<String?> billingAddressName;
  final Value<String?> shippingAddressName;
  final Value<String?> contactName;
  final Value<String?> priceList;
  final Value<double?> minQuantity;
  final Value<double?> maxQuantity;
  final Value<String?> discountType;
  final Value<double?> discountPercentage;
  final Value<double?> discountAmount;
  final Value<bool?> enableHeaderDiscount;
  final Value<double?> accumulatedPurchase;
  final Value<DateTime?> validFrom;
  final Value<DateTime?> validTo;
  final Value<String?> taxId;
  final Value<String?> taxGroup;
  const CustomerCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.customerId = const Value.absent(),
    this.customerName = const Value.absent(),
    this.companyName = const Value.absent(),
    this.customerType = const Value.absent(),
    this.customerGroup = const Value.absent(),
    this.customerTerritory = const Value.absent(),
    this.defaultCurrency = const Value.absent(),
    this.paymentTerms = const Value.absent(),
    this.language = const Value.absent(),
    this.creditLimit = const Value.absent(),
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.contactName = const Value.absent(),
    this.priceList = const Value.absent(),
    this.minQuantity = const Value.absent(),
    this.maxQuantity = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.enableHeaderDiscount = const Value.absent(),
    this.accumulatedPurchase = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
    this.taxId = const Value.absent(),
    this.taxGroup = const Value.absent(),
  });
  CustomerCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.customerId = const Value.absent(),
    this.customerName = const Value.absent(),
    this.companyName = const Value.absent(),
    this.customerType = const Value.absent(),
    this.customerGroup = const Value.absent(),
    this.customerTerritory = const Value.absent(),
    this.defaultCurrency = const Value.absent(),
    this.paymentTerms = const Value.absent(),
    this.language = const Value.absent(),
    this.creditLimit = const Value.absent(),
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.contactName = const Value.absent(),
    this.priceList = const Value.absent(),
    this.minQuantity = const Value.absent(),
    this.maxQuantity = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.enableHeaderDiscount = const Value.absent(),
    this.accumulatedPurchase = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
    this.taxId = const Value.absent(),
    this.taxGroup = const Value.absent(),
  });
  static Insertable<CustomerData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? customerId,
    Expression<String>? customerName,
    Expression<String>? companyName,
    Expression<String>? customerType,
    Expression<String>? customerGroup,
    Expression<String>? customerTerritory,
    Expression<String>? defaultCurrency,
    Expression<String>? paymentTerms,
    Expression<String>? language,
    Expression<double>? creditLimit,
    Expression<String>? billingAddressName,
    Expression<String>? shippingAddressName,
    Expression<String>? contactName,
    Expression<String>? priceList,
    Expression<double>? minQuantity,
    Expression<double>? maxQuantity,
    Expression<String>? discountType,
    Expression<double>? discountPercentage,
    Expression<double>? discountAmount,
    Expression<bool>? enableHeaderDiscount,
    Expression<double>? accumulatedPurchase,
    Expression<DateTime>? validFrom,
    Expression<DateTime>? validTo,
    Expression<String>? taxId,
    Expression<String>? taxGroup,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (customerId != null) 'customer_id': customerId,
      if (customerName != null) 'customer_name': customerName,
      if (companyName != null) 'company_name': companyName,
      if (customerType != null) 'customer_type': customerType,
      if (customerGroup != null) 'customer_group': customerGroup,
      if (customerTerritory != null) 'customer_territory': customerTerritory,
      if (defaultCurrency != null) 'default_currency': defaultCurrency,
      if (paymentTerms != null) 'payment_terms': paymentTerms,
      if (language != null) 'language': language,
      if (creditLimit != null) 'credit_limit': creditLimit,
      if (billingAddressName != null)
        'billing_address_name': billingAddressName,
      if (shippingAddressName != null)
        'shipping_address_name': shippingAddressName,
      if (contactName != null) 'contact_name': contactName,
      if (priceList != null) 'price_list': priceList,
      if (minQuantity != null) 'min_quantity': minQuantity,
      if (maxQuantity != null) 'max_quantity': maxQuantity,
      if (discountType != null) 'discount_type': discountType,
      if (discountPercentage != null) 'discount_percentage': discountPercentage,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (enableHeaderDiscount != null)
        'enable_header_discount': enableHeaderDiscount,
      if (accumulatedPurchase != null)
        'accumulated_purchase': accumulatedPurchase,
      if (validFrom != null) 'valid_from': validFrom,
      if (validTo != null) 'valid_to': validTo,
      if (taxId != null) 'tax_id': taxId,
      if (taxGroup != null) 'tax_group': taxGroup,
    });
  }

  CustomerCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? customerId,
      Value<String?>? customerName,
      Value<String?>? companyName,
      Value<String?>? customerType,
      Value<String?>? customerGroup,
      Value<String?>? customerTerritory,
      Value<String?>? defaultCurrency,
      Value<String?>? paymentTerms,
      Value<String?>? language,
      Value<double?>? creditLimit,
      Value<String?>? billingAddressName,
      Value<String?>? shippingAddressName,
      Value<String?>? contactName,
      Value<String?>? priceList,
      Value<double?>? minQuantity,
      Value<double?>? maxQuantity,
      Value<String?>? discountType,
      Value<double?>? discountPercentage,
      Value<double?>? discountAmount,
      Value<bool?>? enableHeaderDiscount,
      Value<double?>? accumulatedPurchase,
      Value<DateTime?>? validFrom,
      Value<DateTime?>? validTo,
      Value<String?>? taxId,
      Value<String?>? taxGroup}) {
    return CustomerCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      customerId: customerId ?? this.customerId,
      customerName: customerName ?? this.customerName,
      companyName: companyName ?? this.companyName,
      customerType: customerType ?? this.customerType,
      customerGroup: customerGroup ?? this.customerGroup,
      customerTerritory: customerTerritory ?? this.customerTerritory,
      defaultCurrency: defaultCurrency ?? this.defaultCurrency,
      paymentTerms: paymentTerms ?? this.paymentTerms,
      language: language ?? this.language,
      creditLimit: creditLimit ?? this.creditLimit,
      billingAddressName: billingAddressName ?? this.billingAddressName,
      shippingAddressName: shippingAddressName ?? this.shippingAddressName,
      contactName: contactName ?? this.contactName,
      priceList: priceList ?? this.priceList,
      minQuantity: minQuantity ?? this.minQuantity,
      maxQuantity: maxQuantity ?? this.maxQuantity,
      discountType: discountType ?? this.discountType,
      discountPercentage: discountPercentage ?? this.discountPercentage,
      discountAmount: discountAmount ?? this.discountAmount,
      enableHeaderDiscount: enableHeaderDiscount ?? this.enableHeaderDiscount,
      accumulatedPurchase: accumulatedPurchase ?? this.accumulatedPurchase,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo ?? this.validTo,
      taxId: taxId ?? this.taxId,
      taxGroup: taxGroup ?? this.taxGroup,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (customerName.present) {
      map['customer_name'] = Variable<String>(customerName.value);
    }
    if (companyName.present) {
      map['company_name'] = Variable<String>(companyName.value);
    }
    if (customerType.present) {
      map['customer_type'] = Variable<String>(customerType.value);
    }
    if (customerGroup.present) {
      map['customer_group'] = Variable<String>(customerGroup.value);
    }
    if (customerTerritory.present) {
      map['customer_territory'] = Variable<String>(customerTerritory.value);
    }
    if (defaultCurrency.present) {
      map['default_currency'] = Variable<String>(defaultCurrency.value);
    }
    if (paymentTerms.present) {
      map['payment_terms'] = Variable<String>(paymentTerms.value);
    }
    if (language.present) {
      map['language'] = Variable<String>(language.value);
    }
    if (creditLimit.present) {
      map['credit_limit'] = Variable<double>(creditLimit.value);
    }
    if (billingAddressName.present) {
      map['billing_address_name'] = Variable<String>(billingAddressName.value);
    }
    if (shippingAddressName.present) {
      map['shipping_address_name'] =
          Variable<String>(shippingAddressName.value);
    }
    if (contactName.present) {
      map['contact_name'] = Variable<String>(contactName.value);
    }
    if (priceList.present) {
      map['price_list'] = Variable<String>(priceList.value);
    }
    if (minQuantity.present) {
      map['min_quantity'] = Variable<double>(minQuantity.value);
    }
    if (maxQuantity.present) {
      map['max_quantity'] = Variable<double>(maxQuantity.value);
    }
    if (discountType.present) {
      map['discount_type'] = Variable<String>(discountType.value);
    }
    if (discountPercentage.present) {
      map['discount_percentage'] = Variable<double>(discountPercentage.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (enableHeaderDiscount.present) {
      map['enable_header_discount'] =
          Variable<bool>(enableHeaderDiscount.value);
    }
    if (accumulatedPurchase.present) {
      map['accumulated_purchase'] = Variable<double>(accumulatedPurchase.value);
    }
    if (validFrom.present) {
      map['valid_from'] = Variable<DateTime>(validFrom.value);
    }
    if (validTo.present) {
      map['valid_to'] = Variable<DateTime>(validTo.value);
    }
    if (taxId.present) {
      map['tax_id'] = Variable<String>(taxId.value);
    }
    if (taxGroup.present) {
      map['tax_group'] = Variable<String>(taxGroup.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomerCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('companyName: $companyName, ')
          ..write('customerType: $customerType, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('customerTerritory: $customerTerritory, ')
          ..write('defaultCurrency: $defaultCurrency, ')
          ..write('paymentTerms: $paymentTerms, ')
          ..write('language: $language, ')
          ..write('creditLimit: $creditLimit, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('contactName: $contactName, ')
          ..write('priceList: $priceList, ')
          ..write('minQuantity: $minQuantity, ')
          ..write('maxQuantity: $maxQuantity, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('enableHeaderDiscount: $enableHeaderDiscount, ')
          ..write('accumulatedPurchase: $accumulatedPurchase, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo, ')
          ..write('taxId: $taxId, ')
          ..write('taxGroup: $taxGroup')
          ..write(')'))
        .toString();
  }
}

class $AddresTable extends Addres with TableInfo<$AddresTable, Addre> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AddresTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _customerIdMeta =
      const VerificationMeta('customerId');
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
      'customer_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _addressTitleMeta =
      const VerificationMeta('addressTitle');
  @override
  late final GeneratedColumn<String> addressTitle = GeneratedColumn<String>(
      'address_title', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _addressTypeMeta =
      const VerificationMeta('addressType');
  @override
  late final GeneratedColumn<String> addressType = GeneratedColumn<String>(
      'address_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _addressLine1Meta =
      const VerificationMeta('addressLine1');
  @override
  late final GeneratedColumn<String> addressLine1 = GeneratedColumn<String>(
      'address_line1', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _addressLine2Meta =
      const VerificationMeta('addressLine2');
  @override
  late final GeneratedColumn<String> addressLine2 = GeneratedColumn<String>(
      'address_line2', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _cityMeta = const VerificationMeta('city');
  @override
  late final GeneratedColumn<String> city = GeneratedColumn<String>(
      'city', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _stateMeta = const VerificationMeta('state');
  @override
  late final GeneratedColumn<String> state = GeneratedColumn<String>(
      'state', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _apartmentMeta =
      const VerificationMeta('apartment');
  @override
  late final GeneratedColumn<String> apartment = GeneratedColumn<String>(
      'apartment', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _countryMeta =
      const VerificationMeta('country');
  @override
  late final GeneratedColumn<String> country = GeneratedColumn<String>(
      'country', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _zipCodeMeta =
      const VerificationMeta('zipCode');
  @override
  late final GeneratedColumn<String> zipCode = GeneratedColumn<String>(
      'zip_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _contactPersonMeta =
      const VerificationMeta('contactPerson');
  @override
  late final GeneratedColumn<String> contactPerson = GeneratedColumn<String>(
      'contact_person', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _phoneNumberMeta =
      const VerificationMeta('phoneNumber');
  @override
  late final GeneratedColumn<String> phoneNumber = GeneratedColumn<String>(
      'phone_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isYourCompanyAddressMeta =
      const VerificationMeta('isYourCompanyAddress');
  @override
  late final GeneratedColumn<bool> isYourCompanyAddress = GeneratedColumn<bool>(
      'is_your_company_address', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_your_company_address" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isPrimaryAddressMeta =
      const VerificationMeta('isPrimaryAddress');
  @override
  late final GeneratedColumn<bool> isPrimaryAddress = GeneratedColumn<bool>(
      'is_primary_address', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_primary_address" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isShippingAddressMeta =
      const VerificationMeta('isShippingAddress');
  @override
  late final GeneratedColumn<bool> isShippingAddress = GeneratedColumn<bool>(
      'is_shipping_address', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_shipping_address" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _latitudeMeta =
      const VerificationMeta('latitude');
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
      'latitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _longitudeMeta =
      const VerificationMeta('longitude');
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
      'longitude', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        customerId,
        addressTitle,
        addressType,
        addressLine1,
        addressLine2,
        city,
        state,
        apartment,
        country,
        zipCode,
        contactPerson,
        phoneNumber,
        isYourCompanyAddress,
        isPrimaryAddress,
        isShippingAddress,
        latitude,
        longitude,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'addres';
  @override
  VerificationContext validateIntegrity(Insertable<Addre> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id']!, _customerIdMeta));
    }
    if (data.containsKey('address_title')) {
      context.handle(
          _addressTitleMeta,
          addressTitle.isAcceptableOrUnknown(
              data['address_title']!, _addressTitleMeta));
    }
    if (data.containsKey('address_type')) {
      context.handle(
          _addressTypeMeta,
          addressType.isAcceptableOrUnknown(
              data['address_type']!, _addressTypeMeta));
    }
    if (data.containsKey('address_line1')) {
      context.handle(
          _addressLine1Meta,
          addressLine1.isAcceptableOrUnknown(
              data['address_line1']!, _addressLine1Meta));
    }
    if (data.containsKey('address_line2')) {
      context.handle(
          _addressLine2Meta,
          addressLine2.isAcceptableOrUnknown(
              data['address_line2']!, _addressLine2Meta));
    }
    if (data.containsKey('city')) {
      context.handle(
          _cityMeta, city.isAcceptableOrUnknown(data['city']!, _cityMeta));
    }
    if (data.containsKey('state')) {
      context.handle(
          _stateMeta, state.isAcceptableOrUnknown(data['state']!, _stateMeta));
    }
    if (data.containsKey('apartment')) {
      context.handle(_apartmentMeta,
          apartment.isAcceptableOrUnknown(data['apartment']!, _apartmentMeta));
    }
    if (data.containsKey('country')) {
      context.handle(_countryMeta,
          country.isAcceptableOrUnknown(data['country']!, _countryMeta));
    }
    if (data.containsKey('zip_code')) {
      context.handle(_zipCodeMeta,
          zipCode.isAcceptableOrUnknown(data['zip_code']!, _zipCodeMeta));
    }
    if (data.containsKey('contact_person')) {
      context.handle(
          _contactPersonMeta,
          contactPerson.isAcceptableOrUnknown(
              data['contact_person']!, _contactPersonMeta));
    }
    if (data.containsKey('phone_number')) {
      context.handle(
          _phoneNumberMeta,
          phoneNumber.isAcceptableOrUnknown(
              data['phone_number']!, _phoneNumberMeta));
    }
    if (data.containsKey('is_your_company_address')) {
      context.handle(
          _isYourCompanyAddressMeta,
          isYourCompanyAddress.isAcceptableOrUnknown(
              data['is_your_company_address']!, _isYourCompanyAddressMeta));
    }
    if (data.containsKey('is_primary_address')) {
      context.handle(
          _isPrimaryAddressMeta,
          isPrimaryAddress.isAcceptableOrUnknown(
              data['is_primary_address']!, _isPrimaryAddressMeta));
    }
    if (data.containsKey('is_shipping_address')) {
      context.handle(
          _isShippingAddressMeta,
          isShippingAddress.isAcceptableOrUnknown(
              data['is_shipping_address']!, _isShippingAddressMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Addre map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Addre(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      customerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_id']),
      addressTitle: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address_title']),
      addressType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address_type']),
      addressLine1: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address_line1']),
      addressLine2: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address_line2']),
      city: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}city']),
      state: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}state']),
      apartment: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}apartment']),
      country: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}country']),
      zipCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}zip_code']),
      contactPerson: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contact_person']),
      phoneNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}phone_number']),
      isYourCompanyAddress: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_your_company_address']),
      isPrimaryAddress: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_primary_address']),
      isShippingAddress: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_shipping_address']),
      latitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}latitude']),
      longitude: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}longitude']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted']),
    );
  }

  @override
  $AddresTable createAlias(String alias) {
    return $AddresTable(attachedDatabase, alias);
  }
}

class Addre extends DataClass implements Insertable<Addre> {
  final String? tenantId;
  final int id;
  final String? customerId;
  final String? addressTitle;
  final String? addressType;
  final String? addressLine1;
  final String? addressLine2;
  final String? city;
  final String? state;
  final String? apartment;
  final String? country;
  final String? zipCode;
  final String? contactPerson;
  final String? phoneNumber;
  final bool? isYourCompanyAddress;
  final bool? isPrimaryAddress;
  final bool? isShippingAddress;
  final double? latitude;
  final double? longitude;
  final bool? isDeleted;
  const Addre(
      {this.tenantId,
      required this.id,
      this.customerId,
      this.addressTitle,
      this.addressType,
      this.addressLine1,
      this.addressLine2,
      this.city,
      this.state,
      this.apartment,
      this.country,
      this.zipCode,
      this.contactPerson,
      this.phoneNumber,
      this.isYourCompanyAddress,
      this.isPrimaryAddress,
      this.isShippingAddress,
      this.latitude,
      this.longitude,
      this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || addressTitle != null) {
      map['address_title'] = Variable<String>(addressTitle);
    }
    if (!nullToAbsent || addressType != null) {
      map['address_type'] = Variable<String>(addressType);
    }
    if (!nullToAbsent || addressLine1 != null) {
      map['address_line1'] = Variable<String>(addressLine1);
    }
    if (!nullToAbsent || addressLine2 != null) {
      map['address_line2'] = Variable<String>(addressLine2);
    }
    if (!nullToAbsent || city != null) {
      map['city'] = Variable<String>(city);
    }
    if (!nullToAbsent || state != null) {
      map['state'] = Variable<String>(state);
    }
    if (!nullToAbsent || apartment != null) {
      map['apartment'] = Variable<String>(apartment);
    }
    if (!nullToAbsent || country != null) {
      map['country'] = Variable<String>(country);
    }
    if (!nullToAbsent || zipCode != null) {
      map['zip_code'] = Variable<String>(zipCode);
    }
    if (!nullToAbsent || contactPerson != null) {
      map['contact_person'] = Variable<String>(contactPerson);
    }
    if (!nullToAbsent || phoneNumber != null) {
      map['phone_number'] = Variable<String>(phoneNumber);
    }
    if (!nullToAbsent || isYourCompanyAddress != null) {
      map['is_your_company_address'] = Variable<bool>(isYourCompanyAddress);
    }
    if (!nullToAbsent || isPrimaryAddress != null) {
      map['is_primary_address'] = Variable<bool>(isPrimaryAddress);
    }
    if (!nullToAbsent || isShippingAddress != null) {
      map['is_shipping_address'] = Variable<bool>(isShippingAddress);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    return map;
  }

  AddresCompanion toCompanion(bool nullToAbsent) {
    return AddresCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      addressTitle: addressTitle == null && nullToAbsent
          ? const Value.absent()
          : Value(addressTitle),
      addressType: addressType == null && nullToAbsent
          ? const Value.absent()
          : Value(addressType),
      addressLine1: addressLine1 == null && nullToAbsent
          ? const Value.absent()
          : Value(addressLine1),
      addressLine2: addressLine2 == null && nullToAbsent
          ? const Value.absent()
          : Value(addressLine2),
      city: city == null && nullToAbsent ? const Value.absent() : Value(city),
      state:
          state == null && nullToAbsent ? const Value.absent() : Value(state),
      apartment: apartment == null && nullToAbsent
          ? const Value.absent()
          : Value(apartment),
      country: country == null && nullToAbsent
          ? const Value.absent()
          : Value(country),
      zipCode: zipCode == null && nullToAbsent
          ? const Value.absent()
          : Value(zipCode),
      contactPerson: contactPerson == null && nullToAbsent
          ? const Value.absent()
          : Value(contactPerson),
      phoneNumber: phoneNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(phoneNumber),
      isYourCompanyAddress: isYourCompanyAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(isYourCompanyAddress),
      isPrimaryAddress: isPrimaryAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(isPrimaryAddress),
      isShippingAddress: isShippingAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(isShippingAddress),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
    );
  }

  factory Addre.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Addre(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      customerId: serializer.fromJson<String?>(json['customerId']),
      addressTitle: serializer.fromJson<String?>(json['addressTitle']),
      addressType: serializer.fromJson<String?>(json['addressType']),
      addressLine1: serializer.fromJson<String?>(json['addressLine1']),
      addressLine2: serializer.fromJson<String?>(json['addressLine2']),
      city: serializer.fromJson<String?>(json['city']),
      state: serializer.fromJson<String?>(json['state']),
      apartment: serializer.fromJson<String?>(json['apartment']),
      country: serializer.fromJson<String?>(json['country']),
      zipCode: serializer.fromJson<String?>(json['zipCode']),
      contactPerson: serializer.fromJson<String?>(json['contactPerson']),
      phoneNumber: serializer.fromJson<String?>(json['phoneNumber']),
      isYourCompanyAddress:
          serializer.fromJson<bool?>(json['isYourCompanyAddress']),
      isPrimaryAddress: serializer.fromJson<bool?>(json['isPrimaryAddress']),
      isShippingAddress: serializer.fromJson<bool?>(json['isShippingAddress']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      isDeleted: serializer.fromJson<bool?>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'customerId': serializer.toJson<String?>(customerId),
      'addressTitle': serializer.toJson<String?>(addressTitle),
      'addressType': serializer.toJson<String?>(addressType),
      'addressLine1': serializer.toJson<String?>(addressLine1),
      'addressLine2': serializer.toJson<String?>(addressLine2),
      'city': serializer.toJson<String?>(city),
      'state': serializer.toJson<String?>(state),
      'apartment': serializer.toJson<String?>(apartment),
      'country': serializer.toJson<String?>(country),
      'zipCode': serializer.toJson<String?>(zipCode),
      'contactPerson': serializer.toJson<String?>(contactPerson),
      'phoneNumber': serializer.toJson<String?>(phoneNumber),
      'isYourCompanyAddress': serializer.toJson<bool?>(isYourCompanyAddress),
      'isPrimaryAddress': serializer.toJson<bool?>(isPrimaryAddress),
      'isShippingAddress': serializer.toJson<bool?>(isShippingAddress),
      'latitude': serializer.toJson<double?>(latitude),
      'longitude': serializer.toJson<double?>(longitude),
      'isDeleted': serializer.toJson<bool?>(isDeleted),
    };
  }

  Addre copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> customerId = const Value.absent(),
          Value<String?> addressTitle = const Value.absent(),
          Value<String?> addressType = const Value.absent(),
          Value<String?> addressLine1 = const Value.absent(),
          Value<String?> addressLine2 = const Value.absent(),
          Value<String?> city = const Value.absent(),
          Value<String?> state = const Value.absent(),
          Value<String?> apartment = const Value.absent(),
          Value<String?> country = const Value.absent(),
          Value<String?> zipCode = const Value.absent(),
          Value<String?> contactPerson = const Value.absent(),
          Value<String?> phoneNumber = const Value.absent(),
          Value<bool?> isYourCompanyAddress = const Value.absent(),
          Value<bool?> isPrimaryAddress = const Value.absent(),
          Value<bool?> isShippingAddress = const Value.absent(),
          Value<double?> latitude = const Value.absent(),
          Value<double?> longitude = const Value.absent(),
          Value<bool?> isDeleted = const Value.absent()}) =>
      Addre(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        customerId: customerId.present ? customerId.value : this.customerId,
        addressTitle:
            addressTitle.present ? addressTitle.value : this.addressTitle,
        addressType: addressType.present ? addressType.value : this.addressType,
        addressLine1:
            addressLine1.present ? addressLine1.value : this.addressLine1,
        addressLine2:
            addressLine2.present ? addressLine2.value : this.addressLine2,
        city: city.present ? city.value : this.city,
        state: state.present ? state.value : this.state,
        apartment: apartment.present ? apartment.value : this.apartment,
        country: country.present ? country.value : this.country,
        zipCode: zipCode.present ? zipCode.value : this.zipCode,
        contactPerson:
            contactPerson.present ? contactPerson.value : this.contactPerson,
        phoneNumber: phoneNumber.present ? phoneNumber.value : this.phoneNumber,
        isYourCompanyAddress: isYourCompanyAddress.present
            ? isYourCompanyAddress.value
            : this.isYourCompanyAddress,
        isPrimaryAddress: isPrimaryAddress.present
            ? isPrimaryAddress.value
            : this.isPrimaryAddress,
        isShippingAddress: isShippingAddress.present
            ? isShippingAddress.value
            : this.isShippingAddress,
        latitude: latitude.present ? latitude.value : this.latitude,
        longitude: longitude.present ? longitude.value : this.longitude,
        isDeleted: isDeleted.present ? isDeleted.value : this.isDeleted,
      );
  @override
  String toString() {
    return (StringBuffer('Addre(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('addressTitle: $addressTitle, ')
          ..write('addressType: $addressType, ')
          ..write('addressLine1: $addressLine1, ')
          ..write('addressLine2: $addressLine2, ')
          ..write('city: $city, ')
          ..write('state: $state, ')
          ..write('apartment: $apartment, ')
          ..write('country: $country, ')
          ..write('zipCode: $zipCode, ')
          ..write('contactPerson: $contactPerson, ')
          ..write('phoneNumber: $phoneNumber, ')
          ..write('isYourCompanyAddress: $isYourCompanyAddress, ')
          ..write('isPrimaryAddress: $isPrimaryAddress, ')
          ..write('isShippingAddress: $isShippingAddress, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      customerId,
      addressTitle,
      addressType,
      addressLine1,
      addressLine2,
      city,
      state,
      apartment,
      country,
      zipCode,
      contactPerson,
      phoneNumber,
      isYourCompanyAddress,
      isPrimaryAddress,
      isShippingAddress,
      latitude,
      longitude,
      isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Addre &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.customerId == this.customerId &&
          other.addressTitle == this.addressTitle &&
          other.addressType == this.addressType &&
          other.addressLine1 == this.addressLine1 &&
          other.addressLine2 == this.addressLine2 &&
          other.city == this.city &&
          other.state == this.state &&
          other.apartment == this.apartment &&
          other.country == this.country &&
          other.zipCode == this.zipCode &&
          other.contactPerson == this.contactPerson &&
          other.phoneNumber == this.phoneNumber &&
          other.isYourCompanyAddress == this.isYourCompanyAddress &&
          other.isPrimaryAddress == this.isPrimaryAddress &&
          other.isShippingAddress == this.isShippingAddress &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.isDeleted == this.isDeleted);
}

class AddresCompanion extends UpdateCompanion<Addre> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> customerId;
  final Value<String?> addressTitle;
  final Value<String?> addressType;
  final Value<String?> addressLine1;
  final Value<String?> addressLine2;
  final Value<String?> city;
  final Value<String?> state;
  final Value<String?> apartment;
  final Value<String?> country;
  final Value<String?> zipCode;
  final Value<String?> contactPerson;
  final Value<String?> phoneNumber;
  final Value<bool?> isYourCompanyAddress;
  final Value<bool?> isPrimaryAddress;
  final Value<bool?> isShippingAddress;
  final Value<double?> latitude;
  final Value<double?> longitude;
  final Value<bool?> isDeleted;
  const AddresCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.customerId = const Value.absent(),
    this.addressTitle = const Value.absent(),
    this.addressType = const Value.absent(),
    this.addressLine1 = const Value.absent(),
    this.addressLine2 = const Value.absent(),
    this.city = const Value.absent(),
    this.state = const Value.absent(),
    this.apartment = const Value.absent(),
    this.country = const Value.absent(),
    this.zipCode = const Value.absent(),
    this.contactPerson = const Value.absent(),
    this.phoneNumber = const Value.absent(),
    this.isYourCompanyAddress = const Value.absent(),
    this.isPrimaryAddress = const Value.absent(),
    this.isShippingAddress = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  AddresCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.customerId = const Value.absent(),
    this.addressTitle = const Value.absent(),
    this.addressType = const Value.absent(),
    this.addressLine1 = const Value.absent(),
    this.addressLine2 = const Value.absent(),
    this.city = const Value.absent(),
    this.state = const Value.absent(),
    this.apartment = const Value.absent(),
    this.country = const Value.absent(),
    this.zipCode = const Value.absent(),
    this.contactPerson = const Value.absent(),
    this.phoneNumber = const Value.absent(),
    this.isYourCompanyAddress = const Value.absent(),
    this.isPrimaryAddress = const Value.absent(),
    this.isShippingAddress = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  static Insertable<Addre> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? customerId,
    Expression<String>? addressTitle,
    Expression<String>? addressType,
    Expression<String>? addressLine1,
    Expression<String>? addressLine2,
    Expression<String>? city,
    Expression<String>? state,
    Expression<String>? apartment,
    Expression<String>? country,
    Expression<String>? zipCode,
    Expression<String>? contactPerson,
    Expression<String>? phoneNumber,
    Expression<bool>? isYourCompanyAddress,
    Expression<bool>? isPrimaryAddress,
    Expression<bool>? isShippingAddress,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (customerId != null) 'customer_id': customerId,
      if (addressTitle != null) 'address_title': addressTitle,
      if (addressType != null) 'address_type': addressType,
      if (addressLine1 != null) 'address_line1': addressLine1,
      if (addressLine2 != null) 'address_line2': addressLine2,
      if (city != null) 'city': city,
      if (state != null) 'state': state,
      if (apartment != null) 'apartment': apartment,
      if (country != null) 'country': country,
      if (zipCode != null) 'zip_code': zipCode,
      if (contactPerson != null) 'contact_person': contactPerson,
      if (phoneNumber != null) 'phone_number': phoneNumber,
      if (isYourCompanyAddress != null)
        'is_your_company_address': isYourCompanyAddress,
      if (isPrimaryAddress != null) 'is_primary_address': isPrimaryAddress,
      if (isShippingAddress != null) 'is_shipping_address': isShippingAddress,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  AddresCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? customerId,
      Value<String?>? addressTitle,
      Value<String?>? addressType,
      Value<String?>? addressLine1,
      Value<String?>? addressLine2,
      Value<String?>? city,
      Value<String?>? state,
      Value<String?>? apartment,
      Value<String?>? country,
      Value<String?>? zipCode,
      Value<String?>? contactPerson,
      Value<String?>? phoneNumber,
      Value<bool?>? isYourCompanyAddress,
      Value<bool?>? isPrimaryAddress,
      Value<bool?>? isShippingAddress,
      Value<double?>? latitude,
      Value<double?>? longitude,
      Value<bool?>? isDeleted}) {
    return AddresCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      customerId: customerId ?? this.customerId,
      addressTitle: addressTitle ?? this.addressTitle,
      addressType: addressType ?? this.addressType,
      addressLine1: addressLine1 ?? this.addressLine1,
      addressLine2: addressLine2 ?? this.addressLine2,
      city: city ?? this.city,
      state: state ?? this.state,
      apartment: apartment ?? this.apartment,
      country: country ?? this.country,
      zipCode: zipCode ?? this.zipCode,
      contactPerson: contactPerson ?? this.contactPerson,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      isYourCompanyAddress: isYourCompanyAddress ?? this.isYourCompanyAddress,
      isPrimaryAddress: isPrimaryAddress ?? this.isPrimaryAddress,
      isShippingAddress: isShippingAddress ?? this.isShippingAddress,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (addressTitle.present) {
      map['address_title'] = Variable<String>(addressTitle.value);
    }
    if (addressType.present) {
      map['address_type'] = Variable<String>(addressType.value);
    }
    if (addressLine1.present) {
      map['address_line1'] = Variable<String>(addressLine1.value);
    }
    if (addressLine2.present) {
      map['address_line2'] = Variable<String>(addressLine2.value);
    }
    if (city.present) {
      map['city'] = Variable<String>(city.value);
    }
    if (state.present) {
      map['state'] = Variable<String>(state.value);
    }
    if (apartment.present) {
      map['apartment'] = Variable<String>(apartment.value);
    }
    if (country.present) {
      map['country'] = Variable<String>(country.value);
    }
    if (zipCode.present) {
      map['zip_code'] = Variable<String>(zipCode.value);
    }
    if (contactPerson.present) {
      map['contact_person'] = Variable<String>(contactPerson.value);
    }
    if (phoneNumber.present) {
      map['phone_number'] = Variable<String>(phoneNumber.value);
    }
    if (isYourCompanyAddress.present) {
      map['is_your_company_address'] =
          Variable<bool>(isYourCompanyAddress.value);
    }
    if (isPrimaryAddress.present) {
      map['is_primary_address'] = Variable<bool>(isPrimaryAddress.value);
    }
    if (isShippingAddress.present) {
      map['is_shipping_address'] = Variable<bool>(isShippingAddress.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AddresCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('addressTitle: $addressTitle, ')
          ..write('addressType: $addressType, ')
          ..write('addressLine1: $addressLine1, ')
          ..write('addressLine2: $addressLine2, ')
          ..write('city: $city, ')
          ..write('state: $state, ')
          ..write('apartment: $apartment, ')
          ..write('country: $country, ')
          ..write('zipCode: $zipCode, ')
          ..write('contactPerson: $contactPerson, ')
          ..write('phoneNumber: $phoneNumber, ')
          ..write('isYourCompanyAddress: $isYourCompanyAddress, ')
          ..write('isPrimaryAddress: $isPrimaryAddress, ')
          ..write('isShippingAddress: $isShippingAddress, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $ContactTable extends Contact with TableInfo<$ContactTable, ContactData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ContactTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _contactTitleMeta =
      const VerificationMeta('contactTitle');
  @override
  late final GeneratedColumn<String> contactTitle = GeneratedColumn<String>(
      'contact_title', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerIdMeta =
      const VerificationMeta('customerId');
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
      'customer_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _contactPersonMeta =
      const VerificationMeta('contactPerson');
  @override
  late final GeneratedColumn<String> contactPerson = GeneratedColumn<String>(
      'contact_person', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _workNumberMeta =
      const VerificationMeta('workNumber');
  @override
  late final GeneratedColumn<String> workNumber = GeneratedColumn<String>(
      'work_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _cellNumberMeta =
      const VerificationMeta('cellNumber');
  @override
  late final GeneratedColumn<String> cellNumber = GeneratedColumn<String>(
      'cell_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _whatappNumberMeta =
      const VerificationMeta('whatappNumber');
  @override
  late final GeneratedColumn<String> whatappNumber = GeneratedColumn<String>(
      'whatapp_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isYourCompanyContactMeta =
      const VerificationMeta('isYourCompanyContact');
  @override
  late final GeneratedColumn<bool> isYourCompanyContact = GeneratedColumn<bool>(
      'is_your_company_contact', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_your_company_contact" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isPrimaryContactMeta =
      const VerificationMeta('isPrimaryContact');
  @override
  late final GeneratedColumn<bool> isPrimaryContact = GeneratedColumn<bool>(
      'is_primary_contact', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_primary_contact" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isUserContactMeta =
      const VerificationMeta('isUserContact');
  @override
  late final GeneratedColumn<bool> isUserContact = GeneratedColumn<bool>(
      'is_user_contact', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_user_contact" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        contactTitle,
        customerId,
        contactPerson,
        workNumber,
        cellNumber,
        whatappNumber,
        isYourCompanyContact,
        isPrimaryContact,
        isUserContact,
        userName
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'contact';
  @override
  VerificationContext validateIntegrity(Insertable<ContactData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('contact_title')) {
      context.handle(
          _contactTitleMeta,
          contactTitle.isAcceptableOrUnknown(
              data['contact_title']!, _contactTitleMeta));
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id']!, _customerIdMeta));
    }
    if (data.containsKey('contact_person')) {
      context.handle(
          _contactPersonMeta,
          contactPerson.isAcceptableOrUnknown(
              data['contact_person']!, _contactPersonMeta));
    }
    if (data.containsKey('work_number')) {
      context.handle(
          _workNumberMeta,
          workNumber.isAcceptableOrUnknown(
              data['work_number']!, _workNumberMeta));
    }
    if (data.containsKey('cell_number')) {
      context.handle(
          _cellNumberMeta,
          cellNumber.isAcceptableOrUnknown(
              data['cell_number']!, _cellNumberMeta));
    }
    if (data.containsKey('whatapp_number')) {
      context.handle(
          _whatappNumberMeta,
          whatappNumber.isAcceptableOrUnknown(
              data['whatapp_number']!, _whatappNumberMeta));
    }
    if (data.containsKey('is_your_company_contact')) {
      context.handle(
          _isYourCompanyContactMeta,
          isYourCompanyContact.isAcceptableOrUnknown(
              data['is_your_company_contact']!, _isYourCompanyContactMeta));
    }
    if (data.containsKey('is_primary_contact')) {
      context.handle(
          _isPrimaryContactMeta,
          isPrimaryContact.isAcceptableOrUnknown(
              data['is_primary_contact']!, _isPrimaryContactMeta));
    }
    if (data.containsKey('is_user_contact')) {
      context.handle(
          _isUserContactMeta,
          isUserContact.isAcceptableOrUnknown(
              data['is_user_contact']!, _isUserContactMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ContactData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ContactData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      contactTitle: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contact_title']),
      customerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_id']),
      contactPerson: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}contact_person']),
      workNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}work_number']),
      cellNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cell_number']),
      whatappNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}whatapp_number']),
      isYourCompanyContact: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_your_company_contact']),
      isPrimaryContact: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_primary_contact']),
      isUserContact: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_user_contact']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
    );
  }

  @override
  $ContactTable createAlias(String alias) {
    return $ContactTable(attachedDatabase, alias);
  }
}

class ContactData extends DataClass implements Insertable<ContactData> {
  final String? tenantId;
  final int id;
  final String? contactTitle;
  final String? customerId;
  final String? contactPerson;
  final String? workNumber;
  final String? cellNumber;
  final String? whatappNumber;
  final bool? isYourCompanyContact;
  final bool? isPrimaryContact;
  final bool? isUserContact;
  final String? userName;
  const ContactData(
      {this.tenantId,
      required this.id,
      this.contactTitle,
      this.customerId,
      this.contactPerson,
      this.workNumber,
      this.cellNumber,
      this.whatappNumber,
      this.isYourCompanyContact,
      this.isPrimaryContact,
      this.isUserContact,
      this.userName});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || contactTitle != null) {
      map['contact_title'] = Variable<String>(contactTitle);
    }
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || contactPerson != null) {
      map['contact_person'] = Variable<String>(contactPerson);
    }
    if (!nullToAbsent || workNumber != null) {
      map['work_number'] = Variable<String>(workNumber);
    }
    if (!nullToAbsent || cellNumber != null) {
      map['cell_number'] = Variable<String>(cellNumber);
    }
    if (!nullToAbsent || whatappNumber != null) {
      map['whatapp_number'] = Variable<String>(whatappNumber);
    }
    if (!nullToAbsent || isYourCompanyContact != null) {
      map['is_your_company_contact'] = Variable<bool>(isYourCompanyContact);
    }
    if (!nullToAbsent || isPrimaryContact != null) {
      map['is_primary_contact'] = Variable<bool>(isPrimaryContact);
    }
    if (!nullToAbsent || isUserContact != null) {
      map['is_user_contact'] = Variable<bool>(isUserContact);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    return map;
  }

  ContactCompanion toCompanion(bool nullToAbsent) {
    return ContactCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      contactTitle: contactTitle == null && nullToAbsent
          ? const Value.absent()
          : Value(contactTitle),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      contactPerson: contactPerson == null && nullToAbsent
          ? const Value.absent()
          : Value(contactPerson),
      workNumber: workNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(workNumber),
      cellNumber: cellNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(cellNumber),
      whatappNumber: whatappNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(whatappNumber),
      isYourCompanyContact: isYourCompanyContact == null && nullToAbsent
          ? const Value.absent()
          : Value(isYourCompanyContact),
      isPrimaryContact: isPrimaryContact == null && nullToAbsent
          ? const Value.absent()
          : Value(isPrimaryContact),
      isUserContact: isUserContact == null && nullToAbsent
          ? const Value.absent()
          : Value(isUserContact),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
    );
  }

  factory ContactData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ContactData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      contactTitle: serializer.fromJson<String?>(json['contactTitle']),
      customerId: serializer.fromJson<String?>(json['customerId']),
      contactPerson: serializer.fromJson<String?>(json['contactPerson']),
      workNumber: serializer.fromJson<String?>(json['workNumber']),
      cellNumber: serializer.fromJson<String?>(json['cellNumber']),
      whatappNumber: serializer.fromJson<String?>(json['whatappNumber']),
      isYourCompanyContact:
          serializer.fromJson<bool?>(json['isYourCompanyContact']),
      isPrimaryContact: serializer.fromJson<bool?>(json['isPrimaryContact']),
      isUserContact: serializer.fromJson<bool?>(json['isUserContact']),
      userName: serializer.fromJson<String?>(json['userName']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'contactTitle': serializer.toJson<String?>(contactTitle),
      'customerId': serializer.toJson<String?>(customerId),
      'contactPerson': serializer.toJson<String?>(contactPerson),
      'workNumber': serializer.toJson<String?>(workNumber),
      'cellNumber': serializer.toJson<String?>(cellNumber),
      'whatappNumber': serializer.toJson<String?>(whatappNumber),
      'isYourCompanyContact': serializer.toJson<bool?>(isYourCompanyContact),
      'isPrimaryContact': serializer.toJson<bool?>(isPrimaryContact),
      'isUserContact': serializer.toJson<bool?>(isUserContact),
      'userName': serializer.toJson<String?>(userName),
    };
  }

  ContactData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> contactTitle = const Value.absent(),
          Value<String?> customerId = const Value.absent(),
          Value<String?> contactPerson = const Value.absent(),
          Value<String?> workNumber = const Value.absent(),
          Value<String?> cellNumber = const Value.absent(),
          Value<String?> whatappNumber = const Value.absent(),
          Value<bool?> isYourCompanyContact = const Value.absent(),
          Value<bool?> isPrimaryContact = const Value.absent(),
          Value<bool?> isUserContact = const Value.absent(),
          Value<String?> userName = const Value.absent()}) =>
      ContactData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        contactTitle:
            contactTitle.present ? contactTitle.value : this.contactTitle,
        customerId: customerId.present ? customerId.value : this.customerId,
        contactPerson:
            contactPerson.present ? contactPerson.value : this.contactPerson,
        workNumber: workNumber.present ? workNumber.value : this.workNumber,
        cellNumber: cellNumber.present ? cellNumber.value : this.cellNumber,
        whatappNumber:
            whatappNumber.present ? whatappNumber.value : this.whatappNumber,
        isYourCompanyContact: isYourCompanyContact.present
            ? isYourCompanyContact.value
            : this.isYourCompanyContact,
        isPrimaryContact: isPrimaryContact.present
            ? isPrimaryContact.value
            : this.isPrimaryContact,
        isUserContact:
            isUserContact.present ? isUserContact.value : this.isUserContact,
        userName: userName.present ? userName.value : this.userName,
      );
  @override
  String toString() {
    return (StringBuffer('ContactData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('contactTitle: $contactTitle, ')
          ..write('customerId: $customerId, ')
          ..write('contactPerson: $contactPerson, ')
          ..write('workNumber: $workNumber, ')
          ..write('cellNumber: $cellNumber, ')
          ..write('whatappNumber: $whatappNumber, ')
          ..write('isYourCompanyContact: $isYourCompanyContact, ')
          ..write('isPrimaryContact: $isPrimaryContact, ')
          ..write('isUserContact: $isUserContact, ')
          ..write('userName: $userName')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      contactTitle,
      customerId,
      contactPerson,
      workNumber,
      cellNumber,
      whatappNumber,
      isYourCompanyContact,
      isPrimaryContact,
      isUserContact,
      userName);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ContactData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.contactTitle == this.contactTitle &&
          other.customerId == this.customerId &&
          other.contactPerson == this.contactPerson &&
          other.workNumber == this.workNumber &&
          other.cellNumber == this.cellNumber &&
          other.whatappNumber == this.whatappNumber &&
          other.isYourCompanyContact == this.isYourCompanyContact &&
          other.isPrimaryContact == this.isPrimaryContact &&
          other.isUserContact == this.isUserContact &&
          other.userName == this.userName);
}

class ContactCompanion extends UpdateCompanion<ContactData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> contactTitle;
  final Value<String?> customerId;
  final Value<String?> contactPerson;
  final Value<String?> workNumber;
  final Value<String?> cellNumber;
  final Value<String?> whatappNumber;
  final Value<bool?> isYourCompanyContact;
  final Value<bool?> isPrimaryContact;
  final Value<bool?> isUserContact;
  final Value<String?> userName;
  const ContactCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.contactTitle = const Value.absent(),
    this.customerId = const Value.absent(),
    this.contactPerson = const Value.absent(),
    this.workNumber = const Value.absent(),
    this.cellNumber = const Value.absent(),
    this.whatappNumber = const Value.absent(),
    this.isYourCompanyContact = const Value.absent(),
    this.isPrimaryContact = const Value.absent(),
    this.isUserContact = const Value.absent(),
    this.userName = const Value.absent(),
  });
  ContactCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.contactTitle = const Value.absent(),
    this.customerId = const Value.absent(),
    this.contactPerson = const Value.absent(),
    this.workNumber = const Value.absent(),
    this.cellNumber = const Value.absent(),
    this.whatappNumber = const Value.absent(),
    this.isYourCompanyContact = const Value.absent(),
    this.isPrimaryContact = const Value.absent(),
    this.isUserContact = const Value.absent(),
    this.userName = const Value.absent(),
  });
  static Insertable<ContactData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? contactTitle,
    Expression<String>? customerId,
    Expression<String>? contactPerson,
    Expression<String>? workNumber,
    Expression<String>? cellNumber,
    Expression<String>? whatappNumber,
    Expression<bool>? isYourCompanyContact,
    Expression<bool>? isPrimaryContact,
    Expression<bool>? isUserContact,
    Expression<String>? userName,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (contactTitle != null) 'contact_title': contactTitle,
      if (customerId != null) 'customer_id': customerId,
      if (contactPerson != null) 'contact_person': contactPerson,
      if (workNumber != null) 'work_number': workNumber,
      if (cellNumber != null) 'cell_number': cellNumber,
      if (whatappNumber != null) 'whatapp_number': whatappNumber,
      if (isYourCompanyContact != null)
        'is_your_company_contact': isYourCompanyContact,
      if (isPrimaryContact != null) 'is_primary_contact': isPrimaryContact,
      if (isUserContact != null) 'is_user_contact': isUserContact,
      if (userName != null) 'user_name': userName,
    });
  }

  ContactCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? contactTitle,
      Value<String?>? customerId,
      Value<String?>? contactPerson,
      Value<String?>? workNumber,
      Value<String?>? cellNumber,
      Value<String?>? whatappNumber,
      Value<bool?>? isYourCompanyContact,
      Value<bool?>? isPrimaryContact,
      Value<bool?>? isUserContact,
      Value<String?>? userName}) {
    return ContactCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      contactTitle: contactTitle ?? this.contactTitle,
      customerId: customerId ?? this.customerId,
      contactPerson: contactPerson ?? this.contactPerson,
      workNumber: workNumber ?? this.workNumber,
      cellNumber: cellNumber ?? this.cellNumber,
      whatappNumber: whatappNumber ?? this.whatappNumber,
      isYourCompanyContact: isYourCompanyContact ?? this.isYourCompanyContact,
      isPrimaryContact: isPrimaryContact ?? this.isPrimaryContact,
      isUserContact: isUserContact ?? this.isUserContact,
      userName: userName ?? this.userName,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (contactTitle.present) {
      map['contact_title'] = Variable<String>(contactTitle.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (contactPerson.present) {
      map['contact_person'] = Variable<String>(contactPerson.value);
    }
    if (workNumber.present) {
      map['work_number'] = Variable<String>(workNumber.value);
    }
    if (cellNumber.present) {
      map['cell_number'] = Variable<String>(cellNumber.value);
    }
    if (whatappNumber.present) {
      map['whatapp_number'] = Variable<String>(whatappNumber.value);
    }
    if (isYourCompanyContact.present) {
      map['is_your_company_contact'] =
          Variable<bool>(isYourCompanyContact.value);
    }
    if (isPrimaryContact.present) {
      map['is_primary_contact'] = Variable<bool>(isPrimaryContact.value);
    }
    if (isUserContact.present) {
      map['is_user_contact'] = Variable<bool>(isUserContact.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ContactCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('contactTitle: $contactTitle, ')
          ..write('customerId: $customerId, ')
          ..write('contactPerson: $contactPerson, ')
          ..write('workNumber: $workNumber, ')
          ..write('cellNumber: $cellNumber, ')
          ..write('whatappNumber: $whatappNumber, ')
          ..write('isYourCompanyContact: $isYourCompanyContact, ')
          ..write('isPrimaryContact: $isPrimaryContact, ')
          ..write('isUserContact: $isUserContact, ')
          ..write('userName: $userName')
          ..write(')'))
        .toString();
  }
}

class $ItemsTable extends Items with TableInfo<$ItemsTable, Item> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
      'item_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemCodeMeta =
      const VerificationMeta('itemCode');
  @override
  late final GeneratedColumn<String> itemCode = GeneratedColumn<String>(
      'item_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemNameMeta =
      const VerificationMeta('itemName');
  @override
  late final GeneratedColumn<String> itemName = GeneratedColumn<String>(
      'item_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemGroupMeta =
      const VerificationMeta('itemGroup');
  @override
  late final GeneratedColumn<String> itemGroup = GeneratedColumn<String>(
      'item_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _taxGroupMeta =
      const VerificationMeta('taxGroup');
  @override
  late final GeneratedColumn<String> taxGroup = GeneratedColumn<String>(
      'tax_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _uomMeta = const VerificationMeta('uom');
  @override
  late final GeneratedColumn<String> uom = GeneratedColumn<String>(
      'uom', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _trackInventoryMeta =
      const VerificationMeta('trackInventory');
  @override
  late final GeneratedColumn<bool> trackInventory = GeneratedColumn<bool>(
      'track_inventory', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("track_inventory" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _categoryMeta =
      const VerificationMeta('category');
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
      'category', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isProductBundleParentMeta =
      const VerificationMeta('isProductBundleParent');
  @override
  late final GeneratedColumn<bool> isProductBundleParent =
      GeneratedColumn<bool>('is_product_bundle_parent', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          defaultConstraints: GeneratedColumn.constraintIsAlways(
              'CHECK ("is_product_bundle_parent" IN (0, 1))'),
          defaultValue: Constant(false));
  static const VerificationMeta _isQuickMenueMeta =
      const VerificationMeta('isQuickMenue');
  @override
  late final GeneratedColumn<bool> isQuickMenue = GeneratedColumn<bool>(
      'is_quick_menue', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_quick_menue" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isRetiredMeta =
      const VerificationMeta('isRetired');
  @override
  late final GeneratedColumn<bool> isRetired = GeneratedColumn<bool>(
      'is_retired', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_retired" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _retiredDateMeta =
      const VerificationMeta('retiredDate');
  @override
  late final GeneratedColumn<DateTime> retiredDate = GeneratedColumn<DateTime>(
      'retired_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _hasVariantMeta =
      const VerificationMeta('hasVariant');
  @override
  late final GeneratedColumn<bool> hasVariant = GeneratedColumn<bool>(
      'has_variant', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("has_variant" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _defaultWarehouseMeta =
      const VerificationMeta('defaultWarehouse');
  @override
  late final GeneratedColumn<String> defaultWarehouse = GeneratedColumn<String>(
      'default_warehouse', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        itemId,
        description,
        itemCode,
        itemName,
        itemGroup,
        taxGroup,
        uom,
        trackInventory,
        category,
        isProductBundleParent,
        isQuickMenue,
        isRetired,
        retiredDate,
        hasVariant,
        defaultWarehouse,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'items';
  @override
  VerificationContext validateIntegrity(Insertable<Item> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code']!, _itemCodeMeta));
    }
    if (data.containsKey('item_name')) {
      context.handle(_itemNameMeta,
          itemName.isAcceptableOrUnknown(data['item_name']!, _itemNameMeta));
    }
    if (data.containsKey('item_group')) {
      context.handle(_itemGroupMeta,
          itemGroup.isAcceptableOrUnknown(data['item_group']!, _itemGroupMeta));
    }
    if (data.containsKey('tax_group')) {
      context.handle(_taxGroupMeta,
          taxGroup.isAcceptableOrUnknown(data['tax_group']!, _taxGroupMeta));
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom']!, _uomMeta));
    }
    if (data.containsKey('track_inventory')) {
      context.handle(
          _trackInventoryMeta,
          trackInventory.isAcceptableOrUnknown(
              data['track_inventory']!, _trackInventoryMeta));
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category']!, _categoryMeta));
    }
    if (data.containsKey('is_product_bundle_parent')) {
      context.handle(
          _isProductBundleParentMeta,
          isProductBundleParent.isAcceptableOrUnknown(
              data['is_product_bundle_parent']!, _isProductBundleParentMeta));
    }
    if (data.containsKey('is_quick_menue')) {
      context.handle(
          _isQuickMenueMeta,
          isQuickMenue.isAcceptableOrUnknown(
              data['is_quick_menue']!, _isQuickMenueMeta));
    }
    if (data.containsKey('is_retired')) {
      context.handle(_isRetiredMeta,
          isRetired.isAcceptableOrUnknown(data['is_retired']!, _isRetiredMeta));
    }
    if (data.containsKey('retired_date')) {
      context.handle(
          _retiredDateMeta,
          retiredDate.isAcceptableOrUnknown(
              data['retired_date']!, _retiredDateMeta));
    }
    if (data.containsKey('has_variant')) {
      context.handle(
          _hasVariantMeta,
          hasVariant.isAcceptableOrUnknown(
              data['has_variant']!, _hasVariantMeta));
    }
    if (data.containsKey('default_warehouse')) {
      context.handle(
          _defaultWarehouseMeta,
          defaultWarehouse.isAcceptableOrUnknown(
              data['default_warehouse']!, _defaultWarehouseMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {itemId};
  @override
  Item map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Item(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_id'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      itemCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_code']),
      itemName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_name']),
      itemGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_group']),
      taxGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tax_group']),
      uom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uom']),
      trackInventory: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}track_inventory'])!,
      category: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}category']),
      isProductBundleParent: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}is_product_bundle_parent'])!,
      isQuickMenue: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_quick_menue'])!,
      isRetired: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_retired'])!,
      retiredDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}retired_date']),
      hasVariant: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}has_variant'])!,
      defaultWarehouse: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}default_warehouse']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $ItemsTable createAlias(String alias) {
    return $ItemsTable(attachedDatabase, alias);
  }
}

class Item extends DataClass implements Insertable<Item> {
  final String? tenantId;
  final int id;
  final String itemId;
  final String? description;
  final String? itemCode;
  final String? itemName;
  final String? itemGroup;
  final String? taxGroup;
  final String? uom;
  final bool trackInventory;
  final String? category;
  final bool isProductBundleParent;
  final bool isQuickMenue;
  final bool isRetired;
  final DateTime? retiredDate;
  final bool hasVariant;
  final String? defaultWarehouse;
  final bool isDeleted;
  const Item(
      {this.tenantId,
      required this.id,
      required this.itemId,
      this.description,
      this.itemCode,
      this.itemName,
      this.itemGroup,
      this.taxGroup,
      this.uom,
      required this.trackInventory,
      this.category,
      required this.isProductBundleParent,
      required this.isQuickMenue,
      required this.isRetired,
      this.retiredDate,
      required this.hasVariant,
      this.defaultWarehouse,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    map['item_id'] = Variable<String>(itemId);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || itemName != null) {
      map['item_name'] = Variable<String>(itemName);
    }
    if (!nullToAbsent || itemGroup != null) {
      map['item_group'] = Variable<String>(itemGroup);
    }
    if (!nullToAbsent || taxGroup != null) {
      map['tax_group'] = Variable<String>(taxGroup);
    }
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    map['track_inventory'] = Variable<bool>(trackInventory);
    if (!nullToAbsent || category != null) {
      map['category'] = Variable<String>(category);
    }
    map['is_product_bundle_parent'] = Variable<bool>(isProductBundleParent);
    map['is_quick_menue'] = Variable<bool>(isQuickMenue);
    map['is_retired'] = Variable<bool>(isRetired);
    if (!nullToAbsent || retiredDate != null) {
      map['retired_date'] = Variable<DateTime>(retiredDate);
    }
    map['has_variant'] = Variable<bool>(hasVariant);
    if (!nullToAbsent || defaultWarehouse != null) {
      map['default_warehouse'] = Variable<String>(defaultWarehouse);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  ItemsCompanion toCompanion(bool nullToAbsent) {
    return ItemsCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      itemId: Value(itemId),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      itemName: itemName == null && nullToAbsent
          ? const Value.absent()
          : Value(itemName),
      itemGroup: itemGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(itemGroup),
      taxGroup: taxGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(taxGroup),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
      trackInventory: Value(trackInventory),
      category: category == null && nullToAbsent
          ? const Value.absent()
          : Value(category),
      isProductBundleParent: Value(isProductBundleParent),
      isQuickMenue: Value(isQuickMenue),
      isRetired: Value(isRetired),
      retiredDate: retiredDate == null && nullToAbsent
          ? const Value.absent()
          : Value(retiredDate),
      hasVariant: Value(hasVariant),
      defaultWarehouse: defaultWarehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultWarehouse),
      isDeleted: Value(isDeleted),
    );
  }

  factory Item.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Item(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<String>(json['itemId']),
      description: serializer.fromJson<String?>(json['description']),
      itemCode: serializer.fromJson<String?>(json['itemCode']),
      itemName: serializer.fromJson<String?>(json['itemName']),
      itemGroup: serializer.fromJson<String?>(json['itemGroup']),
      taxGroup: serializer.fromJson<String?>(json['taxGroup']),
      uom: serializer.fromJson<String?>(json['uom']),
      trackInventory: serializer.fromJson<bool>(json['trackInventory']),
      category: serializer.fromJson<String?>(json['category']),
      isProductBundleParent:
          serializer.fromJson<bool>(json['isProductBundleParent']),
      isQuickMenue: serializer.fromJson<bool>(json['isQuickMenue']),
      isRetired: serializer.fromJson<bool>(json['isRetired']),
      retiredDate: serializer.fromJson<DateTime?>(json['retiredDate']),
      hasVariant: serializer.fromJson<bool>(json['hasVariant']),
      defaultWarehouse: serializer.fromJson<String?>(json['defaultWarehouse']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemId': serializer.toJson<String>(itemId),
      'description': serializer.toJson<String?>(description),
      'itemCode': serializer.toJson<String?>(itemCode),
      'itemName': serializer.toJson<String?>(itemName),
      'itemGroup': serializer.toJson<String?>(itemGroup),
      'taxGroup': serializer.toJson<String?>(taxGroup),
      'uom': serializer.toJson<String?>(uom),
      'trackInventory': serializer.toJson<bool>(trackInventory),
      'category': serializer.toJson<String?>(category),
      'isProductBundleParent': serializer.toJson<bool>(isProductBundleParent),
      'isQuickMenue': serializer.toJson<bool>(isQuickMenue),
      'isRetired': serializer.toJson<bool>(isRetired),
      'retiredDate': serializer.toJson<DateTime?>(retiredDate),
      'hasVariant': serializer.toJson<bool>(hasVariant),
      'defaultWarehouse': serializer.toJson<String?>(defaultWarehouse),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  Item copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          String? itemId,
          Value<String?> description = const Value.absent(),
          Value<String?> itemCode = const Value.absent(),
          Value<String?> itemName = const Value.absent(),
          Value<String?> itemGroup = const Value.absent(),
          Value<String?> taxGroup = const Value.absent(),
          Value<String?> uom = const Value.absent(),
          bool? trackInventory,
          Value<String?> category = const Value.absent(),
          bool? isProductBundleParent,
          bool? isQuickMenue,
          bool? isRetired,
          Value<DateTime?> retiredDate = const Value.absent(),
          bool? hasVariant,
          Value<String?> defaultWarehouse = const Value.absent(),
          bool? isDeleted}) =>
      Item(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        description: description.present ? description.value : this.description,
        itemCode: itemCode.present ? itemCode.value : this.itemCode,
        itemName: itemName.present ? itemName.value : this.itemName,
        itemGroup: itemGroup.present ? itemGroup.value : this.itemGroup,
        taxGroup: taxGroup.present ? taxGroup.value : this.taxGroup,
        uom: uom.present ? uom.value : this.uom,
        trackInventory: trackInventory ?? this.trackInventory,
        category: category.present ? category.value : this.category,
        isProductBundleParent:
            isProductBundleParent ?? this.isProductBundleParent,
        isQuickMenue: isQuickMenue ?? this.isQuickMenue,
        isRetired: isRetired ?? this.isRetired,
        retiredDate: retiredDate.present ? retiredDate.value : this.retiredDate,
        hasVariant: hasVariant ?? this.hasVariant,
        defaultWarehouse: defaultWarehouse.present
            ? defaultWarehouse.value
            : this.defaultWarehouse,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  @override
  String toString() {
    return (StringBuffer('Item(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('description: $description, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('uom: $uom, ')
          ..write('trackInventory: $trackInventory, ')
          ..write('category: $category, ')
          ..write('isProductBundleParent: $isProductBundleParent, ')
          ..write('isQuickMenue: $isQuickMenue, ')
          ..write('isRetired: $isRetired, ')
          ..write('retiredDate: $retiredDate, ')
          ..write('hasVariant: $hasVariant, ')
          ..write('defaultWarehouse: $defaultWarehouse, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      itemId,
      description,
      itemCode,
      itemName,
      itemGroup,
      taxGroup,
      uom,
      trackInventory,
      category,
      isProductBundleParent,
      isQuickMenue,
      isRetired,
      retiredDate,
      hasVariant,
      defaultWarehouse,
      isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Item &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.description == this.description &&
          other.itemCode == this.itemCode &&
          other.itemName == this.itemName &&
          other.itemGroup == this.itemGroup &&
          other.taxGroup == this.taxGroup &&
          other.uom == this.uom &&
          other.trackInventory == this.trackInventory &&
          other.category == this.category &&
          other.isProductBundleParent == this.isProductBundleParent &&
          other.isQuickMenue == this.isQuickMenue &&
          other.isRetired == this.isRetired &&
          other.retiredDate == this.retiredDate &&
          other.hasVariant == this.hasVariant &&
          other.defaultWarehouse == this.defaultWarehouse &&
          other.isDeleted == this.isDeleted);
}

class ItemsCompanion extends UpdateCompanion<Item> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String> itemId;
  final Value<String?> description;
  final Value<String?> itemCode;
  final Value<String?> itemName;
  final Value<String?> itemGroup;
  final Value<String?> taxGroup;
  final Value<String?> uom;
  final Value<bool> trackInventory;
  final Value<String?> category;
  final Value<bool> isProductBundleParent;
  final Value<bool> isQuickMenue;
  final Value<bool> isRetired;
  final Value<DateTime?> retiredDate;
  final Value<bool> hasVariant;
  final Value<String?> defaultWarehouse;
  final Value<bool> isDeleted;
  final Value<int> rowid;
  const ItemsCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.description = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.taxGroup = const Value.absent(),
    this.uom = const Value.absent(),
    this.trackInventory = const Value.absent(),
    this.category = const Value.absent(),
    this.isProductBundleParent = const Value.absent(),
    this.isQuickMenue = const Value.absent(),
    this.isRetired = const Value.absent(),
    this.retiredDate = const Value.absent(),
    this.hasVariant = const Value.absent(),
    this.defaultWarehouse = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ItemsCompanion.insert({
    this.tenantId = const Value.absent(),
    required int id,
    required String itemId,
    this.description = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.taxGroup = const Value.absent(),
    this.uom = const Value.absent(),
    this.trackInventory = const Value.absent(),
    this.category = const Value.absent(),
    this.isProductBundleParent = const Value.absent(),
    this.isQuickMenue = const Value.absent(),
    this.isRetired = const Value.absent(),
    this.retiredDate = const Value.absent(),
    this.hasVariant = const Value.absent(),
    this.defaultWarehouse = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : id = Value(id),
        itemId = Value(itemId);
  static Insertable<Item> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? itemId,
    Expression<String>? description,
    Expression<String>? itemCode,
    Expression<String>? itemName,
    Expression<String>? itemGroup,
    Expression<String>? taxGroup,
    Expression<String>? uom,
    Expression<bool>? trackInventory,
    Expression<String>? category,
    Expression<bool>? isProductBundleParent,
    Expression<bool>? isQuickMenue,
    Expression<bool>? isRetired,
    Expression<DateTime>? retiredDate,
    Expression<bool>? hasVariant,
    Expression<String>? defaultWarehouse,
    Expression<bool>? isDeleted,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (description != null) 'description': description,
      if (itemCode != null) 'item_code': itemCode,
      if (itemName != null) 'item_name': itemName,
      if (itemGroup != null) 'item_group': itemGroup,
      if (taxGroup != null) 'tax_group': taxGroup,
      if (uom != null) 'uom': uom,
      if (trackInventory != null) 'track_inventory': trackInventory,
      if (category != null) 'category': category,
      if (isProductBundleParent != null)
        'is_product_bundle_parent': isProductBundleParent,
      if (isQuickMenue != null) 'is_quick_menue': isQuickMenue,
      if (isRetired != null) 'is_retired': isRetired,
      if (retiredDate != null) 'retired_date': retiredDate,
      if (hasVariant != null) 'has_variant': hasVariant,
      if (defaultWarehouse != null) 'default_warehouse': defaultWarehouse,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ItemsCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String>? itemId,
      Value<String?>? description,
      Value<String?>? itemCode,
      Value<String?>? itemName,
      Value<String?>? itemGroup,
      Value<String?>? taxGroup,
      Value<String?>? uom,
      Value<bool>? trackInventory,
      Value<String?>? category,
      Value<bool>? isProductBundleParent,
      Value<bool>? isQuickMenue,
      Value<bool>? isRetired,
      Value<DateTime?>? retiredDate,
      Value<bool>? hasVariant,
      Value<String?>? defaultWarehouse,
      Value<bool>? isDeleted,
      Value<int>? rowid}) {
    return ItemsCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      description: description ?? this.description,
      itemCode: itemCode ?? this.itemCode,
      itemName: itemName ?? this.itemName,
      itemGroup: itemGroup ?? this.itemGroup,
      taxGroup: taxGroup ?? this.taxGroup,
      uom: uom ?? this.uom,
      trackInventory: trackInventory ?? this.trackInventory,
      category: category ?? this.category,
      isProductBundleParent:
          isProductBundleParent ?? this.isProductBundleParent,
      isQuickMenue: isQuickMenue ?? this.isQuickMenue,
      isRetired: isRetired ?? this.isRetired,
      retiredDate: retiredDate ?? this.retiredDate,
      hasVariant: hasVariant ?? this.hasVariant,
      defaultWarehouse: defaultWarehouse ?? this.defaultWarehouse,
      isDeleted: isDeleted ?? this.isDeleted,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (itemName.present) {
      map['item_name'] = Variable<String>(itemName.value);
    }
    if (itemGroup.present) {
      map['item_group'] = Variable<String>(itemGroup.value);
    }
    if (taxGroup.present) {
      map['tax_group'] = Variable<String>(taxGroup.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    if (trackInventory.present) {
      map['track_inventory'] = Variable<bool>(trackInventory.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (isProductBundleParent.present) {
      map['is_product_bundle_parent'] =
          Variable<bool>(isProductBundleParent.value);
    }
    if (isQuickMenue.present) {
      map['is_quick_menue'] = Variable<bool>(isQuickMenue.value);
    }
    if (isRetired.present) {
      map['is_retired'] = Variable<bool>(isRetired.value);
    }
    if (retiredDate.present) {
      map['retired_date'] = Variable<DateTime>(retiredDate.value);
    }
    if (hasVariant.present) {
      map['has_variant'] = Variable<bool>(hasVariant.value);
    }
    if (defaultWarehouse.present) {
      map['default_warehouse'] = Variable<String>(defaultWarehouse.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemsCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('description: $description, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('uom: $uom, ')
          ..write('trackInventory: $trackInventory, ')
          ..write('category: $category, ')
          ..write('isProductBundleParent: $isProductBundleParent, ')
          ..write('isQuickMenue: $isQuickMenue, ')
          ..write('isRetired: $isRetired, ')
          ..write('retiredDate: $retiredDate, ')
          ..write('hasVariant: $hasVariant, ')
          ..write('defaultWarehouse: $defaultWarehouse, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ItemsPricesTable extends ItemsPrices
    with TableInfo<$ItemsPricesTable, ItemsPrice> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ItemsPricesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
      'item_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _itemCodeMeta =
      const VerificationMeta('itemCode');
  @override
  late final GeneratedColumn<String> itemCode = GeneratedColumn<String>(
      'item_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _priceListMeta =
      const VerificationMeta('priceList');
  @override
  late final GeneratedColumn<String> priceList = GeneratedColumn<String>(
      'price_list', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemNameMeta =
      const VerificationMeta('itemName');
  @override
  late final GeneratedColumn<String> itemName = GeneratedColumn<String>(
      'item_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemPriceMeta =
      const VerificationMeta('itemPrice');
  @override
  late final GeneratedColumn<double> itemPrice = GeneratedColumn<double>(
      'item_price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _returnPriceMeta =
      const VerificationMeta('returnPrice');
  @override
  late final GeneratedColumn<double> returnPrice = GeneratedColumn<double>(
      'return_price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _depositMeta =
      const VerificationMeta('deposit');
  @override
  late final GeneratedColumn<double> deposit = GeneratedColumn<double>(
      'deposit', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _shippingCostMeta =
      const VerificationMeta('shippingCost');
  @override
  late final GeneratedColumn<double> shippingCost = GeneratedColumn<double>(
      'shipping_cost', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _sellingDepositMeta =
      const VerificationMeta('sellingDeposit');
  @override
  late final GeneratedColumn<double> sellingDeposit = GeneratedColumn<double>(
      'selling_deposit', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _returnDepositMeta =
      const VerificationMeta('returnDeposit');
  @override
  late final GeneratedColumn<double> returnDeposit = GeneratedColumn<double>(
      'return_deposit', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _conversionFactorMeta =
      const VerificationMeta('conversionFactor');
  @override
  late final GeneratedColumn<double> conversionFactor = GeneratedColumn<double>(
      'conversion_factor', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _actualPointsMeta =
      const VerificationMeta('actualPoints');
  @override
  late final GeneratedColumn<double> actualPoints = GeneratedColumn<double>(
      'actual_points', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _uomMeta = const VerificationMeta('uom');
  @override
  late final GeneratedColumn<String> uom = GeneratedColumn<String>(
      'uom', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _currencyMeta =
      const VerificationMeta('currency');
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
      'currency', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _pricingScheduleNoMeta =
      const VerificationMeta('pricingScheduleNo');
  @override
  late final GeneratedColumn<int> pricingScheduleNo = GeneratedColumn<int>(
      'pricing_schedule_no', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isDiscountEnableMeta =
      const VerificationMeta('isDiscountEnable');
  @override
  late final GeneratedColumn<bool> isDiscountEnable = GeneratedColumn<bool>(
      'is_discount_enable', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_discount_enable" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _validFromMeta =
      const VerificationMeta('validFrom');
  @override
  late final GeneratedColumn<DateTime> validFrom = GeneratedColumn<DateTime>(
      'valid_from', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _validToMeta =
      const VerificationMeta('validTo');
  @override
  late final GeneratedColumn<DateTime> validTo = GeneratedColumn<DateTime>(
      'valid_to', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        itemId,
        itemCode,
        priceList,
        itemName,
        itemPrice,
        returnPrice,
        deposit,
        shippingCost,
        sellingDeposit,
        returnDeposit,
        conversionFactor,
        actualPoints,
        uom,
        currency,
        pricingScheduleNo,
        isActive,
        isDiscountEnable,
        validFrom,
        validTo
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'items_prices';
  @override
  VerificationContext validateIntegrity(Insertable<ItemsPrice> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code']!, _itemCodeMeta));
    }
    if (data.containsKey('price_list')) {
      context.handle(_priceListMeta,
          priceList.isAcceptableOrUnknown(data['price_list']!, _priceListMeta));
    }
    if (data.containsKey('item_name')) {
      context.handle(_itemNameMeta,
          itemName.isAcceptableOrUnknown(data['item_name']!, _itemNameMeta));
    }
    if (data.containsKey('item_price')) {
      context.handle(_itemPriceMeta,
          itemPrice.isAcceptableOrUnknown(data['item_price']!, _itemPriceMeta));
    } else if (isInserting) {
      context.missing(_itemPriceMeta);
    }
    if (data.containsKey('return_price')) {
      context.handle(
          _returnPriceMeta,
          returnPrice.isAcceptableOrUnknown(
              data['return_price']!, _returnPriceMeta));
    } else if (isInserting) {
      context.missing(_returnPriceMeta);
    }
    if (data.containsKey('deposit')) {
      context.handle(_depositMeta,
          deposit.isAcceptableOrUnknown(data['deposit']!, _depositMeta));
    } else if (isInserting) {
      context.missing(_depositMeta);
    }
    if (data.containsKey('shipping_cost')) {
      context.handle(
          _shippingCostMeta,
          shippingCost.isAcceptableOrUnknown(
              data['shipping_cost']!, _shippingCostMeta));
    } else if (isInserting) {
      context.missing(_shippingCostMeta);
    }
    if (data.containsKey('selling_deposit')) {
      context.handle(
          _sellingDepositMeta,
          sellingDeposit.isAcceptableOrUnknown(
              data['selling_deposit']!, _sellingDepositMeta));
    } else if (isInserting) {
      context.missing(_sellingDepositMeta);
    }
    if (data.containsKey('return_deposit')) {
      context.handle(
          _returnDepositMeta,
          returnDeposit.isAcceptableOrUnknown(
              data['return_deposit']!, _returnDepositMeta));
    } else if (isInserting) {
      context.missing(_returnDepositMeta);
    }
    if (data.containsKey('conversion_factor')) {
      context.handle(
          _conversionFactorMeta,
          conversionFactor.isAcceptableOrUnknown(
              data['conversion_factor']!, _conversionFactorMeta));
    } else if (isInserting) {
      context.missing(_conversionFactorMeta);
    }
    if (data.containsKey('actual_points')) {
      context.handle(
          _actualPointsMeta,
          actualPoints.isAcceptableOrUnknown(
              data['actual_points']!, _actualPointsMeta));
    } else if (isInserting) {
      context.missing(_actualPointsMeta);
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom']!, _uomMeta));
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta));
    }
    if (data.containsKey('pricing_schedule_no')) {
      context.handle(
          _pricingScheduleNoMeta,
          pricingScheduleNo.isAcceptableOrUnknown(
              data['pricing_schedule_no']!, _pricingScheduleNoMeta));
    } else if (isInserting) {
      context.missing(_pricingScheduleNoMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('is_discount_enable')) {
      context.handle(
          _isDiscountEnableMeta,
          isDiscountEnable.isAcceptableOrUnknown(
              data['is_discount_enable']!, _isDiscountEnableMeta));
    }
    if (data.containsKey('valid_from')) {
      context.handle(_validFromMeta,
          validFrom.isAcceptableOrUnknown(data['valid_from']!, _validFromMeta));
    }
    if (data.containsKey('valid_to')) {
      context.handle(_validToMeta,
          validTo.isAcceptableOrUnknown(data['valid_to']!, _validToMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemsPrice map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ItemsPrice(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_id'])!,
      itemCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_code']),
      priceList: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}price_list']),
      itemName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_name']),
      itemPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}item_price'])!,
      returnPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}return_price'])!,
      deposit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}deposit'])!,
      shippingCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}shipping_cost'])!,
      sellingDeposit: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}selling_deposit'])!,
      returnDeposit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}return_deposit'])!,
      conversionFactor: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}conversion_factor'])!,
      actualPoints: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}actual_points'])!,
      uom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uom']),
      currency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}currency']),
      pricingScheduleNo: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}pricing_schedule_no'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      isDiscountEnable: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_discount_enable'])!,
      validFrom: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_from']),
      validTo: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_to']),
    );
  }

  @override
  $ItemsPricesTable createAlias(String alias) {
    return $ItemsPricesTable(attachedDatabase, alias);
  }
}

class ItemsPrice extends DataClass implements Insertable<ItemsPrice> {
  final String? tenantId;
  final int id;
  final String itemId;
  final String? itemCode;
  final String? priceList;
  final String? itemName;
  final double itemPrice;
  final double returnPrice;
  final double deposit;
  final double shippingCost;
  final double sellingDeposit;
  final double returnDeposit;
  final double conversionFactor;
  final double actualPoints;
  final String? uom;
  final String? currency;
  final int pricingScheduleNo;
  final bool isActive;
  final bool isDiscountEnable;
  final DateTime? validFrom;
  final DateTime? validTo;
  const ItemsPrice(
      {this.tenantId,
      required this.id,
      required this.itemId,
      this.itemCode,
      this.priceList,
      this.itemName,
      required this.itemPrice,
      required this.returnPrice,
      required this.deposit,
      required this.shippingCost,
      required this.sellingDeposit,
      required this.returnDeposit,
      required this.conversionFactor,
      required this.actualPoints,
      this.uom,
      this.currency,
      required this.pricingScheduleNo,
      required this.isActive,
      required this.isDiscountEnable,
      this.validFrom,
      this.validTo});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    map['item_id'] = Variable<String>(itemId);
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || priceList != null) {
      map['price_list'] = Variable<String>(priceList);
    }
    if (!nullToAbsent || itemName != null) {
      map['item_name'] = Variable<String>(itemName);
    }
    map['item_price'] = Variable<double>(itemPrice);
    map['return_price'] = Variable<double>(returnPrice);
    map['deposit'] = Variable<double>(deposit);
    map['shipping_cost'] = Variable<double>(shippingCost);
    map['selling_deposit'] = Variable<double>(sellingDeposit);
    map['return_deposit'] = Variable<double>(returnDeposit);
    map['conversion_factor'] = Variable<double>(conversionFactor);
    map['actual_points'] = Variable<double>(actualPoints);
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    map['pricing_schedule_no'] = Variable<int>(pricingScheduleNo);
    map['is_active'] = Variable<bool>(isActive);
    map['is_discount_enable'] = Variable<bool>(isDiscountEnable);
    if (!nullToAbsent || validFrom != null) {
      map['valid_from'] = Variable<DateTime>(validFrom);
    }
    if (!nullToAbsent || validTo != null) {
      map['valid_to'] = Variable<DateTime>(validTo);
    }
    return map;
  }

  ItemsPricesCompanion toCompanion(bool nullToAbsent) {
    return ItemsPricesCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      itemId: Value(itemId),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      priceList: priceList == null && nullToAbsent
          ? const Value.absent()
          : Value(priceList),
      itemName: itemName == null && nullToAbsent
          ? const Value.absent()
          : Value(itemName),
      itemPrice: Value(itemPrice),
      returnPrice: Value(returnPrice),
      deposit: Value(deposit),
      shippingCost: Value(shippingCost),
      sellingDeposit: Value(sellingDeposit),
      returnDeposit: Value(returnDeposit),
      conversionFactor: Value(conversionFactor),
      actualPoints: Value(actualPoints),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      pricingScheduleNo: Value(pricingScheduleNo),
      isActive: Value(isActive),
      isDiscountEnable: Value(isDiscountEnable),
      validFrom: validFrom == null && nullToAbsent
          ? const Value.absent()
          : Value(validFrom),
      validTo: validTo == null && nullToAbsent
          ? const Value.absent()
          : Value(validTo),
    );
  }

  factory ItemsPrice.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemsPrice(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<String>(json['itemId']),
      itemCode: serializer.fromJson<String?>(json['itemCode']),
      priceList: serializer.fromJson<String?>(json['priceList']),
      itemName: serializer.fromJson<String?>(json['itemName']),
      itemPrice: serializer.fromJson<double>(json['itemPrice']),
      returnPrice: serializer.fromJson<double>(json['returnPrice']),
      deposit: serializer.fromJson<double>(json['deposit']),
      shippingCost: serializer.fromJson<double>(json['shippingCost']),
      sellingDeposit: serializer.fromJson<double>(json['sellingDeposit']),
      returnDeposit: serializer.fromJson<double>(json['returnDeposit']),
      conversionFactor: serializer.fromJson<double>(json['conversionFactor']),
      actualPoints: serializer.fromJson<double>(json['actualPoints']),
      uom: serializer.fromJson<String?>(json['uom']),
      currency: serializer.fromJson<String?>(json['currency']),
      pricingScheduleNo: serializer.fromJson<int>(json['pricingScheduleNo']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isDiscountEnable: serializer.fromJson<bool>(json['isDiscountEnable']),
      validFrom: serializer.fromJson<DateTime?>(json['validFrom']),
      validTo: serializer.fromJson<DateTime?>(json['validTo']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemId': serializer.toJson<String>(itemId),
      'itemCode': serializer.toJson<String?>(itemCode),
      'priceList': serializer.toJson<String?>(priceList),
      'itemName': serializer.toJson<String?>(itemName),
      'itemPrice': serializer.toJson<double>(itemPrice),
      'returnPrice': serializer.toJson<double>(returnPrice),
      'deposit': serializer.toJson<double>(deposit),
      'shippingCost': serializer.toJson<double>(shippingCost),
      'sellingDeposit': serializer.toJson<double>(sellingDeposit),
      'returnDeposit': serializer.toJson<double>(returnDeposit),
      'conversionFactor': serializer.toJson<double>(conversionFactor),
      'actualPoints': serializer.toJson<double>(actualPoints),
      'uom': serializer.toJson<String?>(uom),
      'currency': serializer.toJson<String?>(currency),
      'pricingScheduleNo': serializer.toJson<int>(pricingScheduleNo),
      'isActive': serializer.toJson<bool>(isActive),
      'isDiscountEnable': serializer.toJson<bool>(isDiscountEnable),
      'validFrom': serializer.toJson<DateTime?>(validFrom),
      'validTo': serializer.toJson<DateTime?>(validTo),
    };
  }

  ItemsPrice copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          String? itemId,
          Value<String?> itemCode = const Value.absent(),
          Value<String?> priceList = const Value.absent(),
          Value<String?> itemName = const Value.absent(),
          double? itemPrice,
          double? returnPrice,
          double? deposit,
          double? shippingCost,
          double? sellingDeposit,
          double? returnDeposit,
          double? conversionFactor,
          double? actualPoints,
          Value<String?> uom = const Value.absent(),
          Value<String?> currency = const Value.absent(),
          int? pricingScheduleNo,
          bool? isActive,
          bool? isDiscountEnable,
          Value<DateTime?> validFrom = const Value.absent(),
          Value<DateTime?> validTo = const Value.absent()}) =>
      ItemsPrice(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        itemCode: itemCode.present ? itemCode.value : this.itemCode,
        priceList: priceList.present ? priceList.value : this.priceList,
        itemName: itemName.present ? itemName.value : this.itemName,
        itemPrice: itemPrice ?? this.itemPrice,
        returnPrice: returnPrice ?? this.returnPrice,
        deposit: deposit ?? this.deposit,
        shippingCost: shippingCost ?? this.shippingCost,
        sellingDeposit: sellingDeposit ?? this.sellingDeposit,
        returnDeposit: returnDeposit ?? this.returnDeposit,
        conversionFactor: conversionFactor ?? this.conversionFactor,
        actualPoints: actualPoints ?? this.actualPoints,
        uom: uom.present ? uom.value : this.uom,
        currency: currency.present ? currency.value : this.currency,
        pricingScheduleNo: pricingScheduleNo ?? this.pricingScheduleNo,
        isActive: isActive ?? this.isActive,
        isDiscountEnable: isDiscountEnable ?? this.isDiscountEnable,
        validFrom: validFrom.present ? validFrom.value : this.validFrom,
        validTo: validTo.present ? validTo.value : this.validTo,
      );
  @override
  String toString() {
    return (StringBuffer('ItemsPrice(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('priceList: $priceList, ')
          ..write('itemName: $itemName, ')
          ..write('itemPrice: $itemPrice, ')
          ..write('returnPrice: $returnPrice, ')
          ..write('deposit: $deposit, ')
          ..write('shippingCost: $shippingCost, ')
          ..write('sellingDeposit: $sellingDeposit, ')
          ..write('returnDeposit: $returnDeposit, ')
          ..write('conversionFactor: $conversionFactor, ')
          ..write('actualPoints: $actualPoints, ')
          ..write('uom: $uom, ')
          ..write('currency: $currency, ')
          ..write('pricingScheduleNo: $pricingScheduleNo, ')
          ..write('isActive: $isActive, ')
          ..write('isDiscountEnable: $isDiscountEnable, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        id,
        itemId,
        itemCode,
        priceList,
        itemName,
        itemPrice,
        returnPrice,
        deposit,
        shippingCost,
        sellingDeposit,
        returnDeposit,
        conversionFactor,
        actualPoints,
        uom,
        currency,
        pricingScheduleNo,
        isActive,
        isDiscountEnable,
        validFrom,
        validTo
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemsPrice &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.itemCode == this.itemCode &&
          other.priceList == this.priceList &&
          other.itemName == this.itemName &&
          other.itemPrice == this.itemPrice &&
          other.returnPrice == this.returnPrice &&
          other.deposit == this.deposit &&
          other.shippingCost == this.shippingCost &&
          other.sellingDeposit == this.sellingDeposit &&
          other.returnDeposit == this.returnDeposit &&
          other.conversionFactor == this.conversionFactor &&
          other.actualPoints == this.actualPoints &&
          other.uom == this.uom &&
          other.currency == this.currency &&
          other.pricingScheduleNo == this.pricingScheduleNo &&
          other.isActive == this.isActive &&
          other.isDiscountEnable == this.isDiscountEnable &&
          other.validFrom == this.validFrom &&
          other.validTo == this.validTo);
}

class ItemsPricesCompanion extends UpdateCompanion<ItemsPrice> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String> itemId;
  final Value<String?> itemCode;
  final Value<String?> priceList;
  final Value<String?> itemName;
  final Value<double> itemPrice;
  final Value<double> returnPrice;
  final Value<double> deposit;
  final Value<double> shippingCost;
  final Value<double> sellingDeposit;
  final Value<double> returnDeposit;
  final Value<double> conversionFactor;
  final Value<double> actualPoints;
  final Value<String?> uom;
  final Value<String?> currency;
  final Value<int> pricingScheduleNo;
  final Value<bool> isActive;
  final Value<bool> isDiscountEnable;
  final Value<DateTime?> validFrom;
  final Value<DateTime?> validTo;
  const ItemsPricesCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.priceList = const Value.absent(),
    this.itemName = const Value.absent(),
    this.itemPrice = const Value.absent(),
    this.returnPrice = const Value.absent(),
    this.deposit = const Value.absent(),
    this.shippingCost = const Value.absent(),
    this.sellingDeposit = const Value.absent(),
    this.returnDeposit = const Value.absent(),
    this.conversionFactor = const Value.absent(),
    this.actualPoints = const Value.absent(),
    this.uom = const Value.absent(),
    this.currency = const Value.absent(),
    this.pricingScheduleNo = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isDiscountEnable = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  });
  ItemsPricesCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    required String itemId,
    this.itemCode = const Value.absent(),
    this.priceList = const Value.absent(),
    this.itemName = const Value.absent(),
    required double itemPrice,
    required double returnPrice,
    required double deposit,
    required double shippingCost,
    required double sellingDeposit,
    required double returnDeposit,
    required double conversionFactor,
    required double actualPoints,
    this.uom = const Value.absent(),
    this.currency = const Value.absent(),
    required int pricingScheduleNo,
    this.isActive = const Value.absent(),
    this.isDiscountEnable = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  })  : itemId = Value(itemId),
        itemPrice = Value(itemPrice),
        returnPrice = Value(returnPrice),
        deposit = Value(deposit),
        shippingCost = Value(shippingCost),
        sellingDeposit = Value(sellingDeposit),
        returnDeposit = Value(returnDeposit),
        conversionFactor = Value(conversionFactor),
        actualPoints = Value(actualPoints),
        pricingScheduleNo = Value(pricingScheduleNo);
  static Insertable<ItemsPrice> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? itemId,
    Expression<String>? itemCode,
    Expression<String>? priceList,
    Expression<String>? itemName,
    Expression<double>? itemPrice,
    Expression<double>? returnPrice,
    Expression<double>? deposit,
    Expression<double>? shippingCost,
    Expression<double>? sellingDeposit,
    Expression<double>? returnDeposit,
    Expression<double>? conversionFactor,
    Expression<double>? actualPoints,
    Expression<String>? uom,
    Expression<String>? currency,
    Expression<int>? pricingScheduleNo,
    Expression<bool>? isActive,
    Expression<bool>? isDiscountEnable,
    Expression<DateTime>? validFrom,
    Expression<DateTime>? validTo,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (itemCode != null) 'item_code': itemCode,
      if (priceList != null) 'price_list': priceList,
      if (itemName != null) 'item_name': itemName,
      if (itemPrice != null) 'item_price': itemPrice,
      if (returnPrice != null) 'return_price': returnPrice,
      if (deposit != null) 'deposit': deposit,
      if (shippingCost != null) 'shipping_cost': shippingCost,
      if (sellingDeposit != null) 'selling_deposit': sellingDeposit,
      if (returnDeposit != null) 'return_deposit': returnDeposit,
      if (conversionFactor != null) 'conversion_factor': conversionFactor,
      if (actualPoints != null) 'actual_points': actualPoints,
      if (uom != null) 'uom': uom,
      if (currency != null) 'currency': currency,
      if (pricingScheduleNo != null) 'pricing_schedule_no': pricingScheduleNo,
      if (isActive != null) 'is_active': isActive,
      if (isDiscountEnable != null) 'is_discount_enable': isDiscountEnable,
      if (validFrom != null) 'valid_from': validFrom,
      if (validTo != null) 'valid_to': validTo,
    });
  }

  ItemsPricesCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String>? itemId,
      Value<String?>? itemCode,
      Value<String?>? priceList,
      Value<String?>? itemName,
      Value<double>? itemPrice,
      Value<double>? returnPrice,
      Value<double>? deposit,
      Value<double>? shippingCost,
      Value<double>? sellingDeposit,
      Value<double>? returnDeposit,
      Value<double>? conversionFactor,
      Value<double>? actualPoints,
      Value<String?>? uom,
      Value<String?>? currency,
      Value<int>? pricingScheduleNo,
      Value<bool>? isActive,
      Value<bool>? isDiscountEnable,
      Value<DateTime?>? validFrom,
      Value<DateTime?>? validTo}) {
    return ItemsPricesCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      itemCode: itemCode ?? this.itemCode,
      priceList: priceList ?? this.priceList,
      itemName: itemName ?? this.itemName,
      itemPrice: itemPrice ?? this.itemPrice,
      returnPrice: returnPrice ?? this.returnPrice,
      deposit: deposit ?? this.deposit,
      shippingCost: shippingCost ?? this.shippingCost,
      sellingDeposit: sellingDeposit ?? this.sellingDeposit,
      returnDeposit: returnDeposit ?? this.returnDeposit,
      conversionFactor: conversionFactor ?? this.conversionFactor,
      actualPoints: actualPoints ?? this.actualPoints,
      uom: uom ?? this.uom,
      currency: currency ?? this.currency,
      pricingScheduleNo: pricingScheduleNo ?? this.pricingScheduleNo,
      isActive: isActive ?? this.isActive,
      isDiscountEnable: isDiscountEnable ?? this.isDiscountEnable,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo ?? this.validTo,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (priceList.present) {
      map['price_list'] = Variable<String>(priceList.value);
    }
    if (itemName.present) {
      map['item_name'] = Variable<String>(itemName.value);
    }
    if (itemPrice.present) {
      map['item_price'] = Variable<double>(itemPrice.value);
    }
    if (returnPrice.present) {
      map['return_price'] = Variable<double>(returnPrice.value);
    }
    if (deposit.present) {
      map['deposit'] = Variable<double>(deposit.value);
    }
    if (shippingCost.present) {
      map['shipping_cost'] = Variable<double>(shippingCost.value);
    }
    if (sellingDeposit.present) {
      map['selling_deposit'] = Variable<double>(sellingDeposit.value);
    }
    if (returnDeposit.present) {
      map['return_deposit'] = Variable<double>(returnDeposit.value);
    }
    if (conversionFactor.present) {
      map['conversion_factor'] = Variable<double>(conversionFactor.value);
    }
    if (actualPoints.present) {
      map['actual_points'] = Variable<double>(actualPoints.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (pricingScheduleNo.present) {
      map['pricing_schedule_no'] = Variable<int>(pricingScheduleNo.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isDiscountEnable.present) {
      map['is_discount_enable'] = Variable<bool>(isDiscountEnable.value);
    }
    if (validFrom.present) {
      map['valid_from'] = Variable<DateTime>(validFrom.value);
    }
    if (validTo.present) {
      map['valid_to'] = Variable<DateTime>(validTo.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemsPricesCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('priceList: $priceList, ')
          ..write('itemName: $itemName, ')
          ..write('itemPrice: $itemPrice, ')
          ..write('returnPrice: $returnPrice, ')
          ..write('deposit: $deposit, ')
          ..write('shippingCost: $shippingCost, ')
          ..write('sellingDeposit: $sellingDeposit, ')
          ..write('returnDeposit: $returnDeposit, ')
          ..write('conversionFactor: $conversionFactor, ')
          ..write('actualPoints: $actualPoints, ')
          ..write('uom: $uom, ')
          ..write('currency: $currency, ')
          ..write('pricingScheduleNo: $pricingScheduleNo, ')
          ..write('isActive: $isActive, ')
          ..write('isDiscountEnable: $isDiscountEnable, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }
}

class $ItemPricingRuleTable extends ItemPricingRule
    with TableInfo<$ItemPricingRuleTable, ItemPricingRuleData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ItemPricingRuleTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _priorityMeta =
      const VerificationMeta('priority');
  @override
  late final GeneratedColumn<int> priority = GeneratedColumn<int>(
      'priority', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
      'item_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemCodeMeta =
      const VerificationMeta('itemCode');
  @override
  late final GeneratedColumn<String> itemCode = GeneratedColumn<String>(
      'item_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _priceListMeta =
      const VerificationMeta('priceList');
  @override
  late final GeneratedColumn<String> priceList = GeneratedColumn<String>(
      'price_list', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerIdMeta =
      const VerificationMeta('customerId');
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
      'customer_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _minQuantityMeta =
      const VerificationMeta('minQuantity');
  @override
  late final GeneratedColumn<double> minQuantity = GeneratedColumn<double>(
      'min_quantity', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _maxQuantityMeta =
      const VerificationMeta('maxQuantity');
  @override
  late final GeneratedColumn<double> maxQuantity = GeneratedColumn<double>(
      'max_quantity', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _discountPercentageMeta =
      const VerificationMeta('discountPercentage');
  @override
  late final GeneratedColumn<double> discountPercentage =
      GeneratedColumn<double>('discount_percentage', aliasedName, false,
          type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _uomMeta = const VerificationMeta('uom');
  @override
  late final GeneratedColumn<String> uom = GeneratedColumn<String>(
      'uom', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _priceOrDiscountMeta =
      const VerificationMeta('priceOrDiscount');
  @override
  late final GeneratedColumn<String> priceOrDiscount = GeneratedColumn<String>(
      'price_or_discount', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _customerGroupMeta =
      const VerificationMeta('customerGroup');
  @override
  late final GeneratedColumn<String> customerGroup = GeneratedColumn<String>(
      'customer_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemGroupMeta =
      const VerificationMeta('itemGroup');
  @override
  late final GeneratedColumn<String> itemGroup = GeneratedColumn<String>(
      'item_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _categoryMeta =
      const VerificationMeta('category');
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
      'category', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _applicableForMeta =
      const VerificationMeta('applicableFor');
  @override
  late final GeneratedColumn<String> applicableFor = GeneratedColumn<String>(
      'applicable_for', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _applyOnMeta =
      const VerificationMeta('applyOn');
  @override
  late final GeneratedColumn<String> applyOn = GeneratedColumn<String>(
      'apply_on', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _ruleNameMeta =
      const VerificationMeta('ruleName');
  @override
  late final GeneratedColumn<String> ruleName = GeneratedColumn<String>(
      'rule_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isDiscountEnableMeta =
      const VerificationMeta('isDiscountEnable');
  @override
  late final GeneratedColumn<bool> isDiscountEnable = GeneratedColumn<bool>(
      'is_discount_enable', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_discount_enable" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _validFromMeta =
      const VerificationMeta('validFrom');
  @override
  late final GeneratedColumn<DateTime> validFrom = GeneratedColumn<DateTime>(
      'valid_from', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _validToMeta =
      const VerificationMeta('validTo');
  @override
  late final GeneratedColumn<DateTime> validTo = GeneratedColumn<DateTime>(
      'valid_to', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        priority,
        itemId,
        itemCode,
        priceList,
        customerId,
        minQuantity,
        maxQuantity,
        price,
        discountPercentage,
        uom,
        priceOrDiscount,
        customerGroup,
        itemGroup,
        category,
        applicableFor,
        applyOn,
        title,
        ruleName,
        isActive,
        isDeleted,
        isDiscountEnable,
        validFrom,
        validTo
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'item_pricing_rule';
  @override
  VerificationContext validateIntegrity(
      Insertable<ItemPricingRuleData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('priority')) {
      context.handle(_priorityMeta,
          priority.isAcceptableOrUnknown(data['priority']!, _priorityMeta));
    } else if (isInserting) {
      context.missing(_priorityMeta);
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code']!, _itemCodeMeta));
    }
    if (data.containsKey('price_list')) {
      context.handle(_priceListMeta,
          priceList.isAcceptableOrUnknown(data['price_list']!, _priceListMeta));
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id']!, _customerIdMeta));
    }
    if (data.containsKey('min_quantity')) {
      context.handle(
          _minQuantityMeta,
          minQuantity.isAcceptableOrUnknown(
              data['min_quantity']!, _minQuantityMeta));
    } else if (isInserting) {
      context.missing(_minQuantityMeta);
    }
    if (data.containsKey('max_quantity')) {
      context.handle(
          _maxQuantityMeta,
          maxQuantity.isAcceptableOrUnknown(
              data['max_quantity']!, _maxQuantityMeta));
    } else if (isInserting) {
      context.missing(_maxQuantityMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('discount_percentage')) {
      context.handle(
          _discountPercentageMeta,
          discountPercentage.isAcceptableOrUnknown(
              data['discount_percentage']!, _discountPercentageMeta));
    } else if (isInserting) {
      context.missing(_discountPercentageMeta);
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom']!, _uomMeta));
    }
    if (data.containsKey('price_or_discount')) {
      context.handle(
          _priceOrDiscountMeta,
          priceOrDiscount.isAcceptableOrUnknown(
              data['price_or_discount']!, _priceOrDiscountMeta));
    }
    if (data.containsKey('customer_group')) {
      context.handle(
          _customerGroupMeta,
          customerGroup.isAcceptableOrUnknown(
              data['customer_group']!, _customerGroupMeta));
    }
    if (data.containsKey('item_group')) {
      context.handle(_itemGroupMeta,
          itemGroup.isAcceptableOrUnknown(data['item_group']!, _itemGroupMeta));
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category']!, _categoryMeta));
    }
    if (data.containsKey('applicable_for')) {
      context.handle(
          _applicableForMeta,
          applicableFor.isAcceptableOrUnknown(
              data['applicable_for']!, _applicableForMeta));
    }
    if (data.containsKey('apply_on')) {
      context.handle(_applyOnMeta,
          applyOn.isAcceptableOrUnknown(data['apply_on']!, _applyOnMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    }
    if (data.containsKey('rule_name')) {
      context.handle(_ruleNameMeta,
          ruleName.isAcceptableOrUnknown(data['rule_name']!, _ruleNameMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('is_discount_enable')) {
      context.handle(
          _isDiscountEnableMeta,
          isDiscountEnable.isAcceptableOrUnknown(
              data['is_discount_enable']!, _isDiscountEnableMeta));
    }
    if (data.containsKey('valid_from')) {
      context.handle(_validFromMeta,
          validFrom.isAcceptableOrUnknown(data['valid_from']!, _validFromMeta));
    }
    if (data.containsKey('valid_to')) {
      context.handle(_validToMeta,
          validTo.isAcceptableOrUnknown(data['valid_to']!, _validToMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemPricingRuleData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ItemPricingRuleData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      priority: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}priority'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_id']),
      itemCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_code']),
      priceList: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}price_list']),
      customerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_id']),
      minQuantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}min_quantity'])!,
      maxQuantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}max_quantity'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      discountPercentage: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}discount_percentage'])!,
      uom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uom']),
      priceOrDiscount: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}price_or_discount']),
      customerGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_group']),
      itemGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_group']),
      category: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}category']),
      applicableFor: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}applicable_for']),
      applyOn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}apply_on']),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title']),
      ruleName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}rule_name']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      isDiscountEnable: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_discount_enable'])!,
      validFrom: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_from']),
      validTo: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}valid_to']),
    );
  }

  @override
  $ItemPricingRuleTable createAlias(String alias) {
    return $ItemPricingRuleTable(attachedDatabase, alias);
  }
}

class ItemPricingRuleData extends DataClass
    implements Insertable<ItemPricingRuleData> {
  final String? tenantId;
  final int id;
  final int priority;
  final String? itemId;
  final String? itemCode;
  final String? priceList;
  final String? customerId;
  final double minQuantity;
  final double maxQuantity;
  final double price;
  final double discountPercentage;
  final String? uom;
  final String? priceOrDiscount;
  final String? customerGroup;
  final String? itemGroup;
  final String? category;
  final String? applicableFor;
  final String? applyOn;
  final String? title;
  final String? ruleName;
  final bool isActive;
  final bool isDeleted;
  final bool isDiscountEnable;
  final DateTime? validFrom;
  final DateTime? validTo;
  const ItemPricingRuleData(
      {this.tenantId,
      required this.id,
      required this.priority,
      this.itemId,
      this.itemCode,
      this.priceList,
      this.customerId,
      required this.minQuantity,
      required this.maxQuantity,
      required this.price,
      required this.discountPercentage,
      this.uom,
      this.priceOrDiscount,
      this.customerGroup,
      this.itemGroup,
      this.category,
      this.applicableFor,
      this.applyOn,
      this.title,
      this.ruleName,
      required this.isActive,
      required this.isDeleted,
      required this.isDiscountEnable,
      this.validFrom,
      this.validTo});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    map['priority'] = Variable<int>(priority);
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || priceList != null) {
      map['price_list'] = Variable<String>(priceList);
    }
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    map['min_quantity'] = Variable<double>(minQuantity);
    map['max_quantity'] = Variable<double>(maxQuantity);
    map['price'] = Variable<double>(price);
    map['discount_percentage'] = Variable<double>(discountPercentage);
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    if (!nullToAbsent || priceOrDiscount != null) {
      map['price_or_discount'] = Variable<String>(priceOrDiscount);
    }
    if (!nullToAbsent || customerGroup != null) {
      map['customer_group'] = Variable<String>(customerGroup);
    }
    if (!nullToAbsent || itemGroup != null) {
      map['item_group'] = Variable<String>(itemGroup);
    }
    if (!nullToAbsent || category != null) {
      map['category'] = Variable<String>(category);
    }
    if (!nullToAbsent || applicableFor != null) {
      map['applicable_for'] = Variable<String>(applicableFor);
    }
    if (!nullToAbsent || applyOn != null) {
      map['apply_on'] = Variable<String>(applyOn);
    }
    if (!nullToAbsent || title != null) {
      map['title'] = Variable<String>(title);
    }
    if (!nullToAbsent || ruleName != null) {
      map['rule_name'] = Variable<String>(ruleName);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['is_discount_enable'] = Variable<bool>(isDiscountEnable);
    if (!nullToAbsent || validFrom != null) {
      map['valid_from'] = Variable<DateTime>(validFrom);
    }
    if (!nullToAbsent || validTo != null) {
      map['valid_to'] = Variable<DateTime>(validTo);
    }
    return map;
  }

  ItemPricingRuleCompanion toCompanion(bool nullToAbsent) {
    return ItemPricingRuleCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      priority: Value(priority),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      priceList: priceList == null && nullToAbsent
          ? const Value.absent()
          : Value(priceList),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      minQuantity: Value(minQuantity),
      maxQuantity: Value(maxQuantity),
      price: Value(price),
      discountPercentage: Value(discountPercentage),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
      priceOrDiscount: priceOrDiscount == null && nullToAbsent
          ? const Value.absent()
          : Value(priceOrDiscount),
      customerGroup: customerGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(customerGroup),
      itemGroup: itemGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(itemGroup),
      category: category == null && nullToAbsent
          ? const Value.absent()
          : Value(category),
      applicableFor: applicableFor == null && nullToAbsent
          ? const Value.absent()
          : Value(applicableFor),
      applyOn: applyOn == null && nullToAbsent
          ? const Value.absent()
          : Value(applyOn),
      title:
          title == null && nullToAbsent ? const Value.absent() : Value(title),
      ruleName: ruleName == null && nullToAbsent
          ? const Value.absent()
          : Value(ruleName),
      isActive: Value(isActive),
      isDeleted: Value(isDeleted),
      isDiscountEnable: Value(isDiscountEnable),
      validFrom: validFrom == null && nullToAbsent
          ? const Value.absent()
          : Value(validFrom),
      validTo: validTo == null && nullToAbsent
          ? const Value.absent()
          : Value(validTo),
    );
  }

  factory ItemPricingRuleData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemPricingRuleData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      priority: serializer.fromJson<int>(json['priority']),
      itemId: serializer.fromJson<String?>(json['itemId']),
      itemCode: serializer.fromJson<String?>(json['itemCode']),
      priceList: serializer.fromJson<String?>(json['priceList']),
      customerId: serializer.fromJson<String?>(json['customerId']),
      minQuantity: serializer.fromJson<double>(json['minQuantity']),
      maxQuantity: serializer.fromJson<double>(json['maxQuantity']),
      price: serializer.fromJson<double>(json['price']),
      discountPercentage:
          serializer.fromJson<double>(json['discountPercentage']),
      uom: serializer.fromJson<String?>(json['uom']),
      priceOrDiscount: serializer.fromJson<String?>(json['priceOrDiscount']),
      customerGroup: serializer.fromJson<String?>(json['customerGroup']),
      itemGroup: serializer.fromJson<String?>(json['itemGroup']),
      category: serializer.fromJson<String?>(json['category']),
      applicableFor: serializer.fromJson<String?>(json['applicableFor']),
      applyOn: serializer.fromJson<String?>(json['applyOn']),
      title: serializer.fromJson<String?>(json['title']),
      ruleName: serializer.fromJson<String?>(json['ruleName']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      isDiscountEnable: serializer.fromJson<bool>(json['isDiscountEnable']),
      validFrom: serializer.fromJson<DateTime?>(json['validFrom']),
      validTo: serializer.fromJson<DateTime?>(json['validTo']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'priority': serializer.toJson<int>(priority),
      'itemId': serializer.toJson<String?>(itemId),
      'itemCode': serializer.toJson<String?>(itemCode),
      'priceList': serializer.toJson<String?>(priceList),
      'customerId': serializer.toJson<String?>(customerId),
      'minQuantity': serializer.toJson<double>(minQuantity),
      'maxQuantity': serializer.toJson<double>(maxQuantity),
      'price': serializer.toJson<double>(price),
      'discountPercentage': serializer.toJson<double>(discountPercentage),
      'uom': serializer.toJson<String?>(uom),
      'priceOrDiscount': serializer.toJson<String?>(priceOrDiscount),
      'customerGroup': serializer.toJson<String?>(customerGroup),
      'itemGroup': serializer.toJson<String?>(itemGroup),
      'category': serializer.toJson<String?>(category),
      'applicableFor': serializer.toJson<String?>(applicableFor),
      'applyOn': serializer.toJson<String?>(applyOn),
      'title': serializer.toJson<String?>(title),
      'ruleName': serializer.toJson<String?>(ruleName),
      'isActive': serializer.toJson<bool>(isActive),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'isDiscountEnable': serializer.toJson<bool>(isDiscountEnable),
      'validFrom': serializer.toJson<DateTime?>(validFrom),
      'validTo': serializer.toJson<DateTime?>(validTo),
    };
  }

  ItemPricingRuleData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          int? priority,
          Value<String?> itemId = const Value.absent(),
          Value<String?> itemCode = const Value.absent(),
          Value<String?> priceList = const Value.absent(),
          Value<String?> customerId = const Value.absent(),
          double? minQuantity,
          double? maxQuantity,
          double? price,
          double? discountPercentage,
          Value<String?> uom = const Value.absent(),
          Value<String?> priceOrDiscount = const Value.absent(),
          Value<String?> customerGroup = const Value.absent(),
          Value<String?> itemGroup = const Value.absent(),
          Value<String?> category = const Value.absent(),
          Value<String?> applicableFor = const Value.absent(),
          Value<String?> applyOn = const Value.absent(),
          Value<String?> title = const Value.absent(),
          Value<String?> ruleName = const Value.absent(),
          bool? isActive,
          bool? isDeleted,
          bool? isDiscountEnable,
          Value<DateTime?> validFrom = const Value.absent(),
          Value<DateTime?> validTo = const Value.absent()}) =>
      ItemPricingRuleData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        priority: priority ?? this.priority,
        itemId: itemId.present ? itemId.value : this.itemId,
        itemCode: itemCode.present ? itemCode.value : this.itemCode,
        priceList: priceList.present ? priceList.value : this.priceList,
        customerId: customerId.present ? customerId.value : this.customerId,
        minQuantity: minQuantity ?? this.minQuantity,
        maxQuantity: maxQuantity ?? this.maxQuantity,
        price: price ?? this.price,
        discountPercentage: discountPercentage ?? this.discountPercentage,
        uom: uom.present ? uom.value : this.uom,
        priceOrDiscount: priceOrDiscount.present
            ? priceOrDiscount.value
            : this.priceOrDiscount,
        customerGroup:
            customerGroup.present ? customerGroup.value : this.customerGroup,
        itemGroup: itemGroup.present ? itemGroup.value : this.itemGroup,
        category: category.present ? category.value : this.category,
        applicableFor:
            applicableFor.present ? applicableFor.value : this.applicableFor,
        applyOn: applyOn.present ? applyOn.value : this.applyOn,
        title: title.present ? title.value : this.title,
        ruleName: ruleName.present ? ruleName.value : this.ruleName,
        isActive: isActive ?? this.isActive,
        isDeleted: isDeleted ?? this.isDeleted,
        isDiscountEnable: isDiscountEnable ?? this.isDiscountEnable,
        validFrom: validFrom.present ? validFrom.value : this.validFrom,
        validTo: validTo.present ? validTo.value : this.validTo,
      );
  @override
  String toString() {
    return (StringBuffer('ItemPricingRuleData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('priority: $priority, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('priceList: $priceList, ')
          ..write('customerId: $customerId, ')
          ..write('minQuantity: $minQuantity, ')
          ..write('maxQuantity: $maxQuantity, ')
          ..write('price: $price, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('uom: $uom, ')
          ..write('priceOrDiscount: $priceOrDiscount, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('applicableFor: $applicableFor, ')
          ..write('applyOn: $applyOn, ')
          ..write('title: $title, ')
          ..write('ruleName: $ruleName, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('isDiscountEnable: $isDiscountEnable, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        id,
        priority,
        itemId,
        itemCode,
        priceList,
        customerId,
        minQuantity,
        maxQuantity,
        price,
        discountPercentage,
        uom,
        priceOrDiscount,
        customerGroup,
        itemGroup,
        category,
        applicableFor,
        applyOn,
        title,
        ruleName,
        isActive,
        isDeleted,
        isDiscountEnable,
        validFrom,
        validTo
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemPricingRuleData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.priority == this.priority &&
          other.itemId == this.itemId &&
          other.itemCode == this.itemCode &&
          other.priceList == this.priceList &&
          other.customerId == this.customerId &&
          other.minQuantity == this.minQuantity &&
          other.maxQuantity == this.maxQuantity &&
          other.price == this.price &&
          other.discountPercentage == this.discountPercentage &&
          other.uom == this.uom &&
          other.priceOrDiscount == this.priceOrDiscount &&
          other.customerGroup == this.customerGroup &&
          other.itemGroup == this.itemGroup &&
          other.category == this.category &&
          other.applicableFor == this.applicableFor &&
          other.applyOn == this.applyOn &&
          other.title == this.title &&
          other.ruleName == this.ruleName &&
          other.isActive == this.isActive &&
          other.isDeleted == this.isDeleted &&
          other.isDiscountEnable == this.isDiscountEnable &&
          other.validFrom == this.validFrom &&
          other.validTo == this.validTo);
}

class ItemPricingRuleCompanion extends UpdateCompanion<ItemPricingRuleData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<int> priority;
  final Value<String?> itemId;
  final Value<String?> itemCode;
  final Value<String?> priceList;
  final Value<String?> customerId;
  final Value<double> minQuantity;
  final Value<double> maxQuantity;
  final Value<double> price;
  final Value<double> discountPercentage;
  final Value<String?> uom;
  final Value<String?> priceOrDiscount;
  final Value<String?> customerGroup;
  final Value<String?> itemGroup;
  final Value<String?> category;
  final Value<String?> applicableFor;
  final Value<String?> applyOn;
  final Value<String?> title;
  final Value<String?> ruleName;
  final Value<bool> isActive;
  final Value<bool> isDeleted;
  final Value<bool> isDiscountEnable;
  final Value<DateTime?> validFrom;
  final Value<DateTime?> validTo;
  const ItemPricingRuleCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.priority = const Value.absent(),
    this.itemId = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.priceList = const Value.absent(),
    this.customerId = const Value.absent(),
    this.minQuantity = const Value.absent(),
    this.maxQuantity = const Value.absent(),
    this.price = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.uom = const Value.absent(),
    this.priceOrDiscount = const Value.absent(),
    this.customerGroup = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.category = const Value.absent(),
    this.applicableFor = const Value.absent(),
    this.applyOn = const Value.absent(),
    this.title = const Value.absent(),
    this.ruleName = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.isDiscountEnable = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  });
  ItemPricingRuleCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    required int priority,
    this.itemId = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.priceList = const Value.absent(),
    this.customerId = const Value.absent(),
    required double minQuantity,
    required double maxQuantity,
    required double price,
    required double discountPercentage,
    this.uom = const Value.absent(),
    this.priceOrDiscount = const Value.absent(),
    this.customerGroup = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.category = const Value.absent(),
    this.applicableFor = const Value.absent(),
    this.applyOn = const Value.absent(),
    this.title = const Value.absent(),
    this.ruleName = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.isDiscountEnable = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  })  : priority = Value(priority),
        minQuantity = Value(minQuantity),
        maxQuantity = Value(maxQuantity),
        price = Value(price),
        discountPercentage = Value(discountPercentage);
  static Insertable<ItemPricingRuleData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<int>? priority,
    Expression<String>? itemId,
    Expression<String>? itemCode,
    Expression<String>? priceList,
    Expression<String>? customerId,
    Expression<double>? minQuantity,
    Expression<double>? maxQuantity,
    Expression<double>? price,
    Expression<double>? discountPercentage,
    Expression<String>? uom,
    Expression<String>? priceOrDiscount,
    Expression<String>? customerGroup,
    Expression<String>? itemGroup,
    Expression<String>? category,
    Expression<String>? applicableFor,
    Expression<String>? applyOn,
    Expression<String>? title,
    Expression<String>? ruleName,
    Expression<bool>? isActive,
    Expression<bool>? isDeleted,
    Expression<bool>? isDiscountEnable,
    Expression<DateTime>? validFrom,
    Expression<DateTime>? validTo,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (priority != null) 'priority': priority,
      if (itemId != null) 'item_id': itemId,
      if (itemCode != null) 'item_code': itemCode,
      if (priceList != null) 'price_list': priceList,
      if (customerId != null) 'customer_id': customerId,
      if (minQuantity != null) 'min_quantity': minQuantity,
      if (maxQuantity != null) 'max_quantity': maxQuantity,
      if (price != null) 'price': price,
      if (discountPercentage != null) 'discount_percentage': discountPercentage,
      if (uom != null) 'uom': uom,
      if (priceOrDiscount != null) 'price_or_discount': priceOrDiscount,
      if (customerGroup != null) 'customer_group': customerGroup,
      if (itemGroup != null) 'item_group': itemGroup,
      if (category != null) 'category': category,
      if (applicableFor != null) 'applicable_for': applicableFor,
      if (applyOn != null) 'apply_on': applyOn,
      if (title != null) 'title': title,
      if (ruleName != null) 'rule_name': ruleName,
      if (isActive != null) 'is_active': isActive,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (isDiscountEnable != null) 'is_discount_enable': isDiscountEnable,
      if (validFrom != null) 'valid_from': validFrom,
      if (validTo != null) 'valid_to': validTo,
    });
  }

  ItemPricingRuleCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<int>? priority,
      Value<String?>? itemId,
      Value<String?>? itemCode,
      Value<String?>? priceList,
      Value<String?>? customerId,
      Value<double>? minQuantity,
      Value<double>? maxQuantity,
      Value<double>? price,
      Value<double>? discountPercentage,
      Value<String?>? uom,
      Value<String?>? priceOrDiscount,
      Value<String?>? customerGroup,
      Value<String?>? itemGroup,
      Value<String?>? category,
      Value<String?>? applicableFor,
      Value<String?>? applyOn,
      Value<String?>? title,
      Value<String?>? ruleName,
      Value<bool>? isActive,
      Value<bool>? isDeleted,
      Value<bool>? isDiscountEnable,
      Value<DateTime?>? validFrom,
      Value<DateTime?>? validTo}) {
    return ItemPricingRuleCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      priority: priority ?? this.priority,
      itemId: itemId ?? this.itemId,
      itemCode: itemCode ?? this.itemCode,
      priceList: priceList ?? this.priceList,
      customerId: customerId ?? this.customerId,
      minQuantity: minQuantity ?? this.minQuantity,
      maxQuantity: maxQuantity ?? this.maxQuantity,
      price: price ?? this.price,
      discountPercentage: discountPercentage ?? this.discountPercentage,
      uom: uom ?? this.uom,
      priceOrDiscount: priceOrDiscount ?? this.priceOrDiscount,
      customerGroup: customerGroup ?? this.customerGroup,
      itemGroup: itemGroup ?? this.itemGroup,
      category: category ?? this.category,
      applicableFor: applicableFor ?? this.applicableFor,
      applyOn: applyOn ?? this.applyOn,
      title: title ?? this.title,
      ruleName: ruleName ?? this.ruleName,
      isActive: isActive ?? this.isActive,
      isDeleted: isDeleted ?? this.isDeleted,
      isDiscountEnable: isDiscountEnable ?? this.isDiscountEnable,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo ?? this.validTo,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (priority.present) {
      map['priority'] = Variable<int>(priority.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (priceList.present) {
      map['price_list'] = Variable<String>(priceList.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (minQuantity.present) {
      map['min_quantity'] = Variable<double>(minQuantity.value);
    }
    if (maxQuantity.present) {
      map['max_quantity'] = Variable<double>(maxQuantity.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (discountPercentage.present) {
      map['discount_percentage'] = Variable<double>(discountPercentage.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    if (priceOrDiscount.present) {
      map['price_or_discount'] = Variable<String>(priceOrDiscount.value);
    }
    if (customerGroup.present) {
      map['customer_group'] = Variable<String>(customerGroup.value);
    }
    if (itemGroup.present) {
      map['item_group'] = Variable<String>(itemGroup.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (applicableFor.present) {
      map['applicable_for'] = Variable<String>(applicableFor.value);
    }
    if (applyOn.present) {
      map['apply_on'] = Variable<String>(applyOn.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (ruleName.present) {
      map['rule_name'] = Variable<String>(ruleName.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (isDiscountEnable.present) {
      map['is_discount_enable'] = Variable<bool>(isDiscountEnable.value);
    }
    if (validFrom.present) {
      map['valid_from'] = Variable<DateTime>(validFrom.value);
    }
    if (validTo.present) {
      map['valid_to'] = Variable<DateTime>(validTo.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemPricingRuleCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('priority: $priority, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('priceList: $priceList, ')
          ..write('customerId: $customerId, ')
          ..write('minQuantity: $minQuantity, ')
          ..write('maxQuantity: $maxQuantity, ')
          ..write('price: $price, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('uom: $uom, ')
          ..write('priceOrDiscount: $priceOrDiscount, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('applicableFor: $applicableFor, ')
          ..write('applyOn: $applyOn, ')
          ..write('title: $title, ')
          ..write('ruleName: $ruleName, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('isDiscountEnable: $isDiscountEnable, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }
}

class $CategoresTable extends Categores
    with TableInfo<$CategoresTable, Categore> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CategoresTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
      'item_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _parentCategoryMeta =
      const VerificationMeta('parentCategory');
  @override
  late final GeneratedColumn<String> parentCategory = GeneratedColumn<String>(
      'parent_category', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _categoryMeta =
      const VerificationMeta('category');
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
      'category', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [tenantId, id, itemId, parentCategory, category];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'categores';
  @override
  VerificationContext validateIntegrity(Insertable<Categore> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    }
    if (data.containsKey('parent_category')) {
      context.handle(
          _parentCategoryMeta,
          parentCategory.isAcceptableOrUnknown(
              data['parent_category']!, _parentCategoryMeta));
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category']!, _categoryMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Categore map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Categore(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_id']),
      parentCategory: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}parent_category']),
      category: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}category']),
    );
  }

  @override
  $CategoresTable createAlias(String alias) {
    return $CategoresTable(attachedDatabase, alias);
  }
}

class Categore extends DataClass implements Insertable<Categore> {
  final String? tenantId;
  final int id;
  final String? itemId;
  final String? parentCategory;
  final String? category;
  const Categore(
      {this.tenantId,
      required this.id,
      this.itemId,
      this.parentCategory,
      this.category});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || parentCategory != null) {
      map['parent_category'] = Variable<String>(parentCategory);
    }
    if (!nullToAbsent || category != null) {
      map['category'] = Variable<String>(category);
    }
    return map;
  }

  CategoresCompanion toCompanion(bool nullToAbsent) {
    return CategoresCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      parentCategory: parentCategory == null && nullToAbsent
          ? const Value.absent()
          : Value(parentCategory),
      category: category == null && nullToAbsent
          ? const Value.absent()
          : Value(category),
    );
  }

  factory Categore.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Categore(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<String?>(json['itemId']),
      parentCategory: serializer.fromJson<String?>(json['parentCategory']),
      category: serializer.fromJson<String?>(json['category']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemId': serializer.toJson<String?>(itemId),
      'parentCategory': serializer.toJson<String?>(parentCategory),
      'category': serializer.toJson<String?>(category),
    };
  }

  Categore copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> itemId = const Value.absent(),
          Value<String?> parentCategory = const Value.absent(),
          Value<String?> category = const Value.absent()}) =>
      Categore(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        itemId: itemId.present ? itemId.value : this.itemId,
        parentCategory:
            parentCategory.present ? parentCategory.value : this.parentCategory,
        category: category.present ? category.value : this.category,
      );
  @override
  String toString() {
    return (StringBuffer('Categore(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('parentCategory: $parentCategory, ')
          ..write('category: $category')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(tenantId, id, itemId, parentCategory, category);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Categore &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.parentCategory == this.parentCategory &&
          other.category == this.category);
}

class CategoresCompanion extends UpdateCompanion<Categore> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> itemId;
  final Value<String?> parentCategory;
  final Value<String?> category;
  const CategoresCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.parentCategory = const Value.absent(),
    this.category = const Value.absent(),
  });
  CategoresCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.parentCategory = const Value.absent(),
    this.category = const Value.absent(),
  });
  static Insertable<Categore> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? itemId,
    Expression<String>? parentCategory,
    Expression<String>? category,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (parentCategory != null) 'parent_category': parentCategory,
      if (category != null) 'category': category,
    });
  }

  CategoresCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? itemId,
      Value<String?>? parentCategory,
      Value<String?>? category}) {
    return CategoresCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      parentCategory: parentCategory ?? this.parentCategory,
      category: category ?? this.category,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (parentCategory.present) {
      map['parent_category'] = Variable<String>(parentCategory.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CategoresCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('parentCategory: $parentCategory, ')
          ..write('category: $category')
          ..write(')'))
        .toString();
  }
}

class $ItemGroupsTable extends ItemGroups
    with TableInfo<$ItemGroupsTable, ItemGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ItemGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
      'item_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _parentGroupMeta =
      const VerificationMeta('parentGroup');
  @override
  late final GeneratedColumn<String> parentGroup = GeneratedColumn<String>(
      'parent_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _groupMeta = const VerificationMeta('group');
  @override
  late final GeneratedColumn<String> group = GeneratedColumn<String>(
      'group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [tenantId, id, itemId, parentGroup, group];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'item_groups';
  @override
  VerificationContext validateIntegrity(Insertable<ItemGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    }
    if (data.containsKey('parent_group')) {
      context.handle(
          _parentGroupMeta,
          parentGroup.isAcceptableOrUnknown(
              data['parent_group']!, _parentGroupMeta));
    }
    if (data.containsKey('group')) {
      context.handle(
          _groupMeta, group.isAcceptableOrUnknown(data['group']!, _groupMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ItemGroup(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_id']),
      parentGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}parent_group']),
      group: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}group']),
    );
  }

  @override
  $ItemGroupsTable createAlias(String alias) {
    return $ItemGroupsTable(attachedDatabase, alias);
  }
}

class ItemGroup extends DataClass implements Insertable<ItemGroup> {
  final String? tenantId;
  final int id;
  final String? itemId;
  final String? parentGroup;
  final String? group;
  const ItemGroup(
      {this.tenantId,
      required this.id,
      this.itemId,
      this.parentGroup,
      this.group});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || parentGroup != null) {
      map['parent_group'] = Variable<String>(parentGroup);
    }
    if (!nullToAbsent || group != null) {
      map['group'] = Variable<String>(group);
    }
    return map;
  }

  ItemGroupsCompanion toCompanion(bool nullToAbsent) {
    return ItemGroupsCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      parentGroup: parentGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(parentGroup),
      group:
          group == null && nullToAbsent ? const Value.absent() : Value(group),
    );
  }

  factory ItemGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemGroup(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<String?>(json['itemId']),
      parentGroup: serializer.fromJson<String?>(json['parentGroup']),
      group: serializer.fromJson<String?>(json['group']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemId': serializer.toJson<String?>(itemId),
      'parentGroup': serializer.toJson<String?>(parentGroup),
      'group': serializer.toJson<String?>(group),
    };
  }

  ItemGroup copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> itemId = const Value.absent(),
          Value<String?> parentGroup = const Value.absent(),
          Value<String?> group = const Value.absent()}) =>
      ItemGroup(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        itemId: itemId.present ? itemId.value : this.itemId,
        parentGroup: parentGroup.present ? parentGroup.value : this.parentGroup,
        group: group.present ? group.value : this.group,
      );
  @override
  String toString() {
    return (StringBuffer('ItemGroup(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('parentGroup: $parentGroup, ')
          ..write('group: $group')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, itemId, parentGroup, group);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemGroup &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.parentGroup == this.parentGroup &&
          other.group == this.group);
}

class ItemGroupsCompanion extends UpdateCompanion<ItemGroup> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> itemId;
  final Value<String?> parentGroup;
  final Value<String?> group;
  const ItemGroupsCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.parentGroup = const Value.absent(),
    this.group = const Value.absent(),
  });
  ItemGroupsCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.parentGroup = const Value.absent(),
    this.group = const Value.absent(),
  });
  static Insertable<ItemGroup> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? itemId,
    Expression<String>? parentGroup,
    Expression<String>? group,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (parentGroup != null) 'parent_group': parentGroup,
      if (group != null) 'group': group,
    });
  }

  ItemGroupsCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? itemId,
      Value<String?>? parentGroup,
      Value<String?>? group}) {
    return ItemGroupsCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      parentGroup: parentGroup ?? this.parentGroup,
      group: group ?? this.group,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (parentGroup.present) {
      map['parent_group'] = Variable<String>(parentGroup.value);
    }
    if (group.present) {
      map['group'] = Variable<String>(group.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemGroupsCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('parentGroup: $parentGroup, ')
          ..write('group: $group')
          ..write(')'))
        .toString();
  }
}

class $PriceListTable extends PriceList
    with TableInfo<$PriceListTable, PriceListData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PriceListTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _priceListNameMeta =
      const VerificationMeta('priceListName');
  @override
  late final GeneratedColumn<String> priceListName = GeneratedColumn<String>(
      'price_list_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _currencyMeta =
      const VerificationMeta('currency');
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
      'currency', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isBuyingMeta =
      const VerificationMeta('isBuying');
  @override
  late final GeneratedColumn<bool> isBuying = GeneratedColumn<bool>(
      'is_buying', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_buying" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isSellingMeta =
      const VerificationMeta('isSelling');
  @override
  late final GeneratedColumn<bool> isSelling = GeneratedColumn<bool>(
      'is_selling', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_selling" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isPriceNotUOMDependencyMeta =
      const VerificationMeta('isPriceNotUOMDependency');
  @override
  late final GeneratedColumn<bool> isPriceNotUOMDependency =
      GeneratedColumn<bool>('is_price_not_u_o_m_dependency', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          defaultConstraints: GeneratedColumn.constraintIsAlways(
              'CHECK ("is_price_not_u_o_m_dependency" IN (0, 1))'),
          defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        priceListName,
        currency,
        isActive,
        isBuying,
        isSelling,
        isPriceNotUOMDependency
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'price_list';
  @override
  VerificationContext validateIntegrity(Insertable<PriceListData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('price_list_name')) {
      context.handle(
          _priceListNameMeta,
          priceListName.isAcceptableOrUnknown(
              data['price_list_name']!, _priceListNameMeta));
    } else if (isInserting) {
      context.missing(_priceListNameMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('is_buying')) {
      context.handle(_isBuyingMeta,
          isBuying.isAcceptableOrUnknown(data['is_buying']!, _isBuyingMeta));
    }
    if (data.containsKey('is_selling')) {
      context.handle(_isSellingMeta,
          isSelling.isAcceptableOrUnknown(data['is_selling']!, _isSellingMeta));
    }
    if (data.containsKey('is_price_not_u_o_m_dependency')) {
      context.handle(
          _isPriceNotUOMDependencyMeta,
          isPriceNotUOMDependency.isAcceptableOrUnknown(
              data['is_price_not_u_o_m_dependency']!,
              _isPriceNotUOMDependencyMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PriceListData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PriceListData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      priceListName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}price_list_name'])!,
      currency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}currency']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      isBuying: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_buying'])!,
      isSelling: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_selling'])!,
      isPriceNotUOMDependency: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}is_price_not_u_o_m_dependency'])!,
    );
  }

  @override
  $PriceListTable createAlias(String alias) {
    return $PriceListTable(attachedDatabase, alias);
  }
}

class PriceListData extends DataClass implements Insertable<PriceListData> {
  final String? tenantId;
  final int id;
  final String priceListName;
  final String? currency;
  final bool isActive;
  final bool isBuying;
  final bool isSelling;
  final bool isPriceNotUOMDependency;
  const PriceListData(
      {this.tenantId,
      required this.id,
      required this.priceListName,
      this.currency,
      required this.isActive,
      required this.isBuying,
      required this.isSelling,
      required this.isPriceNotUOMDependency});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    map['price_list_name'] = Variable<String>(priceListName);
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['is_buying'] = Variable<bool>(isBuying);
    map['is_selling'] = Variable<bool>(isSelling);
    map['is_price_not_u_o_m_dependency'] =
        Variable<bool>(isPriceNotUOMDependency);
    return map;
  }

  PriceListCompanion toCompanion(bool nullToAbsent) {
    return PriceListCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      priceListName: Value(priceListName),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      isActive: Value(isActive),
      isBuying: Value(isBuying),
      isSelling: Value(isSelling),
      isPriceNotUOMDependency: Value(isPriceNotUOMDependency),
    );
  }

  factory PriceListData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PriceListData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      priceListName: serializer.fromJson<String>(json['priceListName']),
      currency: serializer.fromJson<String?>(json['currency']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isBuying: serializer.fromJson<bool>(json['isBuying']),
      isSelling: serializer.fromJson<bool>(json['isSelling']),
      isPriceNotUOMDependency:
          serializer.fromJson<bool>(json['isPriceNotUOMDependency']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'priceListName': serializer.toJson<String>(priceListName),
      'currency': serializer.toJson<String?>(currency),
      'isActive': serializer.toJson<bool>(isActive),
      'isBuying': serializer.toJson<bool>(isBuying),
      'isSelling': serializer.toJson<bool>(isSelling),
      'isPriceNotUOMDependency':
          serializer.toJson<bool>(isPriceNotUOMDependency),
    };
  }

  PriceListData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          String? priceListName,
          Value<String?> currency = const Value.absent(),
          bool? isActive,
          bool? isBuying,
          bool? isSelling,
          bool? isPriceNotUOMDependency}) =>
      PriceListData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        priceListName: priceListName ?? this.priceListName,
        currency: currency.present ? currency.value : this.currency,
        isActive: isActive ?? this.isActive,
        isBuying: isBuying ?? this.isBuying,
        isSelling: isSelling ?? this.isSelling,
        isPriceNotUOMDependency:
            isPriceNotUOMDependency ?? this.isPriceNotUOMDependency,
      );
  @override
  String toString() {
    return (StringBuffer('PriceListData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('priceListName: $priceListName, ')
          ..write('currency: $currency, ')
          ..write('isActive: $isActive, ')
          ..write('isBuying: $isBuying, ')
          ..write('isSelling: $isSelling, ')
          ..write('isPriceNotUOMDependency: $isPriceNotUOMDependency')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, priceListName, currency,
      isActive, isBuying, isSelling, isPriceNotUOMDependency);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PriceListData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.priceListName == this.priceListName &&
          other.currency == this.currency &&
          other.isActive == this.isActive &&
          other.isBuying == this.isBuying &&
          other.isSelling == this.isSelling &&
          other.isPriceNotUOMDependency == this.isPriceNotUOMDependency);
}

class PriceListCompanion extends UpdateCompanion<PriceListData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String> priceListName;
  final Value<String?> currency;
  final Value<bool> isActive;
  final Value<bool> isBuying;
  final Value<bool> isSelling;
  final Value<bool> isPriceNotUOMDependency;
  const PriceListCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.priceListName = const Value.absent(),
    this.currency = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isBuying = const Value.absent(),
    this.isSelling = const Value.absent(),
    this.isPriceNotUOMDependency = const Value.absent(),
  });
  PriceListCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    required String priceListName,
    this.currency = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isBuying = const Value.absent(),
    this.isSelling = const Value.absent(),
    this.isPriceNotUOMDependency = const Value.absent(),
  }) : priceListName = Value(priceListName);
  static Insertable<PriceListData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? priceListName,
    Expression<String>? currency,
    Expression<bool>? isActive,
    Expression<bool>? isBuying,
    Expression<bool>? isSelling,
    Expression<bool>? isPriceNotUOMDependency,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (priceListName != null) 'price_list_name': priceListName,
      if (currency != null) 'currency': currency,
      if (isActive != null) 'is_active': isActive,
      if (isBuying != null) 'is_buying': isBuying,
      if (isSelling != null) 'is_selling': isSelling,
      if (isPriceNotUOMDependency != null)
        'is_price_not_u_o_m_dependency': isPriceNotUOMDependency,
    });
  }

  PriceListCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String>? priceListName,
      Value<String?>? currency,
      Value<bool>? isActive,
      Value<bool>? isBuying,
      Value<bool>? isSelling,
      Value<bool>? isPriceNotUOMDependency}) {
    return PriceListCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      priceListName: priceListName ?? this.priceListName,
      currency: currency ?? this.currency,
      isActive: isActive ?? this.isActive,
      isBuying: isBuying ?? this.isBuying,
      isSelling: isSelling ?? this.isSelling,
      isPriceNotUOMDependency:
          isPriceNotUOMDependency ?? this.isPriceNotUOMDependency,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (priceListName.present) {
      map['price_list_name'] = Variable<String>(priceListName.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isBuying.present) {
      map['is_buying'] = Variable<bool>(isBuying.value);
    }
    if (isSelling.present) {
      map['is_selling'] = Variable<bool>(isSelling.value);
    }
    if (isPriceNotUOMDependency.present) {
      map['is_price_not_u_o_m_dependency'] =
          Variable<bool>(isPriceNotUOMDependency.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PriceListCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('priceListName: $priceListName, ')
          ..write('currency: $currency, ')
          ..write('isActive: $isActive, ')
          ..write('isBuying: $isBuying, ')
          ..write('isSelling: $isSelling, ')
          ..write('isPriceNotUOMDependency: $isPriceNotUOMDependency')
          ..write(')'))
        .toString();
  }
}

class $UnitOfMeasureTable extends UnitOfMeasure
    with TableInfo<$UnitOfMeasureTable, UnitOfMeasureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UnitOfMeasureTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _uomMeta = const VerificationMeta('uom');
  @override
  late final GeneratedColumn<String> uom = GeneratedColumn<String>(
      'uom', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [tenantId, id, uom];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'unit_of_measure';
  @override
  VerificationContext validateIntegrity(Insertable<UnitOfMeasureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom']!, _uomMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UnitOfMeasureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UnitOfMeasureData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uom']),
    );
  }

  @override
  $UnitOfMeasureTable createAlias(String alias) {
    return $UnitOfMeasureTable(attachedDatabase, alias);
  }
}

class UnitOfMeasureData extends DataClass
    implements Insertable<UnitOfMeasureData> {
  final String? tenantId;
  final int id;
  final String? uom;
  const UnitOfMeasureData({this.tenantId, required this.id, this.uom});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    return map;
  }

  UnitOfMeasureCompanion toCompanion(bool nullToAbsent) {
    return UnitOfMeasureCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
    );
  }

  factory UnitOfMeasureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UnitOfMeasureData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      uom: serializer.fromJson<String?>(json['uom']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'uom': serializer.toJson<String?>(uom),
    };
  }

  UnitOfMeasureData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> uom = const Value.absent()}) =>
      UnitOfMeasureData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        uom: uom.present ? uom.value : this.uom,
      );
  @override
  String toString() {
    return (StringBuffer('UnitOfMeasureData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('uom: $uom')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, uom);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UnitOfMeasureData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.uom == this.uom);
}

class UnitOfMeasureCompanion extends UpdateCompanion<UnitOfMeasureData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> uom;
  const UnitOfMeasureCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.uom = const Value.absent(),
  });
  UnitOfMeasureCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.uom = const Value.absent(),
  });
  static Insertable<UnitOfMeasureData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? uom,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (uom != null) 'uom': uom,
    });
  }

  UnitOfMeasureCompanion copyWith(
      {Value<String?>? tenantId, Value<int>? id, Value<String?>? uom}) {
    return UnitOfMeasureCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      uom: uom ?? this.uom,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UnitOfMeasureCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('uom: $uom')
          ..write(')'))
        .toString();
  }
}

class $StockUnitOfMeasureTable extends StockUnitOfMeasure
    with TableInfo<$StockUnitOfMeasureTable, StockUnitOfMeasureData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $StockUnitOfMeasureTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
      'item_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _uomMeta = const VerificationMeta('uom');
  @override
  late final GeneratedColumn<String> uom = GeneratedColumn<String>(
      'uom', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createUserIdMeta =
      const VerificationMeta('createUserId');
  @override
  late final GeneratedColumn<int> createUserId = GeneratedColumn<int>(
      'create_user_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _creationTimeMeta =
      const VerificationMeta('creationTime');
  @override
  late final GeneratedColumn<DateTime> creationTime = GeneratedColumn<DateTime>(
      'creation_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deleteTimeMeta =
      const VerificationMeta('deleteTime');
  @override
  late final GeneratedColumn<DateTime> deleteTime = GeneratedColumn<DateTime>(
      'delete_time', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _deleteUserIdMeta =
      const VerificationMeta('deleteUserId');
  @override
  late final GeneratedColumn<int> deleteUserId = GeneratedColumn<int>(
      'delete_user_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _creatorUserMeta =
      const VerificationMeta('creatorUser');
  @override
  late final GeneratedColumn<String> creatorUser = GeneratedColumn<String>(
      'creator_user', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deleterUserIdMeta =
      const VerificationMeta('deleterUserId');
  @override
  late final GeneratedColumn<String> deleterUserId = GeneratedColumn<String>(
      'deleter_user_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _lastModifierUserMeta =
      const VerificationMeta('lastModifierUser');
  @override
  late final GeneratedColumn<String> lastModifierUser = GeneratedColumn<String>(
      'last_modifier_user', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _lastModifierUserIdMeta =
      const VerificationMeta('lastModifierUserId');
  @override
  late final GeneratedColumn<int> lastModifierUserId = GeneratedColumn<int>(
      'last_modifier_user_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        itemId,
        uom,
        createUserId,
        creationTime,
        deleteTime,
        deleteUserId,
        creatorUser,
        deleterUserId,
        isDeleted,
        lastModifierUser,
        lastModifierUserId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_unit_of_measure';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockUnitOfMeasureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom']!, _uomMeta));
    }
    if (data.containsKey('create_user_id')) {
      context.handle(
          _createUserIdMeta,
          createUserId.isAcceptableOrUnknown(
              data['create_user_id']!, _createUserIdMeta));
    }
    if (data.containsKey('creation_time')) {
      context.handle(
          _creationTimeMeta,
          creationTime.isAcceptableOrUnknown(
              data['creation_time']!, _creationTimeMeta));
    }
    if (data.containsKey('delete_time')) {
      context.handle(
          _deleteTimeMeta,
          deleteTime.isAcceptableOrUnknown(
              data['delete_time']!, _deleteTimeMeta));
    }
    if (data.containsKey('delete_user_id')) {
      context.handle(
          _deleteUserIdMeta,
          deleteUserId.isAcceptableOrUnknown(
              data['delete_user_id']!, _deleteUserIdMeta));
    }
    if (data.containsKey('creator_user')) {
      context.handle(
          _creatorUserMeta,
          creatorUser.isAcceptableOrUnknown(
              data['creator_user']!, _creatorUserMeta));
    }
    if (data.containsKey('deleter_user_id')) {
      context.handle(
          _deleterUserIdMeta,
          deleterUserId.isAcceptableOrUnknown(
              data['deleter_user_id']!, _deleterUserIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('last_modifier_user')) {
      context.handle(
          _lastModifierUserMeta,
          lastModifierUser.isAcceptableOrUnknown(
              data['last_modifier_user']!, _lastModifierUserMeta));
    }
    if (data.containsKey('last_modifier_user_id')) {
      context.handle(
          _lastModifierUserIdMeta,
          lastModifierUserId.isAcceptableOrUnknown(
              data['last_modifier_user_id']!, _lastModifierUserIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StockUnitOfMeasureData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockUnitOfMeasureData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_id']),
      uom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uom']),
      createUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}create_user_id']),
      creationTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}creation_time']),
      deleteTime: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}delete_time']),
      deleteUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}delete_user_id']),
      creatorUser: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}creator_user']),
      deleterUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}deleter_user_id']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      lastModifierUser: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}last_modifier_user']),
      lastModifierUserId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}last_modifier_user_id']),
    );
  }

  @override
  $StockUnitOfMeasureTable createAlias(String alias) {
    return $StockUnitOfMeasureTable(attachedDatabase, alias);
  }
}

class StockUnitOfMeasureData extends DataClass
    implements Insertable<StockUnitOfMeasureData> {
  final String? tenantId;
  final int id;
  final String? itemId;
  final String? uom;
  final int? createUserId;
  final DateTime? creationTime;
  final DateTime? deleteTime;
  final int? deleteUserId;
  final String? creatorUser;
  final String? deleterUserId;
  final bool isDeleted;
  final String? lastModifierUser;
  final int? lastModifierUserId;
  const StockUnitOfMeasureData(
      {this.tenantId,
      required this.id,
      this.itemId,
      this.uom,
      this.createUserId,
      this.creationTime,
      this.deleteTime,
      this.deleteUserId,
      this.creatorUser,
      this.deleterUserId,
      required this.isDeleted,
      this.lastModifierUser,
      this.lastModifierUserId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    if (!nullToAbsent || createUserId != null) {
      map['create_user_id'] = Variable<int>(createUserId);
    }
    if (!nullToAbsent || creationTime != null) {
      map['creation_time'] = Variable<DateTime>(creationTime);
    }
    if (!nullToAbsent || deleteTime != null) {
      map['delete_time'] = Variable<DateTime>(deleteTime);
    }
    if (!nullToAbsent || deleteUserId != null) {
      map['delete_user_id'] = Variable<int>(deleteUserId);
    }
    if (!nullToAbsent || creatorUser != null) {
      map['creator_user'] = Variable<String>(creatorUser);
    }
    if (!nullToAbsent || deleterUserId != null) {
      map['deleter_user_id'] = Variable<String>(deleterUserId);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || lastModifierUser != null) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser);
    }
    if (!nullToAbsent || lastModifierUserId != null) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId);
    }
    return map;
  }

  StockUnitOfMeasureCompanion toCompanion(bool nullToAbsent) {
    return StockUnitOfMeasureCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
      createUserId: createUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(createUserId),
      creationTime: creationTime == null && nullToAbsent
          ? const Value.absent()
          : Value(creationTime),
      deleteTime: deleteTime == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteTime),
      deleteUserId: deleteUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteUserId),
      creatorUser: creatorUser == null && nullToAbsent
          ? const Value.absent()
          : Value(creatorUser),
      deleterUserId: deleterUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleterUserId),
      isDeleted: Value(isDeleted),
      lastModifierUser: lastModifierUser == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUser),
      lastModifierUserId: lastModifierUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUserId),
    );
  }

  factory StockUnitOfMeasureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockUnitOfMeasureData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<String?>(json['itemId']),
      uom: serializer.fromJson<String?>(json['uom']),
      createUserId: serializer.fromJson<int?>(json['createUserId']),
      creationTime: serializer.fromJson<DateTime?>(json['creationTime']),
      deleteTime: serializer.fromJson<DateTime?>(json['deleteTime']),
      deleteUserId: serializer.fromJson<int?>(json['deleteUserId']),
      creatorUser: serializer.fromJson<String?>(json['creatorUser']),
      deleterUserId: serializer.fromJson<String?>(json['deleterUserId']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      lastModifierUser: serializer.fromJson<String?>(json['lastModifierUser']),
      lastModifierUserId: serializer.fromJson<int?>(json['lastModifierUserId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemId': serializer.toJson<String?>(itemId),
      'uom': serializer.toJson<String?>(uom),
      'createUserId': serializer.toJson<int?>(createUserId),
      'creationTime': serializer.toJson<DateTime?>(creationTime),
      'deleteTime': serializer.toJson<DateTime?>(deleteTime),
      'deleteUserId': serializer.toJson<int?>(deleteUserId),
      'creatorUser': serializer.toJson<String?>(creatorUser),
      'deleterUserId': serializer.toJson<String?>(deleterUserId),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'lastModifierUser': serializer.toJson<String?>(lastModifierUser),
      'lastModifierUserId': serializer.toJson<int?>(lastModifierUserId),
    };
  }

  StockUnitOfMeasureData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> itemId = const Value.absent(),
          Value<String?> uom = const Value.absent(),
          Value<int?> createUserId = const Value.absent(),
          Value<DateTime?> creationTime = const Value.absent(),
          Value<DateTime?> deleteTime = const Value.absent(),
          Value<int?> deleteUserId = const Value.absent(),
          Value<String?> creatorUser = const Value.absent(),
          Value<String?> deleterUserId = const Value.absent(),
          bool? isDeleted,
          Value<String?> lastModifierUser = const Value.absent(),
          Value<int?> lastModifierUserId = const Value.absent()}) =>
      StockUnitOfMeasureData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        itemId: itemId.present ? itemId.value : this.itemId,
        uom: uom.present ? uom.value : this.uom,
        createUserId:
            createUserId.present ? createUserId.value : this.createUserId,
        creationTime:
            creationTime.present ? creationTime.value : this.creationTime,
        deleteTime: deleteTime.present ? deleteTime.value : this.deleteTime,
        deleteUserId:
            deleteUserId.present ? deleteUserId.value : this.deleteUserId,
        creatorUser: creatorUser.present ? creatorUser.value : this.creatorUser,
        deleterUserId:
            deleterUserId.present ? deleterUserId.value : this.deleterUserId,
        isDeleted: isDeleted ?? this.isDeleted,
        lastModifierUser: lastModifierUser.present
            ? lastModifierUser.value
            : this.lastModifierUser,
        lastModifierUserId: lastModifierUserId.present
            ? lastModifierUserId.value
            : this.lastModifierUserId,
      );
  @override
  String toString() {
    return (StringBuffer('StockUnitOfMeasureData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('uom: $uom, ')
          ..write('createUserId: $createUserId, ')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      itemId,
      uom,
      createUserId,
      creationTime,
      deleteTime,
      deleteUserId,
      creatorUser,
      deleterUserId,
      isDeleted,
      lastModifierUser,
      lastModifierUserId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockUnitOfMeasureData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.uom == this.uom &&
          other.createUserId == this.createUserId &&
          other.creationTime == this.creationTime &&
          other.deleteTime == this.deleteTime &&
          other.deleteUserId == this.deleteUserId &&
          other.creatorUser == this.creatorUser &&
          other.deleterUserId == this.deleterUserId &&
          other.isDeleted == this.isDeleted &&
          other.lastModifierUser == this.lastModifierUser &&
          other.lastModifierUserId == this.lastModifierUserId);
}

class StockUnitOfMeasureCompanion
    extends UpdateCompanion<StockUnitOfMeasureData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> itemId;
  final Value<String?> uom;
  final Value<int?> createUserId;
  final Value<DateTime?> creationTime;
  final Value<DateTime?> deleteTime;
  final Value<int?> deleteUserId;
  final Value<String?> creatorUser;
  final Value<String?> deleterUserId;
  final Value<bool> isDeleted;
  final Value<String?> lastModifierUser;
  final Value<int?> lastModifierUserId;
  const StockUnitOfMeasureCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.uom = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
  });
  StockUnitOfMeasureCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.uom = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
  });
  static Insertable<StockUnitOfMeasureData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? itemId,
    Expression<String>? uom,
    Expression<int>? createUserId,
    Expression<DateTime>? creationTime,
    Expression<DateTime>? deleteTime,
    Expression<int>? deleteUserId,
    Expression<String>? creatorUser,
    Expression<String>? deleterUserId,
    Expression<bool>? isDeleted,
    Expression<String>? lastModifierUser,
    Expression<int>? lastModifierUserId,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (uom != null) 'uom': uom,
      if (createUserId != null) 'create_user_id': createUserId,
      if (creationTime != null) 'creation_time': creationTime,
      if (deleteTime != null) 'delete_time': deleteTime,
      if (deleteUserId != null) 'delete_user_id': deleteUserId,
      if (creatorUser != null) 'creator_user': creatorUser,
      if (deleterUserId != null) 'deleter_user_id': deleterUserId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (lastModifierUser != null) 'last_modifier_user': lastModifierUser,
      if (lastModifierUserId != null)
        'last_modifier_user_id': lastModifierUserId,
    });
  }

  StockUnitOfMeasureCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? itemId,
      Value<String?>? uom,
      Value<int?>? createUserId,
      Value<DateTime?>? creationTime,
      Value<DateTime?>? deleteTime,
      Value<int?>? deleteUserId,
      Value<String?>? creatorUser,
      Value<String?>? deleterUserId,
      Value<bool>? isDeleted,
      Value<String?>? lastModifierUser,
      Value<int?>? lastModifierUserId}) {
    return StockUnitOfMeasureCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      uom: uom ?? this.uom,
      createUserId: createUserId ?? this.createUserId,
      creationTime: creationTime ?? this.creationTime,
      deleteTime: deleteTime ?? this.deleteTime,
      deleteUserId: deleteUserId ?? this.deleteUserId,
      creatorUser: creatorUser ?? this.creatorUser,
      deleterUserId: deleterUserId ?? this.deleterUserId,
      isDeleted: isDeleted ?? this.isDeleted,
      lastModifierUser: lastModifierUser ?? this.lastModifierUser,
      lastModifierUserId: lastModifierUserId ?? this.lastModifierUserId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    if (createUserId.present) {
      map['create_user_id'] = Variable<int>(createUserId.value);
    }
    if (creationTime.present) {
      map['creation_time'] = Variable<DateTime>(creationTime.value);
    }
    if (deleteTime.present) {
      map['delete_time'] = Variable<DateTime>(deleteTime.value);
    }
    if (deleteUserId.present) {
      map['delete_user_id'] = Variable<int>(deleteUserId.value);
    }
    if (creatorUser.present) {
      map['creator_user'] = Variable<String>(creatorUser.value);
    }
    if (deleterUserId.present) {
      map['deleter_user_id'] = Variable<String>(deleterUserId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (lastModifierUser.present) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser.value);
    }
    if (lastModifierUserId.present) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockUnitOfMeasureCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('uom: $uom, ')
          ..write('createUserId: $createUserId, ')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId')
          ..write(')'))
        .toString();
  }
}

class $JourneyPlanTable extends JourneyPlan
    with TableInfo<$JourneyPlanTable, JourneyPlanData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $JourneyPlanTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _customerIdMeta =
      const VerificationMeta('customerId');
  @override
  late final GeneratedColumn<String> customerId = GeneratedColumn<String>(
      'customer_id', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _customerNameMeta =
      const VerificationMeta('customerName');
  @override
  late final GeneratedColumn<String> customerName = GeneratedColumn<String>(
      'customer_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _companyNameMeta =
      const VerificationMeta('companyName');
  @override
  late final GeneratedColumn<String> companyName = GeneratedColumn<String>(
      'company_name', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _customerTypeMeta =
      const VerificationMeta('customerType');
  @override
  late final GeneratedColumn<String> customerType = GeneratedColumn<String>(
      'customer_type', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _customerGroupMeta =
      const VerificationMeta('customerGroup');
  @override
  late final GeneratedColumn<String> customerGroup = GeneratedColumn<String>(
      'customer_group', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _customerTerritoryMeta =
      const VerificationMeta('customerTerritory');
  @override
  late final GeneratedColumn<String> customerTerritory =
      GeneratedColumn<String>('customer_territory', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _billingAddressNameMeta =
      const VerificationMeta('billingAddressName');
  @override
  late final GeneratedColumn<String> billingAddressName =
      GeneratedColumn<String>('billing_address_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _shippingAddressNameMeta =
      const VerificationMeta('shippingAddressName');
  @override
  late final GeneratedColumn<String> shippingAddressName =
      GeneratedColumn<String>('shipping_address_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _assignToMeta =
      const VerificationMeta('assignTo');
  @override
  late final GeneratedColumn<String> assignTo = GeneratedColumn<String>(
      'assign_to', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _expiryDateMeta =
      const VerificationMeta('expiryDate');
  @override
  late final GeneratedColumn<DateTime> expiryDate = GeneratedColumn<DateTime>(
      'expiry_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _weekNumberMeta =
      const VerificationMeta('weekNumber');
  @override
  late final GeneratedColumn<int> weekNumber = GeneratedColumn<int>(
      'week_number', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _weekDayMeta =
      const VerificationMeta('weekDay');
  @override
  late final GeneratedColumn<String> weekDay = GeneratedColumn<String>(
      'week_day', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _inMilesMeta =
      const VerificationMeta('inMiles');
  @override
  late final GeneratedColumn<double> inMiles = GeneratedColumn<double>(
      'in_miles', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _inKilometerMeta =
      const VerificationMeta('inKilometer');
  @override
  late final GeneratedColumn<double> inKilometer = GeneratedColumn<double>(
      'in_kilometer', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _inMeterMeta =
      const VerificationMeta('inMeter');
  @override
  late final GeneratedColumn<double> inMeter = GeneratedColumn<double>(
      'in_meter', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _distanceLabelMeta =
      const VerificationMeta('distanceLabel');
  @override
  late final GeneratedColumn<String> distanceLabel = GeneratedColumn<String>(
      'distance_label', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _distanceUsedMeta =
      const VerificationMeta('distanceUsed');
  @override
  late final GeneratedColumn<double> distanceUsed = GeneratedColumn<double>(
      'distance_used', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _transactionStatusMeta =
      const VerificationMeta('transactionStatus');
  @override
  late final GeneratedColumn<String> transactionStatus =
      GeneratedColumn<String>('transaction_status', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        customerId,
        customerName,
        companyName,
        customerType,
        customerGroup,
        customerTerritory,
        billingAddressName,
        shippingAddressName,
        assignTo,
        expiryDate,
        weekNumber,
        weekDay,
        inMiles,
        inKilometer,
        inMeter,
        distanceLabel,
        distanceUsed,
        transactionStatus,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'journey_plan';
  @override
  VerificationContext validateIntegrity(Insertable<JourneyPlanData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id']!, _customerIdMeta));
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('customer_name')) {
      context.handle(
          _customerNameMeta,
          customerName.isAcceptableOrUnknown(
              data['customer_name']!, _customerNameMeta));
    } else if (isInserting) {
      context.missing(_customerNameMeta);
    }
    if (data.containsKey('company_name')) {
      context.handle(
          _companyNameMeta,
          companyName.isAcceptableOrUnknown(
              data['company_name']!, _companyNameMeta));
    } else if (isInserting) {
      context.missing(_companyNameMeta);
    }
    if (data.containsKey('customer_type')) {
      context.handle(
          _customerTypeMeta,
          customerType.isAcceptableOrUnknown(
              data['customer_type']!, _customerTypeMeta));
    } else if (isInserting) {
      context.missing(_customerTypeMeta);
    }
    if (data.containsKey('customer_group')) {
      context.handle(
          _customerGroupMeta,
          customerGroup.isAcceptableOrUnknown(
              data['customer_group']!, _customerGroupMeta));
    } else if (isInserting) {
      context.missing(_customerGroupMeta);
    }
    if (data.containsKey('customer_territory')) {
      context.handle(
          _customerTerritoryMeta,
          customerTerritory.isAcceptableOrUnknown(
              data['customer_territory']!, _customerTerritoryMeta));
    } else if (isInserting) {
      context.missing(_customerTerritoryMeta);
    }
    if (data.containsKey('billing_address_name')) {
      context.handle(
          _billingAddressNameMeta,
          billingAddressName.isAcceptableOrUnknown(
              data['billing_address_name']!, _billingAddressNameMeta));
    }
    if (data.containsKey('shipping_address_name')) {
      context.handle(
          _shippingAddressNameMeta,
          shippingAddressName.isAcceptableOrUnknown(
              data['shipping_address_name']!, _shippingAddressNameMeta));
    }
    if (data.containsKey('assign_to')) {
      context.handle(_assignToMeta,
          assignTo.isAcceptableOrUnknown(data['assign_to']!, _assignToMeta));
    }
    if (data.containsKey('expiry_date')) {
      context.handle(
          _expiryDateMeta,
          expiryDate.isAcceptableOrUnknown(
              data['expiry_date']!, _expiryDateMeta));
    }
    if (data.containsKey('week_number')) {
      context.handle(
          _weekNumberMeta,
          weekNumber.isAcceptableOrUnknown(
              data['week_number']!, _weekNumberMeta));
    }
    if (data.containsKey('week_day')) {
      context.handle(_weekDayMeta,
          weekDay.isAcceptableOrUnknown(data['week_day']!, _weekDayMeta));
    }
    if (data.containsKey('in_miles')) {
      context.handle(_inMilesMeta,
          inMiles.isAcceptableOrUnknown(data['in_miles']!, _inMilesMeta));
    }
    if (data.containsKey('in_kilometer')) {
      context.handle(
          _inKilometerMeta,
          inKilometer.isAcceptableOrUnknown(
              data['in_kilometer']!, _inKilometerMeta));
    }
    if (data.containsKey('in_meter')) {
      context.handle(_inMeterMeta,
          inMeter.isAcceptableOrUnknown(data['in_meter']!, _inMeterMeta));
    }
    if (data.containsKey('distance_label')) {
      context.handle(
          _distanceLabelMeta,
          distanceLabel.isAcceptableOrUnknown(
              data['distance_label']!, _distanceLabelMeta));
    }
    if (data.containsKey('distance_used')) {
      context.handle(
          _distanceUsedMeta,
          distanceUsed.isAcceptableOrUnknown(
              data['distance_used']!, _distanceUsedMeta));
    }
    if (data.containsKey('transaction_status')) {
      context.handle(
          _transactionStatusMeta,
          transactionStatus.isAcceptableOrUnknown(
              data['transaction_status']!, _transactionStatusMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  JourneyPlanData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return JourneyPlanData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      customerId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_id'])!,
      customerName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_name'])!,
      companyName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}company_name'])!,
      customerType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_type'])!,
      customerGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}customer_group'])!,
      customerTerritory: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}customer_territory'])!,
      billingAddressName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}billing_address_name']),
      shippingAddressName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}shipping_address_name']),
      assignTo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}assign_to']),
      expiryDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}expiry_date']),
      weekNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}week_number']),
      weekDay: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}week_day']),
      inMiles: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}in_miles']),
      inKilometer: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}in_kilometer']),
      inMeter: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}in_meter']),
      distanceLabel: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}distance_label']),
      distanceUsed: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}distance_used']),
      transactionStatus: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_status']),
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $JourneyPlanTable createAlias(String alias) {
    return $JourneyPlanTable(attachedDatabase, alias);
  }
}

class JourneyPlanData extends DataClass implements Insertable<JourneyPlanData> {
  final String? tenantId;
  final int id;
  final String customerId;
  final String customerName;
  final String companyName;
  final String customerType;
  final String customerGroup;
  final String customerTerritory;
  final String? billingAddressName;
  final String? shippingAddressName;
  final String? assignTo;
  final DateTime? expiryDate;
  final int? weekNumber;
  final String? weekDay;
  final double? inMiles;
  final double? inKilometer;
  final double? inMeter;
  final String? distanceLabel;
  final double? distanceUsed;
  final String? transactionStatus;
  final bool isDeleted;
  const JourneyPlanData(
      {this.tenantId,
      required this.id,
      required this.customerId,
      required this.customerName,
      required this.companyName,
      required this.customerType,
      required this.customerGroup,
      required this.customerTerritory,
      this.billingAddressName,
      this.shippingAddressName,
      this.assignTo,
      this.expiryDate,
      this.weekNumber,
      this.weekDay,
      this.inMiles,
      this.inKilometer,
      this.inMeter,
      this.distanceLabel,
      this.distanceUsed,
      this.transactionStatus,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    map['customer_id'] = Variable<String>(customerId);
    map['customer_name'] = Variable<String>(customerName);
    map['company_name'] = Variable<String>(companyName);
    map['customer_type'] = Variable<String>(customerType);
    map['customer_group'] = Variable<String>(customerGroup);
    map['customer_territory'] = Variable<String>(customerTerritory);
    if (!nullToAbsent || billingAddressName != null) {
      map['billing_address_name'] = Variable<String>(billingAddressName);
    }
    if (!nullToAbsent || shippingAddressName != null) {
      map['shipping_address_name'] = Variable<String>(shippingAddressName);
    }
    if (!nullToAbsent || assignTo != null) {
      map['assign_to'] = Variable<String>(assignTo);
    }
    if (!nullToAbsent || expiryDate != null) {
      map['expiry_date'] = Variable<DateTime>(expiryDate);
    }
    if (!nullToAbsent || weekNumber != null) {
      map['week_number'] = Variable<int>(weekNumber);
    }
    if (!nullToAbsent || weekDay != null) {
      map['week_day'] = Variable<String>(weekDay);
    }
    if (!nullToAbsent || inMiles != null) {
      map['in_miles'] = Variable<double>(inMiles);
    }
    if (!nullToAbsent || inKilometer != null) {
      map['in_kilometer'] = Variable<double>(inKilometer);
    }
    if (!nullToAbsent || inMeter != null) {
      map['in_meter'] = Variable<double>(inMeter);
    }
    if (!nullToAbsent || distanceLabel != null) {
      map['distance_label'] = Variable<String>(distanceLabel);
    }
    if (!nullToAbsent || distanceUsed != null) {
      map['distance_used'] = Variable<double>(distanceUsed);
    }
    if (!nullToAbsent || transactionStatus != null) {
      map['transaction_status'] = Variable<String>(transactionStatus);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  JourneyPlanCompanion toCompanion(bool nullToAbsent) {
    return JourneyPlanCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      customerId: Value(customerId),
      customerName: Value(customerName),
      companyName: Value(companyName),
      customerType: Value(customerType),
      customerGroup: Value(customerGroup),
      customerTerritory: Value(customerTerritory),
      billingAddressName: billingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(billingAddressName),
      shippingAddressName: shippingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(shippingAddressName),
      assignTo: assignTo == null && nullToAbsent
          ? const Value.absent()
          : Value(assignTo),
      expiryDate: expiryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(expiryDate),
      weekNumber: weekNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(weekNumber),
      weekDay: weekDay == null && nullToAbsent
          ? const Value.absent()
          : Value(weekDay),
      inMiles: inMiles == null && nullToAbsent
          ? const Value.absent()
          : Value(inMiles),
      inKilometer: inKilometer == null && nullToAbsent
          ? const Value.absent()
          : Value(inKilometer),
      inMeter: inMeter == null && nullToAbsent
          ? const Value.absent()
          : Value(inMeter),
      distanceLabel: distanceLabel == null && nullToAbsent
          ? const Value.absent()
          : Value(distanceLabel),
      distanceUsed: distanceUsed == null && nullToAbsent
          ? const Value.absent()
          : Value(distanceUsed),
      transactionStatus: transactionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionStatus),
      isDeleted: Value(isDeleted),
    );
  }

  factory JourneyPlanData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return JourneyPlanData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      customerId: serializer.fromJson<String>(json['customerId']),
      customerName: serializer.fromJson<String>(json['customerName']),
      companyName: serializer.fromJson<String>(json['companyName']),
      customerType: serializer.fromJson<String>(json['customerType']),
      customerGroup: serializer.fromJson<String>(json['customerGroup']),
      customerTerritory: serializer.fromJson<String>(json['customerTerritory']),
      billingAddressName:
          serializer.fromJson<String?>(json['billingAddressName']),
      shippingAddressName:
          serializer.fromJson<String?>(json['shippingAddressName']),
      assignTo: serializer.fromJson<String?>(json['assignTo']),
      expiryDate: serializer.fromJson<DateTime?>(json['expiryDate']),
      weekNumber: serializer.fromJson<int?>(json['weekNumber']),
      weekDay: serializer.fromJson<String?>(json['weekDay']),
      inMiles: serializer.fromJson<double?>(json['inMiles']),
      inKilometer: serializer.fromJson<double?>(json['inKilometer']),
      inMeter: serializer.fromJson<double?>(json['inMeter']),
      distanceLabel: serializer.fromJson<String?>(json['distanceLabel']),
      distanceUsed: serializer.fromJson<double?>(json['distanceUsed']),
      transactionStatus:
          serializer.fromJson<String?>(json['transactionStatus']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'customerId': serializer.toJson<String>(customerId),
      'customerName': serializer.toJson<String>(customerName),
      'companyName': serializer.toJson<String>(companyName),
      'customerType': serializer.toJson<String>(customerType),
      'customerGroup': serializer.toJson<String>(customerGroup),
      'customerTerritory': serializer.toJson<String>(customerTerritory),
      'billingAddressName': serializer.toJson<String?>(billingAddressName),
      'shippingAddressName': serializer.toJson<String?>(shippingAddressName),
      'assignTo': serializer.toJson<String?>(assignTo),
      'expiryDate': serializer.toJson<DateTime?>(expiryDate),
      'weekNumber': serializer.toJson<int?>(weekNumber),
      'weekDay': serializer.toJson<String?>(weekDay),
      'inMiles': serializer.toJson<double?>(inMiles),
      'inKilometer': serializer.toJson<double?>(inKilometer),
      'inMeter': serializer.toJson<double?>(inMeter),
      'distanceLabel': serializer.toJson<String?>(distanceLabel),
      'distanceUsed': serializer.toJson<double?>(distanceUsed),
      'transactionStatus': serializer.toJson<String?>(transactionStatus),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  JourneyPlanData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          String? customerId,
          String? customerName,
          String? companyName,
          String? customerType,
          String? customerGroup,
          String? customerTerritory,
          Value<String?> billingAddressName = const Value.absent(),
          Value<String?> shippingAddressName = const Value.absent(),
          Value<String?> assignTo = const Value.absent(),
          Value<DateTime?> expiryDate = const Value.absent(),
          Value<int?> weekNumber = const Value.absent(),
          Value<String?> weekDay = const Value.absent(),
          Value<double?> inMiles = const Value.absent(),
          Value<double?> inKilometer = const Value.absent(),
          Value<double?> inMeter = const Value.absent(),
          Value<String?> distanceLabel = const Value.absent(),
          Value<double?> distanceUsed = const Value.absent(),
          Value<String?> transactionStatus = const Value.absent(),
          bool? isDeleted}) =>
      JourneyPlanData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        customerId: customerId ?? this.customerId,
        customerName: customerName ?? this.customerName,
        companyName: companyName ?? this.companyName,
        customerType: customerType ?? this.customerType,
        customerGroup: customerGroup ?? this.customerGroup,
        customerTerritory: customerTerritory ?? this.customerTerritory,
        billingAddressName: billingAddressName.present
            ? billingAddressName.value
            : this.billingAddressName,
        shippingAddressName: shippingAddressName.present
            ? shippingAddressName.value
            : this.shippingAddressName,
        assignTo: assignTo.present ? assignTo.value : this.assignTo,
        expiryDate: expiryDate.present ? expiryDate.value : this.expiryDate,
        weekNumber: weekNumber.present ? weekNumber.value : this.weekNumber,
        weekDay: weekDay.present ? weekDay.value : this.weekDay,
        inMiles: inMiles.present ? inMiles.value : this.inMiles,
        inKilometer: inKilometer.present ? inKilometer.value : this.inKilometer,
        inMeter: inMeter.present ? inMeter.value : this.inMeter,
        distanceLabel:
            distanceLabel.present ? distanceLabel.value : this.distanceLabel,
        distanceUsed:
            distanceUsed.present ? distanceUsed.value : this.distanceUsed,
        transactionStatus: transactionStatus.present
            ? transactionStatus.value
            : this.transactionStatus,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  @override
  String toString() {
    return (StringBuffer('JourneyPlanData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('companyName: $companyName, ')
          ..write('customerType: $customerType, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('customerTerritory: $customerTerritory, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('assignTo: $assignTo, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('weekNumber: $weekNumber, ')
          ..write('weekDay: $weekDay, ')
          ..write('inMiles: $inMiles, ')
          ..write('inKilometer: $inKilometer, ')
          ..write('inMeter: $inMeter, ')
          ..write('distanceLabel: $distanceLabel, ')
          ..write('distanceUsed: $distanceUsed, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        id,
        customerId,
        customerName,
        companyName,
        customerType,
        customerGroup,
        customerTerritory,
        billingAddressName,
        shippingAddressName,
        assignTo,
        expiryDate,
        weekNumber,
        weekDay,
        inMiles,
        inKilometer,
        inMeter,
        distanceLabel,
        distanceUsed,
        transactionStatus,
        isDeleted
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is JourneyPlanData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.customerId == this.customerId &&
          other.customerName == this.customerName &&
          other.companyName == this.companyName &&
          other.customerType == this.customerType &&
          other.customerGroup == this.customerGroup &&
          other.customerTerritory == this.customerTerritory &&
          other.billingAddressName == this.billingAddressName &&
          other.shippingAddressName == this.shippingAddressName &&
          other.assignTo == this.assignTo &&
          other.expiryDate == this.expiryDate &&
          other.weekNumber == this.weekNumber &&
          other.weekDay == this.weekDay &&
          other.inMiles == this.inMiles &&
          other.inKilometer == this.inKilometer &&
          other.inMeter == this.inMeter &&
          other.distanceLabel == this.distanceLabel &&
          other.distanceUsed == this.distanceUsed &&
          other.transactionStatus == this.transactionStatus &&
          other.isDeleted == this.isDeleted);
}

class JourneyPlanCompanion extends UpdateCompanion<JourneyPlanData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String> customerId;
  final Value<String> customerName;
  final Value<String> companyName;
  final Value<String> customerType;
  final Value<String> customerGroup;
  final Value<String> customerTerritory;
  final Value<String?> billingAddressName;
  final Value<String?> shippingAddressName;
  final Value<String?> assignTo;
  final Value<DateTime?> expiryDate;
  final Value<int?> weekNumber;
  final Value<String?> weekDay;
  final Value<double?> inMiles;
  final Value<double?> inKilometer;
  final Value<double?> inMeter;
  final Value<String?> distanceLabel;
  final Value<double?> distanceUsed;
  final Value<String?> transactionStatus;
  final Value<bool> isDeleted;
  const JourneyPlanCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.customerId = const Value.absent(),
    this.customerName = const Value.absent(),
    this.companyName = const Value.absent(),
    this.customerType = const Value.absent(),
    this.customerGroup = const Value.absent(),
    this.customerTerritory = const Value.absent(),
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.assignTo = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.weekNumber = const Value.absent(),
    this.weekDay = const Value.absent(),
    this.inMiles = const Value.absent(),
    this.inKilometer = const Value.absent(),
    this.inMeter = const Value.absent(),
    this.distanceLabel = const Value.absent(),
    this.distanceUsed = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  JourneyPlanCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    required String customerId,
    required String customerName,
    required String companyName,
    required String customerType,
    required String customerGroup,
    required String customerTerritory,
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.assignTo = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.weekNumber = const Value.absent(),
    this.weekDay = const Value.absent(),
    this.inMiles = const Value.absent(),
    this.inKilometer = const Value.absent(),
    this.inMeter = const Value.absent(),
    this.distanceLabel = const Value.absent(),
    this.distanceUsed = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.isDeleted = const Value.absent(),
  })  : customerId = Value(customerId),
        customerName = Value(customerName),
        companyName = Value(companyName),
        customerType = Value(customerType),
        customerGroup = Value(customerGroup),
        customerTerritory = Value(customerTerritory);
  static Insertable<JourneyPlanData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? customerId,
    Expression<String>? customerName,
    Expression<String>? companyName,
    Expression<String>? customerType,
    Expression<String>? customerGroup,
    Expression<String>? customerTerritory,
    Expression<String>? billingAddressName,
    Expression<String>? shippingAddressName,
    Expression<String>? assignTo,
    Expression<DateTime>? expiryDate,
    Expression<int>? weekNumber,
    Expression<String>? weekDay,
    Expression<double>? inMiles,
    Expression<double>? inKilometer,
    Expression<double>? inMeter,
    Expression<String>? distanceLabel,
    Expression<double>? distanceUsed,
    Expression<String>? transactionStatus,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (customerId != null) 'customer_id': customerId,
      if (customerName != null) 'customer_name': customerName,
      if (companyName != null) 'company_name': companyName,
      if (customerType != null) 'customer_type': customerType,
      if (customerGroup != null) 'customer_group': customerGroup,
      if (customerTerritory != null) 'customer_territory': customerTerritory,
      if (billingAddressName != null)
        'billing_address_name': billingAddressName,
      if (shippingAddressName != null)
        'shipping_address_name': shippingAddressName,
      if (assignTo != null) 'assign_to': assignTo,
      if (expiryDate != null) 'expiry_date': expiryDate,
      if (weekNumber != null) 'week_number': weekNumber,
      if (weekDay != null) 'week_day': weekDay,
      if (inMiles != null) 'in_miles': inMiles,
      if (inKilometer != null) 'in_kilometer': inKilometer,
      if (inMeter != null) 'in_meter': inMeter,
      if (distanceLabel != null) 'distance_label': distanceLabel,
      if (distanceUsed != null) 'distance_used': distanceUsed,
      if (transactionStatus != null) 'transaction_status': transactionStatus,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  JourneyPlanCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String>? customerId,
      Value<String>? customerName,
      Value<String>? companyName,
      Value<String>? customerType,
      Value<String>? customerGroup,
      Value<String>? customerTerritory,
      Value<String?>? billingAddressName,
      Value<String?>? shippingAddressName,
      Value<String?>? assignTo,
      Value<DateTime?>? expiryDate,
      Value<int?>? weekNumber,
      Value<String?>? weekDay,
      Value<double?>? inMiles,
      Value<double?>? inKilometer,
      Value<double?>? inMeter,
      Value<String?>? distanceLabel,
      Value<double?>? distanceUsed,
      Value<String?>? transactionStatus,
      Value<bool>? isDeleted}) {
    return JourneyPlanCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      customerId: customerId ?? this.customerId,
      customerName: customerName ?? this.customerName,
      companyName: companyName ?? this.companyName,
      customerType: customerType ?? this.customerType,
      customerGroup: customerGroup ?? this.customerGroup,
      customerTerritory: customerTerritory ?? this.customerTerritory,
      billingAddressName: billingAddressName ?? this.billingAddressName,
      shippingAddressName: shippingAddressName ?? this.shippingAddressName,
      assignTo: assignTo ?? this.assignTo,
      expiryDate: expiryDate ?? this.expiryDate,
      weekNumber: weekNumber ?? this.weekNumber,
      weekDay: weekDay ?? this.weekDay,
      inMiles: inMiles ?? this.inMiles,
      inKilometer: inKilometer ?? this.inKilometer,
      inMeter: inMeter ?? this.inMeter,
      distanceLabel: distanceLabel ?? this.distanceLabel,
      distanceUsed: distanceUsed ?? this.distanceUsed,
      transactionStatus: transactionStatus ?? this.transactionStatus,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (customerName.present) {
      map['customer_name'] = Variable<String>(customerName.value);
    }
    if (companyName.present) {
      map['company_name'] = Variable<String>(companyName.value);
    }
    if (customerType.present) {
      map['customer_type'] = Variable<String>(customerType.value);
    }
    if (customerGroup.present) {
      map['customer_group'] = Variable<String>(customerGroup.value);
    }
    if (customerTerritory.present) {
      map['customer_territory'] = Variable<String>(customerTerritory.value);
    }
    if (billingAddressName.present) {
      map['billing_address_name'] = Variable<String>(billingAddressName.value);
    }
    if (shippingAddressName.present) {
      map['shipping_address_name'] =
          Variable<String>(shippingAddressName.value);
    }
    if (assignTo.present) {
      map['assign_to'] = Variable<String>(assignTo.value);
    }
    if (expiryDate.present) {
      map['expiry_date'] = Variable<DateTime>(expiryDate.value);
    }
    if (weekNumber.present) {
      map['week_number'] = Variable<int>(weekNumber.value);
    }
    if (weekDay.present) {
      map['week_day'] = Variable<String>(weekDay.value);
    }
    if (inMiles.present) {
      map['in_miles'] = Variable<double>(inMiles.value);
    }
    if (inKilometer.present) {
      map['in_kilometer'] = Variable<double>(inKilometer.value);
    }
    if (inMeter.present) {
      map['in_meter'] = Variable<double>(inMeter.value);
    }
    if (distanceLabel.present) {
      map['distance_label'] = Variable<String>(distanceLabel.value);
    }
    if (distanceUsed.present) {
      map['distance_used'] = Variable<double>(distanceUsed.value);
    }
    if (transactionStatus.present) {
      map['transaction_status'] = Variable<String>(transactionStatus.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('JourneyPlanCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('companyName: $companyName, ')
          ..write('customerType: $customerType, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('customerTerritory: $customerTerritory, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('assignTo: $assignTo, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('weekNumber: $weekNumber, ')
          ..write('weekDay: $weekDay, ')
          ..write('inMiles: $inMiles, ')
          ..write('inKilometer: $inKilometer, ')
          ..write('inMeter: $inMeter, ')
          ..write('distanceLabel: $distanceLabel, ')
          ..write('distanceUsed: $distanceUsed, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $UPCCodeTable extends UPCCode with TableInfo<$UPCCodeTable, UPCCodeData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UPCCodeTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _upcCodeMeta =
      const VerificationMeta('upcCode');
  @override
  late final GeneratedColumn<String> upcCode = GeneratedColumn<String>(
      'upc_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _codeTypeMeta =
      const VerificationMeta('codeType');
  @override
  late final GeneratedColumn<String> codeType = GeneratedColumn<String>(
      'code_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
      'item_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [tenantId, id, upcCode, codeType, itemId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'u_p_c_code';
  @override
  VerificationContext validateIntegrity(Insertable<UPCCodeData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('upc_code')) {
      context.handle(_upcCodeMeta,
          upcCode.isAcceptableOrUnknown(data['upc_code']!, _upcCodeMeta));
    }
    if (data.containsKey('code_type')) {
      context.handle(_codeTypeMeta,
          codeType.isAcceptableOrUnknown(data['code_type']!, _codeTypeMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UPCCodeData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UPCCodeData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      upcCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}upc_code']),
      codeType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code_type']),
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_id']),
    );
  }

  @override
  $UPCCodeTable createAlias(String alias) {
    return $UPCCodeTable(attachedDatabase, alias);
  }
}

class UPCCodeData extends DataClass implements Insertable<UPCCodeData> {
  final String? tenantId;
  final int id;
  final String? upcCode;
  final String? codeType;
  final String? itemId;
  const UPCCodeData(
      {this.tenantId,
      required this.id,
      this.upcCode,
      this.codeType,
      this.itemId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || upcCode != null) {
      map['upc_code'] = Variable<String>(upcCode);
    }
    if (!nullToAbsent || codeType != null) {
      map['code_type'] = Variable<String>(codeType);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    return map;
  }

  UPCCodeCompanion toCompanion(bool nullToAbsent) {
    return UPCCodeCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      upcCode: upcCode == null && nullToAbsent
          ? const Value.absent()
          : Value(upcCode),
      codeType: codeType == null && nullToAbsent
          ? const Value.absent()
          : Value(codeType),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
    );
  }

  factory UPCCodeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UPCCodeData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      upcCode: serializer.fromJson<String?>(json['upcCode']),
      codeType: serializer.fromJson<String?>(json['codeType']),
      itemId: serializer.fromJson<String?>(json['itemId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'upcCode': serializer.toJson<String?>(upcCode),
      'codeType': serializer.toJson<String?>(codeType),
      'itemId': serializer.toJson<String?>(itemId),
    };
  }

  UPCCodeData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> upcCode = const Value.absent(),
          Value<String?> codeType = const Value.absent(),
          Value<String?> itemId = const Value.absent()}) =>
      UPCCodeData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        upcCode: upcCode.present ? upcCode.value : this.upcCode,
        codeType: codeType.present ? codeType.value : this.codeType,
        itemId: itemId.present ? itemId.value : this.itemId,
      );
  @override
  String toString() {
    return (StringBuffer('UPCCodeData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('upcCode: $upcCode, ')
          ..write('codeType: $codeType, ')
          ..write('itemId: $itemId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, upcCode, codeType, itemId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UPCCodeData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.upcCode == this.upcCode &&
          other.codeType == this.codeType &&
          other.itemId == this.itemId);
}

class UPCCodeCompanion extends UpdateCompanion<UPCCodeData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> upcCode;
  final Value<String?> codeType;
  final Value<String?> itemId;
  const UPCCodeCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.upcCode = const Value.absent(),
    this.codeType = const Value.absent(),
    this.itemId = const Value.absent(),
  });
  UPCCodeCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.upcCode = const Value.absent(),
    this.codeType = const Value.absent(),
    this.itemId = const Value.absent(),
  });
  static Insertable<UPCCodeData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? upcCode,
    Expression<String>? codeType,
    Expression<String>? itemId,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (upcCode != null) 'upc_code': upcCode,
      if (codeType != null) 'code_type': codeType,
      if (itemId != null) 'item_id': itemId,
    });
  }

  UPCCodeCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? upcCode,
      Value<String?>? codeType,
      Value<String?>? itemId}) {
    return UPCCodeCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      upcCode: upcCode ?? this.upcCode,
      codeType: codeType ?? this.codeType,
      itemId: itemId ?? this.itemId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (upcCode.present) {
      map['upc_code'] = Variable<String>(upcCode.value);
    }
    if (codeType.present) {
      map['code_type'] = Variable<String>(codeType.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UPCCodeCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('upcCode: $upcCode, ')
          ..write('codeType: $codeType, ')
          ..write('itemId: $itemId')
          ..write(')'))
        .toString();
  }
}

class $InventoryItemsTable extends InventoryItems
    with TableInfo<$InventoryItemsTable, InventoryItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $InventoryItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _itemCodeMeta =
      const VerificationMeta('itemCode');
  @override
  late final GeneratedColumn<String> itemCode = GeneratedColumn<String>(
      'item_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemNameMeta =
      const VerificationMeta('itemName');
  @override
  late final GeneratedColumn<String> itemName = GeneratedColumn<String>(
      'item_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _uomMeta = const VerificationMeta('uom');
  @override
  late final GeneratedColumn<String> uom = GeneratedColumn<String>(
      'uom', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _defaultWarehouseMeta =
      const VerificationMeta('defaultWarehouse');
  @override
  late final GeneratedColumn<String> defaultWarehouse = GeneratedColumn<String>(
      'default_warehouse', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _quantityOnHandMeta =
      const VerificationMeta('quantityOnHand');
  @override
  late final GeneratedColumn<double> quantityOnHand = GeneratedColumn<double>(
      'quantity_on_hand', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantityAvailableMeta =
      const VerificationMeta('quantityAvailable');
  @override
  late final GeneratedColumn<double> quantityAvailable =
      GeneratedColumn<double>('quantity_available', aliasedName, false,
          type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantityAdjustMeta =
      const VerificationMeta('quantityAdjust');
  @override
  late final GeneratedColumn<double> quantityAdjust = GeneratedColumn<double>(
      'quantity_adjust', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantitySoldOnInvoiceMeta =
      const VerificationMeta('quantitySoldOnInvoice');
  @override
  late final GeneratedColumn<double> quantitySoldOnInvoice =
      GeneratedColumn<double>('quantity_sold_on_invoice', aliasedName, false,
          type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantitySoldOnOrderMeta =
      const VerificationMeta('quantitySoldOnOrder');
  @override
  late final GeneratedColumn<double> quantitySoldOnOrder =
      GeneratedColumn<double>('quantity_sold_on_order', aliasedName, false,
          type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantityCountMeta =
      const VerificationMeta('quantityCount');
  @override
  late final GeneratedColumn<double> quantityCount = GeneratedColumn<double>(
      'quantity_count', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _inventoryCycleNumberMeta =
      const VerificationMeta('inventoryCycleNumber');
  @override
  late final GeneratedColumn<String> inventoryCycleNumber =
      GeneratedColumn<String>('inventory_cycle_number', aliasedName, false,
          type: DriftSqlType.string, requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        itemCode,
        itemName,
        uom,
        defaultWarehouse,
        quantityOnHand,
        quantityAvailable,
        quantityAdjust,
        quantitySoldOnInvoice,
        quantitySoldOnOrder,
        quantityCount,
        inventoryCycleNumber
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'inventory_items';
  @override
  VerificationContext validateIntegrity(Insertable<InventoryItem> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code']!, _itemCodeMeta));
    }
    if (data.containsKey('item_name')) {
      context.handle(_itemNameMeta,
          itemName.isAcceptableOrUnknown(data['item_name']!, _itemNameMeta));
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom']!, _uomMeta));
    }
    if (data.containsKey('default_warehouse')) {
      context.handle(
          _defaultWarehouseMeta,
          defaultWarehouse.isAcceptableOrUnknown(
              data['default_warehouse']!, _defaultWarehouseMeta));
    }
    if (data.containsKey('quantity_on_hand')) {
      context.handle(
          _quantityOnHandMeta,
          quantityOnHand.isAcceptableOrUnknown(
              data['quantity_on_hand']!, _quantityOnHandMeta));
    } else if (isInserting) {
      context.missing(_quantityOnHandMeta);
    }
    if (data.containsKey('quantity_available')) {
      context.handle(
          _quantityAvailableMeta,
          quantityAvailable.isAcceptableOrUnknown(
              data['quantity_available']!, _quantityAvailableMeta));
    } else if (isInserting) {
      context.missing(_quantityAvailableMeta);
    }
    if (data.containsKey('quantity_adjust')) {
      context.handle(
          _quantityAdjustMeta,
          quantityAdjust.isAcceptableOrUnknown(
              data['quantity_adjust']!, _quantityAdjustMeta));
    } else if (isInserting) {
      context.missing(_quantityAdjustMeta);
    }
    if (data.containsKey('quantity_sold_on_invoice')) {
      context.handle(
          _quantitySoldOnInvoiceMeta,
          quantitySoldOnInvoice.isAcceptableOrUnknown(
              data['quantity_sold_on_invoice']!, _quantitySoldOnInvoiceMeta));
    } else if (isInserting) {
      context.missing(_quantitySoldOnInvoiceMeta);
    }
    if (data.containsKey('quantity_sold_on_order')) {
      context.handle(
          _quantitySoldOnOrderMeta,
          quantitySoldOnOrder.isAcceptableOrUnknown(
              data['quantity_sold_on_order']!, _quantitySoldOnOrderMeta));
    } else if (isInserting) {
      context.missing(_quantitySoldOnOrderMeta);
    }
    if (data.containsKey('quantity_count')) {
      context.handle(
          _quantityCountMeta,
          quantityCount.isAcceptableOrUnknown(
              data['quantity_count']!, _quantityCountMeta));
    } else if (isInserting) {
      context.missing(_quantityCountMeta);
    }
    if (data.containsKey('inventory_cycle_number')) {
      context.handle(
          _inventoryCycleNumberMeta,
          inventoryCycleNumber.isAcceptableOrUnknown(
              data['inventory_cycle_number']!, _inventoryCycleNumberMeta));
    } else if (isInserting) {
      context.missing(_inventoryCycleNumberMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InventoryItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return InventoryItem(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_code']),
      itemName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_name']),
      uom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uom']),
      defaultWarehouse: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}default_warehouse']),
      quantityOnHand: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_on_hand'])!,
      quantityAvailable: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_available'])!,
      quantityAdjust: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}quantity_adjust'])!,
      quantitySoldOnInvoice: attachedDatabase.typeMapping.read(
          DriftSqlType.double,
          data['${effectivePrefix}quantity_sold_on_invoice'])!,
      quantitySoldOnOrder: attachedDatabase.typeMapping.read(
          DriftSqlType.double,
          data['${effectivePrefix}quantity_sold_on_order'])!,
      quantityCount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity_count'])!,
      inventoryCycleNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}inventory_cycle_number'])!,
    );
  }

  @override
  $InventoryItemsTable createAlias(String alias) {
    return $InventoryItemsTable(attachedDatabase, alias);
  }
}

class InventoryItem extends DataClass implements Insertable<InventoryItem> {
  final String? tenantId;
  final int id;
  final String? itemCode;
  final String? itemName;
  final String? uom;
  final String? defaultWarehouse;
  final double quantityOnHand;
  final double quantityAvailable;
  final double quantityAdjust;
  final double quantitySoldOnInvoice;
  final double quantitySoldOnOrder;
  final double quantityCount;
  final String inventoryCycleNumber;
  const InventoryItem(
      {this.tenantId,
      required this.id,
      this.itemCode,
      this.itemName,
      this.uom,
      this.defaultWarehouse,
      required this.quantityOnHand,
      required this.quantityAvailable,
      required this.quantityAdjust,
      required this.quantitySoldOnInvoice,
      required this.quantitySoldOnOrder,
      required this.quantityCount,
      required this.inventoryCycleNumber});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || itemName != null) {
      map['item_name'] = Variable<String>(itemName);
    }
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    if (!nullToAbsent || defaultWarehouse != null) {
      map['default_warehouse'] = Variable<String>(defaultWarehouse);
    }
    map['quantity_on_hand'] = Variable<double>(quantityOnHand);
    map['quantity_available'] = Variable<double>(quantityAvailable);
    map['quantity_adjust'] = Variable<double>(quantityAdjust);
    map['quantity_sold_on_invoice'] = Variable<double>(quantitySoldOnInvoice);
    map['quantity_sold_on_order'] = Variable<double>(quantitySoldOnOrder);
    map['quantity_count'] = Variable<double>(quantityCount);
    map['inventory_cycle_number'] = Variable<String>(inventoryCycleNumber);
    return map;
  }

  InventoryItemsCompanion toCompanion(bool nullToAbsent) {
    return InventoryItemsCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      itemName: itemName == null && nullToAbsent
          ? const Value.absent()
          : Value(itemName),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
      defaultWarehouse: defaultWarehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultWarehouse),
      quantityOnHand: Value(quantityOnHand),
      quantityAvailable: Value(quantityAvailable),
      quantityAdjust: Value(quantityAdjust),
      quantitySoldOnInvoice: Value(quantitySoldOnInvoice),
      quantitySoldOnOrder: Value(quantitySoldOnOrder),
      quantityCount: Value(quantityCount),
      inventoryCycleNumber: Value(inventoryCycleNumber),
    );
  }

  factory InventoryItem.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InventoryItem(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemCode: serializer.fromJson<String?>(json['itemCode']),
      itemName: serializer.fromJson<String?>(json['itemName']),
      uom: serializer.fromJson<String?>(json['uom']),
      defaultWarehouse: serializer.fromJson<String?>(json['defaultWarehouse']),
      quantityOnHand: serializer.fromJson<double>(json['quantityOnHand']),
      quantityAvailable: serializer.fromJson<double>(json['quantityAvailable']),
      quantityAdjust: serializer.fromJson<double>(json['quantityAdjust']),
      quantitySoldOnInvoice:
          serializer.fromJson<double>(json['quantitySoldOnInvoice']),
      quantitySoldOnOrder:
          serializer.fromJson<double>(json['quantitySoldOnOrder']),
      quantityCount: serializer.fromJson<double>(json['quantityCount']),
      inventoryCycleNumber:
          serializer.fromJson<String>(json['inventoryCycleNumber']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemCode': serializer.toJson<String?>(itemCode),
      'itemName': serializer.toJson<String?>(itemName),
      'uom': serializer.toJson<String?>(uom),
      'defaultWarehouse': serializer.toJson<String?>(defaultWarehouse),
      'quantityOnHand': serializer.toJson<double>(quantityOnHand),
      'quantityAvailable': serializer.toJson<double>(quantityAvailable),
      'quantityAdjust': serializer.toJson<double>(quantityAdjust),
      'quantitySoldOnInvoice': serializer.toJson<double>(quantitySoldOnInvoice),
      'quantitySoldOnOrder': serializer.toJson<double>(quantitySoldOnOrder),
      'quantityCount': serializer.toJson<double>(quantityCount),
      'inventoryCycleNumber': serializer.toJson<String>(inventoryCycleNumber),
    };
  }

  InventoryItem copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> itemCode = const Value.absent(),
          Value<String?> itemName = const Value.absent(),
          Value<String?> uom = const Value.absent(),
          Value<String?> defaultWarehouse = const Value.absent(),
          double? quantityOnHand,
          double? quantityAvailable,
          double? quantityAdjust,
          double? quantitySoldOnInvoice,
          double? quantitySoldOnOrder,
          double? quantityCount,
          String? inventoryCycleNumber}) =>
      InventoryItem(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        itemCode: itemCode.present ? itemCode.value : this.itemCode,
        itemName: itemName.present ? itemName.value : this.itemName,
        uom: uom.present ? uom.value : this.uom,
        defaultWarehouse: defaultWarehouse.present
            ? defaultWarehouse.value
            : this.defaultWarehouse,
        quantityOnHand: quantityOnHand ?? this.quantityOnHand,
        quantityAvailable: quantityAvailable ?? this.quantityAvailable,
        quantityAdjust: quantityAdjust ?? this.quantityAdjust,
        quantitySoldOnInvoice:
            quantitySoldOnInvoice ?? this.quantitySoldOnInvoice,
        quantitySoldOnOrder: quantitySoldOnOrder ?? this.quantitySoldOnOrder,
        quantityCount: quantityCount ?? this.quantityCount,
        inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
      );
  @override
  String toString() {
    return (StringBuffer('InventoryItem(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('uom: $uom, ')
          ..write('defaultWarehouse: $defaultWarehouse, ')
          ..write('quantityOnHand: $quantityOnHand, ')
          ..write('quantityAvailable: $quantityAvailable, ')
          ..write('quantityAdjust: $quantityAdjust, ')
          ..write('quantitySoldOnInvoice: $quantitySoldOnInvoice, ')
          ..write('quantitySoldOnOrder: $quantitySoldOnOrder, ')
          ..write('quantityCount: $quantityCount, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      itemCode,
      itemName,
      uom,
      defaultWarehouse,
      quantityOnHand,
      quantityAvailable,
      quantityAdjust,
      quantitySoldOnInvoice,
      quantitySoldOnOrder,
      quantityCount,
      inventoryCycleNumber);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InventoryItem &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemCode == this.itemCode &&
          other.itemName == this.itemName &&
          other.uom == this.uom &&
          other.defaultWarehouse == this.defaultWarehouse &&
          other.quantityOnHand == this.quantityOnHand &&
          other.quantityAvailable == this.quantityAvailable &&
          other.quantityAdjust == this.quantityAdjust &&
          other.quantitySoldOnInvoice == this.quantitySoldOnInvoice &&
          other.quantitySoldOnOrder == this.quantitySoldOnOrder &&
          other.quantityCount == this.quantityCount &&
          other.inventoryCycleNumber == this.inventoryCycleNumber);
}

class InventoryItemsCompanion extends UpdateCompanion<InventoryItem> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> itemCode;
  final Value<String?> itemName;
  final Value<String?> uom;
  final Value<String?> defaultWarehouse;
  final Value<double> quantityOnHand;
  final Value<double> quantityAvailable;
  final Value<double> quantityAdjust;
  final Value<double> quantitySoldOnInvoice;
  final Value<double> quantitySoldOnOrder;
  final Value<double> quantityCount;
  final Value<String> inventoryCycleNumber;
  const InventoryItemsCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.uom = const Value.absent(),
    this.defaultWarehouse = const Value.absent(),
    this.quantityOnHand = const Value.absent(),
    this.quantityAvailable = const Value.absent(),
    this.quantityAdjust = const Value.absent(),
    this.quantitySoldOnInvoice = const Value.absent(),
    this.quantitySoldOnOrder = const Value.absent(),
    this.quantityCount = const Value.absent(),
    this.inventoryCycleNumber = const Value.absent(),
  });
  InventoryItemsCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.uom = const Value.absent(),
    this.defaultWarehouse = const Value.absent(),
    required double quantityOnHand,
    required double quantityAvailable,
    required double quantityAdjust,
    required double quantitySoldOnInvoice,
    required double quantitySoldOnOrder,
    required double quantityCount,
    required String inventoryCycleNumber,
  })  : quantityOnHand = Value(quantityOnHand),
        quantityAvailable = Value(quantityAvailable),
        quantityAdjust = Value(quantityAdjust),
        quantitySoldOnInvoice = Value(quantitySoldOnInvoice),
        quantitySoldOnOrder = Value(quantitySoldOnOrder),
        quantityCount = Value(quantityCount),
        inventoryCycleNumber = Value(inventoryCycleNumber);
  static Insertable<InventoryItem> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? itemCode,
    Expression<String>? itemName,
    Expression<String>? uom,
    Expression<String>? defaultWarehouse,
    Expression<double>? quantityOnHand,
    Expression<double>? quantityAvailable,
    Expression<double>? quantityAdjust,
    Expression<double>? quantitySoldOnInvoice,
    Expression<double>? quantitySoldOnOrder,
    Expression<double>? quantityCount,
    Expression<String>? inventoryCycleNumber,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemCode != null) 'item_code': itemCode,
      if (itemName != null) 'item_name': itemName,
      if (uom != null) 'uom': uom,
      if (defaultWarehouse != null) 'default_warehouse': defaultWarehouse,
      if (quantityOnHand != null) 'quantity_on_hand': quantityOnHand,
      if (quantityAvailable != null) 'quantity_available': quantityAvailable,
      if (quantityAdjust != null) 'quantity_adjust': quantityAdjust,
      if (quantitySoldOnInvoice != null)
        'quantity_sold_on_invoice': quantitySoldOnInvoice,
      if (quantitySoldOnOrder != null)
        'quantity_sold_on_order': quantitySoldOnOrder,
      if (quantityCount != null) 'quantity_count': quantityCount,
      if (inventoryCycleNumber != null)
        'inventory_cycle_number': inventoryCycleNumber,
    });
  }

  InventoryItemsCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? itemCode,
      Value<String?>? itemName,
      Value<String?>? uom,
      Value<String?>? defaultWarehouse,
      Value<double>? quantityOnHand,
      Value<double>? quantityAvailable,
      Value<double>? quantityAdjust,
      Value<double>? quantitySoldOnInvoice,
      Value<double>? quantitySoldOnOrder,
      Value<double>? quantityCount,
      Value<String>? inventoryCycleNumber}) {
    return InventoryItemsCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemCode: itemCode ?? this.itemCode,
      itemName: itemName ?? this.itemName,
      uom: uom ?? this.uom,
      defaultWarehouse: defaultWarehouse ?? this.defaultWarehouse,
      quantityOnHand: quantityOnHand ?? this.quantityOnHand,
      quantityAvailable: quantityAvailable ?? this.quantityAvailable,
      quantityAdjust: quantityAdjust ?? this.quantityAdjust,
      quantitySoldOnInvoice:
          quantitySoldOnInvoice ?? this.quantitySoldOnInvoice,
      quantitySoldOnOrder: quantitySoldOnOrder ?? this.quantitySoldOnOrder,
      quantityCount: quantityCount ?? this.quantityCount,
      inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (itemName.present) {
      map['item_name'] = Variable<String>(itemName.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    if (defaultWarehouse.present) {
      map['default_warehouse'] = Variable<String>(defaultWarehouse.value);
    }
    if (quantityOnHand.present) {
      map['quantity_on_hand'] = Variable<double>(quantityOnHand.value);
    }
    if (quantityAvailable.present) {
      map['quantity_available'] = Variable<double>(quantityAvailable.value);
    }
    if (quantityAdjust.present) {
      map['quantity_adjust'] = Variable<double>(quantityAdjust.value);
    }
    if (quantitySoldOnInvoice.present) {
      map['quantity_sold_on_invoice'] =
          Variable<double>(quantitySoldOnInvoice.value);
    }
    if (quantitySoldOnOrder.present) {
      map['quantity_sold_on_order'] =
          Variable<double>(quantitySoldOnOrder.value);
    }
    if (quantityCount.present) {
      map['quantity_count'] = Variable<double>(quantityCount.value);
    }
    if (inventoryCycleNumber.present) {
      map['inventory_cycle_number'] =
          Variable<String>(inventoryCycleNumber.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InventoryItemsCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('uom: $uom, ')
          ..write('defaultWarehouse: $defaultWarehouse, ')
          ..write('quantityOnHand: $quantityOnHand, ')
          ..write('quantityAvailable: $quantityAvailable, ')
          ..write('quantityAdjust: $quantityAdjust, ')
          ..write('quantitySoldOnInvoice: $quantitySoldOnInvoice, ')
          ..write('quantitySoldOnOrder: $quantitySoldOnOrder, ')
          ..write('quantityCount: $quantityCount, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber')
          ..write(')'))
        .toString();
  }
}

class $InventoryTransactionTable extends InventoryTransaction
    with TableInfo<$InventoryTransactionTable, InventoryTransactionData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $InventoryTransactionTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _itemCodeMeta =
      const VerificationMeta('itemCode');
  @override
  late final GeneratedColumn<String> itemCode = GeneratedColumn<String>(
      'item_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemNameMeta =
      const VerificationMeta('itemName');
  @override
  late final GeneratedColumn<String> itemName = GeneratedColumn<String>(
      'item_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  @override
  late final GeneratedColumn<String> itemId = GeneratedColumn<String>(
      'item_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _itemGroupMeta =
      const VerificationMeta('itemGroup');
  @override
  late final GeneratedColumn<String> itemGroup = GeneratedColumn<String>(
      'item_group', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _stockUomMeta =
      const VerificationMeta('stockUom');
  @override
  late final GeneratedColumn<String> stockUom = GeneratedColumn<String>(
      'stock_uom', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _salesUomMeta =
      const VerificationMeta('salesUom');
  @override
  late final GeneratedColumn<String> salesUom = GeneratedColumn<String>(
      'sales_uom', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _transactionNumberMeta =
      const VerificationMeta('transactionNumber');
  @override
  late final GeneratedColumn<String> transactionNumber =
      GeneratedColumn<String>('transaction_number', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _quantityMoveMeta =
      const VerificationMeta('quantityMove');
  @override
  late final GeneratedColumn<double> quantityMove = GeneratedColumn<double>(
      'quantity_move', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _quantityMoveConvertMeta =
      const VerificationMeta('quantityMoveConvert');
  @override
  late final GeneratedColumn<double> quantityMoveConvert =
      GeneratedColumn<double>('quantity_move_convert', aliasedName, false,
          type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _conversionFactorMeta =
      const VerificationMeta('conversionFactor');
  @override
  late final GeneratedColumn<double> conversionFactor = GeneratedColumn<double>(
      'conversion_factor', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _costPriceMeta =
      const VerificationMeta('costPrice');
  @override
  late final GeneratedColumn<double> costPrice = GeneratedColumn<double>(
      'cost_price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _itemPriceMeta =
      const VerificationMeta('itemPrice');
  @override
  late final GeneratedColumn<double> itemPrice = GeneratedColumn<double>(
      'item_price', aliasedName, false,
      type: DriftSqlType.double, requiredDuringInsert: true);
  static const VerificationMeta _transactionTypeMeta =
      const VerificationMeta('transactionType');
  @override
  late final GeneratedColumn<String> transactionType = GeneratedColumn<String>(
      'transaction_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _reasonCodeMeta =
      const VerificationMeta('reasonCode');
  @override
  late final GeneratedColumn<String> reasonCode = GeneratedColumn<String>(
      'reason_code', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _inventoryCycleMeta =
      const VerificationMeta('inventoryCycle');
  @override
  late final GeneratedColumn<String> inventoryCycle = GeneratedColumn<String>(
      'inventory_cycle', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _toWarehouseMeta =
      const VerificationMeta('toWarehouse');
  @override
  late final GeneratedColumn<String> toWarehouse = GeneratedColumn<String>(
      'to_warehouse', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fromWarehouseMeta =
      const VerificationMeta('fromWarehouse');
  @override
  late final GeneratedColumn<String> fromWarehouse = GeneratedColumn<String>(
      'from_warehouse', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        itemCode,
        itemName,
        itemId,
        description,
        itemGroup,
        stockUom,
        salesUom,
        transactionNumber,
        quantityMove,
        quantityMoveConvert,
        conversionFactor,
        costPrice,
        itemPrice,
        transactionType,
        reasonCode,
        inventoryCycle,
        toWarehouse,
        fromWarehouse
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'inventory_transaction';
  @override
  VerificationContext validateIntegrity(
      Insertable<InventoryTransactionData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code']!, _itemCodeMeta));
    }
    if (data.containsKey('item_name')) {
      context.handle(_itemNameMeta,
          itemName.isAcceptableOrUnknown(data['item_name']!, _itemNameMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('item_group')) {
      context.handle(_itemGroupMeta,
          itemGroup.isAcceptableOrUnknown(data['item_group']!, _itemGroupMeta));
    }
    if (data.containsKey('stock_uom')) {
      context.handle(_stockUomMeta,
          stockUom.isAcceptableOrUnknown(data['stock_uom']!, _stockUomMeta));
    }
    if (data.containsKey('sales_uom')) {
      context.handle(_salesUomMeta,
          salesUom.isAcceptableOrUnknown(data['sales_uom']!, _salesUomMeta));
    }
    if (data.containsKey('transaction_number')) {
      context.handle(
          _transactionNumberMeta,
          transactionNumber.isAcceptableOrUnknown(
              data['transaction_number']!, _transactionNumberMeta));
    }
    if (data.containsKey('quantity_move')) {
      context.handle(
          _quantityMoveMeta,
          quantityMove.isAcceptableOrUnknown(
              data['quantity_move']!, _quantityMoveMeta));
    } else if (isInserting) {
      context.missing(_quantityMoveMeta);
    }
    if (data.containsKey('quantity_move_convert')) {
      context.handle(
          _quantityMoveConvertMeta,
          quantityMoveConvert.isAcceptableOrUnknown(
              data['quantity_move_convert']!, _quantityMoveConvertMeta));
    } else if (isInserting) {
      context.missing(_quantityMoveConvertMeta);
    }
    if (data.containsKey('conversion_factor')) {
      context.handle(
          _conversionFactorMeta,
          conversionFactor.isAcceptableOrUnknown(
              data['conversion_factor']!, _conversionFactorMeta));
    } else if (isInserting) {
      context.missing(_conversionFactorMeta);
    }
    if (data.containsKey('cost_price')) {
      context.handle(_costPriceMeta,
          costPrice.isAcceptableOrUnknown(data['cost_price']!, _costPriceMeta));
    } else if (isInserting) {
      context.missing(_costPriceMeta);
    }
    if (data.containsKey('item_price')) {
      context.handle(_itemPriceMeta,
          itemPrice.isAcceptableOrUnknown(data['item_price']!, _itemPriceMeta));
    } else if (isInserting) {
      context.missing(_itemPriceMeta);
    }
    if (data.containsKey('transaction_type')) {
      context.handle(
          _transactionTypeMeta,
          transactionType.isAcceptableOrUnknown(
              data['transaction_type']!, _transactionTypeMeta));
    }
    if (data.containsKey('reason_code')) {
      context.handle(
          _reasonCodeMeta,
          reasonCode.isAcceptableOrUnknown(
              data['reason_code']!, _reasonCodeMeta));
    }
    if (data.containsKey('inventory_cycle')) {
      context.handle(
          _inventoryCycleMeta,
          inventoryCycle.isAcceptableOrUnknown(
              data['inventory_cycle']!, _inventoryCycleMeta));
    }
    if (data.containsKey('to_warehouse')) {
      context.handle(
          _toWarehouseMeta,
          toWarehouse.isAcceptableOrUnknown(
              data['to_warehouse']!, _toWarehouseMeta));
    }
    if (data.containsKey('from_warehouse')) {
      context.handle(
          _fromWarehouseMeta,
          fromWarehouse.isAcceptableOrUnknown(
              data['from_warehouse']!, _fromWarehouseMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InventoryTransactionData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return InventoryTransactionData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_code']),
      itemName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_name']),
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_id']),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      itemGroup: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_group']),
      stockUom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}stock_uom']),
      salesUom: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sales_uom']),
      transactionNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_number']),
      quantityMove: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity_move'])!,
      quantityMoveConvert: attachedDatabase.typeMapping.read(
          DriftSqlType.double,
          data['${effectivePrefix}quantity_move_convert'])!,
      conversionFactor: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}conversion_factor'])!,
      costPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cost_price'])!,
      itemPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}item_price'])!,
      transactionType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_type']),
      reasonCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason_code']),
      inventoryCycle: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}inventory_cycle']),
      toWarehouse: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}to_warehouse']),
      fromWarehouse: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}from_warehouse']),
    );
  }

  @override
  $InventoryTransactionTable createAlias(String alias) {
    return $InventoryTransactionTable(attachedDatabase, alias);
  }
}

class InventoryTransactionData extends DataClass
    implements Insertable<InventoryTransactionData> {
  final String? tenantId;
  final int id;
  final String? itemCode;
  final String? itemName;
  final String? itemId;
  final String? description;
  final String? itemGroup;
  final String? stockUom;
  final String? salesUom;
  final String? transactionNumber;
  final double quantityMove;
  final double quantityMoveConvert;
  final double conversionFactor;
  final double costPrice;
  final double itemPrice;
  final String? transactionType;
  final String? reasonCode;
  final String? inventoryCycle;
  final String? toWarehouse;
  final String? fromWarehouse;
  const InventoryTransactionData(
      {this.tenantId,
      required this.id,
      this.itemCode,
      this.itemName,
      this.itemId,
      this.description,
      this.itemGroup,
      this.stockUom,
      this.salesUom,
      this.transactionNumber,
      required this.quantityMove,
      required this.quantityMoveConvert,
      required this.conversionFactor,
      required this.costPrice,
      required this.itemPrice,
      this.transactionType,
      this.reasonCode,
      this.inventoryCycle,
      this.toWarehouse,
      this.fromWarehouse});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || itemName != null) {
      map['item_name'] = Variable<String>(itemName);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || itemGroup != null) {
      map['item_group'] = Variable<String>(itemGroup);
    }
    if (!nullToAbsent || stockUom != null) {
      map['stock_uom'] = Variable<String>(stockUom);
    }
    if (!nullToAbsent || salesUom != null) {
      map['sales_uom'] = Variable<String>(salesUom);
    }
    if (!nullToAbsent || transactionNumber != null) {
      map['transaction_number'] = Variable<String>(transactionNumber);
    }
    map['quantity_move'] = Variable<double>(quantityMove);
    map['quantity_move_convert'] = Variable<double>(quantityMoveConvert);
    map['conversion_factor'] = Variable<double>(conversionFactor);
    map['cost_price'] = Variable<double>(costPrice);
    map['item_price'] = Variable<double>(itemPrice);
    if (!nullToAbsent || transactionType != null) {
      map['transaction_type'] = Variable<String>(transactionType);
    }
    if (!nullToAbsent || reasonCode != null) {
      map['reason_code'] = Variable<String>(reasonCode);
    }
    if (!nullToAbsent || inventoryCycle != null) {
      map['inventory_cycle'] = Variable<String>(inventoryCycle);
    }
    if (!nullToAbsent || toWarehouse != null) {
      map['to_warehouse'] = Variable<String>(toWarehouse);
    }
    if (!nullToAbsent || fromWarehouse != null) {
      map['from_warehouse'] = Variable<String>(fromWarehouse);
    }
    return map;
  }

  InventoryTransactionCompanion toCompanion(bool nullToAbsent) {
    return InventoryTransactionCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      itemName: itemName == null && nullToAbsent
          ? const Value.absent()
          : Value(itemName),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      itemGroup: itemGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(itemGroup),
      stockUom: stockUom == null && nullToAbsent
          ? const Value.absent()
          : Value(stockUom),
      salesUom: salesUom == null && nullToAbsent
          ? const Value.absent()
          : Value(salesUom),
      transactionNumber: transactionNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionNumber),
      quantityMove: Value(quantityMove),
      quantityMoveConvert: Value(quantityMoveConvert),
      conversionFactor: Value(conversionFactor),
      costPrice: Value(costPrice),
      itemPrice: Value(itemPrice),
      transactionType: transactionType == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionType),
      reasonCode: reasonCode == null && nullToAbsent
          ? const Value.absent()
          : Value(reasonCode),
      inventoryCycle: inventoryCycle == null && nullToAbsent
          ? const Value.absent()
          : Value(inventoryCycle),
      toWarehouse: toWarehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(toWarehouse),
      fromWarehouse: fromWarehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(fromWarehouse),
    );
  }

  factory InventoryTransactionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InventoryTransactionData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemCode: serializer.fromJson<String?>(json['itemCode']),
      itemName: serializer.fromJson<String?>(json['itemName']),
      itemId: serializer.fromJson<String?>(json['itemId']),
      description: serializer.fromJson<String?>(json['description']),
      itemGroup: serializer.fromJson<String?>(json['itemGroup']),
      stockUom: serializer.fromJson<String?>(json['stockUom']),
      salesUom: serializer.fromJson<String?>(json['salesUom']),
      transactionNumber:
          serializer.fromJson<String?>(json['transactionNumber']),
      quantityMove: serializer.fromJson<double>(json['quantityMove']),
      quantityMoveConvert:
          serializer.fromJson<double>(json['quantityMoveConvert']),
      conversionFactor: serializer.fromJson<double>(json['conversionFactor']),
      costPrice: serializer.fromJson<double>(json['costPrice']),
      itemPrice: serializer.fromJson<double>(json['itemPrice']),
      transactionType: serializer.fromJson<String?>(json['transactionType']),
      reasonCode: serializer.fromJson<String?>(json['reasonCode']),
      inventoryCycle: serializer.fromJson<String?>(json['inventoryCycle']),
      toWarehouse: serializer.fromJson<String?>(json['toWarehouse']),
      fromWarehouse: serializer.fromJson<String?>(json['fromWarehouse']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemCode': serializer.toJson<String?>(itemCode),
      'itemName': serializer.toJson<String?>(itemName),
      'itemId': serializer.toJson<String?>(itemId),
      'description': serializer.toJson<String?>(description),
      'itemGroup': serializer.toJson<String?>(itemGroup),
      'stockUom': serializer.toJson<String?>(stockUom),
      'salesUom': serializer.toJson<String?>(salesUom),
      'transactionNumber': serializer.toJson<String?>(transactionNumber),
      'quantityMove': serializer.toJson<double>(quantityMove),
      'quantityMoveConvert': serializer.toJson<double>(quantityMoveConvert),
      'conversionFactor': serializer.toJson<double>(conversionFactor),
      'costPrice': serializer.toJson<double>(costPrice),
      'itemPrice': serializer.toJson<double>(itemPrice),
      'transactionType': serializer.toJson<String?>(transactionType),
      'reasonCode': serializer.toJson<String?>(reasonCode),
      'inventoryCycle': serializer.toJson<String?>(inventoryCycle),
      'toWarehouse': serializer.toJson<String?>(toWarehouse),
      'fromWarehouse': serializer.toJson<String?>(fromWarehouse),
    };
  }

  InventoryTransactionData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> itemCode = const Value.absent(),
          Value<String?> itemName = const Value.absent(),
          Value<String?> itemId = const Value.absent(),
          Value<String?> description = const Value.absent(),
          Value<String?> itemGroup = const Value.absent(),
          Value<String?> stockUom = const Value.absent(),
          Value<String?> salesUom = const Value.absent(),
          Value<String?> transactionNumber = const Value.absent(),
          double? quantityMove,
          double? quantityMoveConvert,
          double? conversionFactor,
          double? costPrice,
          double? itemPrice,
          Value<String?> transactionType = const Value.absent(),
          Value<String?> reasonCode = const Value.absent(),
          Value<String?> inventoryCycle = const Value.absent(),
          Value<String?> toWarehouse = const Value.absent(),
          Value<String?> fromWarehouse = const Value.absent()}) =>
      InventoryTransactionData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        itemCode: itemCode.present ? itemCode.value : this.itemCode,
        itemName: itemName.present ? itemName.value : this.itemName,
        itemId: itemId.present ? itemId.value : this.itemId,
        description: description.present ? description.value : this.description,
        itemGroup: itemGroup.present ? itemGroup.value : this.itemGroup,
        stockUom: stockUom.present ? stockUom.value : this.stockUom,
        salesUom: salesUom.present ? salesUom.value : this.salesUom,
        transactionNumber: transactionNumber.present
            ? transactionNumber.value
            : this.transactionNumber,
        quantityMove: quantityMove ?? this.quantityMove,
        quantityMoveConvert: quantityMoveConvert ?? this.quantityMoveConvert,
        conversionFactor: conversionFactor ?? this.conversionFactor,
        costPrice: costPrice ?? this.costPrice,
        itemPrice: itemPrice ?? this.itemPrice,
        transactionType: transactionType.present
            ? transactionType.value
            : this.transactionType,
        reasonCode: reasonCode.present ? reasonCode.value : this.reasonCode,
        inventoryCycle:
            inventoryCycle.present ? inventoryCycle.value : this.inventoryCycle,
        toWarehouse: toWarehouse.present ? toWarehouse.value : this.toWarehouse,
        fromWarehouse:
            fromWarehouse.present ? fromWarehouse.value : this.fromWarehouse,
      );
  @override
  String toString() {
    return (StringBuffer('InventoryTransactionData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('itemId: $itemId, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('stockUom: $stockUom, ')
          ..write('salesUom: $salesUom, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('quantityMove: $quantityMove, ')
          ..write('quantityMoveConvert: $quantityMoveConvert, ')
          ..write('conversionFactor: $conversionFactor, ')
          ..write('costPrice: $costPrice, ')
          ..write('itemPrice: $itemPrice, ')
          ..write('transactionType: $transactionType, ')
          ..write('reasonCode: $reasonCode, ')
          ..write('inventoryCycle: $inventoryCycle, ')
          ..write('toWarehouse: $toWarehouse, ')
          ..write('fromWarehouse: $fromWarehouse')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      itemCode,
      itemName,
      itemId,
      description,
      itemGroup,
      stockUom,
      salesUom,
      transactionNumber,
      quantityMove,
      quantityMoveConvert,
      conversionFactor,
      costPrice,
      itemPrice,
      transactionType,
      reasonCode,
      inventoryCycle,
      toWarehouse,
      fromWarehouse);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InventoryTransactionData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemCode == this.itemCode &&
          other.itemName == this.itemName &&
          other.itemId == this.itemId &&
          other.description == this.description &&
          other.itemGroup == this.itemGroup &&
          other.stockUom == this.stockUom &&
          other.salesUom == this.salesUom &&
          other.transactionNumber == this.transactionNumber &&
          other.quantityMove == this.quantityMove &&
          other.quantityMoveConvert == this.quantityMoveConvert &&
          other.conversionFactor == this.conversionFactor &&
          other.costPrice == this.costPrice &&
          other.itemPrice == this.itemPrice &&
          other.transactionType == this.transactionType &&
          other.reasonCode == this.reasonCode &&
          other.inventoryCycle == this.inventoryCycle &&
          other.toWarehouse == this.toWarehouse &&
          other.fromWarehouse == this.fromWarehouse);
}

class InventoryTransactionCompanion
    extends UpdateCompanion<InventoryTransactionData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> itemCode;
  final Value<String?> itemName;
  final Value<String?> itemId;
  final Value<String?> description;
  final Value<String?> itemGroup;
  final Value<String?> stockUom;
  final Value<String?> salesUom;
  final Value<String?> transactionNumber;
  final Value<double> quantityMove;
  final Value<double> quantityMoveConvert;
  final Value<double> conversionFactor;
  final Value<double> costPrice;
  final Value<double> itemPrice;
  final Value<String?> transactionType;
  final Value<String?> reasonCode;
  final Value<String?> inventoryCycle;
  final Value<String?> toWarehouse;
  final Value<String?> fromWarehouse;
  const InventoryTransactionCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.itemId = const Value.absent(),
    this.description = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.stockUom = const Value.absent(),
    this.salesUom = const Value.absent(),
    this.transactionNumber = const Value.absent(),
    this.quantityMove = const Value.absent(),
    this.quantityMoveConvert = const Value.absent(),
    this.conversionFactor = const Value.absent(),
    this.costPrice = const Value.absent(),
    this.itemPrice = const Value.absent(),
    this.transactionType = const Value.absent(),
    this.reasonCode = const Value.absent(),
    this.inventoryCycle = const Value.absent(),
    this.toWarehouse = const Value.absent(),
    this.fromWarehouse = const Value.absent(),
  });
  InventoryTransactionCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.itemId = const Value.absent(),
    this.description = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.stockUom = const Value.absent(),
    this.salesUom = const Value.absent(),
    this.transactionNumber = const Value.absent(),
    required double quantityMove,
    required double quantityMoveConvert,
    required double conversionFactor,
    required double costPrice,
    required double itemPrice,
    this.transactionType = const Value.absent(),
    this.reasonCode = const Value.absent(),
    this.inventoryCycle = const Value.absent(),
    this.toWarehouse = const Value.absent(),
    this.fromWarehouse = const Value.absent(),
  })  : quantityMove = Value(quantityMove),
        quantityMoveConvert = Value(quantityMoveConvert),
        conversionFactor = Value(conversionFactor),
        costPrice = Value(costPrice),
        itemPrice = Value(itemPrice);
  static Insertable<InventoryTransactionData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? itemCode,
    Expression<String>? itemName,
    Expression<String>? itemId,
    Expression<String>? description,
    Expression<String>? itemGroup,
    Expression<String>? stockUom,
    Expression<String>? salesUom,
    Expression<String>? transactionNumber,
    Expression<double>? quantityMove,
    Expression<double>? quantityMoveConvert,
    Expression<double>? conversionFactor,
    Expression<double>? costPrice,
    Expression<double>? itemPrice,
    Expression<String>? transactionType,
    Expression<String>? reasonCode,
    Expression<String>? inventoryCycle,
    Expression<String>? toWarehouse,
    Expression<String>? fromWarehouse,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemCode != null) 'item_code': itemCode,
      if (itemName != null) 'item_name': itemName,
      if (itemId != null) 'item_id': itemId,
      if (description != null) 'description': description,
      if (itemGroup != null) 'item_group': itemGroup,
      if (stockUom != null) 'stock_uom': stockUom,
      if (salesUom != null) 'sales_uom': salesUom,
      if (transactionNumber != null) 'transaction_number': transactionNumber,
      if (quantityMove != null) 'quantity_move': quantityMove,
      if (quantityMoveConvert != null)
        'quantity_move_convert': quantityMoveConvert,
      if (conversionFactor != null) 'conversion_factor': conversionFactor,
      if (costPrice != null) 'cost_price': costPrice,
      if (itemPrice != null) 'item_price': itemPrice,
      if (transactionType != null) 'transaction_type': transactionType,
      if (reasonCode != null) 'reason_code': reasonCode,
      if (inventoryCycle != null) 'inventory_cycle': inventoryCycle,
      if (toWarehouse != null) 'to_warehouse': toWarehouse,
      if (fromWarehouse != null) 'from_warehouse': fromWarehouse,
    });
  }

  InventoryTransactionCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? itemCode,
      Value<String?>? itemName,
      Value<String?>? itemId,
      Value<String?>? description,
      Value<String?>? itemGroup,
      Value<String?>? stockUom,
      Value<String?>? salesUom,
      Value<String?>? transactionNumber,
      Value<double>? quantityMove,
      Value<double>? quantityMoveConvert,
      Value<double>? conversionFactor,
      Value<double>? costPrice,
      Value<double>? itemPrice,
      Value<String?>? transactionType,
      Value<String?>? reasonCode,
      Value<String?>? inventoryCycle,
      Value<String?>? toWarehouse,
      Value<String?>? fromWarehouse}) {
    return InventoryTransactionCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemCode: itemCode ?? this.itemCode,
      itemName: itemName ?? this.itemName,
      itemId: itemId ?? this.itemId,
      description: description ?? this.description,
      itemGroup: itemGroup ?? this.itemGroup,
      stockUom: stockUom ?? this.stockUom,
      salesUom: salesUom ?? this.salesUom,
      transactionNumber: transactionNumber ?? this.transactionNumber,
      quantityMove: quantityMove ?? this.quantityMove,
      quantityMoveConvert: quantityMoveConvert ?? this.quantityMoveConvert,
      conversionFactor: conversionFactor ?? this.conversionFactor,
      costPrice: costPrice ?? this.costPrice,
      itemPrice: itemPrice ?? this.itemPrice,
      transactionType: transactionType ?? this.transactionType,
      reasonCode: reasonCode ?? this.reasonCode,
      inventoryCycle: inventoryCycle ?? this.inventoryCycle,
      toWarehouse: toWarehouse ?? this.toWarehouse,
      fromWarehouse: fromWarehouse ?? this.fromWarehouse,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (itemName.present) {
      map['item_name'] = Variable<String>(itemName.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (itemGroup.present) {
      map['item_group'] = Variable<String>(itemGroup.value);
    }
    if (stockUom.present) {
      map['stock_uom'] = Variable<String>(stockUom.value);
    }
    if (salesUom.present) {
      map['sales_uom'] = Variable<String>(salesUom.value);
    }
    if (transactionNumber.present) {
      map['transaction_number'] = Variable<String>(transactionNumber.value);
    }
    if (quantityMove.present) {
      map['quantity_move'] = Variable<double>(quantityMove.value);
    }
    if (quantityMoveConvert.present) {
      map['quantity_move_convert'] =
          Variable<double>(quantityMoveConvert.value);
    }
    if (conversionFactor.present) {
      map['conversion_factor'] = Variable<double>(conversionFactor.value);
    }
    if (costPrice.present) {
      map['cost_price'] = Variable<double>(costPrice.value);
    }
    if (itemPrice.present) {
      map['item_price'] = Variable<double>(itemPrice.value);
    }
    if (transactionType.present) {
      map['transaction_type'] = Variable<String>(transactionType.value);
    }
    if (reasonCode.present) {
      map['reason_code'] = Variable<String>(reasonCode.value);
    }
    if (inventoryCycle.present) {
      map['inventory_cycle'] = Variable<String>(inventoryCycle.value);
    }
    if (toWarehouse.present) {
      map['to_warehouse'] = Variable<String>(toWarehouse.value);
    }
    if (fromWarehouse.present) {
      map['from_warehouse'] = Variable<String>(fromWarehouse.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InventoryTransactionCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('itemId: $itemId, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('stockUom: $stockUom, ')
          ..write('salesUom: $salesUom, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('quantityMove: $quantityMove, ')
          ..write('quantityMoveConvert: $quantityMoveConvert, ')
          ..write('conversionFactor: $conversionFactor, ')
          ..write('costPrice: $costPrice, ')
          ..write('itemPrice: $itemPrice, ')
          ..write('transactionType: $transactionType, ')
          ..write('reasonCode: $reasonCode, ')
          ..write('inventoryCycle: $inventoryCycle, ')
          ..write('toWarehouse: $toWarehouse, ')
          ..write('fromWarehouse: $fromWarehouse')
          ..write(')'))
        .toString();
  }
}

class $MoneyDepositTable extends MoneyDeposit
    with TableInfo<$MoneyDepositTable, MoneyDepositData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MoneyDepositTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _clockInDaySessionIdMeta =
      const VerificationMeta('clockInDaySessionId');
  @override
  late final GeneratedColumn<String> clockInDaySessionId =
      GeneratedColumn<String>('clock_in_day_session_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clockOutDaySessionIdMeta =
      const VerificationMeta('clockOutDaySessionId');
  @override
  late final GeneratedColumn<String> clockOutDaySessionId =
      GeneratedColumn<String>('clock_out_day_session_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _depositIdMeta =
      const VerificationMeta('depositId');
  @override
  late final GeneratedColumn<String> depositId = GeneratedColumn<String>(
      'deposit_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  @override
  late final GeneratedColumn<DateTime> startDate = GeneratedColumn<DateTime>(
      'start_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  @override
  late final GeneratedColumn<DateTime> endDate = GeneratedColumn<DateTime>(
      'end_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _depositStatusMeta =
      const VerificationMeta('depositStatus');
  @override
  late final GeneratedColumn<String> depositStatus = GeneratedColumn<String>(
      'deposit_status', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _denominatorMeta =
      const VerificationMeta('denominator');
  @override
  late final GeneratedColumn<double> denominator = GeneratedColumn<double>(
      'denominator', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _denominatorTypeMeta =
      const VerificationMeta('denominatorType');
  @override
  late final GeneratedColumn<String> denominatorType = GeneratedColumn<String>(
      'denominator_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _depositDescriptionMeta =
      const VerificationMeta('depositDescription');
  @override
  late final GeneratedColumn<String> depositDescription =
      GeneratedColumn<String>('deposit_description', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<double> amount = GeneratedColumn<double>(
      'amount', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _currencyMeta =
      const VerificationMeta('currency');
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
      'currency', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  @override
  late final GeneratedColumn<double> exchangeRate = GeneratedColumn<double>(
      'exchange_rate', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _subTotalMeta =
      const VerificationMeta('subTotal');
  @override
  late final GeneratedColumn<double> subTotal = GeneratedColumn<double>(
      'sub_total', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _grandTotalMeta =
      const VerificationMeta('grandTotal');
  @override
  late final GeneratedColumn<double> grandTotal = GeneratedColumn<double>(
      'grand_total', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        clockInDaySessionId,
        clockOutDaySessionId,
        depositId,
        type,
        startDate,
        endDate,
        depositStatus,
        userName,
        denominator,
        denominatorType,
        depositDescription,
        amount,
        currency,
        exchangeRate,
        subTotal,
        grandTotal
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'money_deposit';
  @override
  VerificationContext validateIntegrity(Insertable<MoneyDepositData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('clock_in_day_session_id')) {
      context.handle(
          _clockInDaySessionIdMeta,
          clockInDaySessionId.isAcceptableOrUnknown(
              data['clock_in_day_session_id']!, _clockInDaySessionIdMeta));
    }
    if (data.containsKey('clock_out_day_session_id')) {
      context.handle(
          _clockOutDaySessionIdMeta,
          clockOutDaySessionId.isAcceptableOrUnknown(
              data['clock_out_day_session_id']!, _clockOutDaySessionIdMeta));
    }
    if (data.containsKey('deposit_id')) {
      context.handle(_depositIdMeta,
          depositId.isAcceptableOrUnknown(data['deposit_id']!, _depositIdMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    }
    if (data.containsKey('deposit_status')) {
      context.handle(
          _depositStatusMeta,
          depositStatus.isAcceptableOrUnknown(
              data['deposit_status']!, _depositStatusMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('denominator')) {
      context.handle(
          _denominatorMeta,
          denominator.isAcceptableOrUnknown(
              data['denominator']!, _denominatorMeta));
    }
    if (data.containsKey('denominator_type')) {
      context.handle(
          _denominatorTypeMeta,
          denominatorType.isAcceptableOrUnknown(
              data['denominator_type']!, _denominatorTypeMeta));
    }
    if (data.containsKey('deposit_description')) {
      context.handle(
          _depositDescriptionMeta,
          depositDescription.isAcceptableOrUnknown(
              data['deposit_description']!, _depositDescriptionMeta));
    }
    if (data.containsKey('amount')) {
      context.handle(_amountMeta,
          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta));
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate']!, _exchangeRateMeta));
    }
    if (data.containsKey('sub_total')) {
      context.handle(_subTotalMeta,
          subTotal.isAcceptableOrUnknown(data['sub_total']!, _subTotalMeta));
    }
    if (data.containsKey('grand_total')) {
      context.handle(
          _grandTotalMeta,
          grandTotal.isAcceptableOrUnknown(
              data['grand_total']!, _grandTotalMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => const {};
  @override
  MoneyDepositData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MoneyDepositData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      clockInDaySessionId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}clock_in_day_session_id']),
      clockOutDaySessionId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}clock_out_day_session_id']),
      depositId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}deposit_id']),
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type']),
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}start_date']),
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}end_date']),
      depositStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}deposit_status']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      denominator: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}denominator']),
      denominatorType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}denominator_type']),
      depositDescription: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}deposit_description']),
      amount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}amount']),
      currency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}currency']),
      exchangeRate: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}exchange_rate']),
      subTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}sub_total']),
      grandTotal: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}grand_total']),
    );
  }

  @override
  $MoneyDepositTable createAlias(String alias) {
    return $MoneyDepositTable(attachedDatabase, alias);
  }
}

class MoneyDepositData extends DataClass
    implements Insertable<MoneyDepositData> {
  final String? tenantId;
  final int id;
  final String? clockInDaySessionId;
  final String? clockOutDaySessionId;
  final String? depositId;
  final String? type;
  final DateTime? startDate;
  final DateTime? endDate;
  final String? depositStatus;
  final String? userName;
  final double? denominator;
  final String? denominatorType;
  final String? depositDescription;
  final double? amount;
  final String? currency;
  final double? exchangeRate;
  final double? subTotal;
  final double? grandTotal;
  const MoneyDepositData(
      {this.tenantId,
      required this.id,
      this.clockInDaySessionId,
      this.clockOutDaySessionId,
      this.depositId,
      this.type,
      this.startDate,
      this.endDate,
      this.depositStatus,
      this.userName,
      this.denominator,
      this.denominatorType,
      this.depositDescription,
      this.amount,
      this.currency,
      this.exchangeRate,
      this.subTotal,
      this.grandTotal});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || clockInDaySessionId != null) {
      map['clock_in_day_session_id'] = Variable<String>(clockInDaySessionId);
    }
    if (!nullToAbsent || clockOutDaySessionId != null) {
      map['clock_out_day_session_id'] = Variable<String>(clockOutDaySessionId);
    }
    if (!nullToAbsent || depositId != null) {
      map['deposit_id'] = Variable<String>(depositId);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<DateTime>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<DateTime>(endDate);
    }
    if (!nullToAbsent || depositStatus != null) {
      map['deposit_status'] = Variable<String>(depositStatus);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || denominator != null) {
      map['denominator'] = Variable<double>(denominator);
    }
    if (!nullToAbsent || denominatorType != null) {
      map['denominator_type'] = Variable<String>(denominatorType);
    }
    if (!nullToAbsent || depositDescription != null) {
      map['deposit_description'] = Variable<String>(depositDescription);
    }
    if (!nullToAbsent || amount != null) {
      map['amount'] = Variable<double>(amount);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    if (!nullToAbsent || exchangeRate != null) {
      map['exchange_rate'] = Variable<double>(exchangeRate);
    }
    if (!nullToAbsent || subTotal != null) {
      map['sub_total'] = Variable<double>(subTotal);
    }
    if (!nullToAbsent || grandTotal != null) {
      map['grand_total'] = Variable<double>(grandTotal);
    }
    return map;
  }

  MoneyDepositCompanion toCompanion(bool nullToAbsent) {
    return MoneyDepositCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      clockInDaySessionId: clockInDaySessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(clockInDaySessionId),
      clockOutDaySessionId: clockOutDaySessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(clockOutDaySessionId),
      depositId: depositId == null && nullToAbsent
          ? const Value.absent()
          : Value(depositId),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      depositStatus: depositStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(depositStatus),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      denominator: denominator == null && nullToAbsent
          ? const Value.absent()
          : Value(denominator),
      denominatorType: denominatorType == null && nullToAbsent
          ? const Value.absent()
          : Value(denominatorType),
      depositDescription: depositDescription == null && nullToAbsent
          ? const Value.absent()
          : Value(depositDescription),
      amount:
          amount == null && nullToAbsent ? const Value.absent() : Value(amount),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      exchangeRate: exchangeRate == null && nullToAbsent
          ? const Value.absent()
          : Value(exchangeRate),
      subTotal: subTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(subTotal),
      grandTotal: grandTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(grandTotal),
    );
  }

  factory MoneyDepositData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MoneyDepositData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      clockInDaySessionId:
          serializer.fromJson<String?>(json['clockInDaySessionId']),
      clockOutDaySessionId:
          serializer.fromJson<String?>(json['clockOutDaySessionId']),
      depositId: serializer.fromJson<String?>(json['depositId']),
      type: serializer.fromJson<String?>(json['type']),
      startDate: serializer.fromJson<DateTime?>(json['startDate']),
      endDate: serializer.fromJson<DateTime?>(json['endDate']),
      depositStatus: serializer.fromJson<String?>(json['depositStatus']),
      userName: serializer.fromJson<String?>(json['userName']),
      denominator: serializer.fromJson<double?>(json['denominator']),
      denominatorType: serializer.fromJson<String?>(json['denominatorType']),
      depositDescription:
          serializer.fromJson<String?>(json['depositDescription']),
      amount: serializer.fromJson<double?>(json['amount']),
      currency: serializer.fromJson<String?>(json['currency']),
      exchangeRate: serializer.fromJson<double?>(json['exchangeRate']),
      subTotal: serializer.fromJson<double?>(json['subTotal']),
      grandTotal: serializer.fromJson<double?>(json['grandTotal']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'clockInDaySessionId': serializer.toJson<String?>(clockInDaySessionId),
      'clockOutDaySessionId': serializer.toJson<String?>(clockOutDaySessionId),
      'depositId': serializer.toJson<String?>(depositId),
      'type': serializer.toJson<String?>(type),
      'startDate': serializer.toJson<DateTime?>(startDate),
      'endDate': serializer.toJson<DateTime?>(endDate),
      'depositStatus': serializer.toJson<String?>(depositStatus),
      'userName': serializer.toJson<String?>(userName),
      'denominator': serializer.toJson<double?>(denominator),
      'denominatorType': serializer.toJson<String?>(denominatorType),
      'depositDescription': serializer.toJson<String?>(depositDescription),
      'amount': serializer.toJson<double?>(amount),
      'currency': serializer.toJson<String?>(currency),
      'exchangeRate': serializer.toJson<double?>(exchangeRate),
      'subTotal': serializer.toJson<double?>(subTotal),
      'grandTotal': serializer.toJson<double?>(grandTotal),
    };
  }

  MoneyDepositData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> clockInDaySessionId = const Value.absent(),
          Value<String?> clockOutDaySessionId = const Value.absent(),
          Value<String?> depositId = const Value.absent(),
          Value<String?> type = const Value.absent(),
          Value<DateTime?> startDate = const Value.absent(),
          Value<DateTime?> endDate = const Value.absent(),
          Value<String?> depositStatus = const Value.absent(),
          Value<String?> userName = const Value.absent(),
          Value<double?> denominator = const Value.absent(),
          Value<String?> denominatorType = const Value.absent(),
          Value<String?> depositDescription = const Value.absent(),
          Value<double?> amount = const Value.absent(),
          Value<String?> currency = const Value.absent(),
          Value<double?> exchangeRate = const Value.absent(),
          Value<double?> subTotal = const Value.absent(),
          Value<double?> grandTotal = const Value.absent()}) =>
      MoneyDepositData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        clockInDaySessionId: clockInDaySessionId.present
            ? clockInDaySessionId.value
            : this.clockInDaySessionId,
        clockOutDaySessionId: clockOutDaySessionId.present
            ? clockOutDaySessionId.value
            : this.clockOutDaySessionId,
        depositId: depositId.present ? depositId.value : this.depositId,
        type: type.present ? type.value : this.type,
        startDate: startDate.present ? startDate.value : this.startDate,
        endDate: endDate.present ? endDate.value : this.endDate,
        depositStatus:
            depositStatus.present ? depositStatus.value : this.depositStatus,
        userName: userName.present ? userName.value : this.userName,
        denominator: denominator.present ? denominator.value : this.denominator,
        denominatorType: denominatorType.present
            ? denominatorType.value
            : this.denominatorType,
        depositDescription: depositDescription.present
            ? depositDescription.value
            : this.depositDescription,
        amount: amount.present ? amount.value : this.amount,
        currency: currency.present ? currency.value : this.currency,
        exchangeRate:
            exchangeRate.present ? exchangeRate.value : this.exchangeRate,
        subTotal: subTotal.present ? subTotal.value : this.subTotal,
        grandTotal: grandTotal.present ? grandTotal.value : this.grandTotal,
      );
  @override
  String toString() {
    return (StringBuffer('MoneyDepositData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('clockInDaySessionId: $clockInDaySessionId, ')
          ..write('clockOutDaySessionId: $clockOutDaySessionId, ')
          ..write('depositId: $depositId, ')
          ..write('type: $type, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('depositStatus: $depositStatus, ')
          ..write('userName: $userName, ')
          ..write('denominator: $denominator, ')
          ..write('denominatorType: $denominatorType, ')
          ..write('depositDescription: $depositDescription, ')
          ..write('amount: $amount, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      clockInDaySessionId,
      clockOutDaySessionId,
      depositId,
      type,
      startDate,
      endDate,
      depositStatus,
      userName,
      denominator,
      denominatorType,
      depositDescription,
      amount,
      currency,
      exchangeRate,
      subTotal,
      grandTotal);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MoneyDepositData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.clockInDaySessionId == this.clockInDaySessionId &&
          other.clockOutDaySessionId == this.clockOutDaySessionId &&
          other.depositId == this.depositId &&
          other.type == this.type &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.depositStatus == this.depositStatus &&
          other.userName == this.userName &&
          other.denominator == this.denominator &&
          other.denominatorType == this.denominatorType &&
          other.depositDescription == this.depositDescription &&
          other.amount == this.amount &&
          other.currency == this.currency &&
          other.exchangeRate == this.exchangeRate &&
          other.subTotal == this.subTotal &&
          other.grandTotal == this.grandTotal);
}

class MoneyDepositCompanion extends UpdateCompanion<MoneyDepositData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> clockInDaySessionId;
  final Value<String?> clockOutDaySessionId;
  final Value<String?> depositId;
  final Value<String?> type;
  final Value<DateTime?> startDate;
  final Value<DateTime?> endDate;
  final Value<String?> depositStatus;
  final Value<String?> userName;
  final Value<double?> denominator;
  final Value<String?> denominatorType;
  final Value<String?> depositDescription;
  final Value<double?> amount;
  final Value<String?> currency;
  final Value<double?> exchangeRate;
  final Value<double?> subTotal;
  final Value<double?> grandTotal;
  final Value<int> rowid;
  const MoneyDepositCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.clockInDaySessionId = const Value.absent(),
    this.clockOutDaySessionId = const Value.absent(),
    this.depositId = const Value.absent(),
    this.type = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.depositStatus = const Value.absent(),
    this.userName = const Value.absent(),
    this.denominator = const Value.absent(),
    this.denominatorType = const Value.absent(),
    this.depositDescription = const Value.absent(),
    this.amount = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.subTotal = const Value.absent(),
    this.grandTotal = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MoneyDepositCompanion.insert({
    this.tenantId = const Value.absent(),
    required int id,
    this.clockInDaySessionId = const Value.absent(),
    this.clockOutDaySessionId = const Value.absent(),
    this.depositId = const Value.absent(),
    this.type = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.depositStatus = const Value.absent(),
    this.userName = const Value.absent(),
    this.denominator = const Value.absent(),
    this.denominatorType = const Value.absent(),
    this.depositDescription = const Value.absent(),
    this.amount = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.subTotal = const Value.absent(),
    this.grandTotal = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<MoneyDepositData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? clockInDaySessionId,
    Expression<String>? clockOutDaySessionId,
    Expression<String>? depositId,
    Expression<String>? type,
    Expression<DateTime>? startDate,
    Expression<DateTime>? endDate,
    Expression<String>? depositStatus,
    Expression<String>? userName,
    Expression<double>? denominator,
    Expression<String>? denominatorType,
    Expression<String>? depositDescription,
    Expression<double>? amount,
    Expression<String>? currency,
    Expression<double>? exchangeRate,
    Expression<double>? subTotal,
    Expression<double>? grandTotal,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (clockInDaySessionId != null)
        'clock_in_day_session_id': clockInDaySessionId,
      if (clockOutDaySessionId != null)
        'clock_out_day_session_id': clockOutDaySessionId,
      if (depositId != null) 'deposit_id': depositId,
      if (type != null) 'type': type,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (depositStatus != null) 'deposit_status': depositStatus,
      if (userName != null) 'user_name': userName,
      if (denominator != null) 'denominator': denominator,
      if (denominatorType != null) 'denominator_type': denominatorType,
      if (depositDescription != null) 'deposit_description': depositDescription,
      if (amount != null) 'amount': amount,
      if (currency != null) 'currency': currency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (subTotal != null) 'sub_total': subTotal,
      if (grandTotal != null) 'grand_total': grandTotal,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MoneyDepositCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? clockInDaySessionId,
      Value<String?>? clockOutDaySessionId,
      Value<String?>? depositId,
      Value<String?>? type,
      Value<DateTime?>? startDate,
      Value<DateTime?>? endDate,
      Value<String?>? depositStatus,
      Value<String?>? userName,
      Value<double?>? denominator,
      Value<String?>? denominatorType,
      Value<String?>? depositDescription,
      Value<double?>? amount,
      Value<String?>? currency,
      Value<double?>? exchangeRate,
      Value<double?>? subTotal,
      Value<double?>? grandTotal,
      Value<int>? rowid}) {
    return MoneyDepositCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      clockInDaySessionId: clockInDaySessionId ?? this.clockInDaySessionId,
      clockOutDaySessionId: clockOutDaySessionId ?? this.clockOutDaySessionId,
      depositId: depositId ?? this.depositId,
      type: type ?? this.type,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      depositStatus: depositStatus ?? this.depositStatus,
      userName: userName ?? this.userName,
      denominator: denominator ?? this.denominator,
      denominatorType: denominatorType ?? this.denominatorType,
      depositDescription: depositDescription ?? this.depositDescription,
      amount: amount ?? this.amount,
      currency: currency ?? this.currency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      subTotal: subTotal ?? this.subTotal,
      grandTotal: grandTotal ?? this.grandTotal,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (clockInDaySessionId.present) {
      map['clock_in_day_session_id'] =
          Variable<String>(clockInDaySessionId.value);
    }
    if (clockOutDaySessionId.present) {
      map['clock_out_day_session_id'] =
          Variable<String>(clockOutDaySessionId.value);
    }
    if (depositId.present) {
      map['deposit_id'] = Variable<String>(depositId.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<DateTime>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<DateTime>(endDate.value);
    }
    if (depositStatus.present) {
      map['deposit_status'] = Variable<String>(depositStatus.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (denominator.present) {
      map['denominator'] = Variable<double>(denominator.value);
    }
    if (denominatorType.present) {
      map['denominator_type'] = Variable<String>(denominatorType.value);
    }
    if (depositDescription.present) {
      map['deposit_description'] = Variable<String>(depositDescription.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (subTotal.present) {
      map['sub_total'] = Variable<double>(subTotal.value);
    }
    if (grandTotal.present) {
      map['grand_total'] = Variable<double>(grandTotal.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MoneyDepositCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('clockInDaySessionId: $clockInDaySessionId, ')
          ..write('clockOutDaySessionId: $clockOutDaySessionId, ')
          ..write('depositId: $depositId, ')
          ..write('type: $type, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('depositStatus: $depositStatus, ')
          ..write('userName: $userName, ')
          ..write('denominator: $denominator, ')
          ..write('denominatorType: $denominatorType, ')
          ..write('depositDescription: $depositDescription, ')
          ..write('amount: $amount, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ClockInTable extends ClockIn with TableInfo<$ClockInTable, ClockInData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ClockInTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _clockInDaySessionIdMeta =
      const VerificationMeta('clockInDaySessionId');
  @override
  late final GeneratedColumn<String> clockInDaySessionId =
      GeneratedColumn<String>('clock_in_day_session_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clockOutDaySessionIdMeta =
      const VerificationMeta('clockOutDaySessionId');
  @override
  late final GeneratedColumn<String> clockOutDaySessionId =
      GeneratedColumn<String>('clock_out_day_session_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _inventoryCycleIdMeta =
      const VerificationMeta('inventoryCycleId');
  @override
  late final GeneratedColumn<String> inventoryCycleId = GeneratedColumn<String>(
      'inventory_cycle_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fullNameMeta =
      const VerificationMeta('fullName');
  @override
  late final GeneratedColumn<String> fullName = GeneratedColumn<String>(
      'full_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  @override
  late final GeneratedColumn<DateTime> startDate = GeneratedColumn<DateTime>(
      'start_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  @override
  late final GeneratedColumn<DateTime> endDate = GeneratedColumn<DateTime>(
      'end_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _warehouseNameMeta =
      const VerificationMeta('warehouseName');
  @override
  late final GeneratedColumn<DateTime> warehouseName =
      GeneratedColumn<DateTime>('warehouse_name', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _shiftNameMeta =
      const VerificationMeta('shiftName');
  @override
  late final GeneratedColumn<String> shiftName = GeneratedColumn<String>(
      'shift_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fleetNumberMeta =
      const VerificationMeta('fleetNumber');
  @override
  late final GeneratedColumn<String> fleetNumber = GeneratedColumn<String>(
      'fleet_number', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _licensePlateMeta =
      const VerificationMeta('licensePlate');
  @override
  late final GeneratedColumn<String> licensePlate = GeneratedColumn<String>(
      'license_plate', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _userNameMeta =
      const VerificationMeta('userName');
  @override
  late final GeneratedColumn<String> userName = GeneratedColumn<String>(
      'user_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _sesionTypeMeta =
      const VerificationMeta('sesionType');
  @override
  late final GeneratedColumn<String> sesionType = GeneratedColumn<String>(
      'sesion_type', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _sessionStatusMeta =
      const VerificationMeta('sessionStatus');
  @override
  late final GeneratedColumn<String> sessionStatus = GeneratedColumn<String>(
      'session_status', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _deviceIdMeta =
      const VerificationMeta('deviceId');
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
      'device_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _depositAmountMeta =
      const VerificationMeta('depositAmount');
  @override
  late final GeneratedColumn<double> depositAmount = GeneratedColumn<double>(
      'deposit_amount', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _totalSalesMeta =
      const VerificationMeta('totalSales');
  @override
  late final GeneratedColumn<double> totalSales = GeneratedColumn<double>(
      'total_sales', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _arPaymentMeta =
      const VerificationMeta('arPayment');
  @override
  late final GeneratedColumn<double> arPayment = GeneratedColumn<double>(
      'ar_payment', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _totalAmountDueMeta =
      const VerificationMeta('totalAmountDue');
  @override
  late final GeneratedColumn<double> totalAmountDue = GeneratedColumn<double>(
      'total_amount_due', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _balanceBroughtForwardMeta =
      const VerificationMeta('balanceBroughtForward');
  @override
  late final GeneratedColumn<double> balanceBroughtForward =
      GeneratedColumn<double>('balance_brought_forward', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _balanceAmountMeta =
      const VerificationMeta('balanceAmount');
  @override
  late final GeneratedColumn<double> balanceAmount = GeneratedColumn<double>(
      'balance_amount', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _balanceTextMeta =
      const VerificationMeta('balanceText');
  @override
  late final GeneratedColumn<String> balanceText = GeneratedColumn<String>(
      'balance_text', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _cashTransferMeta =
      const VerificationMeta('cashTransfer');
  @override
  late final GeneratedColumn<double> cashTransfer = GeneratedColumn<double>(
      'cash_transfer', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _creditSalesMeta =
      const VerificationMeta('creditSales');
  @override
  late final GeneratedColumn<double> creditSales = GeneratedColumn<double>(
      'credit_sales', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        clockInDaySessionId,
        clockOutDaySessionId,
        inventoryCycleId,
        fullName,
        startDate,
        endDate,
        warehouseName,
        shiftName,
        fleetNumber,
        licensePlate,
        userName,
        sesionType,
        sessionStatus,
        deviceId,
        depositAmount,
        totalSales,
        arPayment,
        totalAmountDue,
        balanceBroughtForward,
        balanceAmount,
        balanceText,
        cashTransfer,
        creditSales
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'clock_in';
  @override
  VerificationContext validateIntegrity(Insertable<ClockInData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('clock_in_day_session_id')) {
      context.handle(
          _clockInDaySessionIdMeta,
          clockInDaySessionId.isAcceptableOrUnknown(
              data['clock_in_day_session_id']!, _clockInDaySessionIdMeta));
    }
    if (data.containsKey('clock_out_day_session_id')) {
      context.handle(
          _clockOutDaySessionIdMeta,
          clockOutDaySessionId.isAcceptableOrUnknown(
              data['clock_out_day_session_id']!, _clockOutDaySessionIdMeta));
    }
    if (data.containsKey('inventory_cycle_id')) {
      context.handle(
          _inventoryCycleIdMeta,
          inventoryCycleId.isAcceptableOrUnknown(
              data['inventory_cycle_id']!, _inventoryCycleIdMeta));
    }
    if (data.containsKey('full_name')) {
      context.handle(_fullNameMeta,
          fullName.isAcceptableOrUnknown(data['full_name']!, _fullNameMeta));
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    }
    if (data.containsKey('warehouse_name')) {
      context.handle(
          _warehouseNameMeta,
          warehouseName.isAcceptableOrUnknown(
              data['warehouse_name']!, _warehouseNameMeta));
    }
    if (data.containsKey('shift_name')) {
      context.handle(_shiftNameMeta,
          shiftName.isAcceptableOrUnknown(data['shift_name']!, _shiftNameMeta));
    }
    if (data.containsKey('fleet_number')) {
      context.handle(
          _fleetNumberMeta,
          fleetNumber.isAcceptableOrUnknown(
              data['fleet_number']!, _fleetNumberMeta));
    }
    if (data.containsKey('license_plate')) {
      context.handle(
          _licensePlateMeta,
          licensePlate.isAcceptableOrUnknown(
              data['license_plate']!, _licensePlateMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name']!, _userNameMeta));
    }
    if (data.containsKey('sesion_type')) {
      context.handle(
          _sesionTypeMeta,
          sesionType.isAcceptableOrUnknown(
              data['sesion_type']!, _sesionTypeMeta));
    }
    if (data.containsKey('session_status')) {
      context.handle(
          _sessionStatusMeta,
          sessionStatus.isAcceptableOrUnknown(
              data['session_status']!, _sessionStatusMeta));
    }
    if (data.containsKey('device_id')) {
      context.handle(_deviceIdMeta,
          deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta));
    }
    if (data.containsKey('deposit_amount')) {
      context.handle(
          _depositAmountMeta,
          depositAmount.isAcceptableOrUnknown(
              data['deposit_amount']!, _depositAmountMeta));
    }
    if (data.containsKey('total_sales')) {
      context.handle(
          _totalSalesMeta,
          totalSales.isAcceptableOrUnknown(
              data['total_sales']!, _totalSalesMeta));
    }
    if (data.containsKey('ar_payment')) {
      context.handle(_arPaymentMeta,
          arPayment.isAcceptableOrUnknown(data['ar_payment']!, _arPaymentMeta));
    }
    if (data.containsKey('total_amount_due')) {
      context.handle(
          _totalAmountDueMeta,
          totalAmountDue.isAcceptableOrUnknown(
              data['total_amount_due']!, _totalAmountDueMeta));
    }
    if (data.containsKey('balance_brought_forward')) {
      context.handle(
          _balanceBroughtForwardMeta,
          balanceBroughtForward.isAcceptableOrUnknown(
              data['balance_brought_forward']!, _balanceBroughtForwardMeta));
    }
    if (data.containsKey('balance_amount')) {
      context.handle(
          _balanceAmountMeta,
          balanceAmount.isAcceptableOrUnknown(
              data['balance_amount']!, _balanceAmountMeta));
    }
    if (data.containsKey('balance_text')) {
      context.handle(
          _balanceTextMeta,
          balanceText.isAcceptableOrUnknown(
              data['balance_text']!, _balanceTextMeta));
    }
    if (data.containsKey('cash_transfer')) {
      context.handle(
          _cashTransferMeta,
          cashTransfer.isAcceptableOrUnknown(
              data['cash_transfer']!, _cashTransferMeta));
    }
    if (data.containsKey('credit_sales')) {
      context.handle(
          _creditSalesMeta,
          creditSales.isAcceptableOrUnknown(
              data['credit_sales']!, _creditSalesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ClockInData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ClockInData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      clockInDaySessionId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}clock_in_day_session_id']),
      clockOutDaySessionId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}clock_out_day_session_id']),
      inventoryCycleId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}inventory_cycle_id']),
      fullName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}full_name']),
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}start_date']),
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}end_date']),
      warehouseName: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}warehouse_name']),
      shiftName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}shift_name']),
      fleetNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fleet_number']),
      licensePlate: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}license_plate']),
      userName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_name']),
      sesionType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sesion_type']),
      sessionStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}session_status']),
      deviceId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}device_id']),
      depositAmount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}deposit_amount']),
      totalSales: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_sales']),
      arPayment: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}ar_payment']),
      totalAmountDue: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}total_amount_due']),
      balanceBroughtForward: attachedDatabase.typeMapping.read(
          DriftSqlType.double,
          data['${effectivePrefix}balance_brought_forward']),
      balanceAmount: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}balance_amount']),
      balanceText: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}balance_text']),
      cashTransfer: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cash_transfer']),
      creditSales: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}credit_sales']),
    );
  }

  @override
  $ClockInTable createAlias(String alias) {
    return $ClockInTable(attachedDatabase, alias);
  }
}

class ClockInData extends DataClass implements Insertable<ClockInData> {
  final String? tenantId;
  final int id;
  final String? clockInDaySessionId;
  final String? clockOutDaySessionId;
  final String? inventoryCycleId;
  final String? fullName;
  final DateTime? startDate;
  final DateTime? endDate;
  final DateTime? warehouseName;
  final String? shiftName;
  final String? fleetNumber;
  final String? licensePlate;
  final String? userName;
  final String? sesionType;
  final String? sessionStatus;
  final String? deviceId;
  final double? depositAmount;
  final double? totalSales;
  final double? arPayment;
  final double? totalAmountDue;
  final double? balanceBroughtForward;
  final double? balanceAmount;
  final String? balanceText;
  final double? cashTransfer;
  final double? creditSales;
  const ClockInData(
      {this.tenantId,
      required this.id,
      this.clockInDaySessionId,
      this.clockOutDaySessionId,
      this.inventoryCycleId,
      this.fullName,
      this.startDate,
      this.endDate,
      this.warehouseName,
      this.shiftName,
      this.fleetNumber,
      this.licensePlate,
      this.userName,
      this.sesionType,
      this.sessionStatus,
      this.deviceId,
      this.depositAmount,
      this.totalSales,
      this.arPayment,
      this.totalAmountDue,
      this.balanceBroughtForward,
      this.balanceAmount,
      this.balanceText,
      this.cashTransfer,
      this.creditSales});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || clockInDaySessionId != null) {
      map['clock_in_day_session_id'] = Variable<String>(clockInDaySessionId);
    }
    if (!nullToAbsent || clockOutDaySessionId != null) {
      map['clock_out_day_session_id'] = Variable<String>(clockOutDaySessionId);
    }
    if (!nullToAbsent || inventoryCycleId != null) {
      map['inventory_cycle_id'] = Variable<String>(inventoryCycleId);
    }
    if (!nullToAbsent || fullName != null) {
      map['full_name'] = Variable<String>(fullName);
    }
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<DateTime>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<DateTime>(endDate);
    }
    if (!nullToAbsent || warehouseName != null) {
      map['warehouse_name'] = Variable<DateTime>(warehouseName);
    }
    if (!nullToAbsent || shiftName != null) {
      map['shift_name'] = Variable<String>(shiftName);
    }
    if (!nullToAbsent || fleetNumber != null) {
      map['fleet_number'] = Variable<String>(fleetNumber);
    }
    if (!nullToAbsent || licensePlate != null) {
      map['license_plate'] = Variable<String>(licensePlate);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || sesionType != null) {
      map['sesion_type'] = Variable<String>(sesionType);
    }
    if (!nullToAbsent || sessionStatus != null) {
      map['session_status'] = Variable<String>(sessionStatus);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || depositAmount != null) {
      map['deposit_amount'] = Variable<double>(depositAmount);
    }
    if (!nullToAbsent || totalSales != null) {
      map['total_sales'] = Variable<double>(totalSales);
    }
    if (!nullToAbsent || arPayment != null) {
      map['ar_payment'] = Variable<double>(arPayment);
    }
    if (!nullToAbsent || totalAmountDue != null) {
      map['total_amount_due'] = Variable<double>(totalAmountDue);
    }
    if (!nullToAbsent || balanceBroughtForward != null) {
      map['balance_brought_forward'] = Variable<double>(balanceBroughtForward);
    }
    if (!nullToAbsent || balanceAmount != null) {
      map['balance_amount'] = Variable<double>(balanceAmount);
    }
    if (!nullToAbsent || balanceText != null) {
      map['balance_text'] = Variable<String>(balanceText);
    }
    if (!nullToAbsent || cashTransfer != null) {
      map['cash_transfer'] = Variable<double>(cashTransfer);
    }
    if (!nullToAbsent || creditSales != null) {
      map['credit_sales'] = Variable<double>(creditSales);
    }
    return map;
  }

  ClockInCompanion toCompanion(bool nullToAbsent) {
    return ClockInCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      clockInDaySessionId: clockInDaySessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(clockInDaySessionId),
      clockOutDaySessionId: clockOutDaySessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(clockOutDaySessionId),
      inventoryCycleId: inventoryCycleId == null && nullToAbsent
          ? const Value.absent()
          : Value(inventoryCycleId),
      fullName: fullName == null && nullToAbsent
          ? const Value.absent()
          : Value(fullName),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      warehouseName: warehouseName == null && nullToAbsent
          ? const Value.absent()
          : Value(warehouseName),
      shiftName: shiftName == null && nullToAbsent
          ? const Value.absent()
          : Value(shiftName),
      fleetNumber: fleetNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(fleetNumber),
      licensePlate: licensePlate == null && nullToAbsent
          ? const Value.absent()
          : Value(licensePlate),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      sesionType: sesionType == null && nullToAbsent
          ? const Value.absent()
          : Value(sesionType),
      sessionStatus: sessionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(sessionStatus),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      depositAmount: depositAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(depositAmount),
      totalSales: totalSales == null && nullToAbsent
          ? const Value.absent()
          : Value(totalSales),
      arPayment: arPayment == null && nullToAbsent
          ? const Value.absent()
          : Value(arPayment),
      totalAmountDue: totalAmountDue == null && nullToAbsent
          ? const Value.absent()
          : Value(totalAmountDue),
      balanceBroughtForward: balanceBroughtForward == null && nullToAbsent
          ? const Value.absent()
          : Value(balanceBroughtForward),
      balanceAmount: balanceAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(balanceAmount),
      balanceText: balanceText == null && nullToAbsent
          ? const Value.absent()
          : Value(balanceText),
      cashTransfer: cashTransfer == null && nullToAbsent
          ? const Value.absent()
          : Value(cashTransfer),
      creditSales: creditSales == null && nullToAbsent
          ? const Value.absent()
          : Value(creditSales),
    );
  }

  factory ClockInData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ClockInData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      clockInDaySessionId:
          serializer.fromJson<String?>(json['clockInDaySessionId']),
      clockOutDaySessionId:
          serializer.fromJson<String?>(json['clockOutDaySessionId']),
      inventoryCycleId: serializer.fromJson<String?>(json['inventoryCycleId']),
      fullName: serializer.fromJson<String?>(json['fullName']),
      startDate: serializer.fromJson<DateTime?>(json['startDate']),
      endDate: serializer.fromJson<DateTime?>(json['endDate']),
      warehouseName: serializer.fromJson<DateTime?>(json['warehouseName']),
      shiftName: serializer.fromJson<String?>(json['shiftName']),
      fleetNumber: serializer.fromJson<String?>(json['fleetNumber']),
      licensePlate: serializer.fromJson<String?>(json['licensePlate']),
      userName: serializer.fromJson<String?>(json['userName']),
      sesionType: serializer.fromJson<String?>(json['sesionType']),
      sessionStatus: serializer.fromJson<String?>(json['sessionStatus']),
      deviceId: serializer.fromJson<String?>(json['deviceId']),
      depositAmount: serializer.fromJson<double?>(json['depositAmount']),
      totalSales: serializer.fromJson<double?>(json['totalSales']),
      arPayment: serializer.fromJson<double?>(json['arPayment']),
      totalAmountDue: serializer.fromJson<double?>(json['totalAmountDue']),
      balanceBroughtForward:
          serializer.fromJson<double?>(json['balanceBroughtForward']),
      balanceAmount: serializer.fromJson<double?>(json['balanceAmount']),
      balanceText: serializer.fromJson<String?>(json['balanceText']),
      cashTransfer: serializer.fromJson<double?>(json['cashTransfer']),
      creditSales: serializer.fromJson<double?>(json['creditSales']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'clockInDaySessionId': serializer.toJson<String?>(clockInDaySessionId),
      'clockOutDaySessionId': serializer.toJson<String?>(clockOutDaySessionId),
      'inventoryCycleId': serializer.toJson<String?>(inventoryCycleId),
      'fullName': serializer.toJson<String?>(fullName),
      'startDate': serializer.toJson<DateTime?>(startDate),
      'endDate': serializer.toJson<DateTime?>(endDate),
      'warehouseName': serializer.toJson<DateTime?>(warehouseName),
      'shiftName': serializer.toJson<String?>(shiftName),
      'fleetNumber': serializer.toJson<String?>(fleetNumber),
      'licensePlate': serializer.toJson<String?>(licensePlate),
      'userName': serializer.toJson<String?>(userName),
      'sesionType': serializer.toJson<String?>(sesionType),
      'sessionStatus': serializer.toJson<String?>(sessionStatus),
      'deviceId': serializer.toJson<String?>(deviceId),
      'depositAmount': serializer.toJson<double?>(depositAmount),
      'totalSales': serializer.toJson<double?>(totalSales),
      'arPayment': serializer.toJson<double?>(arPayment),
      'totalAmountDue': serializer.toJson<double?>(totalAmountDue),
      'balanceBroughtForward':
          serializer.toJson<double?>(balanceBroughtForward),
      'balanceAmount': serializer.toJson<double?>(balanceAmount),
      'balanceText': serializer.toJson<String?>(balanceText),
      'cashTransfer': serializer.toJson<double?>(cashTransfer),
      'creditSales': serializer.toJson<double?>(creditSales),
    };
  }

  ClockInData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> clockInDaySessionId = const Value.absent(),
          Value<String?> clockOutDaySessionId = const Value.absent(),
          Value<String?> inventoryCycleId = const Value.absent(),
          Value<String?> fullName = const Value.absent(),
          Value<DateTime?> startDate = const Value.absent(),
          Value<DateTime?> endDate = const Value.absent(),
          Value<DateTime?> warehouseName = const Value.absent(),
          Value<String?> shiftName = const Value.absent(),
          Value<String?> fleetNumber = const Value.absent(),
          Value<String?> licensePlate = const Value.absent(),
          Value<String?> userName = const Value.absent(),
          Value<String?> sesionType = const Value.absent(),
          Value<String?> sessionStatus = const Value.absent(),
          Value<String?> deviceId = const Value.absent(),
          Value<double?> depositAmount = const Value.absent(),
          Value<double?> totalSales = const Value.absent(),
          Value<double?> arPayment = const Value.absent(),
          Value<double?> totalAmountDue = const Value.absent(),
          Value<double?> balanceBroughtForward = const Value.absent(),
          Value<double?> balanceAmount = const Value.absent(),
          Value<String?> balanceText = const Value.absent(),
          Value<double?> cashTransfer = const Value.absent(),
          Value<double?> creditSales = const Value.absent()}) =>
      ClockInData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        clockInDaySessionId: clockInDaySessionId.present
            ? clockInDaySessionId.value
            : this.clockInDaySessionId,
        clockOutDaySessionId: clockOutDaySessionId.present
            ? clockOutDaySessionId.value
            : this.clockOutDaySessionId,
        inventoryCycleId: inventoryCycleId.present
            ? inventoryCycleId.value
            : this.inventoryCycleId,
        fullName: fullName.present ? fullName.value : this.fullName,
        startDate: startDate.present ? startDate.value : this.startDate,
        endDate: endDate.present ? endDate.value : this.endDate,
        warehouseName:
            warehouseName.present ? warehouseName.value : this.warehouseName,
        shiftName: shiftName.present ? shiftName.value : this.shiftName,
        fleetNumber: fleetNumber.present ? fleetNumber.value : this.fleetNumber,
        licensePlate:
            licensePlate.present ? licensePlate.value : this.licensePlate,
        userName: userName.present ? userName.value : this.userName,
        sesionType: sesionType.present ? sesionType.value : this.sesionType,
        sessionStatus:
            sessionStatus.present ? sessionStatus.value : this.sessionStatus,
        deviceId: deviceId.present ? deviceId.value : this.deviceId,
        depositAmount:
            depositAmount.present ? depositAmount.value : this.depositAmount,
        totalSales: totalSales.present ? totalSales.value : this.totalSales,
        arPayment: arPayment.present ? arPayment.value : this.arPayment,
        totalAmountDue:
            totalAmountDue.present ? totalAmountDue.value : this.totalAmountDue,
        balanceBroughtForward: balanceBroughtForward.present
            ? balanceBroughtForward.value
            : this.balanceBroughtForward,
        balanceAmount:
            balanceAmount.present ? balanceAmount.value : this.balanceAmount,
        balanceText: balanceText.present ? balanceText.value : this.balanceText,
        cashTransfer:
            cashTransfer.present ? cashTransfer.value : this.cashTransfer,
        creditSales: creditSales.present ? creditSales.value : this.creditSales,
      );
  @override
  String toString() {
    return (StringBuffer('ClockInData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('clockInDaySessionId: $clockInDaySessionId, ')
          ..write('clockOutDaySessionId: $clockOutDaySessionId, ')
          ..write('inventoryCycleId: $inventoryCycleId, ')
          ..write('fullName: $fullName, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('warehouseName: $warehouseName, ')
          ..write('shiftName: $shiftName, ')
          ..write('fleetNumber: $fleetNumber, ')
          ..write('licensePlate: $licensePlate, ')
          ..write('userName: $userName, ')
          ..write('sesionType: $sesionType, ')
          ..write('sessionStatus: $sessionStatus, ')
          ..write('deviceId: $deviceId, ')
          ..write('depositAmount: $depositAmount, ')
          ..write('totalSales: $totalSales, ')
          ..write('arPayment: $arPayment, ')
          ..write('totalAmountDue: $totalAmountDue, ')
          ..write('balanceBroughtForward: $balanceBroughtForward, ')
          ..write('balanceAmount: $balanceAmount, ')
          ..write('balanceText: $balanceText, ')
          ..write('cashTransfer: $cashTransfer, ')
          ..write('creditSales: $creditSales')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        id,
        clockInDaySessionId,
        clockOutDaySessionId,
        inventoryCycleId,
        fullName,
        startDate,
        endDate,
        warehouseName,
        shiftName,
        fleetNumber,
        licensePlate,
        userName,
        sesionType,
        sessionStatus,
        deviceId,
        depositAmount,
        totalSales,
        arPayment,
        totalAmountDue,
        balanceBroughtForward,
        balanceAmount,
        balanceText,
        cashTransfer,
        creditSales
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ClockInData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.clockInDaySessionId == this.clockInDaySessionId &&
          other.clockOutDaySessionId == this.clockOutDaySessionId &&
          other.inventoryCycleId == this.inventoryCycleId &&
          other.fullName == this.fullName &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.warehouseName == this.warehouseName &&
          other.shiftName == this.shiftName &&
          other.fleetNumber == this.fleetNumber &&
          other.licensePlate == this.licensePlate &&
          other.userName == this.userName &&
          other.sesionType == this.sesionType &&
          other.sessionStatus == this.sessionStatus &&
          other.deviceId == this.deviceId &&
          other.depositAmount == this.depositAmount &&
          other.totalSales == this.totalSales &&
          other.arPayment == this.arPayment &&
          other.totalAmountDue == this.totalAmountDue &&
          other.balanceBroughtForward == this.balanceBroughtForward &&
          other.balanceAmount == this.balanceAmount &&
          other.balanceText == this.balanceText &&
          other.cashTransfer == this.cashTransfer &&
          other.creditSales == this.creditSales);
}

class ClockInCompanion extends UpdateCompanion<ClockInData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> clockInDaySessionId;
  final Value<String?> clockOutDaySessionId;
  final Value<String?> inventoryCycleId;
  final Value<String?> fullName;
  final Value<DateTime?> startDate;
  final Value<DateTime?> endDate;
  final Value<DateTime?> warehouseName;
  final Value<String?> shiftName;
  final Value<String?> fleetNumber;
  final Value<String?> licensePlate;
  final Value<String?> userName;
  final Value<String?> sesionType;
  final Value<String?> sessionStatus;
  final Value<String?> deviceId;
  final Value<double?> depositAmount;
  final Value<double?> totalSales;
  final Value<double?> arPayment;
  final Value<double?> totalAmountDue;
  final Value<double?> balanceBroughtForward;
  final Value<double?> balanceAmount;
  final Value<String?> balanceText;
  final Value<double?> cashTransfer;
  final Value<double?> creditSales;
  const ClockInCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.clockInDaySessionId = const Value.absent(),
    this.clockOutDaySessionId = const Value.absent(),
    this.inventoryCycleId = const Value.absent(),
    this.fullName = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.warehouseName = const Value.absent(),
    this.shiftName = const Value.absent(),
    this.fleetNumber = const Value.absent(),
    this.licensePlate = const Value.absent(),
    this.userName = const Value.absent(),
    this.sesionType = const Value.absent(),
    this.sessionStatus = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.depositAmount = const Value.absent(),
    this.totalSales = const Value.absent(),
    this.arPayment = const Value.absent(),
    this.totalAmountDue = const Value.absent(),
    this.balanceBroughtForward = const Value.absent(),
    this.balanceAmount = const Value.absent(),
    this.balanceText = const Value.absent(),
    this.cashTransfer = const Value.absent(),
    this.creditSales = const Value.absent(),
  });
  ClockInCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.clockInDaySessionId = const Value.absent(),
    this.clockOutDaySessionId = const Value.absent(),
    this.inventoryCycleId = const Value.absent(),
    this.fullName = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.warehouseName = const Value.absent(),
    this.shiftName = const Value.absent(),
    this.fleetNumber = const Value.absent(),
    this.licensePlate = const Value.absent(),
    this.userName = const Value.absent(),
    this.sesionType = const Value.absent(),
    this.sessionStatus = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.depositAmount = const Value.absent(),
    this.totalSales = const Value.absent(),
    this.arPayment = const Value.absent(),
    this.totalAmountDue = const Value.absent(),
    this.balanceBroughtForward = const Value.absent(),
    this.balanceAmount = const Value.absent(),
    this.balanceText = const Value.absent(),
    this.cashTransfer = const Value.absent(),
    this.creditSales = const Value.absent(),
  });
  static Insertable<ClockInData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? clockInDaySessionId,
    Expression<String>? clockOutDaySessionId,
    Expression<String>? inventoryCycleId,
    Expression<String>? fullName,
    Expression<DateTime>? startDate,
    Expression<DateTime>? endDate,
    Expression<DateTime>? warehouseName,
    Expression<String>? shiftName,
    Expression<String>? fleetNumber,
    Expression<String>? licensePlate,
    Expression<String>? userName,
    Expression<String>? sesionType,
    Expression<String>? sessionStatus,
    Expression<String>? deviceId,
    Expression<double>? depositAmount,
    Expression<double>? totalSales,
    Expression<double>? arPayment,
    Expression<double>? totalAmountDue,
    Expression<double>? balanceBroughtForward,
    Expression<double>? balanceAmount,
    Expression<String>? balanceText,
    Expression<double>? cashTransfer,
    Expression<double>? creditSales,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (clockInDaySessionId != null)
        'clock_in_day_session_id': clockInDaySessionId,
      if (clockOutDaySessionId != null)
        'clock_out_day_session_id': clockOutDaySessionId,
      if (inventoryCycleId != null) 'inventory_cycle_id': inventoryCycleId,
      if (fullName != null) 'full_name': fullName,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (warehouseName != null) 'warehouse_name': warehouseName,
      if (shiftName != null) 'shift_name': shiftName,
      if (fleetNumber != null) 'fleet_number': fleetNumber,
      if (licensePlate != null) 'license_plate': licensePlate,
      if (userName != null) 'user_name': userName,
      if (sesionType != null) 'sesion_type': sesionType,
      if (sessionStatus != null) 'session_status': sessionStatus,
      if (deviceId != null) 'device_id': deviceId,
      if (depositAmount != null) 'deposit_amount': depositAmount,
      if (totalSales != null) 'total_sales': totalSales,
      if (arPayment != null) 'ar_payment': arPayment,
      if (totalAmountDue != null) 'total_amount_due': totalAmountDue,
      if (balanceBroughtForward != null)
        'balance_brought_forward': balanceBroughtForward,
      if (balanceAmount != null) 'balance_amount': balanceAmount,
      if (balanceText != null) 'balance_text': balanceText,
      if (cashTransfer != null) 'cash_transfer': cashTransfer,
      if (creditSales != null) 'credit_sales': creditSales,
    });
  }

  ClockInCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? clockInDaySessionId,
      Value<String?>? clockOutDaySessionId,
      Value<String?>? inventoryCycleId,
      Value<String?>? fullName,
      Value<DateTime?>? startDate,
      Value<DateTime?>? endDate,
      Value<DateTime?>? warehouseName,
      Value<String?>? shiftName,
      Value<String?>? fleetNumber,
      Value<String?>? licensePlate,
      Value<String?>? userName,
      Value<String?>? sesionType,
      Value<String?>? sessionStatus,
      Value<String?>? deviceId,
      Value<double?>? depositAmount,
      Value<double?>? totalSales,
      Value<double?>? arPayment,
      Value<double?>? totalAmountDue,
      Value<double?>? balanceBroughtForward,
      Value<double?>? balanceAmount,
      Value<String?>? balanceText,
      Value<double?>? cashTransfer,
      Value<double?>? creditSales}) {
    return ClockInCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      clockInDaySessionId: clockInDaySessionId ?? this.clockInDaySessionId,
      clockOutDaySessionId: clockOutDaySessionId ?? this.clockOutDaySessionId,
      inventoryCycleId: inventoryCycleId ?? this.inventoryCycleId,
      fullName: fullName ?? this.fullName,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      warehouseName: warehouseName ?? this.warehouseName,
      shiftName: shiftName ?? this.shiftName,
      fleetNumber: fleetNumber ?? this.fleetNumber,
      licensePlate: licensePlate ?? this.licensePlate,
      userName: userName ?? this.userName,
      sesionType: sesionType ?? this.sesionType,
      sessionStatus: sessionStatus ?? this.sessionStatus,
      deviceId: deviceId ?? this.deviceId,
      depositAmount: depositAmount ?? this.depositAmount,
      totalSales: totalSales ?? this.totalSales,
      arPayment: arPayment ?? this.arPayment,
      totalAmountDue: totalAmountDue ?? this.totalAmountDue,
      balanceBroughtForward:
          balanceBroughtForward ?? this.balanceBroughtForward,
      balanceAmount: balanceAmount ?? this.balanceAmount,
      balanceText: balanceText ?? this.balanceText,
      cashTransfer: cashTransfer ?? this.cashTransfer,
      creditSales: creditSales ?? this.creditSales,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (clockInDaySessionId.present) {
      map['clock_in_day_session_id'] =
          Variable<String>(clockInDaySessionId.value);
    }
    if (clockOutDaySessionId.present) {
      map['clock_out_day_session_id'] =
          Variable<String>(clockOutDaySessionId.value);
    }
    if (inventoryCycleId.present) {
      map['inventory_cycle_id'] = Variable<String>(inventoryCycleId.value);
    }
    if (fullName.present) {
      map['full_name'] = Variable<String>(fullName.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<DateTime>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<DateTime>(endDate.value);
    }
    if (warehouseName.present) {
      map['warehouse_name'] = Variable<DateTime>(warehouseName.value);
    }
    if (shiftName.present) {
      map['shift_name'] = Variable<String>(shiftName.value);
    }
    if (fleetNumber.present) {
      map['fleet_number'] = Variable<String>(fleetNumber.value);
    }
    if (licensePlate.present) {
      map['license_plate'] = Variable<String>(licensePlate.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (sesionType.present) {
      map['sesion_type'] = Variable<String>(sesionType.value);
    }
    if (sessionStatus.present) {
      map['session_status'] = Variable<String>(sessionStatus.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (depositAmount.present) {
      map['deposit_amount'] = Variable<double>(depositAmount.value);
    }
    if (totalSales.present) {
      map['total_sales'] = Variable<double>(totalSales.value);
    }
    if (arPayment.present) {
      map['ar_payment'] = Variable<double>(arPayment.value);
    }
    if (totalAmountDue.present) {
      map['total_amount_due'] = Variable<double>(totalAmountDue.value);
    }
    if (balanceBroughtForward.present) {
      map['balance_brought_forward'] =
          Variable<double>(balanceBroughtForward.value);
    }
    if (balanceAmount.present) {
      map['balance_amount'] = Variable<double>(balanceAmount.value);
    }
    if (balanceText.present) {
      map['balance_text'] = Variable<String>(balanceText.value);
    }
    if (cashTransfer.present) {
      map['cash_transfer'] = Variable<double>(cashTransfer.value);
    }
    if (creditSales.present) {
      map['credit_sales'] = Variable<double>(creditSales.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ClockInCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('clockInDaySessionId: $clockInDaySessionId, ')
          ..write('clockOutDaySessionId: $clockOutDaySessionId, ')
          ..write('inventoryCycleId: $inventoryCycleId, ')
          ..write('fullName: $fullName, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('warehouseName: $warehouseName, ')
          ..write('shiftName: $shiftName, ')
          ..write('fleetNumber: $fleetNumber, ')
          ..write('licensePlate: $licensePlate, ')
          ..write('userName: $userName, ')
          ..write('sesionType: $sesionType, ')
          ..write('sessionStatus: $sessionStatus, ')
          ..write('deviceId: $deviceId, ')
          ..write('depositAmount: $depositAmount, ')
          ..write('totalSales: $totalSales, ')
          ..write('arPayment: $arPayment, ')
          ..write('totalAmountDue: $totalAmountDue, ')
          ..write('balanceBroughtForward: $balanceBroughtForward, ')
          ..write('balanceAmount: $balanceAmount, ')
          ..write('balanceText: $balanceText, ')
          ..write('cashTransfer: $cashTransfer, ')
          ..write('creditSales: $creditSales')
          ..write(')'))
        .toString();
  }
}

class $SystemCurrencyTable extends SystemCurrency
    with TableInfo<$SystemCurrencyTable, SystemCurrencyData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SystemCurrencyTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _currencyNameMeta =
      const VerificationMeta('currencyName');
  @override
  late final GeneratedColumn<String> currencyName = GeneratedColumn<String>(
      'currency_name', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fractionMeta =
      const VerificationMeta('fraction');
  @override
  late final GeneratedColumn<String> fraction = GeneratedColumn<String>(
      'fraction', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _numberFormatMeta =
      const VerificationMeta('numberFormat');
  @override
  late final GeneratedColumn<String> numberFormat = GeneratedColumn<String>(
      'number_format', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _symbolMeta = const VerificationMeta('symbol');
  @override
  late final GeneratedColumn<String> symbol = GeneratedColumn<String>(
      'symbol', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _smallestCurrencyFractionValueMeta =
      const VerificationMeta('smallestCurrencyFractionValue');
  @override
  late final GeneratedColumn<double> smallestCurrencyFractionValue =
      GeneratedColumn<double>(
          'smallest_currency_fraction_value', aliasedName, true,
          type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _effectiveDateMeta =
      const VerificationMeta('effectiveDate');
  @override
  late final GeneratedColumn<DateTime> effectiveDate =
      GeneratedColumn<DateTime>('effective_date', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        currencyName,
        fraction,
        numberFormat,
        symbol,
        smallestCurrencyFractionValue,
        effectiveDate,
        isActive,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'system_currency';
  @override
  VerificationContext validateIntegrity(Insertable<SystemCurrencyData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('currency_name')) {
      context.handle(
          _currencyNameMeta,
          currencyName.isAcceptableOrUnknown(
              data['currency_name']!, _currencyNameMeta));
    }
    if (data.containsKey('fraction')) {
      context.handle(_fractionMeta,
          fraction.isAcceptableOrUnknown(data['fraction']!, _fractionMeta));
    }
    if (data.containsKey('number_format')) {
      context.handle(
          _numberFormatMeta,
          numberFormat.isAcceptableOrUnknown(
              data['number_format']!, _numberFormatMeta));
    }
    if (data.containsKey('symbol')) {
      context.handle(_symbolMeta,
          symbol.isAcceptableOrUnknown(data['symbol']!, _symbolMeta));
    }
    if (data.containsKey('smallest_currency_fraction_value')) {
      context.handle(
          _smallestCurrencyFractionValueMeta,
          smallestCurrencyFractionValue.isAcceptableOrUnknown(
              data['smallest_currency_fraction_value']!,
              _smallestCurrencyFractionValueMeta));
    }
    if (data.containsKey('effective_date')) {
      context.handle(
          _effectiveDateMeta,
          effectiveDate.isAcceptableOrUnknown(
              data['effective_date']!, _effectiveDateMeta));
    } else if (isInserting) {
      context.missing(_effectiveDateMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SystemCurrencyData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SystemCurrencyData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      currencyName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}currency_name']),
      fraction: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}fraction']),
      numberFormat: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}number_format']),
      symbol: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}symbol']),
      smallestCurrencyFractionValue: attachedDatabase.typeMapping.read(
          DriftSqlType.double,
          data['${effectivePrefix}smallest_currency_fraction_value']),
      effectiveDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}effective_date'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $SystemCurrencyTable createAlias(String alias) {
    return $SystemCurrencyTable(attachedDatabase, alias);
  }
}

class SystemCurrencyData extends DataClass
    implements Insertable<SystemCurrencyData> {
  final String? tenantId;
  final int id;
  final String? currencyName;
  final String? fraction;
  final String? numberFormat;
  final String? symbol;
  final double? smallestCurrencyFractionValue;
  final DateTime effectiveDate;
  final bool isActive;
  final bool isDeleted;
  const SystemCurrencyData(
      {this.tenantId,
      required this.id,
      this.currencyName,
      this.fraction,
      this.numberFormat,
      this.symbol,
      this.smallestCurrencyFractionValue,
      required this.effectiveDate,
      required this.isActive,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || currencyName != null) {
      map['currency_name'] = Variable<String>(currencyName);
    }
    if (!nullToAbsent || fraction != null) {
      map['fraction'] = Variable<String>(fraction);
    }
    if (!nullToAbsent || numberFormat != null) {
      map['number_format'] = Variable<String>(numberFormat);
    }
    if (!nullToAbsent || symbol != null) {
      map['symbol'] = Variable<String>(symbol);
    }
    if (!nullToAbsent || smallestCurrencyFractionValue != null) {
      map['smallest_currency_fraction_value'] =
          Variable<double>(smallestCurrencyFractionValue);
    }
    map['effective_date'] = Variable<DateTime>(effectiveDate);
    map['is_active'] = Variable<bool>(isActive);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  SystemCurrencyCompanion toCompanion(bool nullToAbsent) {
    return SystemCurrencyCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      currencyName: currencyName == null && nullToAbsent
          ? const Value.absent()
          : Value(currencyName),
      fraction: fraction == null && nullToAbsent
          ? const Value.absent()
          : Value(fraction),
      numberFormat: numberFormat == null && nullToAbsent
          ? const Value.absent()
          : Value(numberFormat),
      symbol:
          symbol == null && nullToAbsent ? const Value.absent() : Value(symbol),
      smallestCurrencyFractionValue:
          smallestCurrencyFractionValue == null && nullToAbsent
              ? const Value.absent()
              : Value(smallestCurrencyFractionValue),
      effectiveDate: Value(effectiveDate),
      isActive: Value(isActive),
      isDeleted: Value(isDeleted),
    );
  }

  factory SystemCurrencyData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SystemCurrencyData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      currencyName: serializer.fromJson<String?>(json['currencyName']),
      fraction: serializer.fromJson<String?>(json['fraction']),
      numberFormat: serializer.fromJson<String?>(json['numberFormat']),
      symbol: serializer.fromJson<String?>(json['symbol']),
      smallestCurrencyFractionValue:
          serializer.fromJson<double?>(json['smallestCurrencyFractionValue']),
      effectiveDate: serializer.fromJson<DateTime>(json['effectiveDate']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'currencyName': serializer.toJson<String?>(currencyName),
      'fraction': serializer.toJson<String?>(fraction),
      'numberFormat': serializer.toJson<String?>(numberFormat),
      'symbol': serializer.toJson<String?>(symbol),
      'smallestCurrencyFractionValue':
          serializer.toJson<double?>(smallestCurrencyFractionValue),
      'effectiveDate': serializer.toJson<DateTime>(effectiveDate),
      'isActive': serializer.toJson<bool>(isActive),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  SystemCurrencyData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> currencyName = const Value.absent(),
          Value<String?> fraction = const Value.absent(),
          Value<String?> numberFormat = const Value.absent(),
          Value<String?> symbol = const Value.absent(),
          Value<double?> smallestCurrencyFractionValue = const Value.absent(),
          DateTime? effectiveDate,
          bool? isActive,
          bool? isDeleted}) =>
      SystemCurrencyData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        currencyName:
            currencyName.present ? currencyName.value : this.currencyName,
        fraction: fraction.present ? fraction.value : this.fraction,
        numberFormat:
            numberFormat.present ? numberFormat.value : this.numberFormat,
        symbol: symbol.present ? symbol.value : this.symbol,
        smallestCurrencyFractionValue: smallestCurrencyFractionValue.present
            ? smallestCurrencyFractionValue.value
            : this.smallestCurrencyFractionValue,
        effectiveDate: effectiveDate ?? this.effectiveDate,
        isActive: isActive ?? this.isActive,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  @override
  String toString() {
    return (StringBuffer('SystemCurrencyData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('currencyName: $currencyName, ')
          ..write('fraction: $fraction, ')
          ..write('numberFormat: $numberFormat, ')
          ..write('symbol: $symbol, ')
          ..write(
              'smallestCurrencyFractionValue: $smallestCurrencyFractionValue, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      currencyName,
      fraction,
      numberFormat,
      symbol,
      smallestCurrencyFractionValue,
      effectiveDate,
      isActive,
      isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SystemCurrencyData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.currencyName == this.currencyName &&
          other.fraction == this.fraction &&
          other.numberFormat == this.numberFormat &&
          other.symbol == this.symbol &&
          other.smallestCurrencyFractionValue ==
              this.smallestCurrencyFractionValue &&
          other.effectiveDate == this.effectiveDate &&
          other.isActive == this.isActive &&
          other.isDeleted == this.isDeleted);
}

class SystemCurrencyCompanion extends UpdateCompanion<SystemCurrencyData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> currencyName;
  final Value<String?> fraction;
  final Value<String?> numberFormat;
  final Value<String?> symbol;
  final Value<double?> smallestCurrencyFractionValue;
  final Value<DateTime> effectiveDate;
  final Value<bool> isActive;
  final Value<bool> isDeleted;
  const SystemCurrencyCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.currencyName = const Value.absent(),
    this.fraction = const Value.absent(),
    this.numberFormat = const Value.absent(),
    this.symbol = const Value.absent(),
    this.smallestCurrencyFractionValue = const Value.absent(),
    this.effectiveDate = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  SystemCurrencyCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.currencyName = const Value.absent(),
    this.fraction = const Value.absent(),
    this.numberFormat = const Value.absent(),
    this.symbol = const Value.absent(),
    this.smallestCurrencyFractionValue = const Value.absent(),
    required DateTime effectiveDate,
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
  }) : effectiveDate = Value(effectiveDate);
  static Insertable<SystemCurrencyData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? currencyName,
    Expression<String>? fraction,
    Expression<String>? numberFormat,
    Expression<String>? symbol,
    Expression<double>? smallestCurrencyFractionValue,
    Expression<DateTime>? effectiveDate,
    Expression<bool>? isActive,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (currencyName != null) 'currency_name': currencyName,
      if (fraction != null) 'fraction': fraction,
      if (numberFormat != null) 'number_format': numberFormat,
      if (symbol != null) 'symbol': symbol,
      if (smallestCurrencyFractionValue != null)
        'smallest_currency_fraction_value': smallestCurrencyFractionValue,
      if (effectiveDate != null) 'effective_date': effectiveDate,
      if (isActive != null) 'is_active': isActive,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  SystemCurrencyCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? currencyName,
      Value<String?>? fraction,
      Value<String?>? numberFormat,
      Value<String?>? symbol,
      Value<double?>? smallestCurrencyFractionValue,
      Value<DateTime>? effectiveDate,
      Value<bool>? isActive,
      Value<bool>? isDeleted}) {
    return SystemCurrencyCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      currencyName: currencyName ?? this.currencyName,
      fraction: fraction ?? this.fraction,
      numberFormat: numberFormat ?? this.numberFormat,
      symbol: symbol ?? this.symbol,
      smallestCurrencyFractionValue:
          smallestCurrencyFractionValue ?? this.smallestCurrencyFractionValue,
      effectiveDate: effectiveDate ?? this.effectiveDate,
      isActive: isActive ?? this.isActive,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (currencyName.present) {
      map['currency_name'] = Variable<String>(currencyName.value);
    }
    if (fraction.present) {
      map['fraction'] = Variable<String>(fraction.value);
    }
    if (numberFormat.present) {
      map['number_format'] = Variable<String>(numberFormat.value);
    }
    if (symbol.present) {
      map['symbol'] = Variable<String>(symbol.value);
    }
    if (smallestCurrencyFractionValue.present) {
      map['smallest_currency_fraction_value'] =
          Variable<double>(smallestCurrencyFractionValue.value);
    }
    if (effectiveDate.present) {
      map['effective_date'] = Variable<DateTime>(effectiveDate.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SystemCurrencyCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('currencyName: $currencyName, ')
          ..write('fraction: $fraction, ')
          ..write('numberFormat: $numberFormat, ')
          ..write('symbol: $symbol, ')
          ..write(
              'smallestCurrencyFractionValue: $smallestCurrencyFractionValue, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $ExchangeRateTable extends ExchangeRate
    with TableInfo<$ExchangeRateTable, ExchangeRateData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ExchangeRateTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _tenantIdMeta =
      const VerificationMeta('tenantId');
  @override
  late final GeneratedColumn<String> tenantId = GeneratedColumn<String>(
      'tenant_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _toCurrencyMeta =
      const VerificationMeta('toCurrency');
  @override
  late final GeneratedColumn<String> toCurrency = GeneratedColumn<String>(
      'to_currency', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _fromCurrencyMeta =
      const VerificationMeta('fromCurrency');
  @override
  late final GeneratedColumn<String> fromCurrency = GeneratedColumn<String>(
      'from_currency', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  @override
  late final GeneratedColumn<double> exchangeRate = GeneratedColumn<double>(
      'exchange_rate', aliasedName, true,
      type: DriftSqlType.double, requiredDuringInsert: false);
  static const VerificationMeta _effectiveDateMeta =
      const VerificationMeta('effectiveDate');
  @override
  late final GeneratedColumn<DateTime> effectiveDate =
      GeneratedColumn<DateTime>('effective_date', aliasedName, false,
          type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_active" IN (0, 1))'),
      defaultValue: Constant(false));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        toCurrency,
        fromCurrency,
        exchangeRate,
        effectiveDate,
        isActive,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'exchange_rate';
  @override
  VerificationContext validateIntegrity(Insertable<ExchangeRateData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id']!, _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('to_currency')) {
      context.handle(
          _toCurrencyMeta,
          toCurrency.isAcceptableOrUnknown(
              data['to_currency']!, _toCurrencyMeta));
    }
    if (data.containsKey('from_currency')) {
      context.handle(
          _fromCurrencyMeta,
          fromCurrency.isAcceptableOrUnknown(
              data['from_currency']!, _fromCurrencyMeta));
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate']!, _exchangeRateMeta));
    }
    if (data.containsKey('effective_date')) {
      context.handle(
          _effectiveDateMeta,
          effectiveDate.isAcceptableOrUnknown(
              data['effective_date']!, _effectiveDateMeta));
    } else if (isInserting) {
      context.missing(_effectiveDateMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ExchangeRateData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ExchangeRateData(
      tenantId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tenant_id']),
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      toCurrency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}to_currency']),
      fromCurrency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}from_currency']),
      exchangeRate: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}exchange_rate']),
      effectiveDate: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}effective_date'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
    );
  }

  @override
  $ExchangeRateTable createAlias(String alias) {
    return $ExchangeRateTable(attachedDatabase, alias);
  }
}

class ExchangeRateData extends DataClass
    implements Insertable<ExchangeRateData> {
  final String? tenantId;
  final int id;
  final String? toCurrency;
  final String? fromCurrency;
  final double? exchangeRate;
  final DateTime effectiveDate;
  final bool isActive;
  final bool isDeleted;
  const ExchangeRateData(
      {this.tenantId,
      required this.id,
      this.toCurrency,
      this.fromCurrency,
      this.exchangeRate,
      required this.effectiveDate,
      required this.isActive,
      required this.isDeleted});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<String>(tenantId);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || toCurrency != null) {
      map['to_currency'] = Variable<String>(toCurrency);
    }
    if (!nullToAbsent || fromCurrency != null) {
      map['from_currency'] = Variable<String>(fromCurrency);
    }
    if (!nullToAbsent || exchangeRate != null) {
      map['exchange_rate'] = Variable<double>(exchangeRate);
    }
    map['effective_date'] = Variable<DateTime>(effectiveDate);
    map['is_active'] = Variable<bool>(isActive);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  ExchangeRateCompanion toCompanion(bool nullToAbsent) {
    return ExchangeRateCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: Value(id),
      toCurrency: toCurrency == null && nullToAbsent
          ? const Value.absent()
          : Value(toCurrency),
      fromCurrency: fromCurrency == null && nullToAbsent
          ? const Value.absent()
          : Value(fromCurrency),
      exchangeRate: exchangeRate == null && nullToAbsent
          ? const Value.absent()
          : Value(exchangeRate),
      effectiveDate: Value(effectiveDate),
      isActive: Value(isActive),
      isDeleted: Value(isDeleted),
    );
  }

  factory ExchangeRateData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ExchangeRateData(
      tenantId: serializer.fromJson<String?>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      toCurrency: serializer.fromJson<String?>(json['toCurrency']),
      fromCurrency: serializer.fromJson<String?>(json['fromCurrency']),
      exchangeRate: serializer.fromJson<double?>(json['exchangeRate']),
      effectiveDate: serializer.fromJson<DateTime>(json['effectiveDate']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<String?>(tenantId),
      'id': serializer.toJson<int>(id),
      'toCurrency': serializer.toJson<String?>(toCurrency),
      'fromCurrency': serializer.toJson<String?>(fromCurrency),
      'exchangeRate': serializer.toJson<double?>(exchangeRate),
      'effectiveDate': serializer.toJson<DateTime>(effectiveDate),
      'isActive': serializer.toJson<bool>(isActive),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  ExchangeRateData copyWith(
          {Value<String?> tenantId = const Value.absent(),
          int? id,
          Value<String?> toCurrency = const Value.absent(),
          Value<String?> fromCurrency = const Value.absent(),
          Value<double?> exchangeRate = const Value.absent(),
          DateTime? effectiveDate,
          bool? isActive,
          bool? isDeleted}) =>
      ExchangeRateData(
        tenantId: tenantId.present ? tenantId.value : this.tenantId,
        id: id ?? this.id,
        toCurrency: toCurrency.present ? toCurrency.value : this.toCurrency,
        fromCurrency:
            fromCurrency.present ? fromCurrency.value : this.fromCurrency,
        exchangeRate:
            exchangeRate.present ? exchangeRate.value : this.exchangeRate,
        effectiveDate: effectiveDate ?? this.effectiveDate,
        isActive: isActive ?? this.isActive,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  @override
  String toString() {
    return (StringBuffer('ExchangeRateData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('toCurrency: $toCurrency, ')
          ..write('fromCurrency: $fromCurrency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, toCurrency, fromCurrency,
      exchangeRate, effectiveDate, isActive, isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ExchangeRateData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.toCurrency == this.toCurrency &&
          other.fromCurrency == this.fromCurrency &&
          other.exchangeRate == this.exchangeRate &&
          other.effectiveDate == this.effectiveDate &&
          other.isActive == this.isActive &&
          other.isDeleted == this.isDeleted);
}

class ExchangeRateCompanion extends UpdateCompanion<ExchangeRateData> {
  final Value<String?> tenantId;
  final Value<int> id;
  final Value<String?> toCurrency;
  final Value<String?> fromCurrency;
  final Value<double?> exchangeRate;
  final Value<DateTime> effectiveDate;
  final Value<bool> isActive;
  final Value<bool> isDeleted;
  const ExchangeRateCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.toCurrency = const Value.absent(),
    this.fromCurrency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.effectiveDate = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  ExchangeRateCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.toCurrency = const Value.absent(),
    this.fromCurrency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    required DateTime effectiveDate,
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
  }) : effectiveDate = Value(effectiveDate);
  static Insertable<ExchangeRateData> custom({
    Expression<String>? tenantId,
    Expression<int>? id,
    Expression<String>? toCurrency,
    Expression<String>? fromCurrency,
    Expression<double>? exchangeRate,
    Expression<DateTime>? effectiveDate,
    Expression<bool>? isActive,
    Expression<bool>? isDeleted,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (toCurrency != null) 'to_currency': toCurrency,
      if (fromCurrency != null) 'from_currency': fromCurrency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (effectiveDate != null) 'effective_date': effectiveDate,
      if (isActive != null) 'is_active': isActive,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  ExchangeRateCompanion copyWith(
      {Value<String?>? tenantId,
      Value<int>? id,
      Value<String?>? toCurrency,
      Value<String?>? fromCurrency,
      Value<double?>? exchangeRate,
      Value<DateTime>? effectiveDate,
      Value<bool>? isActive,
      Value<bool>? isDeleted}) {
    return ExchangeRateCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      toCurrency: toCurrency ?? this.toCurrency,
      fromCurrency: fromCurrency ?? this.fromCurrency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      effectiveDate: effectiveDate ?? this.effectiveDate,
      isActive: isActive ?? this.isActive,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<String>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (toCurrency.present) {
      map['to_currency'] = Variable<String>(toCurrency.value);
    }
    if (fromCurrency.present) {
      map['from_currency'] = Variable<String>(fromCurrency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (effectiveDate.present) {
      map['effective_date'] = Variable<DateTime>(effectiveDate.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ExchangeRateCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('toCurrency: $toCurrency, ')
          ..write('fromCurrency: $fromCurrency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

abstract class _$MyDatabase extends GeneratedDatabase {
  _$MyDatabase(QueryExecutor e) : super(e);
  late final $UsersTable users = $UsersTable(this);
  late final $CommunicationTable communication = $CommunicationTable(this);
  late final $BackgroundJobScheduleTable backgroundJobSchedule =
      $BackgroundJobScheduleTable(this);
  late final $BackgroundJobLogsTable backgroundJobLogs =
      $BackgroundJobLogsTable(this);
  late final $PreferenceTable preference = $PreferenceTable(this);
  late final $MobileDeviceTable mobileDevice = $MobileDeviceTable(this);
  late final $BusinessRuleTable businessRule = $BusinessRuleTable(this);
  late final $NonGlobalBusinessRuleTable nonGlobalBusinessRule =
      $NonGlobalBusinessRuleTable(this);
  late final $ApplicationLoggerTable applicationLogger =
      $ApplicationLoggerTable(this);
  late final $TenantTable tenant = $TenantTable(this);
  late final $NonGlobalPreferenceTable nonGlobalPreference =
      $NonGlobalPreferenceTable(this);
  late final $DesktopTable desktop = $DesktopTable(this);
  late final $SalesOrderHeaderTable salesOrderHeader =
      $SalesOrderHeaderTable(this);
  late final $SalesOrderDetailTable salesOrderDetail =
      $SalesOrderDetailTable(this);
  late final $SalesOrderDetailTempTable salesOrderDetailTemp =
      $SalesOrderDetailTempTable(this);
  late final $SeriesNumberGeneratorTable seriesNumberGenerator =
      $SeriesNumberGeneratorTable(this);
  late final $SalesTaxTable salesTax = $SalesTaxTable(this);
  late final $TempNumberLogsTable tempNumberLogs = $TempNumberLogsTable(this);
  late final $CustomerTable customer = $CustomerTable(this);
  late final $AddresTable addres = $AddresTable(this);
  late final $ContactTable contact = $ContactTable(this);
  late final $ItemsTable items = $ItemsTable(this);
  late final $ItemsPricesTable itemsPrices = $ItemsPricesTable(this);
  late final $ItemPricingRuleTable itemPricingRule =
      $ItemPricingRuleTable(this);
  late final $CategoresTable categores = $CategoresTable(this);
  late final $ItemGroupsTable itemGroups = $ItemGroupsTable(this);
  late final $PriceListTable priceList = $PriceListTable(this);
  late final $UnitOfMeasureTable unitOfMeasure = $UnitOfMeasureTable(this);
  late final $StockUnitOfMeasureTable stockUnitOfMeasure =
      $StockUnitOfMeasureTable(this);
  late final $JourneyPlanTable journeyPlan = $JourneyPlanTable(this);
  late final $UPCCodeTable uPCCode = $UPCCodeTable(this);
  late final $InventoryItemsTable inventoryItems = $InventoryItemsTable(this);
  late final $InventoryTransactionTable inventoryTransaction =
      $InventoryTransactionTable(this);
  late final $MoneyDepositTable moneyDeposit = $MoneyDepositTable(this);
  late final $ClockInTable clockIn = $ClockInTable(this);
  late final $SystemCurrencyTable systemCurrency = $SystemCurrencyTable(this);
  late final $ExchangeRateTable exchangeRate = $ExchangeRateTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        users,
        communication,
        backgroundJobSchedule,
        backgroundJobLogs,
        preference,
        mobileDevice,
        businessRule,
        nonGlobalBusinessRule,
        applicationLogger,
        tenant,
        nonGlobalPreference,
        desktop,
        salesOrderHeader,
        salesOrderDetail,
        salesOrderDetailTemp,
        seriesNumberGenerator,
        salesTax,
        tempNumberLogs,
        customer,
        addres,
        contact,
        items,
        itemsPrices,
        itemPricingRule,
        categores,
        itemGroups,
        priceList,
        unitOfMeasure,
        stockUnitOfMeasure,
        journeyPlan,
        uPCCode,
        inventoryItems,
        inventoryTransaction,
        moneyDeposit,
        clockIn,
        systemCurrency,
        exchangeRate
      ];
}
