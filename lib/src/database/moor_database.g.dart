// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'moor_database.dart';

// **************************************************************************
// MoorGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps, unnecessary_this
class User extends DataClass implements Insertable<User> {
  final int tenantId;
  final int id;
  final String userName;
  final String name;
  final String surname;
  final String emailAddress;
  final bool isActive;
  final String fullName;
  final String mobileHash;
  final bool enableOfflineLogin;
  final String firebaseToken;
  final DateTime creationTime;
  final DateTime lastLoginTime;
  final String currency;
  final String themeData;
  User(
      {this.tenantId,
      @required this.id,
      @required this.userName,
      @required this.name,
      @required this.surname,
      @required this.emailAddress,
      @required this.isActive,
      @required this.fullName,
      this.mobileHash,
      @required this.enableOfflineLogin,
      this.firebaseToken,
      this.creationTime,
      this.lastLoginTime,
      this.currency,
      this.themeData});
  factory User.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return User(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      name: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}name']),
      surname: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}surname']),
      emailAddress: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}email_address']),
      isActive: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_active']),
      fullName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}full_name']),
      mobileHash: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}mobile_hash']),
      enableOfflineLogin: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}enable_offline_login']),
      firebaseToken: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}firebase_token']),
      creationTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}creation_time']),
      lastLoginTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}last_login_time']),
      currency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}currency']),
      themeData: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}theme_data']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || name != null) {
      map['name'] = Variable<String>(name);
    }
    if (!nullToAbsent || surname != null) {
      map['surname'] = Variable<String>(surname);
    }
    if (!nullToAbsent || emailAddress != null) {
      map['email_address'] = Variable<String>(emailAddress);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || fullName != null) {
      map['full_name'] = Variable<String>(fullName);
    }
    if (!nullToAbsent || mobileHash != null) {
      map['mobile_hash'] = Variable<String>(mobileHash);
    }
    if (!nullToAbsent || enableOfflineLogin != null) {
      map['enable_offline_login'] = Variable<bool>(enableOfflineLogin);
    }
    if (!nullToAbsent || firebaseToken != null) {
      map['firebase_token'] = Variable<String>(firebaseToken);
    }
    if (!nullToAbsent || creationTime != null) {
      map['creation_time'] = Variable<DateTime>(creationTime);
    }
    if (!nullToAbsent || lastLoginTime != null) {
      map['last_login_time'] = Variable<DateTime>(lastLoginTime);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    if (!nullToAbsent || themeData != null) {
      map['theme_data'] = Variable<String>(themeData);
    }
    return map;
  }

  UsersCompanion toCompanion(bool nullToAbsent) {
    return UsersCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      name: name == null && nullToAbsent ? const Value.absent() : Value(name),
      surname: surname == null && nullToAbsent
          ? const Value.absent()
          : Value(surname),
      emailAddress: emailAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(emailAddress),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      fullName: fullName == null && nullToAbsent
          ? const Value.absent()
          : Value(fullName),
      mobileHash: mobileHash == null && nullToAbsent
          ? const Value.absent()
          : Value(mobileHash),
      enableOfflineLogin: enableOfflineLogin == null && nullToAbsent
          ? const Value.absent()
          : Value(enableOfflineLogin),
      firebaseToken: firebaseToken == null && nullToAbsent
          ? const Value.absent()
          : Value(firebaseToken),
      creationTime: creationTime == null && nullToAbsent
          ? const Value.absent()
          : Value(creationTime),
      lastLoginTime: lastLoginTime == null && nullToAbsent
          ? const Value.absent()
          : Value(lastLoginTime),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      themeData: themeData == null && nullToAbsent
          ? const Value.absent()
          : Value(themeData),
    );
  }

  factory User.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return User(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      userName: serializer.fromJson<String>(json['userName']),
      name: serializer.fromJson<String>(json['name']),
      surname: serializer.fromJson<String>(json['surname']),
      emailAddress: serializer.fromJson<String>(json['emailAddress']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      fullName: serializer.fromJson<String>(json['fullName']),
      mobileHash: serializer.fromJson<String>(json['mobileHash']),
      enableOfflineLogin: serializer.fromJson<bool>(json['enableOfflineLogin']),
      firebaseToken: serializer.fromJson<String>(json['firebaseToken']),
      creationTime: serializer.fromJson<DateTime>(json['creationTime']),
      lastLoginTime: serializer.fromJson<DateTime>(json['lastLoginTime']),
      currency: serializer.fromJson<String>(json['currency']),
      themeData: serializer.fromJson<String>(json['themeData']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'userName': serializer.toJson<String>(userName),
      'name': serializer.toJson<String>(name),
      'surname': serializer.toJson<String>(surname),
      'emailAddress': serializer.toJson<String>(emailAddress),
      'isActive': serializer.toJson<bool>(isActive),
      'fullName': serializer.toJson<String>(fullName),
      'mobileHash': serializer.toJson<String>(mobileHash),
      'enableOfflineLogin': serializer.toJson<bool>(enableOfflineLogin),
      'firebaseToken': serializer.toJson<String>(firebaseToken),
      'creationTime': serializer.toJson<DateTime>(creationTime),
      'lastLoginTime': serializer.toJson<DateTime>(lastLoginTime),
      'currency': serializer.toJson<String>(currency),
      'themeData': serializer.toJson<String>(themeData),
    };
  }

  User copyWith(
          {int tenantId,
          int id,
          String userName,
          String name,
          String surname,
          String emailAddress,
          bool isActive,
          String fullName,
          String mobileHash,
          bool enableOfflineLogin,
          String firebaseToken,
          DateTime creationTime,
          DateTime lastLoginTime,
          String currency,
          String themeData}) =>
      User(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        userName: userName ?? this.userName,
        name: name ?? this.name,
        surname: surname ?? this.surname,
        emailAddress: emailAddress ?? this.emailAddress,
        isActive: isActive ?? this.isActive,
        fullName: fullName ?? this.fullName,
        mobileHash: mobileHash ?? this.mobileHash,
        enableOfflineLogin: enableOfflineLogin ?? this.enableOfflineLogin,
        firebaseToken: firebaseToken ?? this.firebaseToken,
        creationTime: creationTime ?? this.creationTime,
        lastLoginTime: lastLoginTime ?? this.lastLoginTime,
        currency: currency ?? this.currency,
        themeData: themeData ?? this.themeData,
      );
  @override
  String toString() {
    return (StringBuffer('User(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('userName: $userName, ')
          ..write('name: $name, ')
          ..write('surname: $surname, ')
          ..write('emailAddress: $emailAddress, ')
          ..write('isActive: $isActive, ')
          ..write('fullName: $fullName, ')
          ..write('mobileHash: $mobileHash, ')
          ..write('enableOfflineLogin: $enableOfflineLogin, ')
          ..write('firebaseToken: $firebaseToken, ')
          ..write('creationTime: $creationTime, ')
          ..write('lastLoginTime: $lastLoginTime, ')
          ..write('currency: $currency, ')
          ..write('themeData: $themeData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      userName,
      name,
      surname,
      emailAddress,
      isActive,
      fullName,
      mobileHash,
      enableOfflineLogin,
      firebaseToken,
      creationTime,
      lastLoginTime,
      currency,
      themeData);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.userName == this.userName &&
          other.name == this.name &&
          other.surname == this.surname &&
          other.emailAddress == this.emailAddress &&
          other.isActive == this.isActive &&
          other.fullName == this.fullName &&
          other.mobileHash == this.mobileHash &&
          other.enableOfflineLogin == this.enableOfflineLogin &&
          other.firebaseToken == this.firebaseToken &&
          other.creationTime == this.creationTime &&
          other.lastLoginTime == this.lastLoginTime &&
          other.currency == this.currency &&
          other.themeData == this.themeData);
}

class UsersCompanion extends UpdateCompanion<User> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> userName;
  final Value<String> name;
  final Value<String> surname;
  final Value<String> emailAddress;
  final Value<bool> isActive;
  final Value<String> fullName;
  final Value<String> mobileHash;
  final Value<bool> enableOfflineLogin;
  final Value<String> firebaseToken;
  final Value<DateTime> creationTime;
  final Value<DateTime> lastLoginTime;
  final Value<String> currency;
  final Value<String> themeData;
  const UsersCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.userName = const Value.absent(),
    this.name = const Value.absent(),
    this.surname = const Value.absent(),
    this.emailAddress = const Value.absent(),
    this.isActive = const Value.absent(),
    this.fullName = const Value.absent(),
    this.mobileHash = const Value.absent(),
    this.enableOfflineLogin = const Value.absent(),
    this.firebaseToken = const Value.absent(),
    this.creationTime = const Value.absent(),
    this.lastLoginTime = const Value.absent(),
    this.currency = const Value.absent(),
    this.themeData = const Value.absent(),
  });
  UsersCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    @required String userName,
    @required String name,
    @required String surname,
    @required String emailAddress,
    this.isActive = const Value.absent(),
    @required String fullName,
    this.mobileHash = const Value.absent(),
    this.enableOfflineLogin = const Value.absent(),
    this.firebaseToken = const Value.absent(),
    this.creationTime = const Value.absent(),
    this.lastLoginTime = const Value.absent(),
    this.currency = const Value.absent(),
    this.themeData = const Value.absent(),
  })  : userName = Value(userName),
        name = Value(name),
        surname = Value(surname),
        emailAddress = Value(emailAddress),
        fullName = Value(fullName);
  static Insertable<User> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> userName,
    Expression<String> name,
    Expression<String> surname,
    Expression<String> emailAddress,
    Expression<bool> isActive,
    Expression<String> fullName,
    Expression<String> mobileHash,
    Expression<bool> enableOfflineLogin,
    Expression<String> firebaseToken,
    Expression<DateTime> creationTime,
    Expression<DateTime> lastLoginTime,
    Expression<String> currency,
    Expression<String> themeData,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (userName != null) 'user_name': userName,
      if (name != null) 'name': name,
      if (surname != null) 'surname': surname,
      if (emailAddress != null) 'email_address': emailAddress,
      if (isActive != null) 'is_active': isActive,
      if (fullName != null) 'full_name': fullName,
      if (mobileHash != null) 'mobile_hash': mobileHash,
      if (enableOfflineLogin != null)
        'enable_offline_login': enableOfflineLogin,
      if (firebaseToken != null) 'firebase_token': firebaseToken,
      if (creationTime != null) 'creation_time': creationTime,
      if (lastLoginTime != null) 'last_login_time': lastLoginTime,
      if (currency != null) 'currency': currency,
      if (themeData != null) 'theme_data': themeData,
    });
  }

  UsersCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> userName,
      Value<String> name,
      Value<String> surname,
      Value<String> emailAddress,
      Value<bool> isActive,
      Value<String> fullName,
      Value<String> mobileHash,
      Value<bool> enableOfflineLogin,
      Value<String> firebaseToken,
      Value<DateTime> creationTime,
      Value<DateTime> lastLoginTime,
      Value<String> currency,
      Value<String> themeData}) {
    return UsersCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      userName: userName ?? this.userName,
      name: name ?? this.name,
      surname: surname ?? this.surname,
      emailAddress: emailAddress ?? this.emailAddress,
      isActive: isActive ?? this.isActive,
      fullName: fullName ?? this.fullName,
      mobileHash: mobileHash ?? this.mobileHash,
      enableOfflineLogin: enableOfflineLogin ?? this.enableOfflineLogin,
      firebaseToken: firebaseToken ?? this.firebaseToken,
      creationTime: creationTime ?? this.creationTime,
      lastLoginTime: lastLoginTime ?? this.lastLoginTime,
      currency: currency ?? this.currency,
      themeData: themeData ?? this.themeData,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (surname.present) {
      map['surname'] = Variable<String>(surname.value);
    }
    if (emailAddress.present) {
      map['email_address'] = Variable<String>(emailAddress.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (fullName.present) {
      map['full_name'] = Variable<String>(fullName.value);
    }
    if (mobileHash.present) {
      map['mobile_hash'] = Variable<String>(mobileHash.value);
    }
    if (enableOfflineLogin.present) {
      map['enable_offline_login'] = Variable<bool>(enableOfflineLogin.value);
    }
    if (firebaseToken.present) {
      map['firebase_token'] = Variable<String>(firebaseToken.value);
    }
    if (creationTime.present) {
      map['creation_time'] = Variable<DateTime>(creationTime.value);
    }
    if (lastLoginTime.present) {
      map['last_login_time'] = Variable<DateTime>(lastLoginTime.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (themeData.present) {
      map['theme_data'] = Variable<String>(themeData.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UsersCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('userName: $userName, ')
          ..write('name: $name, ')
          ..write('surname: $surname, ')
          ..write('emailAddress: $emailAddress, ')
          ..write('isActive: $isActive, ')
          ..write('fullName: $fullName, ')
          ..write('mobileHash: $mobileHash, ')
          ..write('enableOfflineLogin: $enableOfflineLogin, ')
          ..write('firebaseToken: $firebaseToken, ')
          ..write('creationTime: $creationTime, ')
          ..write('lastLoginTime: $lastLoginTime, ')
          ..write('currency: $currency, ')
          ..write('themeData: $themeData')
          ..write(')'))
        .toString();
  }
}

class $UsersTable extends Users with TableInfo<$UsersTable, User> {
  final GeneratedDatabase _db;
  final String _alias;
  $UsersTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName => _userName ??= GeneratedColumn<String>(
      'user_name', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 100),
      type: const StringType(),
      requiredDuringInsert: true);
  final VerificationMeta _nameMeta = const VerificationMeta('name');
  GeneratedColumn<String> _name;
  @override
  GeneratedColumn<String> get name => _name ??= GeneratedColumn<String>(
      'name', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 300),
      type: const StringType(),
      requiredDuringInsert: true);
  final VerificationMeta _surnameMeta = const VerificationMeta('surname');
  GeneratedColumn<String> _surname;
  @override
  GeneratedColumn<String> get surname => _surname ??= GeneratedColumn<String>(
      'surname', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 150),
      type: const StringType(),
      requiredDuringInsert: true);
  final VerificationMeta _emailAddressMeta =
      const VerificationMeta('emailAddress');
  GeneratedColumn<String> _emailAddress;
  @override
  GeneratedColumn<String> get emailAddress => _emailAddress ??=
      GeneratedColumn<String>('email_address', aliasedName, false,
          additionalChecks: GeneratedColumn.checkTextLength(
              minTextLength: 5, maxTextLength: 400),
          type: const StringType(),
          requiredDuringInsert: true);
  final VerificationMeta _isActiveMeta = const VerificationMeta('isActive');
  GeneratedColumn<bool> _isActive;
  @override
  GeneratedColumn<bool> get isActive =>
      _isActive ??= GeneratedColumn<bool>('is_active', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_active IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _fullNameMeta = const VerificationMeta('fullName');
  GeneratedColumn<String> _fullName;
  @override
  GeneratedColumn<String> get fullName => _fullName ??= GeneratedColumn<String>(
      'full_name', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 300),
      type: const StringType(),
      requiredDuringInsert: true);
  final VerificationMeta _mobileHashMeta = const VerificationMeta('mobileHash');
  GeneratedColumn<String> _mobileHash;
  @override
  GeneratedColumn<String> get mobileHash =>
      _mobileHash ??= GeneratedColumn<String>('mobile_hash', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _enableOfflineLoginMeta =
      const VerificationMeta('enableOfflineLogin');
  GeneratedColumn<bool> _enableOfflineLogin;
  @override
  GeneratedColumn<bool> get enableOfflineLogin => _enableOfflineLogin ??=
      GeneratedColumn<bool>('enable_offline_login', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (enable_offline_login IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _firebaseTokenMeta =
      const VerificationMeta('firebaseToken');
  GeneratedColumn<String> _firebaseToken;
  @override
  GeneratedColumn<String> get firebaseToken => _firebaseToken ??=
      GeneratedColumn<String>('firebase_token', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _creationTimeMeta =
      const VerificationMeta('creationTime');
  GeneratedColumn<DateTime> _creationTime;
  @override
  GeneratedColumn<DateTime> get creationTime => _creationTime ??=
      GeneratedColumn<DateTime>('creation_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _lastLoginTimeMeta =
      const VerificationMeta('lastLoginTime');
  GeneratedColumn<DateTime> _lastLoginTime;
  @override
  GeneratedColumn<DateTime> get lastLoginTime => _lastLoginTime ??=
      GeneratedColumn<DateTime>('last_login_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _currencyMeta = const VerificationMeta('currency');
  GeneratedColumn<String> _currency;
  @override
  GeneratedColumn<String> get currency =>
      _currency ??= GeneratedColumn<String>('currency', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _themeDataMeta = const VerificationMeta('themeData');
  GeneratedColumn<String> _themeData;
  @override
  GeneratedColumn<String> get themeData =>
      _themeData ??= GeneratedColumn<String>('theme_data', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        userName,
        name,
        surname,
        emailAddress,
        isActive,
        fullName,
        mobileHash,
        enableOfflineLogin,
        firebaseToken,
        creationTime,
        lastLoginTime,
        currency,
        themeData
      ];
  @override
  String get aliasedName => _alias ?? 'users';
  @override
  String get actualTableName => 'users';
  @override
  VerificationContext validateIntegrity(Insertable<User> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    } else if (isInserting) {
      context.missing(_userNameMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name'], _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('surname')) {
      context.handle(_surnameMeta,
          surname.isAcceptableOrUnknown(data['surname'], _surnameMeta));
    } else if (isInserting) {
      context.missing(_surnameMeta);
    }
    if (data.containsKey('email_address')) {
      context.handle(
          _emailAddressMeta,
          emailAddress.isAcceptableOrUnknown(
              data['email_address'], _emailAddressMeta));
    } else if (isInserting) {
      context.missing(_emailAddressMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active'], _isActiveMeta));
    }
    if (data.containsKey('full_name')) {
      context.handle(_fullNameMeta,
          fullName.isAcceptableOrUnknown(data['full_name'], _fullNameMeta));
    } else if (isInserting) {
      context.missing(_fullNameMeta);
    }
    if (data.containsKey('mobile_hash')) {
      context.handle(
          _mobileHashMeta,
          mobileHash.isAcceptableOrUnknown(
              data['mobile_hash'], _mobileHashMeta));
    }
    if (data.containsKey('enable_offline_login')) {
      context.handle(
          _enableOfflineLoginMeta,
          enableOfflineLogin.isAcceptableOrUnknown(
              data['enable_offline_login'], _enableOfflineLoginMeta));
    }
    if (data.containsKey('firebase_token')) {
      context.handle(
          _firebaseTokenMeta,
          firebaseToken.isAcceptableOrUnknown(
              data['firebase_token'], _firebaseTokenMeta));
    }
    if (data.containsKey('creation_time')) {
      context.handle(
          _creationTimeMeta,
          creationTime.isAcceptableOrUnknown(
              data['creation_time'], _creationTimeMeta));
    }
    if (data.containsKey('last_login_time')) {
      context.handle(
          _lastLoginTimeMeta,
          lastLoginTime.isAcceptableOrUnknown(
              data['last_login_time'], _lastLoginTimeMeta));
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency'], _currencyMeta));
    }
    if (data.containsKey('theme_data')) {
      context.handle(_themeDataMeta,
          themeData.isAcceptableOrUnknown(data['theme_data'], _themeDataMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  User map(Map<String, dynamic> data, {String tablePrefix}) {
    return User.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $UsersTable createAlias(String alias) {
    return $UsersTable(_db, alias);
  }
}

class CommunicationData extends DataClass
    implements Insertable<CommunicationData> {
  final DateTime creationTime;
  final DateTime deleteTime;
  final int createUserId;
  final String creatorUser;
  final String lastModifierUser;
  final int lastModifierUserId;
  final int deleteUserId;
  final String deleterUserId;
  final bool isDeleted;
  final DateTime importDateTime;
  final DateTime exportDateTime;
  final String exportStatus;
  final String importStatus;
  final String syncError;
  final int id;
  final String serverUrl;
  final String userName;
  final String newPasskey;
  final String confirmPasskey;
  final String syncFrequency;
  final String communicationType;
  final String typeofErp;
  final int tenantId;
  CommunicationData(
      {this.creationTime,
      this.deleteTime,
      this.createUserId,
      this.creatorUser,
      this.lastModifierUser,
      this.lastModifierUserId,
      this.deleteUserId,
      this.deleterUserId,
      @required this.isDeleted,
      this.importDateTime,
      this.exportDateTime,
      @required this.exportStatus,
      @required this.importStatus,
      this.syncError,
      @required this.id,
      @required this.serverUrl,
      this.userName,
      this.newPasskey,
      this.confirmPasskey,
      @required this.syncFrequency,
      @required this.communicationType,
      this.typeofErp,
      this.tenantId});
  factory CommunicationData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return CommunicationData(
      creationTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}creation_time']),
      deleteTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}delete_time']),
      createUserId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}create_user_id']),
      creatorUser: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}creator_user']),
      lastModifierUser: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}last_modifier_user']),
      lastModifierUserId: const IntType().mapFromDatabaseResponse(
          data['${effectivePrefix}last_modifier_user_id']),
      deleteUserId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}delete_user_id']),
      deleterUserId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}deleter_user_id']),
      isDeleted: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_deleted']),
      importDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}import_date_time']),
      exportDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}export_date_time']),
      exportStatus: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}export_status']),
      importStatus: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}import_status']),
      syncError: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sync_error']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      serverUrl: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}server_url']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      newPasskey: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}new_passkey']),
      confirmPasskey: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}confirm_passkey']),
      syncFrequency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sync_frequency']),
      communicationType: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}communication_type']),
      typeofErp: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}typeof_erp']),
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || creationTime != null) {
      map['creation_time'] = Variable<DateTime>(creationTime);
    }
    if (!nullToAbsent || deleteTime != null) {
      map['delete_time'] = Variable<DateTime>(deleteTime);
    }
    if (!nullToAbsent || createUserId != null) {
      map['create_user_id'] = Variable<int>(createUserId);
    }
    if (!nullToAbsent || creatorUser != null) {
      map['creator_user'] = Variable<String>(creatorUser);
    }
    if (!nullToAbsent || lastModifierUser != null) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser);
    }
    if (!nullToAbsent || lastModifierUserId != null) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId);
    }
    if (!nullToAbsent || deleteUserId != null) {
      map['delete_user_id'] = Variable<int>(deleteUserId);
    }
    if (!nullToAbsent || deleterUserId != null) {
      map['deleter_user_id'] = Variable<String>(deleterUserId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || importDateTime != null) {
      map['import_date_time'] = Variable<DateTime>(importDateTime);
    }
    if (!nullToAbsent || exportDateTime != null) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime);
    }
    if (!nullToAbsent || exportStatus != null) {
      map['export_status'] = Variable<String>(exportStatus);
    }
    if (!nullToAbsent || importStatus != null) {
      map['import_status'] = Variable<String>(importStatus);
    }
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || serverUrl != null) {
      map['server_url'] = Variable<String>(serverUrl);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || newPasskey != null) {
      map['new_passkey'] = Variable<String>(newPasskey);
    }
    if (!nullToAbsent || confirmPasskey != null) {
      map['confirm_passkey'] = Variable<String>(confirmPasskey);
    }
    if (!nullToAbsent || syncFrequency != null) {
      map['sync_frequency'] = Variable<String>(syncFrequency);
    }
    if (!nullToAbsent || communicationType != null) {
      map['communication_type'] = Variable<String>(communicationType);
    }
    if (!nullToAbsent || typeofErp != null) {
      map['typeof_erp'] = Variable<String>(typeofErp);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    return map;
  }

  CommunicationCompanion toCompanion(bool nullToAbsent) {
    return CommunicationCompanion(
      creationTime: creationTime == null && nullToAbsent
          ? const Value.absent()
          : Value(creationTime),
      deleteTime: deleteTime == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteTime),
      createUserId: createUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(createUserId),
      creatorUser: creatorUser == null && nullToAbsent
          ? const Value.absent()
          : Value(creatorUser),
      lastModifierUser: lastModifierUser == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUser),
      lastModifierUserId: lastModifierUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUserId),
      deleteUserId: deleteUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteUserId),
      deleterUserId: deleterUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleterUserId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      importDateTime: importDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(importDateTime),
      exportDateTime: exportDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(exportDateTime),
      exportStatus: exportStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(exportStatus),
      importStatus: importStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(importStatus),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      serverUrl: serverUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(serverUrl),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      newPasskey: newPasskey == null && nullToAbsent
          ? const Value.absent()
          : Value(newPasskey),
      confirmPasskey: confirmPasskey == null && nullToAbsent
          ? const Value.absent()
          : Value(confirmPasskey),
      syncFrequency: syncFrequency == null && nullToAbsent
          ? const Value.absent()
          : Value(syncFrequency),
      communicationType: communicationType == null && nullToAbsent
          ? const Value.absent()
          : Value(communicationType),
      typeofErp: typeofErp == null && nullToAbsent
          ? const Value.absent()
          : Value(typeofErp),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory CommunicationData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CommunicationData(
      creationTime: serializer.fromJson<DateTime>(json['creationTime']),
      deleteTime: serializer.fromJson<DateTime>(json['deleteTime']),
      createUserId: serializer.fromJson<int>(json['createUserId']),
      creatorUser: serializer.fromJson<String>(json['creatorUser']),
      lastModifierUser: serializer.fromJson<String>(json['lastModifierUser']),
      lastModifierUserId: serializer.fromJson<int>(json['lastModifierUserId']),
      deleteUserId: serializer.fromJson<int>(json['deleteUserId']),
      deleterUserId: serializer.fromJson<String>(json['deleterUserId']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      importDateTime: serializer.fromJson<DateTime>(json['importDateTime']),
      exportDateTime: serializer.fromJson<DateTime>(json['exportDateTime']),
      exportStatus: serializer.fromJson<String>(json['exportStatus']),
      importStatus: serializer.fromJson<String>(json['importStatus']),
      syncError: serializer.fromJson<String>(json['syncError']),
      id: serializer.fromJson<int>(json['id']),
      serverUrl: serializer.fromJson<String>(json['serverUrl']),
      userName: serializer.fromJson<String>(json['userName']),
      newPasskey: serializer.fromJson<String>(json['newPasskey']),
      confirmPasskey: serializer.fromJson<String>(json['confirmPasskey']),
      syncFrequency: serializer.fromJson<String>(json['syncFrequency']),
      communicationType: serializer.fromJson<String>(json['communicationType']),
      typeofErp: serializer.fromJson<String>(json['typeofErp']),
      tenantId: serializer.fromJson<int>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creationTime': serializer.toJson<DateTime>(creationTime),
      'deleteTime': serializer.toJson<DateTime>(deleteTime),
      'createUserId': serializer.toJson<int>(createUserId),
      'creatorUser': serializer.toJson<String>(creatorUser),
      'lastModifierUser': serializer.toJson<String>(lastModifierUser),
      'lastModifierUserId': serializer.toJson<int>(lastModifierUserId),
      'deleteUserId': serializer.toJson<int>(deleteUserId),
      'deleterUserId': serializer.toJson<String>(deleterUserId),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'importDateTime': serializer.toJson<DateTime>(importDateTime),
      'exportDateTime': serializer.toJson<DateTime>(exportDateTime),
      'exportStatus': serializer.toJson<String>(exportStatus),
      'importStatus': serializer.toJson<String>(importStatus),
      'syncError': serializer.toJson<String>(syncError),
      'id': serializer.toJson<int>(id),
      'serverUrl': serializer.toJson<String>(serverUrl),
      'userName': serializer.toJson<String>(userName),
      'newPasskey': serializer.toJson<String>(newPasskey),
      'confirmPasskey': serializer.toJson<String>(confirmPasskey),
      'syncFrequency': serializer.toJson<String>(syncFrequency),
      'communicationType': serializer.toJson<String>(communicationType),
      'typeofErp': serializer.toJson<String>(typeofErp),
      'tenantId': serializer.toJson<int>(tenantId),
    };
  }

  CommunicationData copyWith(
          {DateTime creationTime,
          DateTime deleteTime,
          int createUserId,
          String creatorUser,
          String lastModifierUser,
          int lastModifierUserId,
          int deleteUserId,
          String deleterUserId,
          bool isDeleted,
          DateTime importDateTime,
          DateTime exportDateTime,
          String exportStatus,
          String importStatus,
          String syncError,
          int id,
          String serverUrl,
          String userName,
          String newPasskey,
          String confirmPasskey,
          String syncFrequency,
          String communicationType,
          String typeofErp,
          int tenantId}) =>
      CommunicationData(
        creationTime: creationTime ?? this.creationTime,
        deleteTime: deleteTime ?? this.deleteTime,
        createUserId: createUserId ?? this.createUserId,
        creatorUser: creatorUser ?? this.creatorUser,
        lastModifierUser: lastModifierUser ?? this.lastModifierUser,
        lastModifierUserId: lastModifierUserId ?? this.lastModifierUserId,
        deleteUserId: deleteUserId ?? this.deleteUserId,
        deleterUserId: deleterUserId ?? this.deleterUserId,
        isDeleted: isDeleted ?? this.isDeleted,
        importDateTime: importDateTime ?? this.importDateTime,
        exportDateTime: exportDateTime ?? this.exportDateTime,
        exportStatus: exportStatus ?? this.exportStatus,
        importStatus: importStatus ?? this.importStatus,
        syncError: syncError ?? this.syncError,
        id: id ?? this.id,
        serverUrl: serverUrl ?? this.serverUrl,
        userName: userName ?? this.userName,
        newPasskey: newPasskey ?? this.newPasskey,
        confirmPasskey: confirmPasskey ?? this.confirmPasskey,
        syncFrequency: syncFrequency ?? this.syncFrequency,
        communicationType: communicationType ?? this.communicationType,
        typeofErp: typeofErp ?? this.typeofErp,
        tenantId: tenantId ?? this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('CommunicationData(')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('createUserId: $createUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('importDateTime: $importDateTime, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('importStatus: $importStatus, ')
          ..write('syncError: $syncError, ')
          ..write('id: $id, ')
          ..write('serverUrl: $serverUrl, ')
          ..write('userName: $userName, ')
          ..write('newPasskey: $newPasskey, ')
          ..write('confirmPasskey: $confirmPasskey, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('communicationType: $communicationType, ')
          ..write('typeofErp: $typeofErp, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        creationTime,
        deleteTime,
        createUserId,
        creatorUser,
        lastModifierUser,
        lastModifierUserId,
        deleteUserId,
        deleterUserId,
        isDeleted,
        importDateTime,
        exportDateTime,
        exportStatus,
        importStatus,
        syncError,
        id,
        serverUrl,
        userName,
        newPasskey,
        confirmPasskey,
        syncFrequency,
        communicationType,
        typeofErp,
        tenantId
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CommunicationData &&
          other.creationTime == this.creationTime &&
          other.deleteTime == this.deleteTime &&
          other.createUserId == this.createUserId &&
          other.creatorUser == this.creatorUser &&
          other.lastModifierUser == this.lastModifierUser &&
          other.lastModifierUserId == this.lastModifierUserId &&
          other.deleteUserId == this.deleteUserId &&
          other.deleterUserId == this.deleterUserId &&
          other.isDeleted == this.isDeleted &&
          other.importDateTime == this.importDateTime &&
          other.exportDateTime == this.exportDateTime &&
          other.exportStatus == this.exportStatus &&
          other.importStatus == this.importStatus &&
          other.syncError == this.syncError &&
          other.id == this.id &&
          other.serverUrl == this.serverUrl &&
          other.userName == this.userName &&
          other.newPasskey == this.newPasskey &&
          other.confirmPasskey == this.confirmPasskey &&
          other.syncFrequency == this.syncFrequency &&
          other.communicationType == this.communicationType &&
          other.typeofErp == this.typeofErp &&
          other.tenantId == this.tenantId);
}

class CommunicationCompanion extends UpdateCompanion<CommunicationData> {
  final Value<DateTime> creationTime;
  final Value<DateTime> deleteTime;
  final Value<int> createUserId;
  final Value<String> creatorUser;
  final Value<String> lastModifierUser;
  final Value<int> lastModifierUserId;
  final Value<int> deleteUserId;
  final Value<String> deleterUserId;
  final Value<bool> isDeleted;
  final Value<DateTime> importDateTime;
  final Value<DateTime> exportDateTime;
  final Value<String> exportStatus;
  final Value<String> importStatus;
  final Value<String> syncError;
  final Value<int> id;
  final Value<String> serverUrl;
  final Value<String> userName;
  final Value<String> newPasskey;
  final Value<String> confirmPasskey;
  final Value<String> syncFrequency;
  final Value<String> communicationType;
  final Value<String> typeofErp;
  final Value<int> tenantId;
  const CommunicationCompanion({
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.importDateTime = const Value.absent(),
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.importStatus = const Value.absent(),
    this.syncError = const Value.absent(),
    this.id = const Value.absent(),
    this.serverUrl = const Value.absent(),
    this.userName = const Value.absent(),
    this.newPasskey = const Value.absent(),
    this.confirmPasskey = const Value.absent(),
    this.syncFrequency = const Value.absent(),
    this.communicationType = const Value.absent(),
    this.typeofErp = const Value.absent(),
    this.tenantId = const Value.absent(),
  });
  CommunicationCompanion.insert({
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.importDateTime = const Value.absent(),
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.importStatus = const Value.absent(),
    this.syncError = const Value.absent(),
    this.id = const Value.absent(),
    @required String serverUrl,
    this.userName = const Value.absent(),
    this.newPasskey = const Value.absent(),
    this.confirmPasskey = const Value.absent(),
    @required String syncFrequency,
    @required String communicationType,
    this.typeofErp = const Value.absent(),
    this.tenantId = const Value.absent(),
  })  : serverUrl = Value(serverUrl),
        syncFrequency = Value(syncFrequency),
        communicationType = Value(communicationType);
  static Insertable<CommunicationData> custom({
    Expression<DateTime> creationTime,
    Expression<DateTime> deleteTime,
    Expression<int> createUserId,
    Expression<String> creatorUser,
    Expression<String> lastModifierUser,
    Expression<int> lastModifierUserId,
    Expression<int> deleteUserId,
    Expression<String> deleterUserId,
    Expression<bool> isDeleted,
    Expression<DateTime> importDateTime,
    Expression<DateTime> exportDateTime,
    Expression<String> exportStatus,
    Expression<String> importStatus,
    Expression<String> syncError,
    Expression<int> id,
    Expression<String> serverUrl,
    Expression<String> userName,
    Expression<String> newPasskey,
    Expression<String> confirmPasskey,
    Expression<String> syncFrequency,
    Expression<String> communicationType,
    Expression<String> typeofErp,
    Expression<int> tenantId,
  }) {
    return RawValuesInsertable({
      if (creationTime != null) 'creation_time': creationTime,
      if (deleteTime != null) 'delete_time': deleteTime,
      if (createUserId != null) 'create_user_id': createUserId,
      if (creatorUser != null) 'creator_user': creatorUser,
      if (lastModifierUser != null) 'last_modifier_user': lastModifierUser,
      if (lastModifierUserId != null)
        'last_modifier_user_id': lastModifierUserId,
      if (deleteUserId != null) 'delete_user_id': deleteUserId,
      if (deleterUserId != null) 'deleter_user_id': deleterUserId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (importDateTime != null) 'import_date_time': importDateTime,
      if (exportDateTime != null) 'export_date_time': exportDateTime,
      if (exportStatus != null) 'export_status': exportStatus,
      if (importStatus != null) 'import_status': importStatus,
      if (syncError != null) 'sync_error': syncError,
      if (id != null) 'id': id,
      if (serverUrl != null) 'server_url': serverUrl,
      if (userName != null) 'user_name': userName,
      if (newPasskey != null) 'new_passkey': newPasskey,
      if (confirmPasskey != null) 'confirm_passkey': confirmPasskey,
      if (syncFrequency != null) 'sync_frequency': syncFrequency,
      if (communicationType != null) 'communication_type': communicationType,
      if (typeofErp != null) 'typeof_erp': typeofErp,
      if (tenantId != null) 'tenant_id': tenantId,
    });
  }

  CommunicationCompanion copyWith(
      {Value<DateTime> creationTime,
      Value<DateTime> deleteTime,
      Value<int> createUserId,
      Value<String> creatorUser,
      Value<String> lastModifierUser,
      Value<int> lastModifierUserId,
      Value<int> deleteUserId,
      Value<String> deleterUserId,
      Value<bool> isDeleted,
      Value<DateTime> importDateTime,
      Value<DateTime> exportDateTime,
      Value<String> exportStatus,
      Value<String> importStatus,
      Value<String> syncError,
      Value<int> id,
      Value<String> serverUrl,
      Value<String> userName,
      Value<String> newPasskey,
      Value<String> confirmPasskey,
      Value<String> syncFrequency,
      Value<String> communicationType,
      Value<String> typeofErp,
      Value<int> tenantId}) {
    return CommunicationCompanion(
      creationTime: creationTime ?? this.creationTime,
      deleteTime: deleteTime ?? this.deleteTime,
      createUserId: createUserId ?? this.createUserId,
      creatorUser: creatorUser ?? this.creatorUser,
      lastModifierUser: lastModifierUser ?? this.lastModifierUser,
      lastModifierUserId: lastModifierUserId ?? this.lastModifierUserId,
      deleteUserId: deleteUserId ?? this.deleteUserId,
      deleterUserId: deleterUserId ?? this.deleterUserId,
      isDeleted: isDeleted ?? this.isDeleted,
      importDateTime: importDateTime ?? this.importDateTime,
      exportDateTime: exportDateTime ?? this.exportDateTime,
      exportStatus: exportStatus ?? this.exportStatus,
      importStatus: importStatus ?? this.importStatus,
      syncError: syncError ?? this.syncError,
      id: id ?? this.id,
      serverUrl: serverUrl ?? this.serverUrl,
      userName: userName ?? this.userName,
      newPasskey: newPasskey ?? this.newPasskey,
      confirmPasskey: confirmPasskey ?? this.confirmPasskey,
      syncFrequency: syncFrequency ?? this.syncFrequency,
      communicationType: communicationType ?? this.communicationType,
      typeofErp: typeofErp ?? this.typeofErp,
      tenantId: tenantId ?? this.tenantId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creationTime.present) {
      map['creation_time'] = Variable<DateTime>(creationTime.value);
    }
    if (deleteTime.present) {
      map['delete_time'] = Variable<DateTime>(deleteTime.value);
    }
    if (createUserId.present) {
      map['create_user_id'] = Variable<int>(createUserId.value);
    }
    if (creatorUser.present) {
      map['creator_user'] = Variable<String>(creatorUser.value);
    }
    if (lastModifierUser.present) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser.value);
    }
    if (lastModifierUserId.present) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId.value);
    }
    if (deleteUserId.present) {
      map['delete_user_id'] = Variable<int>(deleteUserId.value);
    }
    if (deleterUserId.present) {
      map['deleter_user_id'] = Variable<String>(deleterUserId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (importDateTime.present) {
      map['import_date_time'] = Variable<DateTime>(importDateTime.value);
    }
    if (exportDateTime.present) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime.value);
    }
    if (exportStatus.present) {
      map['export_status'] = Variable<String>(exportStatus.value);
    }
    if (importStatus.present) {
      map['import_status'] = Variable<String>(importStatus.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (serverUrl.present) {
      map['server_url'] = Variable<String>(serverUrl.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (newPasskey.present) {
      map['new_passkey'] = Variable<String>(newPasskey.value);
    }
    if (confirmPasskey.present) {
      map['confirm_passkey'] = Variable<String>(confirmPasskey.value);
    }
    if (syncFrequency.present) {
      map['sync_frequency'] = Variable<String>(syncFrequency.value);
    }
    if (communicationType.present) {
      map['communication_type'] = Variable<String>(communicationType.value);
    }
    if (typeofErp.present) {
      map['typeof_erp'] = Variable<String>(typeofErp.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CommunicationCompanion(')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('createUserId: $createUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('importDateTime: $importDateTime, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('importStatus: $importStatus, ')
          ..write('syncError: $syncError, ')
          ..write('id: $id, ')
          ..write('serverUrl: $serverUrl, ')
          ..write('userName: $userName, ')
          ..write('newPasskey: $newPasskey, ')
          ..write('confirmPasskey: $confirmPasskey, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('communicationType: $communicationType, ')
          ..write('typeofErp: $typeofErp, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }
}

class $CommunicationTable extends Communication
    with TableInfo<$CommunicationTable, CommunicationData> {
  final GeneratedDatabase _db;
  final String _alias;
  $CommunicationTable(this._db, [this._alias]);
  final VerificationMeta _creationTimeMeta =
      const VerificationMeta('creationTime');
  GeneratedColumn<DateTime> _creationTime;
  @override
  GeneratedColumn<DateTime> get creationTime => _creationTime ??=
      GeneratedColumn<DateTime>('creation_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _deleteTimeMeta = const VerificationMeta('deleteTime');
  GeneratedColumn<DateTime> _deleteTime;
  @override
  GeneratedColumn<DateTime> get deleteTime => _deleteTime ??=
      GeneratedColumn<DateTime>('delete_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _createUserIdMeta =
      const VerificationMeta('createUserId');
  GeneratedColumn<int> _createUserId;
  @override
  GeneratedColumn<int> get createUserId => _createUserId ??=
      GeneratedColumn<int>('create_user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _creatorUserMeta =
      const VerificationMeta('creatorUser');
  GeneratedColumn<String> _creatorUser;
  @override
  GeneratedColumn<String> get creatorUser => _creatorUser ??=
      GeneratedColumn<String>('creator_user', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _lastModifierUserMeta =
      const VerificationMeta('lastModifierUser');
  GeneratedColumn<String> _lastModifierUser;
  @override
  GeneratedColumn<String> get lastModifierUser => _lastModifierUser ??=
      GeneratedColumn<String>('last_modifier_user', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _lastModifierUserIdMeta =
      const VerificationMeta('lastModifierUserId');
  GeneratedColumn<int> _lastModifierUserId;
  @override
  GeneratedColumn<int> get lastModifierUserId => _lastModifierUserId ??=
      GeneratedColumn<int>('last_modifier_user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _deleteUserIdMeta =
      const VerificationMeta('deleteUserId');
  GeneratedColumn<int> _deleteUserId;
  @override
  GeneratedColumn<int> get deleteUserId => _deleteUserId ??=
      GeneratedColumn<int>('delete_user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _deleterUserIdMeta =
      const VerificationMeta('deleterUserId');
  GeneratedColumn<String> _deleterUserId;
  @override
  GeneratedColumn<String> get deleterUserId => _deleterUserId ??=
      GeneratedColumn<String>('deleter_user_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isDeletedMeta = const VerificationMeta('isDeleted');
  GeneratedColumn<bool> _isDeleted;
  @override
  GeneratedColumn<bool> get isDeleted =>
      _isDeleted ??= GeneratedColumn<bool>('is_deleted', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_deleted IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _importDateTimeMeta =
      const VerificationMeta('importDateTime');
  GeneratedColumn<DateTime> _importDateTime;
  @override
  GeneratedColumn<DateTime> get importDateTime => _importDateTime ??=
      GeneratedColumn<DateTime>('import_date_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _exportDateTimeMeta =
      const VerificationMeta('exportDateTime');
  GeneratedColumn<DateTime> _exportDateTime;
  @override
  GeneratedColumn<DateTime> get exportDateTime => _exportDateTime ??=
      GeneratedColumn<DateTime>('export_date_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _exportStatusMeta =
      const VerificationMeta('exportStatus');
  GeneratedColumn<String> _exportStatus;
  @override
  GeneratedColumn<String> get exportStatus => _exportStatus ??=
      GeneratedColumn<String>('export_status', aliasedName, false,
          type: const StringType(),
          requiredDuringInsert: false,
          defaultValue: Constant('Pending'));
  final VerificationMeta _importStatusMeta =
      const VerificationMeta('importStatus');
  GeneratedColumn<String> _importStatus;
  @override
  GeneratedColumn<String> get importStatus => _importStatus ??=
      GeneratedColumn<String>('import_status', aliasedName, false,
          type: const StringType(),
          requiredDuringInsert: false,
          defaultValue: Constant('Pending'));
  final VerificationMeta _syncErrorMeta = const VerificationMeta('syncError');
  GeneratedColumn<String> _syncError;
  @override
  GeneratedColumn<String> get syncError =>
      _syncError ??= GeneratedColumn<String>('sync_error', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(),
          requiredDuringInsert: false,
          defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
  final VerificationMeta _serverUrlMeta = const VerificationMeta('serverUrl');
  GeneratedColumn<String> _serverUrl;
  @override
  GeneratedColumn<String> get serverUrl =>
      _serverUrl ??= GeneratedColumn<String>('server_url', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _newPasskeyMeta = const VerificationMeta('newPasskey');
  GeneratedColumn<String> _newPasskey;
  @override
  GeneratedColumn<String> get newPasskey =>
      _newPasskey ??= GeneratedColumn<String>('new_passkey', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _confirmPasskeyMeta =
      const VerificationMeta('confirmPasskey');
  GeneratedColumn<String> _confirmPasskey;
  @override
  GeneratedColumn<String> get confirmPasskey => _confirmPasskey ??=
      GeneratedColumn<String>('confirm_passkey', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _syncFrequencyMeta =
      const VerificationMeta('syncFrequency');
  GeneratedColumn<String> _syncFrequency;
  @override
  GeneratedColumn<String> get syncFrequency => _syncFrequency ??=
      GeneratedColumn<String>('sync_frequency', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _communicationTypeMeta =
      const VerificationMeta('communicationType');
  GeneratedColumn<String> _communicationType;
  @override
  GeneratedColumn<String> get communicationType => _communicationType ??=
      GeneratedColumn<String>('communication_type', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _typeofErpMeta = const VerificationMeta('typeofErp');
  GeneratedColumn<String> _typeofErp;
  @override
  GeneratedColumn<String> get typeofErp =>
      _typeofErp ??= GeneratedColumn<String>('typeof_erp', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        creationTime,
        deleteTime,
        createUserId,
        creatorUser,
        lastModifierUser,
        lastModifierUserId,
        deleteUserId,
        deleterUserId,
        isDeleted,
        importDateTime,
        exportDateTime,
        exportStatus,
        importStatus,
        syncError,
        id,
        serverUrl,
        userName,
        newPasskey,
        confirmPasskey,
        syncFrequency,
        communicationType,
        typeofErp,
        tenantId
      ];
  @override
  String get aliasedName => _alias ?? 'communication';
  @override
  String get actualTableName => 'communication';
  @override
  VerificationContext validateIntegrity(Insertable<CommunicationData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creation_time')) {
      context.handle(
          _creationTimeMeta,
          creationTime.isAcceptableOrUnknown(
              data['creation_time'], _creationTimeMeta));
    }
    if (data.containsKey('delete_time')) {
      context.handle(
          _deleteTimeMeta,
          deleteTime.isAcceptableOrUnknown(
              data['delete_time'], _deleteTimeMeta));
    }
    if (data.containsKey('create_user_id')) {
      context.handle(
          _createUserIdMeta,
          createUserId.isAcceptableOrUnknown(
              data['create_user_id'], _createUserIdMeta));
    }
    if (data.containsKey('creator_user')) {
      context.handle(
          _creatorUserMeta,
          creatorUser.isAcceptableOrUnknown(
              data['creator_user'], _creatorUserMeta));
    }
    if (data.containsKey('last_modifier_user')) {
      context.handle(
          _lastModifierUserMeta,
          lastModifierUser.isAcceptableOrUnknown(
              data['last_modifier_user'], _lastModifierUserMeta));
    }
    if (data.containsKey('last_modifier_user_id')) {
      context.handle(
          _lastModifierUserIdMeta,
          lastModifierUserId.isAcceptableOrUnknown(
              data['last_modifier_user_id'], _lastModifierUserIdMeta));
    }
    if (data.containsKey('delete_user_id')) {
      context.handle(
          _deleteUserIdMeta,
          deleteUserId.isAcceptableOrUnknown(
              data['delete_user_id'], _deleteUserIdMeta));
    }
    if (data.containsKey('deleter_user_id')) {
      context.handle(
          _deleterUserIdMeta,
          deleterUserId.isAcceptableOrUnknown(
              data['deleter_user_id'], _deleterUserIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted'], _isDeletedMeta));
    }
    if (data.containsKey('import_date_time')) {
      context.handle(
          _importDateTimeMeta,
          importDateTime.isAcceptableOrUnknown(
              data['import_date_time'], _importDateTimeMeta));
    }
    if (data.containsKey('export_date_time')) {
      context.handle(
          _exportDateTimeMeta,
          exportDateTime.isAcceptableOrUnknown(
              data['export_date_time'], _exportDateTimeMeta));
    }
    if (data.containsKey('export_status')) {
      context.handle(
          _exportStatusMeta,
          exportStatus.isAcceptableOrUnknown(
              data['export_status'], _exportStatusMeta));
    }
    if (data.containsKey('import_status')) {
      context.handle(
          _importStatusMeta,
          importStatus.isAcceptableOrUnknown(
              data['import_status'], _importStatusMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error'], _syncErrorMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('server_url')) {
      context.handle(_serverUrlMeta,
          serverUrl.isAcceptableOrUnknown(data['server_url'], _serverUrlMeta));
    } else if (isInserting) {
      context.missing(_serverUrlMeta);
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    }
    if (data.containsKey('new_passkey')) {
      context.handle(
          _newPasskeyMeta,
          newPasskey.isAcceptableOrUnknown(
              data['new_passkey'], _newPasskeyMeta));
    }
    if (data.containsKey('confirm_passkey')) {
      context.handle(
          _confirmPasskeyMeta,
          confirmPasskey.isAcceptableOrUnknown(
              data['confirm_passkey'], _confirmPasskeyMeta));
    }
    if (data.containsKey('sync_frequency')) {
      context.handle(
          _syncFrequencyMeta,
          syncFrequency.isAcceptableOrUnknown(
              data['sync_frequency'], _syncFrequencyMeta));
    } else if (isInserting) {
      context.missing(_syncFrequencyMeta);
    }
    if (data.containsKey('communication_type')) {
      context.handle(
          _communicationTypeMeta,
          communicationType.isAcceptableOrUnknown(
              data['communication_type'], _communicationTypeMeta));
    } else if (isInserting) {
      context.missing(_communicationTypeMeta);
    }
    if (data.containsKey('typeof_erp')) {
      context.handle(_typeofErpMeta,
          typeofErp.isAcceptableOrUnknown(data['typeof_erp'], _typeofErpMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CommunicationData map(Map<String, dynamic> data, {String tablePrefix}) {
    return CommunicationData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $CommunicationTable createAlias(String alias) {
    return $CommunicationTable(_db, alias);
  }
}

class BackgroundJobScheduleData extends DataClass
    implements Insertable<BackgroundJobScheduleData> {
  final int id;
  final String jobName;
  final DateTime startDateTime;
  final String syncFrequency;
  final bool enableJob;
  final DateTime lastRun;
  final String jobStatus;
  final int tenantId;
  BackgroundJobScheduleData(
      {@required this.id,
      @required this.jobName,
      @required this.startDateTime,
      @required this.syncFrequency,
      @required this.enableJob,
      @required this.lastRun,
      @required this.jobStatus,
      this.tenantId});
  factory BackgroundJobScheduleData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return BackgroundJobScheduleData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      jobName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}job_name']),
      startDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}start_date_time']),
      syncFrequency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sync_frequency']),
      enableJob: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}enable_job']),
      lastRun: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}last_run']),
      jobStatus: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}job_status']),
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || jobName != null) {
      map['job_name'] = Variable<String>(jobName);
    }
    if (!nullToAbsent || startDateTime != null) {
      map['start_date_time'] = Variable<DateTime>(startDateTime);
    }
    if (!nullToAbsent || syncFrequency != null) {
      map['sync_frequency'] = Variable<String>(syncFrequency);
    }
    if (!nullToAbsent || enableJob != null) {
      map['enable_job'] = Variable<bool>(enableJob);
    }
    if (!nullToAbsent || lastRun != null) {
      map['last_run'] = Variable<DateTime>(lastRun);
    }
    if (!nullToAbsent || jobStatus != null) {
      map['job_status'] = Variable<String>(jobStatus);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    return map;
  }

  BackgroundJobScheduleCompanion toCompanion(bool nullToAbsent) {
    return BackgroundJobScheduleCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      jobName: jobName == null && nullToAbsent
          ? const Value.absent()
          : Value(jobName),
      startDateTime: startDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(startDateTime),
      syncFrequency: syncFrequency == null && nullToAbsent
          ? const Value.absent()
          : Value(syncFrequency),
      enableJob: enableJob == null && nullToAbsent
          ? const Value.absent()
          : Value(enableJob),
      lastRun: lastRun == null && nullToAbsent
          ? const Value.absent()
          : Value(lastRun),
      jobStatus: jobStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(jobStatus),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory BackgroundJobScheduleData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BackgroundJobScheduleData(
      id: serializer.fromJson<int>(json['id']),
      jobName: serializer.fromJson<String>(json['jobName']),
      startDateTime: serializer.fromJson<DateTime>(json['startDateTime']),
      syncFrequency: serializer.fromJson<String>(json['syncFrequency']),
      enableJob: serializer.fromJson<bool>(json['enableJob']),
      lastRun: serializer.fromJson<DateTime>(json['lastRun']),
      jobStatus: serializer.fromJson<String>(json['jobStatus']),
      tenantId: serializer.fromJson<int>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'jobName': serializer.toJson<String>(jobName),
      'startDateTime': serializer.toJson<DateTime>(startDateTime),
      'syncFrequency': serializer.toJson<String>(syncFrequency),
      'enableJob': serializer.toJson<bool>(enableJob),
      'lastRun': serializer.toJson<DateTime>(lastRun),
      'jobStatus': serializer.toJson<String>(jobStatus),
      'tenantId': serializer.toJson<int>(tenantId),
    };
  }

  BackgroundJobScheduleData copyWith(
          {int id,
          String jobName,
          DateTime startDateTime,
          String syncFrequency,
          bool enableJob,
          DateTime lastRun,
          String jobStatus,
          int tenantId}) =>
      BackgroundJobScheduleData(
        id: id ?? this.id,
        jobName: jobName ?? this.jobName,
        startDateTime: startDateTime ?? this.startDateTime,
        syncFrequency: syncFrequency ?? this.syncFrequency,
        enableJob: enableJob ?? this.enableJob,
        lastRun: lastRun ?? this.lastRun,
        jobStatus: jobStatus ?? this.jobStatus,
        tenantId: tenantId ?? this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('BackgroundJobScheduleData(')
          ..write('id: $id, ')
          ..write('jobName: $jobName, ')
          ..write('startDateTime: $startDateTime, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('enableJob: $enableJob, ')
          ..write('lastRun: $lastRun, ')
          ..write('jobStatus: $jobStatus, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, jobName, startDateTime, syncFrequency,
      enableJob, lastRun, jobStatus, tenantId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BackgroundJobScheduleData &&
          other.id == this.id &&
          other.jobName == this.jobName &&
          other.startDateTime == this.startDateTime &&
          other.syncFrequency == this.syncFrequency &&
          other.enableJob == this.enableJob &&
          other.lastRun == this.lastRun &&
          other.jobStatus == this.jobStatus &&
          other.tenantId == this.tenantId);
}

class BackgroundJobScheduleCompanion
    extends UpdateCompanion<BackgroundJobScheduleData> {
  final Value<int> id;
  final Value<String> jobName;
  final Value<DateTime> startDateTime;
  final Value<String> syncFrequency;
  final Value<bool> enableJob;
  final Value<DateTime> lastRun;
  final Value<String> jobStatus;
  final Value<int> tenantId;
  const BackgroundJobScheduleCompanion({
    this.id = const Value.absent(),
    this.jobName = const Value.absent(),
    this.startDateTime = const Value.absent(),
    this.syncFrequency = const Value.absent(),
    this.enableJob = const Value.absent(),
    this.lastRun = const Value.absent(),
    this.jobStatus = const Value.absent(),
    this.tenantId = const Value.absent(),
  });
  BackgroundJobScheduleCompanion.insert({
    this.id = const Value.absent(),
    @required String jobName,
    @required DateTime startDateTime,
    @required String syncFrequency,
    this.enableJob = const Value.absent(),
    @required DateTime lastRun,
    @required String jobStatus,
    this.tenantId = const Value.absent(),
  })  : jobName = Value(jobName),
        startDateTime = Value(startDateTime),
        syncFrequency = Value(syncFrequency),
        lastRun = Value(lastRun),
        jobStatus = Value(jobStatus);
  static Insertable<BackgroundJobScheduleData> custom({
    Expression<int> id,
    Expression<String> jobName,
    Expression<DateTime> startDateTime,
    Expression<String> syncFrequency,
    Expression<bool> enableJob,
    Expression<DateTime> lastRun,
    Expression<String> jobStatus,
    Expression<int> tenantId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (jobName != null) 'job_name': jobName,
      if (startDateTime != null) 'start_date_time': startDateTime,
      if (syncFrequency != null) 'sync_frequency': syncFrequency,
      if (enableJob != null) 'enable_job': enableJob,
      if (lastRun != null) 'last_run': lastRun,
      if (jobStatus != null) 'job_status': jobStatus,
      if (tenantId != null) 'tenant_id': tenantId,
    });
  }

  BackgroundJobScheduleCompanion copyWith(
      {Value<int> id,
      Value<String> jobName,
      Value<DateTime> startDateTime,
      Value<String> syncFrequency,
      Value<bool> enableJob,
      Value<DateTime> lastRun,
      Value<String> jobStatus,
      Value<int> tenantId}) {
    return BackgroundJobScheduleCompanion(
      id: id ?? this.id,
      jobName: jobName ?? this.jobName,
      startDateTime: startDateTime ?? this.startDateTime,
      syncFrequency: syncFrequency ?? this.syncFrequency,
      enableJob: enableJob ?? this.enableJob,
      lastRun: lastRun ?? this.lastRun,
      jobStatus: jobStatus ?? this.jobStatus,
      tenantId: tenantId ?? this.tenantId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (jobName.present) {
      map['job_name'] = Variable<String>(jobName.value);
    }
    if (startDateTime.present) {
      map['start_date_time'] = Variable<DateTime>(startDateTime.value);
    }
    if (syncFrequency.present) {
      map['sync_frequency'] = Variable<String>(syncFrequency.value);
    }
    if (enableJob.present) {
      map['enable_job'] = Variable<bool>(enableJob.value);
    }
    if (lastRun.present) {
      map['last_run'] = Variable<DateTime>(lastRun.value);
    }
    if (jobStatus.present) {
      map['job_status'] = Variable<String>(jobStatus.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BackgroundJobScheduleCompanion(')
          ..write('id: $id, ')
          ..write('jobName: $jobName, ')
          ..write('startDateTime: $startDateTime, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('enableJob: $enableJob, ')
          ..write('lastRun: $lastRun, ')
          ..write('jobStatus: $jobStatus, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }
}

class $BackgroundJobScheduleTable extends BackgroundJobSchedule
    with TableInfo<$BackgroundJobScheduleTable, BackgroundJobScheduleData> {
  final GeneratedDatabase _db;
  final String _alias;
  $BackgroundJobScheduleTable(this._db, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(),
          requiredDuringInsert: false,
          defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
  final VerificationMeta _jobNameMeta = const VerificationMeta('jobName');
  GeneratedColumn<String> _jobName;
  @override
  GeneratedColumn<String> get jobName =>
      _jobName ??= GeneratedColumn<String>('job_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _startDateTimeMeta =
      const VerificationMeta('startDateTime');
  GeneratedColumn<DateTime> _startDateTime;
  @override
  GeneratedColumn<DateTime> get startDateTime => _startDateTime ??=
      GeneratedColumn<DateTime>('start_date_time', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _syncFrequencyMeta =
      const VerificationMeta('syncFrequency');
  GeneratedColumn<String> _syncFrequency;
  @override
  GeneratedColumn<String> get syncFrequency => _syncFrequency ??=
      GeneratedColumn<String>('sync_frequency', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _enableJobMeta = const VerificationMeta('enableJob');
  GeneratedColumn<bool> _enableJob;
  @override
  GeneratedColumn<bool> get enableJob =>
      _enableJob ??= GeneratedColumn<bool>('enable_job', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (enable_job IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _lastRunMeta = const VerificationMeta('lastRun');
  GeneratedColumn<DateTime> _lastRun;
  @override
  GeneratedColumn<DateTime> get lastRun =>
      _lastRun ??= GeneratedColumn<DateTime>('last_run', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _jobStatusMeta = const VerificationMeta('jobStatus');
  GeneratedColumn<String> _jobStatus;
  @override
  GeneratedColumn<String> get jobStatus =>
      _jobStatus ??= GeneratedColumn<String>('job_status', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        jobName,
        startDateTime,
        syncFrequency,
        enableJob,
        lastRun,
        jobStatus,
        tenantId
      ];
  @override
  String get aliasedName => _alias ?? 'background_job_schedule';
  @override
  String get actualTableName => 'background_job_schedule';
  @override
  VerificationContext validateIntegrity(
      Insertable<BackgroundJobScheduleData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('job_name')) {
      context.handle(_jobNameMeta,
          jobName.isAcceptableOrUnknown(data['job_name'], _jobNameMeta));
    } else if (isInserting) {
      context.missing(_jobNameMeta);
    }
    if (data.containsKey('start_date_time')) {
      context.handle(
          _startDateTimeMeta,
          startDateTime.isAcceptableOrUnknown(
              data['start_date_time'], _startDateTimeMeta));
    } else if (isInserting) {
      context.missing(_startDateTimeMeta);
    }
    if (data.containsKey('sync_frequency')) {
      context.handle(
          _syncFrequencyMeta,
          syncFrequency.isAcceptableOrUnknown(
              data['sync_frequency'], _syncFrequencyMeta));
    } else if (isInserting) {
      context.missing(_syncFrequencyMeta);
    }
    if (data.containsKey('enable_job')) {
      context.handle(_enableJobMeta,
          enableJob.isAcceptableOrUnknown(data['enable_job'], _enableJobMeta));
    }
    if (data.containsKey('last_run')) {
      context.handle(_lastRunMeta,
          lastRun.isAcceptableOrUnknown(data['last_run'], _lastRunMeta));
    } else if (isInserting) {
      context.missing(_lastRunMeta);
    }
    if (data.containsKey('job_status')) {
      context.handle(_jobStatusMeta,
          jobStatus.isAcceptableOrUnknown(data['job_status'], _jobStatusMeta));
    } else if (isInserting) {
      context.missing(_jobStatusMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BackgroundJobScheduleData map(Map<String, dynamic> data,
      {String tablePrefix}) {
    return BackgroundJobScheduleData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $BackgroundJobScheduleTable createAlias(String alias) {
    return $BackgroundJobScheduleTable(_db, alias);
  }
}

class BackgroundJobLog extends DataClass
    implements Insertable<BackgroundJobLog> {
  final int id;
  final String jobName;
  final DateTime lastRun;
  final String jobStatus;
  final String jobDescription;
  final int tenantId;
  BackgroundJobLog(
      {@required this.id,
      @required this.jobName,
      @required this.lastRun,
      @required this.jobStatus,
      @required this.jobDescription,
      this.tenantId});
  factory BackgroundJobLog.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return BackgroundJobLog(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      jobName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}job_name']),
      lastRun: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}last_run']),
      jobStatus: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}job_status']),
      jobDescription: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}job_description']),
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || jobName != null) {
      map['job_name'] = Variable<String>(jobName);
    }
    if (!nullToAbsent || lastRun != null) {
      map['last_run'] = Variable<DateTime>(lastRun);
    }
    if (!nullToAbsent || jobStatus != null) {
      map['job_status'] = Variable<String>(jobStatus);
    }
    if (!nullToAbsent || jobDescription != null) {
      map['job_description'] = Variable<String>(jobDescription);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    return map;
  }

  BackgroundJobLogsCompanion toCompanion(bool nullToAbsent) {
    return BackgroundJobLogsCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      jobName: jobName == null && nullToAbsent
          ? const Value.absent()
          : Value(jobName),
      lastRun: lastRun == null && nullToAbsent
          ? const Value.absent()
          : Value(lastRun),
      jobStatus: jobStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(jobStatus),
      jobDescription: jobDescription == null && nullToAbsent
          ? const Value.absent()
          : Value(jobDescription),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory BackgroundJobLog.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BackgroundJobLog(
      id: serializer.fromJson<int>(json['id']),
      jobName: serializer.fromJson<String>(json['jobName']),
      lastRun: serializer.fromJson<DateTime>(json['lastRun']),
      jobStatus: serializer.fromJson<String>(json['jobStatus']),
      jobDescription: serializer.fromJson<String>(json['jobDescription']),
      tenantId: serializer.fromJson<int>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'jobName': serializer.toJson<String>(jobName),
      'lastRun': serializer.toJson<DateTime>(lastRun),
      'jobStatus': serializer.toJson<String>(jobStatus),
      'jobDescription': serializer.toJson<String>(jobDescription),
      'tenantId': serializer.toJson<int>(tenantId),
    };
  }

  BackgroundJobLog copyWith(
          {int id,
          String jobName,
          DateTime lastRun,
          String jobStatus,
          String jobDescription,
          int tenantId}) =>
      BackgroundJobLog(
        id: id ?? this.id,
        jobName: jobName ?? this.jobName,
        lastRun: lastRun ?? this.lastRun,
        jobStatus: jobStatus ?? this.jobStatus,
        jobDescription: jobDescription ?? this.jobDescription,
        tenantId: tenantId ?? this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('BackgroundJobLog(')
          ..write('id: $id, ')
          ..write('jobName: $jobName, ')
          ..write('lastRun: $lastRun, ')
          ..write('jobStatus: $jobStatus, ')
          ..write('jobDescription: $jobDescription, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, jobName, lastRun, jobStatus, jobDescription, tenantId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BackgroundJobLog &&
          other.id == this.id &&
          other.jobName == this.jobName &&
          other.lastRun == this.lastRun &&
          other.jobStatus == this.jobStatus &&
          other.jobDescription == this.jobDescription &&
          other.tenantId == this.tenantId);
}

class BackgroundJobLogsCompanion extends UpdateCompanion<BackgroundJobLog> {
  final Value<int> id;
  final Value<String> jobName;
  final Value<DateTime> lastRun;
  final Value<String> jobStatus;
  final Value<String> jobDescription;
  final Value<int> tenantId;
  const BackgroundJobLogsCompanion({
    this.id = const Value.absent(),
    this.jobName = const Value.absent(),
    this.lastRun = const Value.absent(),
    this.jobStatus = const Value.absent(),
    this.jobDescription = const Value.absent(),
    this.tenantId = const Value.absent(),
  });
  BackgroundJobLogsCompanion.insert({
    this.id = const Value.absent(),
    @required String jobName,
    @required DateTime lastRun,
    @required String jobStatus,
    @required String jobDescription,
    this.tenantId = const Value.absent(),
  })  : jobName = Value(jobName),
        lastRun = Value(lastRun),
        jobStatus = Value(jobStatus),
        jobDescription = Value(jobDescription);
  static Insertable<BackgroundJobLog> custom({
    Expression<int> id,
    Expression<String> jobName,
    Expression<DateTime> lastRun,
    Expression<String> jobStatus,
    Expression<String> jobDescription,
    Expression<int> tenantId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (jobName != null) 'job_name': jobName,
      if (lastRun != null) 'last_run': lastRun,
      if (jobStatus != null) 'job_status': jobStatus,
      if (jobDescription != null) 'job_description': jobDescription,
      if (tenantId != null) 'tenant_id': tenantId,
    });
  }

  BackgroundJobLogsCompanion copyWith(
      {Value<int> id,
      Value<String> jobName,
      Value<DateTime> lastRun,
      Value<String> jobStatus,
      Value<String> jobDescription,
      Value<int> tenantId}) {
    return BackgroundJobLogsCompanion(
      id: id ?? this.id,
      jobName: jobName ?? this.jobName,
      lastRun: lastRun ?? this.lastRun,
      jobStatus: jobStatus ?? this.jobStatus,
      jobDescription: jobDescription ?? this.jobDescription,
      tenantId: tenantId ?? this.tenantId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (jobName.present) {
      map['job_name'] = Variable<String>(jobName.value);
    }
    if (lastRun.present) {
      map['last_run'] = Variable<DateTime>(lastRun.value);
    }
    if (jobStatus.present) {
      map['job_status'] = Variable<String>(jobStatus.value);
    }
    if (jobDescription.present) {
      map['job_description'] = Variable<String>(jobDescription.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BackgroundJobLogsCompanion(')
          ..write('id: $id, ')
          ..write('jobName: $jobName, ')
          ..write('lastRun: $lastRun, ')
          ..write('jobStatus: $jobStatus, ')
          ..write('jobDescription: $jobDescription, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }
}

class $BackgroundJobLogsTable extends BackgroundJobLogs
    with TableInfo<$BackgroundJobLogsTable, BackgroundJobLog> {
  final GeneratedDatabase _db;
  final String _alias;
  $BackgroundJobLogsTable(this._db, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _jobNameMeta = const VerificationMeta('jobName');
  GeneratedColumn<String> _jobName;
  @override
  GeneratedColumn<String> get jobName =>
      _jobName ??= GeneratedColumn<String>('job_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _lastRunMeta = const VerificationMeta('lastRun');
  GeneratedColumn<DateTime> _lastRun;
  @override
  GeneratedColumn<DateTime> get lastRun =>
      _lastRun ??= GeneratedColumn<DateTime>('last_run', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _jobStatusMeta = const VerificationMeta('jobStatus');
  GeneratedColumn<String> _jobStatus;
  @override
  GeneratedColumn<String> get jobStatus =>
      _jobStatus ??= GeneratedColumn<String>('job_status', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _jobDescriptionMeta =
      const VerificationMeta('jobDescription');
  GeneratedColumn<String> _jobDescription;
  @override
  GeneratedColumn<String> get jobDescription => _jobDescription ??=
      GeneratedColumn<String>('job_description', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [id, jobName, lastRun, jobStatus, jobDescription, tenantId];
  @override
  String get aliasedName => _alias ?? 'background_job_logs';
  @override
  String get actualTableName => 'background_job_logs';
  @override
  VerificationContext validateIntegrity(Insertable<BackgroundJobLog> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('job_name')) {
      context.handle(_jobNameMeta,
          jobName.isAcceptableOrUnknown(data['job_name'], _jobNameMeta));
    } else if (isInserting) {
      context.missing(_jobNameMeta);
    }
    if (data.containsKey('last_run')) {
      context.handle(_lastRunMeta,
          lastRun.isAcceptableOrUnknown(data['last_run'], _lastRunMeta));
    } else if (isInserting) {
      context.missing(_lastRunMeta);
    }
    if (data.containsKey('job_status')) {
      context.handle(_jobStatusMeta,
          jobStatus.isAcceptableOrUnknown(data['job_status'], _jobStatusMeta));
    } else if (isInserting) {
      context.missing(_jobStatusMeta);
    }
    if (data.containsKey('job_description')) {
      context.handle(
          _jobDescriptionMeta,
          jobDescription.isAcceptableOrUnknown(
              data['job_description'], _jobDescriptionMeta));
    } else if (isInserting) {
      context.missing(_jobDescriptionMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BackgroundJobLog map(Map<String, dynamic> data, {String tablePrefix}) {
    return BackgroundJobLog.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $BackgroundJobLogsTable createAlias(String alias) {
    return $BackgroundJobLogsTable(_db, alias);
  }
}

class PreferenceData extends DataClass implements Insertable<PreferenceData> {
  final int id;
  final int tenantId;
  final String code;
  final String preferenceName;
  final String value;
  final String description;
  final String domain;
  final bool isGlobal;
  final String syncError;
  final DateTime expiredDateTime;
  final String dataType;
  final String dataValue;
  final String groups;
  PreferenceData(
      {@required this.id,
      @required this.tenantId,
      @required this.code,
      this.preferenceName,
      @required this.value,
      this.description,
      this.domain,
      @required this.isGlobal,
      this.syncError,
      this.expiredDateTime,
      this.dataType,
      this.dataValue,
      this.groups});
  factory PreferenceData.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return PreferenceData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      code: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}code']),
      preferenceName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}preference_name']),
      value: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}value']),
      description: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}description']),
      domain: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}domain']),
      isGlobal: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_global']),
      syncError: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sync_error']),
      expiredDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}expired_date_time']),
      dataType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}data_type']),
      dataValue: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}data_value']),
      groups: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}groups']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || preferenceName != null) {
      map['preference_name'] = Variable<String>(preferenceName);
    }
    if (!nullToAbsent || value != null) {
      map['value'] = Variable<String>(value);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || domain != null) {
      map['domain'] = Variable<String>(domain);
    }
    if (!nullToAbsent || isGlobal != null) {
      map['is_global'] = Variable<bool>(isGlobal);
    }
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || expiredDateTime != null) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || dataValue != null) {
      map['data_value'] = Variable<String>(dataValue);
    }
    if (!nullToAbsent || groups != null) {
      map['groups'] = Variable<String>(groups);
    }
    return map;
  }

  PreferenceCompanion toCompanion(bool nullToAbsent) {
    return PreferenceCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      preferenceName: preferenceName == null && nullToAbsent
          ? const Value.absent()
          : Value(preferenceName),
      value:
          value == null && nullToAbsent ? const Value.absent() : Value(value),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      domain:
          domain == null && nullToAbsent ? const Value.absent() : Value(domain),
      isGlobal: isGlobal == null && nullToAbsent
          ? const Value.absent()
          : Value(isGlobal),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      expiredDateTime: expiredDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(expiredDateTime),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      dataValue: dataValue == null && nullToAbsent
          ? const Value.absent()
          : Value(dataValue),
      groups:
          groups == null && nullToAbsent ? const Value.absent() : Value(groups),
    );
  }

  factory PreferenceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PreferenceData(
      id: serializer.fromJson<int>(json['id']),
      tenantId: serializer.fromJson<int>(json['tenantId']),
      code: serializer.fromJson<String>(json['code']),
      preferenceName: serializer.fromJson<String>(json['preferenceName']),
      value: serializer.fromJson<String>(json['value']),
      description: serializer.fromJson<String>(json['description']),
      domain: serializer.fromJson<String>(json['domain']),
      isGlobal: serializer.fromJson<bool>(json['isGlobal']),
      syncError: serializer.fromJson<String>(json['syncError']),
      expiredDateTime: serializer.fromJson<DateTime>(json['expiredDateTime']),
      dataType: serializer.fromJson<String>(json['dataType']),
      dataValue: serializer.fromJson<String>(json['dataValue']),
      groups: serializer.fromJson<String>(json['groups']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'tenantId': serializer.toJson<int>(tenantId),
      'code': serializer.toJson<String>(code),
      'preferenceName': serializer.toJson<String>(preferenceName),
      'value': serializer.toJson<String>(value),
      'description': serializer.toJson<String>(description),
      'domain': serializer.toJson<String>(domain),
      'isGlobal': serializer.toJson<bool>(isGlobal),
      'syncError': serializer.toJson<String>(syncError),
      'expiredDateTime': serializer.toJson<DateTime>(expiredDateTime),
      'dataType': serializer.toJson<String>(dataType),
      'dataValue': serializer.toJson<String>(dataValue),
      'groups': serializer.toJson<String>(groups),
    };
  }

  PreferenceData copyWith(
          {int id,
          int tenantId,
          String code,
          String preferenceName,
          String value,
          String description,
          String domain,
          bool isGlobal,
          String syncError,
          DateTime expiredDateTime,
          String dataType,
          String dataValue,
          String groups}) =>
      PreferenceData(
        id: id ?? this.id,
        tenantId: tenantId ?? this.tenantId,
        code: code ?? this.code,
        preferenceName: preferenceName ?? this.preferenceName,
        value: value ?? this.value,
        description: description ?? this.description,
        domain: domain ?? this.domain,
        isGlobal: isGlobal ?? this.isGlobal,
        syncError: syncError ?? this.syncError,
        expiredDateTime: expiredDateTime ?? this.expiredDateTime,
        dataType: dataType ?? this.dataType,
        dataValue: dataValue ?? this.dataValue,
        groups: groups ?? this.groups,
      );
  @override
  String toString() {
    return (StringBuffer('PreferenceData(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('preferenceName: $preferenceName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('domain: $domain, ')
          ..write('isGlobal: $isGlobal, ')
          ..write('syncError: $syncError, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      tenantId,
      code,
      preferenceName,
      value,
      description,
      domain,
      isGlobal,
      syncError,
      expiredDateTime,
      dataType,
      dataValue,
      groups);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PreferenceData &&
          other.id == this.id &&
          other.tenantId == this.tenantId &&
          other.code == this.code &&
          other.preferenceName == this.preferenceName &&
          other.value == this.value &&
          other.description == this.description &&
          other.domain == this.domain &&
          other.isGlobal == this.isGlobal &&
          other.syncError == this.syncError &&
          other.expiredDateTime == this.expiredDateTime &&
          other.dataType == this.dataType &&
          other.dataValue == this.dataValue &&
          other.groups == this.groups);
}

class PreferenceCompanion extends UpdateCompanion<PreferenceData> {
  final Value<int> id;
  final Value<int> tenantId;
  final Value<String> code;
  final Value<String> preferenceName;
  final Value<String> value;
  final Value<String> description;
  final Value<String> domain;
  final Value<bool> isGlobal;
  final Value<String> syncError;
  final Value<DateTime> expiredDateTime;
  final Value<String> dataType;
  final Value<String> dataValue;
  final Value<String> groups;
  const PreferenceCompanion({
    this.id = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.code = const Value.absent(),
    this.preferenceName = const Value.absent(),
    this.value = const Value.absent(),
    this.description = const Value.absent(),
    this.domain = const Value.absent(),
    this.isGlobal = const Value.absent(),
    this.syncError = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
  });
  PreferenceCompanion.insert({
    @required int id,
    @required int tenantId,
    @required String code,
    this.preferenceName = const Value.absent(),
    @required String value,
    this.description = const Value.absent(),
    this.domain = const Value.absent(),
    this.isGlobal = const Value.absent(),
    this.syncError = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
  })  : id = Value(id),
        tenantId = Value(tenantId),
        code = Value(code),
        value = Value(value);
  static Insertable<PreferenceData> custom({
    Expression<int> id,
    Expression<int> tenantId,
    Expression<String> code,
    Expression<String> preferenceName,
    Expression<String> value,
    Expression<String> description,
    Expression<String> domain,
    Expression<bool> isGlobal,
    Expression<String> syncError,
    Expression<DateTime> expiredDateTime,
    Expression<String> dataType,
    Expression<String> dataValue,
    Expression<String> groups,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (tenantId != null) 'tenant_id': tenantId,
      if (code != null) 'code': code,
      if (preferenceName != null) 'preference_name': preferenceName,
      if (value != null) 'value': value,
      if (description != null) 'description': description,
      if (domain != null) 'domain': domain,
      if (isGlobal != null) 'is_global': isGlobal,
      if (syncError != null) 'sync_error': syncError,
      if (expiredDateTime != null) 'expired_date_time': expiredDateTime,
      if (dataType != null) 'data_type': dataType,
      if (dataValue != null) 'data_value': dataValue,
      if (groups != null) 'groups': groups,
    });
  }

  PreferenceCompanion copyWith(
      {Value<int> id,
      Value<int> tenantId,
      Value<String> code,
      Value<String> preferenceName,
      Value<String> value,
      Value<String> description,
      Value<String> domain,
      Value<bool> isGlobal,
      Value<String> syncError,
      Value<DateTime> expiredDateTime,
      Value<String> dataType,
      Value<String> dataValue,
      Value<String> groups}) {
    return PreferenceCompanion(
      id: id ?? this.id,
      tenantId: tenantId ?? this.tenantId,
      code: code ?? this.code,
      preferenceName: preferenceName ?? this.preferenceName,
      value: value ?? this.value,
      description: description ?? this.description,
      domain: domain ?? this.domain,
      isGlobal: isGlobal ?? this.isGlobal,
      syncError: syncError ?? this.syncError,
      expiredDateTime: expiredDateTime ?? this.expiredDateTime,
      dataType: dataType ?? this.dataType,
      dataValue: dataValue ?? this.dataValue,
      groups: groups ?? this.groups,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (preferenceName.present) {
      map['preference_name'] = Variable<String>(preferenceName.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (domain.present) {
      map['domain'] = Variable<String>(domain.value);
    }
    if (isGlobal.present) {
      map['is_global'] = Variable<bool>(isGlobal.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (expiredDateTime.present) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (dataValue.present) {
      map['data_value'] = Variable<String>(dataValue.value);
    }
    if (groups.present) {
      map['groups'] = Variable<String>(groups.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PreferenceCompanion(')
          ..write('id: $id, ')
          ..write('tenantId: $tenantId, ')
          ..write('code: $code, ')
          ..write('preferenceName: $preferenceName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('domain: $domain, ')
          ..write('isGlobal: $isGlobal, ')
          ..write('syncError: $syncError, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups')
          ..write(')'))
        .toString();
  }
}

class $PreferenceTable extends Preference
    with TableInfo<$PreferenceTable, PreferenceData> {
  final GeneratedDatabase _db;
  final String _alias;
  $PreferenceTable(this._db, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _codeMeta = const VerificationMeta('code');
  GeneratedColumn<String> _code;
  @override
  GeneratedColumn<String> get code =>
      _code ??= GeneratedColumn<String>('code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _preferenceNameMeta =
      const VerificationMeta('preferenceName');
  GeneratedColumn<String> _preferenceName;
  @override
  GeneratedColumn<String> get preferenceName => _preferenceName ??=
      GeneratedColumn<String>('preference_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _valueMeta = const VerificationMeta('value');
  GeneratedColumn<String> _value;
  @override
  GeneratedColumn<String> get value =>
      _value ??= GeneratedColumn<String>('value', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  GeneratedColumn<String> _description;
  @override
  GeneratedColumn<String> get description =>
      _description ??= GeneratedColumn<String>('description', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _domainMeta = const VerificationMeta('domain');
  GeneratedColumn<String> _domain;
  @override
  GeneratedColumn<String> get domain =>
      _domain ??= GeneratedColumn<String>('domain', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isGlobalMeta = const VerificationMeta('isGlobal');
  GeneratedColumn<bool> _isGlobal;
  @override
  GeneratedColumn<bool> get isGlobal =>
      _isGlobal ??= GeneratedColumn<bool>('is_global', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_global IN (0, 1))',
          defaultValue: Constant(true));
  final VerificationMeta _syncErrorMeta = const VerificationMeta('syncError');
  GeneratedColumn<String> _syncError;
  @override
  GeneratedColumn<String> get syncError =>
      _syncError ??= GeneratedColumn<String>('sync_error', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _expiredDateTimeMeta =
      const VerificationMeta('expiredDateTime');
  GeneratedColumn<DateTime> _expiredDateTime;
  @override
  GeneratedColumn<DateTime> get expiredDateTime => _expiredDateTime ??=
      GeneratedColumn<DateTime>('expired_date_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _dataTypeMeta = const VerificationMeta('dataType');
  GeneratedColumn<String> _dataType;
  @override
  GeneratedColumn<String> get dataType =>
      _dataType ??= GeneratedColumn<String>('data_type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _dataValueMeta = const VerificationMeta('dataValue');
  GeneratedColumn<String> _dataValue;
  @override
  GeneratedColumn<String> get dataValue =>
      _dataValue ??= GeneratedColumn<String>('data_value', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _groupsMeta = const VerificationMeta('groups');
  GeneratedColumn<String> _groups;
  @override
  GeneratedColumn<String> get groups =>
      _groups ??= GeneratedColumn<String>('groups', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        tenantId,
        code,
        preferenceName,
        value,
        description,
        domain,
        isGlobal,
        syncError,
        expiredDateTime,
        dataType,
        dataValue,
        groups
      ];
  @override
  String get aliasedName => _alias ?? 'preference';
  @override
  String get actualTableName => 'preference';
  @override
  VerificationContext validateIntegrity(Insertable<PreferenceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    } else if (isInserting) {
      context.missing(_tenantIdMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code'], _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('preference_name')) {
      context.handle(
          _preferenceNameMeta,
          preferenceName.isAcceptableOrUnknown(
              data['preference_name'], _preferenceNameMeta));
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value'], _valueMeta));
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description'], _descriptionMeta));
    }
    if (data.containsKey('domain')) {
      context.handle(_domainMeta,
          domain.isAcceptableOrUnknown(data['domain'], _domainMeta));
    }
    if (data.containsKey('is_global')) {
      context.handle(_isGlobalMeta,
          isGlobal.isAcceptableOrUnknown(data['is_global'], _isGlobalMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error'], _syncErrorMeta));
    }
    if (data.containsKey('expired_date_time')) {
      context.handle(
          _expiredDateTimeMeta,
          expiredDateTime.isAcceptableOrUnknown(
              data['expired_date_time'], _expiredDateTimeMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type'], _dataTypeMeta));
    }
    if (data.containsKey('data_value')) {
      context.handle(_dataValueMeta,
          dataValue.isAcceptableOrUnknown(data['data_value'], _dataValueMeta));
    }
    if (data.containsKey('groups')) {
      context.handle(_groupsMeta,
          groups.isAcceptableOrUnknown(data['groups'], _groupsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  PreferenceData map(Map<String, dynamic> data, {String tablePrefix}) {
    return PreferenceData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $PreferenceTable createAlias(String alias) {
    return $PreferenceTable(_db, alias);
  }
}

class MobileDeviceData extends DataClass
    implements Insertable<MobileDeviceData> {
  final DateTime creationTime;
  final DateTime deleteTime;
  final int createUserId;
  final String creatorUser;
  final String lastModifierUser;
  final int lastModifierUserId;
  final int deleteUserId;
  final String deleterUserId;
  final bool isDeleted;
  final DateTime importDateTime;
  final DateTime exportDateTime;
  final String exportStatus;
  final String importStatus;
  final String syncError;
  final String deviceId;
  final String deviceName;
  final String versionRelease;
  final String versionEnvrement;
  final String bootLoader;
  final String manufacture;
  final String model;
  final int sdkNumber;
  final String hardware;
  final String deviceHost;
  final DateTime deviceTime;
  final String deviceSerial;
  final String deviceMac;
  final String deviceIp;
  final String deviceMode;
  final DateTime activationDate;
  final DateTime expirationDate;
  final int deviceStatus;
  final String companyName;
  final String deviceNickName;
  final double latitude;
  final double longitude;
  final int tenantId;
  MobileDeviceData(
      {this.creationTime,
      this.deleteTime,
      this.createUserId,
      this.creatorUser,
      this.lastModifierUser,
      this.lastModifierUserId,
      this.deleteUserId,
      this.deleterUserId,
      @required this.isDeleted,
      this.importDateTime,
      this.exportDateTime,
      @required this.exportStatus,
      @required this.importStatus,
      this.syncError,
      this.deviceId,
      this.deviceName,
      this.versionRelease,
      this.versionEnvrement,
      this.bootLoader,
      this.manufacture,
      this.model,
      this.sdkNumber,
      this.hardware,
      this.deviceHost,
      this.deviceTime,
      this.deviceSerial,
      this.deviceMac,
      this.deviceIp,
      this.deviceMode,
      this.activationDate,
      this.expirationDate,
      this.deviceStatus,
      this.companyName,
      this.deviceNickName,
      this.latitude,
      this.longitude,
      this.tenantId});
  factory MobileDeviceData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return MobileDeviceData(
      creationTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}creation_time']),
      deleteTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}delete_time']),
      createUserId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}create_user_id']),
      creatorUser: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}creator_user']),
      lastModifierUser: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}last_modifier_user']),
      lastModifierUserId: const IntType().mapFromDatabaseResponse(
          data['${effectivePrefix}last_modifier_user_id']),
      deleteUserId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}delete_user_id']),
      deleterUserId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}deleter_user_id']),
      isDeleted: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_deleted']),
      importDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}import_date_time']),
      exportDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}export_date_time']),
      exportStatus: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}export_status']),
      importStatus: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}import_status']),
      syncError: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sync_error']),
      deviceId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_id']),
      deviceName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_name']),
      versionRelease: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}version_release']),
      versionEnvrement: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}version_envrement']),
      bootLoader: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}boot_loader']),
      manufacture: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}manufacture']),
      model: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}model']),
      sdkNumber: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sdk_number']),
      hardware: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}hardware']),
      deviceHost: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_host']),
      deviceTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_time']),
      deviceSerial: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_serial']),
      deviceMac: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_mac']),
      deviceIp: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_ip']),
      deviceMode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_mode']),
      activationDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}activation_date']),
      expirationDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}expiration_date']),
      deviceStatus: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_status']),
      companyName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}company_name']),
      deviceNickName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_nick_name']),
      latitude: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}latitude']),
      longitude: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}longitude']),
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || creationTime != null) {
      map['creation_time'] = Variable<DateTime>(creationTime);
    }
    if (!nullToAbsent || deleteTime != null) {
      map['delete_time'] = Variable<DateTime>(deleteTime);
    }
    if (!nullToAbsent || createUserId != null) {
      map['create_user_id'] = Variable<int>(createUserId);
    }
    if (!nullToAbsent || creatorUser != null) {
      map['creator_user'] = Variable<String>(creatorUser);
    }
    if (!nullToAbsent || lastModifierUser != null) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser);
    }
    if (!nullToAbsent || lastModifierUserId != null) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId);
    }
    if (!nullToAbsent || deleteUserId != null) {
      map['delete_user_id'] = Variable<int>(deleteUserId);
    }
    if (!nullToAbsent || deleterUserId != null) {
      map['deleter_user_id'] = Variable<String>(deleterUserId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || importDateTime != null) {
      map['import_date_time'] = Variable<DateTime>(importDateTime);
    }
    if (!nullToAbsent || exportDateTime != null) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime);
    }
    if (!nullToAbsent || exportStatus != null) {
      map['export_status'] = Variable<String>(exportStatus);
    }
    if (!nullToAbsent || importStatus != null) {
      map['import_status'] = Variable<String>(importStatus);
    }
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || deviceName != null) {
      map['device_name'] = Variable<String>(deviceName);
    }
    if (!nullToAbsent || versionRelease != null) {
      map['version_release'] = Variable<String>(versionRelease);
    }
    if (!nullToAbsent || versionEnvrement != null) {
      map['version_envrement'] = Variable<String>(versionEnvrement);
    }
    if (!nullToAbsent || bootLoader != null) {
      map['boot_loader'] = Variable<String>(bootLoader);
    }
    if (!nullToAbsent || manufacture != null) {
      map['manufacture'] = Variable<String>(manufacture);
    }
    if (!nullToAbsent || model != null) {
      map['model'] = Variable<String>(model);
    }
    if (!nullToAbsent || sdkNumber != null) {
      map['sdk_number'] = Variable<int>(sdkNumber);
    }
    if (!nullToAbsent || hardware != null) {
      map['hardware'] = Variable<String>(hardware);
    }
    if (!nullToAbsent || deviceHost != null) {
      map['device_host'] = Variable<String>(deviceHost);
    }
    if (!nullToAbsent || deviceTime != null) {
      map['device_time'] = Variable<DateTime>(deviceTime);
    }
    if (!nullToAbsent || deviceSerial != null) {
      map['device_serial'] = Variable<String>(deviceSerial);
    }
    if (!nullToAbsent || deviceMac != null) {
      map['device_mac'] = Variable<String>(deviceMac);
    }
    if (!nullToAbsent || deviceIp != null) {
      map['device_ip'] = Variable<String>(deviceIp);
    }
    if (!nullToAbsent || deviceMode != null) {
      map['device_mode'] = Variable<String>(deviceMode);
    }
    if (!nullToAbsent || activationDate != null) {
      map['activation_date'] = Variable<DateTime>(activationDate);
    }
    if (!nullToAbsent || expirationDate != null) {
      map['expiration_date'] = Variable<DateTime>(expirationDate);
    }
    if (!nullToAbsent || deviceStatus != null) {
      map['device_status'] = Variable<int>(deviceStatus);
    }
    if (!nullToAbsent || companyName != null) {
      map['company_name'] = Variable<String>(companyName);
    }
    if (!nullToAbsent || deviceNickName != null) {
      map['device_nick_name'] = Variable<String>(deviceNickName);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    return map;
  }

  MobileDeviceCompanion toCompanion(bool nullToAbsent) {
    return MobileDeviceCompanion(
      creationTime: creationTime == null && nullToAbsent
          ? const Value.absent()
          : Value(creationTime),
      deleteTime: deleteTime == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteTime),
      createUserId: createUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(createUserId),
      creatorUser: creatorUser == null && nullToAbsent
          ? const Value.absent()
          : Value(creatorUser),
      lastModifierUser: lastModifierUser == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUser),
      lastModifierUserId: lastModifierUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUserId),
      deleteUserId: deleteUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteUserId),
      deleterUserId: deleterUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleterUserId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      importDateTime: importDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(importDateTime),
      exportDateTime: exportDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(exportDateTime),
      exportStatus: exportStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(exportStatus),
      importStatus: importStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(importStatus),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      deviceName: deviceName == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceName),
      versionRelease: versionRelease == null && nullToAbsent
          ? const Value.absent()
          : Value(versionRelease),
      versionEnvrement: versionEnvrement == null && nullToAbsent
          ? const Value.absent()
          : Value(versionEnvrement),
      bootLoader: bootLoader == null && nullToAbsent
          ? const Value.absent()
          : Value(bootLoader),
      manufacture: manufacture == null && nullToAbsent
          ? const Value.absent()
          : Value(manufacture),
      model:
          model == null && nullToAbsent ? const Value.absent() : Value(model),
      sdkNumber: sdkNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(sdkNumber),
      hardware: hardware == null && nullToAbsent
          ? const Value.absent()
          : Value(hardware),
      deviceHost: deviceHost == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceHost),
      deviceTime: deviceTime == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceTime),
      deviceSerial: deviceSerial == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceSerial),
      deviceMac: deviceMac == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceMac),
      deviceIp: deviceIp == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceIp),
      deviceMode: deviceMode == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceMode),
      activationDate: activationDate == null && nullToAbsent
          ? const Value.absent()
          : Value(activationDate),
      expirationDate: expirationDate == null && nullToAbsent
          ? const Value.absent()
          : Value(expirationDate),
      deviceStatus: deviceStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceStatus),
      companyName: companyName == null && nullToAbsent
          ? const Value.absent()
          : Value(companyName),
      deviceNickName: deviceNickName == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceNickName),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory MobileDeviceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MobileDeviceData(
      creationTime: serializer.fromJson<DateTime>(json['creationTime']),
      deleteTime: serializer.fromJson<DateTime>(json['deleteTime']),
      createUserId: serializer.fromJson<int>(json['createUserId']),
      creatorUser: serializer.fromJson<String>(json['creatorUser']),
      lastModifierUser: serializer.fromJson<String>(json['lastModifierUser']),
      lastModifierUserId: serializer.fromJson<int>(json['lastModifierUserId']),
      deleteUserId: serializer.fromJson<int>(json['deleteUserId']),
      deleterUserId: serializer.fromJson<String>(json['deleterUserId']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      importDateTime: serializer.fromJson<DateTime>(json['importDateTime']),
      exportDateTime: serializer.fromJson<DateTime>(json['exportDateTime']),
      exportStatus: serializer.fromJson<String>(json['exportStatus']),
      importStatus: serializer.fromJson<String>(json['importStatus']),
      syncError: serializer.fromJson<String>(json['syncError']),
      deviceId: serializer.fromJson<String>(json['deviceId']),
      deviceName: serializer.fromJson<String>(json['deviceName']),
      versionRelease: serializer.fromJson<String>(json['versionRelease']),
      versionEnvrement: serializer.fromJson<String>(json['versionEnvrement']),
      bootLoader: serializer.fromJson<String>(json['bootLoader']),
      manufacture: serializer.fromJson<String>(json['manufacture']),
      model: serializer.fromJson<String>(json['model']),
      sdkNumber: serializer.fromJson<int>(json['sdkNumber']),
      hardware: serializer.fromJson<String>(json['hardware']),
      deviceHost: serializer.fromJson<String>(json['deviceHost']),
      deviceTime: serializer.fromJson<DateTime>(json['deviceTime']),
      deviceSerial: serializer.fromJson<String>(json['deviceSerial']),
      deviceMac: serializer.fromJson<String>(json['deviceMac']),
      deviceIp: serializer.fromJson<String>(json['deviceIp']),
      deviceMode: serializer.fromJson<String>(json['deviceMode']),
      activationDate: serializer.fromJson<DateTime>(json['activationDate']),
      expirationDate: serializer.fromJson<DateTime>(json['expirationDate']),
      deviceStatus: serializer.fromJson<int>(json['deviceStatus']),
      companyName: serializer.fromJson<String>(json['companyName']),
      deviceNickName: serializer.fromJson<String>(json['deviceNickName']),
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      tenantId: serializer.fromJson<int>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'creationTime': serializer.toJson<DateTime>(creationTime),
      'deleteTime': serializer.toJson<DateTime>(deleteTime),
      'createUserId': serializer.toJson<int>(createUserId),
      'creatorUser': serializer.toJson<String>(creatorUser),
      'lastModifierUser': serializer.toJson<String>(lastModifierUser),
      'lastModifierUserId': serializer.toJson<int>(lastModifierUserId),
      'deleteUserId': serializer.toJson<int>(deleteUserId),
      'deleterUserId': serializer.toJson<String>(deleterUserId),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'importDateTime': serializer.toJson<DateTime>(importDateTime),
      'exportDateTime': serializer.toJson<DateTime>(exportDateTime),
      'exportStatus': serializer.toJson<String>(exportStatus),
      'importStatus': serializer.toJson<String>(importStatus),
      'syncError': serializer.toJson<String>(syncError),
      'deviceId': serializer.toJson<String>(deviceId),
      'deviceName': serializer.toJson<String>(deviceName),
      'versionRelease': serializer.toJson<String>(versionRelease),
      'versionEnvrement': serializer.toJson<String>(versionEnvrement),
      'bootLoader': serializer.toJson<String>(bootLoader),
      'manufacture': serializer.toJson<String>(manufacture),
      'model': serializer.toJson<String>(model),
      'sdkNumber': serializer.toJson<int>(sdkNumber),
      'hardware': serializer.toJson<String>(hardware),
      'deviceHost': serializer.toJson<String>(deviceHost),
      'deviceTime': serializer.toJson<DateTime>(deviceTime),
      'deviceSerial': serializer.toJson<String>(deviceSerial),
      'deviceMac': serializer.toJson<String>(deviceMac),
      'deviceIp': serializer.toJson<String>(deviceIp),
      'deviceMode': serializer.toJson<String>(deviceMode),
      'activationDate': serializer.toJson<DateTime>(activationDate),
      'expirationDate': serializer.toJson<DateTime>(expirationDate),
      'deviceStatus': serializer.toJson<int>(deviceStatus),
      'companyName': serializer.toJson<String>(companyName),
      'deviceNickName': serializer.toJson<String>(deviceNickName),
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'tenantId': serializer.toJson<int>(tenantId),
    };
  }

  MobileDeviceData copyWith(
          {DateTime creationTime,
          DateTime deleteTime,
          int createUserId,
          String creatorUser,
          String lastModifierUser,
          int lastModifierUserId,
          int deleteUserId,
          String deleterUserId,
          bool isDeleted,
          DateTime importDateTime,
          DateTime exportDateTime,
          String exportStatus,
          String importStatus,
          String syncError,
          String deviceId,
          String deviceName,
          String versionRelease,
          String versionEnvrement,
          String bootLoader,
          String manufacture,
          String model,
          int sdkNumber,
          String hardware,
          String deviceHost,
          DateTime deviceTime,
          String deviceSerial,
          String deviceMac,
          String deviceIp,
          String deviceMode,
          DateTime activationDate,
          DateTime expirationDate,
          int deviceStatus,
          String companyName,
          String deviceNickName,
          double latitude,
          double longitude,
          int tenantId}) =>
      MobileDeviceData(
        creationTime: creationTime ?? this.creationTime,
        deleteTime: deleteTime ?? this.deleteTime,
        createUserId: createUserId ?? this.createUserId,
        creatorUser: creatorUser ?? this.creatorUser,
        lastModifierUser: lastModifierUser ?? this.lastModifierUser,
        lastModifierUserId: lastModifierUserId ?? this.lastModifierUserId,
        deleteUserId: deleteUserId ?? this.deleteUserId,
        deleterUserId: deleterUserId ?? this.deleterUserId,
        isDeleted: isDeleted ?? this.isDeleted,
        importDateTime: importDateTime ?? this.importDateTime,
        exportDateTime: exportDateTime ?? this.exportDateTime,
        exportStatus: exportStatus ?? this.exportStatus,
        importStatus: importStatus ?? this.importStatus,
        syncError: syncError ?? this.syncError,
        deviceId: deviceId ?? this.deviceId,
        deviceName: deviceName ?? this.deviceName,
        versionRelease: versionRelease ?? this.versionRelease,
        versionEnvrement: versionEnvrement ?? this.versionEnvrement,
        bootLoader: bootLoader ?? this.bootLoader,
        manufacture: manufacture ?? this.manufacture,
        model: model ?? this.model,
        sdkNumber: sdkNumber ?? this.sdkNumber,
        hardware: hardware ?? this.hardware,
        deviceHost: deviceHost ?? this.deviceHost,
        deviceTime: deviceTime ?? this.deviceTime,
        deviceSerial: deviceSerial ?? this.deviceSerial,
        deviceMac: deviceMac ?? this.deviceMac,
        deviceIp: deviceIp ?? this.deviceIp,
        deviceMode: deviceMode ?? this.deviceMode,
        activationDate: activationDate ?? this.activationDate,
        expirationDate: expirationDate ?? this.expirationDate,
        deviceStatus: deviceStatus ?? this.deviceStatus,
        companyName: companyName ?? this.companyName,
        deviceNickName: deviceNickName ?? this.deviceNickName,
        latitude: latitude ?? this.latitude,
        longitude: longitude ?? this.longitude,
        tenantId: tenantId ?? this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('MobileDeviceData(')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('createUserId: $createUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('importDateTime: $importDateTime, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('importStatus: $importStatus, ')
          ..write('syncError: $syncError, ')
          ..write('deviceId: $deviceId, ')
          ..write('deviceName: $deviceName, ')
          ..write('versionRelease: $versionRelease, ')
          ..write('versionEnvrement: $versionEnvrement, ')
          ..write('bootLoader: $bootLoader, ')
          ..write('manufacture: $manufacture, ')
          ..write('model: $model, ')
          ..write('sdkNumber: $sdkNumber, ')
          ..write('hardware: $hardware, ')
          ..write('deviceHost: $deviceHost, ')
          ..write('deviceTime: $deviceTime, ')
          ..write('deviceSerial: $deviceSerial, ')
          ..write('deviceMac: $deviceMac, ')
          ..write('deviceIp: $deviceIp, ')
          ..write('deviceMode: $deviceMode, ')
          ..write('activationDate: $activationDate, ')
          ..write('expirationDate: $expirationDate, ')
          ..write('deviceStatus: $deviceStatus, ')
          ..write('companyName: $companyName, ')
          ..write('deviceNickName: $deviceNickName, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        creationTime,
        deleteTime,
        createUserId,
        creatorUser,
        lastModifierUser,
        lastModifierUserId,
        deleteUserId,
        deleterUserId,
        isDeleted,
        importDateTime,
        exportDateTime,
        exportStatus,
        importStatus,
        syncError,
        deviceId,
        deviceName,
        versionRelease,
        versionEnvrement,
        bootLoader,
        manufacture,
        model,
        sdkNumber,
        hardware,
        deviceHost,
        deviceTime,
        deviceSerial,
        deviceMac,
        deviceIp,
        deviceMode,
        activationDate,
        expirationDate,
        deviceStatus,
        companyName,
        deviceNickName,
        latitude,
        longitude,
        tenantId
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MobileDeviceData &&
          other.creationTime == this.creationTime &&
          other.deleteTime == this.deleteTime &&
          other.createUserId == this.createUserId &&
          other.creatorUser == this.creatorUser &&
          other.lastModifierUser == this.lastModifierUser &&
          other.lastModifierUserId == this.lastModifierUserId &&
          other.deleteUserId == this.deleteUserId &&
          other.deleterUserId == this.deleterUserId &&
          other.isDeleted == this.isDeleted &&
          other.importDateTime == this.importDateTime &&
          other.exportDateTime == this.exportDateTime &&
          other.exportStatus == this.exportStatus &&
          other.importStatus == this.importStatus &&
          other.syncError == this.syncError &&
          other.deviceId == this.deviceId &&
          other.deviceName == this.deviceName &&
          other.versionRelease == this.versionRelease &&
          other.versionEnvrement == this.versionEnvrement &&
          other.bootLoader == this.bootLoader &&
          other.manufacture == this.manufacture &&
          other.model == this.model &&
          other.sdkNumber == this.sdkNumber &&
          other.hardware == this.hardware &&
          other.deviceHost == this.deviceHost &&
          other.deviceTime == this.deviceTime &&
          other.deviceSerial == this.deviceSerial &&
          other.deviceMac == this.deviceMac &&
          other.deviceIp == this.deviceIp &&
          other.deviceMode == this.deviceMode &&
          other.activationDate == this.activationDate &&
          other.expirationDate == this.expirationDate &&
          other.deviceStatus == this.deviceStatus &&
          other.companyName == this.companyName &&
          other.deviceNickName == this.deviceNickName &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.tenantId == this.tenantId);
}

class MobileDeviceCompanion extends UpdateCompanion<MobileDeviceData> {
  final Value<DateTime> creationTime;
  final Value<DateTime> deleteTime;
  final Value<int> createUserId;
  final Value<String> creatorUser;
  final Value<String> lastModifierUser;
  final Value<int> lastModifierUserId;
  final Value<int> deleteUserId;
  final Value<String> deleterUserId;
  final Value<bool> isDeleted;
  final Value<DateTime> importDateTime;
  final Value<DateTime> exportDateTime;
  final Value<String> exportStatus;
  final Value<String> importStatus;
  final Value<String> syncError;
  final Value<String> deviceId;
  final Value<String> deviceName;
  final Value<String> versionRelease;
  final Value<String> versionEnvrement;
  final Value<String> bootLoader;
  final Value<String> manufacture;
  final Value<String> model;
  final Value<int> sdkNumber;
  final Value<String> hardware;
  final Value<String> deviceHost;
  final Value<DateTime> deviceTime;
  final Value<String> deviceSerial;
  final Value<String> deviceMac;
  final Value<String> deviceIp;
  final Value<String> deviceMode;
  final Value<DateTime> activationDate;
  final Value<DateTime> expirationDate;
  final Value<int> deviceStatus;
  final Value<String> companyName;
  final Value<String> deviceNickName;
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<int> tenantId;
  const MobileDeviceCompanion({
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.importDateTime = const Value.absent(),
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.importStatus = const Value.absent(),
    this.syncError = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.deviceName = const Value.absent(),
    this.versionRelease = const Value.absent(),
    this.versionEnvrement = const Value.absent(),
    this.bootLoader = const Value.absent(),
    this.manufacture = const Value.absent(),
    this.model = const Value.absent(),
    this.sdkNumber = const Value.absent(),
    this.hardware = const Value.absent(),
    this.deviceHost = const Value.absent(),
    this.deviceTime = const Value.absent(),
    this.deviceSerial = const Value.absent(),
    this.deviceMac = const Value.absent(),
    this.deviceIp = const Value.absent(),
    this.deviceMode = const Value.absent(),
    this.activationDate = const Value.absent(),
    this.expirationDate = const Value.absent(),
    this.deviceStatus = const Value.absent(),
    this.companyName = const Value.absent(),
    this.deviceNickName = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.tenantId = const Value.absent(),
  });
  MobileDeviceCompanion.insert({
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.importDateTime = const Value.absent(),
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.importStatus = const Value.absent(),
    this.syncError = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.deviceName = const Value.absent(),
    this.versionRelease = const Value.absent(),
    this.versionEnvrement = const Value.absent(),
    this.bootLoader = const Value.absent(),
    this.manufacture = const Value.absent(),
    this.model = const Value.absent(),
    this.sdkNumber = const Value.absent(),
    this.hardware = const Value.absent(),
    this.deviceHost = const Value.absent(),
    this.deviceTime = const Value.absent(),
    this.deviceSerial = const Value.absent(),
    this.deviceMac = const Value.absent(),
    this.deviceIp = const Value.absent(),
    this.deviceMode = const Value.absent(),
    this.activationDate = const Value.absent(),
    this.expirationDate = const Value.absent(),
    this.deviceStatus = const Value.absent(),
    this.companyName = const Value.absent(),
    this.deviceNickName = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.tenantId = const Value.absent(),
  });
  static Insertable<MobileDeviceData> custom({
    Expression<DateTime> creationTime,
    Expression<DateTime> deleteTime,
    Expression<int> createUserId,
    Expression<String> creatorUser,
    Expression<String> lastModifierUser,
    Expression<int> lastModifierUserId,
    Expression<int> deleteUserId,
    Expression<String> deleterUserId,
    Expression<bool> isDeleted,
    Expression<DateTime> importDateTime,
    Expression<DateTime> exportDateTime,
    Expression<String> exportStatus,
    Expression<String> importStatus,
    Expression<String> syncError,
    Expression<String> deviceId,
    Expression<String> deviceName,
    Expression<String> versionRelease,
    Expression<String> versionEnvrement,
    Expression<String> bootLoader,
    Expression<String> manufacture,
    Expression<String> model,
    Expression<int> sdkNumber,
    Expression<String> hardware,
    Expression<String> deviceHost,
    Expression<DateTime> deviceTime,
    Expression<String> deviceSerial,
    Expression<String> deviceMac,
    Expression<String> deviceIp,
    Expression<String> deviceMode,
    Expression<DateTime> activationDate,
    Expression<DateTime> expirationDate,
    Expression<int> deviceStatus,
    Expression<String> companyName,
    Expression<String> deviceNickName,
    Expression<double> latitude,
    Expression<double> longitude,
    Expression<int> tenantId,
  }) {
    return RawValuesInsertable({
      if (creationTime != null) 'creation_time': creationTime,
      if (deleteTime != null) 'delete_time': deleteTime,
      if (createUserId != null) 'create_user_id': createUserId,
      if (creatorUser != null) 'creator_user': creatorUser,
      if (lastModifierUser != null) 'last_modifier_user': lastModifierUser,
      if (lastModifierUserId != null)
        'last_modifier_user_id': lastModifierUserId,
      if (deleteUserId != null) 'delete_user_id': deleteUserId,
      if (deleterUserId != null) 'deleter_user_id': deleterUserId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (importDateTime != null) 'import_date_time': importDateTime,
      if (exportDateTime != null) 'export_date_time': exportDateTime,
      if (exportStatus != null) 'export_status': exportStatus,
      if (importStatus != null) 'import_status': importStatus,
      if (syncError != null) 'sync_error': syncError,
      if (deviceId != null) 'device_id': deviceId,
      if (deviceName != null) 'device_name': deviceName,
      if (versionRelease != null) 'version_release': versionRelease,
      if (versionEnvrement != null) 'version_envrement': versionEnvrement,
      if (bootLoader != null) 'boot_loader': bootLoader,
      if (manufacture != null) 'manufacture': manufacture,
      if (model != null) 'model': model,
      if (sdkNumber != null) 'sdk_number': sdkNumber,
      if (hardware != null) 'hardware': hardware,
      if (deviceHost != null) 'device_host': deviceHost,
      if (deviceTime != null) 'device_time': deviceTime,
      if (deviceSerial != null) 'device_serial': deviceSerial,
      if (deviceMac != null) 'device_mac': deviceMac,
      if (deviceIp != null) 'device_ip': deviceIp,
      if (deviceMode != null) 'device_mode': deviceMode,
      if (activationDate != null) 'activation_date': activationDate,
      if (expirationDate != null) 'expiration_date': expirationDate,
      if (deviceStatus != null) 'device_status': deviceStatus,
      if (companyName != null) 'company_name': companyName,
      if (deviceNickName != null) 'device_nick_name': deviceNickName,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (tenantId != null) 'tenant_id': tenantId,
    });
  }

  MobileDeviceCompanion copyWith(
      {Value<DateTime> creationTime,
      Value<DateTime> deleteTime,
      Value<int> createUserId,
      Value<String> creatorUser,
      Value<String> lastModifierUser,
      Value<int> lastModifierUserId,
      Value<int> deleteUserId,
      Value<String> deleterUserId,
      Value<bool> isDeleted,
      Value<DateTime> importDateTime,
      Value<DateTime> exportDateTime,
      Value<String> exportStatus,
      Value<String> importStatus,
      Value<String> syncError,
      Value<String> deviceId,
      Value<String> deviceName,
      Value<String> versionRelease,
      Value<String> versionEnvrement,
      Value<String> bootLoader,
      Value<String> manufacture,
      Value<String> model,
      Value<int> sdkNumber,
      Value<String> hardware,
      Value<String> deviceHost,
      Value<DateTime> deviceTime,
      Value<String> deviceSerial,
      Value<String> deviceMac,
      Value<String> deviceIp,
      Value<String> deviceMode,
      Value<DateTime> activationDate,
      Value<DateTime> expirationDate,
      Value<int> deviceStatus,
      Value<String> companyName,
      Value<String> deviceNickName,
      Value<double> latitude,
      Value<double> longitude,
      Value<int> tenantId}) {
    return MobileDeviceCompanion(
      creationTime: creationTime ?? this.creationTime,
      deleteTime: deleteTime ?? this.deleteTime,
      createUserId: createUserId ?? this.createUserId,
      creatorUser: creatorUser ?? this.creatorUser,
      lastModifierUser: lastModifierUser ?? this.lastModifierUser,
      lastModifierUserId: lastModifierUserId ?? this.lastModifierUserId,
      deleteUserId: deleteUserId ?? this.deleteUserId,
      deleterUserId: deleterUserId ?? this.deleterUserId,
      isDeleted: isDeleted ?? this.isDeleted,
      importDateTime: importDateTime ?? this.importDateTime,
      exportDateTime: exportDateTime ?? this.exportDateTime,
      exportStatus: exportStatus ?? this.exportStatus,
      importStatus: importStatus ?? this.importStatus,
      syncError: syncError ?? this.syncError,
      deviceId: deviceId ?? this.deviceId,
      deviceName: deviceName ?? this.deviceName,
      versionRelease: versionRelease ?? this.versionRelease,
      versionEnvrement: versionEnvrement ?? this.versionEnvrement,
      bootLoader: bootLoader ?? this.bootLoader,
      manufacture: manufacture ?? this.manufacture,
      model: model ?? this.model,
      sdkNumber: sdkNumber ?? this.sdkNumber,
      hardware: hardware ?? this.hardware,
      deviceHost: deviceHost ?? this.deviceHost,
      deviceTime: deviceTime ?? this.deviceTime,
      deviceSerial: deviceSerial ?? this.deviceSerial,
      deviceMac: deviceMac ?? this.deviceMac,
      deviceIp: deviceIp ?? this.deviceIp,
      deviceMode: deviceMode ?? this.deviceMode,
      activationDate: activationDate ?? this.activationDate,
      expirationDate: expirationDate ?? this.expirationDate,
      deviceStatus: deviceStatus ?? this.deviceStatus,
      companyName: companyName ?? this.companyName,
      deviceNickName: deviceNickName ?? this.deviceNickName,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      tenantId: tenantId ?? this.tenantId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (creationTime.present) {
      map['creation_time'] = Variable<DateTime>(creationTime.value);
    }
    if (deleteTime.present) {
      map['delete_time'] = Variable<DateTime>(deleteTime.value);
    }
    if (createUserId.present) {
      map['create_user_id'] = Variable<int>(createUserId.value);
    }
    if (creatorUser.present) {
      map['creator_user'] = Variable<String>(creatorUser.value);
    }
    if (lastModifierUser.present) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser.value);
    }
    if (lastModifierUserId.present) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId.value);
    }
    if (deleteUserId.present) {
      map['delete_user_id'] = Variable<int>(deleteUserId.value);
    }
    if (deleterUserId.present) {
      map['deleter_user_id'] = Variable<String>(deleterUserId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (importDateTime.present) {
      map['import_date_time'] = Variable<DateTime>(importDateTime.value);
    }
    if (exportDateTime.present) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime.value);
    }
    if (exportStatus.present) {
      map['export_status'] = Variable<String>(exportStatus.value);
    }
    if (importStatus.present) {
      map['import_status'] = Variable<String>(importStatus.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (deviceName.present) {
      map['device_name'] = Variable<String>(deviceName.value);
    }
    if (versionRelease.present) {
      map['version_release'] = Variable<String>(versionRelease.value);
    }
    if (versionEnvrement.present) {
      map['version_envrement'] = Variable<String>(versionEnvrement.value);
    }
    if (bootLoader.present) {
      map['boot_loader'] = Variable<String>(bootLoader.value);
    }
    if (manufacture.present) {
      map['manufacture'] = Variable<String>(manufacture.value);
    }
    if (model.present) {
      map['model'] = Variable<String>(model.value);
    }
    if (sdkNumber.present) {
      map['sdk_number'] = Variable<int>(sdkNumber.value);
    }
    if (hardware.present) {
      map['hardware'] = Variable<String>(hardware.value);
    }
    if (deviceHost.present) {
      map['device_host'] = Variable<String>(deviceHost.value);
    }
    if (deviceTime.present) {
      map['device_time'] = Variable<DateTime>(deviceTime.value);
    }
    if (deviceSerial.present) {
      map['device_serial'] = Variable<String>(deviceSerial.value);
    }
    if (deviceMac.present) {
      map['device_mac'] = Variable<String>(deviceMac.value);
    }
    if (deviceIp.present) {
      map['device_ip'] = Variable<String>(deviceIp.value);
    }
    if (deviceMode.present) {
      map['device_mode'] = Variable<String>(deviceMode.value);
    }
    if (activationDate.present) {
      map['activation_date'] = Variable<DateTime>(activationDate.value);
    }
    if (expirationDate.present) {
      map['expiration_date'] = Variable<DateTime>(expirationDate.value);
    }
    if (deviceStatus.present) {
      map['device_status'] = Variable<int>(deviceStatus.value);
    }
    if (companyName.present) {
      map['company_name'] = Variable<String>(companyName.value);
    }
    if (deviceNickName.present) {
      map['device_nick_name'] = Variable<String>(deviceNickName.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MobileDeviceCompanion(')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('createUserId: $createUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('importDateTime: $importDateTime, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('importStatus: $importStatus, ')
          ..write('syncError: $syncError, ')
          ..write('deviceId: $deviceId, ')
          ..write('deviceName: $deviceName, ')
          ..write('versionRelease: $versionRelease, ')
          ..write('versionEnvrement: $versionEnvrement, ')
          ..write('bootLoader: $bootLoader, ')
          ..write('manufacture: $manufacture, ')
          ..write('model: $model, ')
          ..write('sdkNumber: $sdkNumber, ')
          ..write('hardware: $hardware, ')
          ..write('deviceHost: $deviceHost, ')
          ..write('deviceTime: $deviceTime, ')
          ..write('deviceSerial: $deviceSerial, ')
          ..write('deviceMac: $deviceMac, ')
          ..write('deviceIp: $deviceIp, ')
          ..write('deviceMode: $deviceMode, ')
          ..write('activationDate: $activationDate, ')
          ..write('expirationDate: $expirationDate, ')
          ..write('deviceStatus: $deviceStatus, ')
          ..write('companyName: $companyName, ')
          ..write('deviceNickName: $deviceNickName, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }
}

class $MobileDeviceTable extends MobileDevice
    with TableInfo<$MobileDeviceTable, MobileDeviceData> {
  final GeneratedDatabase _db;
  final String _alias;
  $MobileDeviceTable(this._db, [this._alias]);
  final VerificationMeta _creationTimeMeta =
      const VerificationMeta('creationTime');
  GeneratedColumn<DateTime> _creationTime;
  @override
  GeneratedColumn<DateTime> get creationTime => _creationTime ??=
      GeneratedColumn<DateTime>('creation_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _deleteTimeMeta = const VerificationMeta('deleteTime');
  GeneratedColumn<DateTime> _deleteTime;
  @override
  GeneratedColumn<DateTime> get deleteTime => _deleteTime ??=
      GeneratedColumn<DateTime>('delete_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _createUserIdMeta =
      const VerificationMeta('createUserId');
  GeneratedColumn<int> _createUserId;
  @override
  GeneratedColumn<int> get createUserId => _createUserId ??=
      GeneratedColumn<int>('create_user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _creatorUserMeta =
      const VerificationMeta('creatorUser');
  GeneratedColumn<String> _creatorUser;
  @override
  GeneratedColumn<String> get creatorUser => _creatorUser ??=
      GeneratedColumn<String>('creator_user', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _lastModifierUserMeta =
      const VerificationMeta('lastModifierUser');
  GeneratedColumn<String> _lastModifierUser;
  @override
  GeneratedColumn<String> get lastModifierUser => _lastModifierUser ??=
      GeneratedColumn<String>('last_modifier_user', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _lastModifierUserIdMeta =
      const VerificationMeta('lastModifierUserId');
  GeneratedColumn<int> _lastModifierUserId;
  @override
  GeneratedColumn<int> get lastModifierUserId => _lastModifierUserId ??=
      GeneratedColumn<int>('last_modifier_user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _deleteUserIdMeta =
      const VerificationMeta('deleteUserId');
  GeneratedColumn<int> _deleteUserId;
  @override
  GeneratedColumn<int> get deleteUserId => _deleteUserId ??=
      GeneratedColumn<int>('delete_user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _deleterUserIdMeta =
      const VerificationMeta('deleterUserId');
  GeneratedColumn<String> _deleterUserId;
  @override
  GeneratedColumn<String> get deleterUserId => _deleterUserId ??=
      GeneratedColumn<String>('deleter_user_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isDeletedMeta = const VerificationMeta('isDeleted');
  GeneratedColumn<bool> _isDeleted;
  @override
  GeneratedColumn<bool> get isDeleted =>
      _isDeleted ??= GeneratedColumn<bool>('is_deleted', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_deleted IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _importDateTimeMeta =
      const VerificationMeta('importDateTime');
  GeneratedColumn<DateTime> _importDateTime;
  @override
  GeneratedColumn<DateTime> get importDateTime => _importDateTime ??=
      GeneratedColumn<DateTime>('import_date_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _exportDateTimeMeta =
      const VerificationMeta('exportDateTime');
  GeneratedColumn<DateTime> _exportDateTime;
  @override
  GeneratedColumn<DateTime> get exportDateTime => _exportDateTime ??=
      GeneratedColumn<DateTime>('export_date_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _exportStatusMeta =
      const VerificationMeta('exportStatus');
  GeneratedColumn<String> _exportStatus;
  @override
  GeneratedColumn<String> get exportStatus => _exportStatus ??=
      GeneratedColumn<String>('export_status', aliasedName, false,
          type: const StringType(),
          requiredDuringInsert: false,
          defaultValue: Constant('Pending'));
  final VerificationMeta _importStatusMeta =
      const VerificationMeta('importStatus');
  GeneratedColumn<String> _importStatus;
  @override
  GeneratedColumn<String> get importStatus => _importStatus ??=
      GeneratedColumn<String>('import_status', aliasedName, false,
          type: const StringType(),
          requiredDuringInsert: false,
          defaultValue: Constant('Pending'));
  final VerificationMeta _syncErrorMeta = const VerificationMeta('syncError');
  GeneratedColumn<String> _syncError;
  @override
  GeneratedColumn<String> get syncError =>
      _syncError ??= GeneratedColumn<String>('sync_error', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceIdMeta = const VerificationMeta('deviceId');
  GeneratedColumn<String> _deviceId;
  @override
  GeneratedColumn<String> get deviceId =>
      _deviceId ??= GeneratedColumn<String>('device_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceNameMeta = const VerificationMeta('deviceName');
  GeneratedColumn<String> _deviceName;
  @override
  GeneratedColumn<String> get deviceName =>
      _deviceName ??= GeneratedColumn<String>('device_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _versionReleaseMeta =
      const VerificationMeta('versionRelease');
  GeneratedColumn<String> _versionRelease;
  @override
  GeneratedColumn<String> get versionRelease => _versionRelease ??=
      GeneratedColumn<String>('version_release', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _versionEnvrementMeta =
      const VerificationMeta('versionEnvrement');
  GeneratedColumn<String> _versionEnvrement;
  @override
  GeneratedColumn<String> get versionEnvrement => _versionEnvrement ??=
      GeneratedColumn<String>('version_envrement', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _bootLoaderMeta = const VerificationMeta('bootLoader');
  GeneratedColumn<String> _bootLoader;
  @override
  GeneratedColumn<String> get bootLoader =>
      _bootLoader ??= GeneratedColumn<String>('boot_loader', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _manufactureMeta =
      const VerificationMeta('manufacture');
  GeneratedColumn<String> _manufacture;
  @override
  GeneratedColumn<String> get manufacture =>
      _manufacture ??= GeneratedColumn<String>('manufacture', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _modelMeta = const VerificationMeta('model');
  GeneratedColumn<String> _model;
  @override
  GeneratedColumn<String> get model =>
      _model ??= GeneratedColumn<String>('model', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _sdkNumberMeta = const VerificationMeta('sdkNumber');
  GeneratedColumn<int> _sdkNumber;
  @override
  GeneratedColumn<int> get sdkNumber =>
      _sdkNumber ??= GeneratedColumn<int>('sdk_number', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _hardwareMeta = const VerificationMeta('hardware');
  GeneratedColumn<String> _hardware;
  @override
  GeneratedColumn<String> get hardware =>
      _hardware ??= GeneratedColumn<String>('hardware', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceHostMeta = const VerificationMeta('deviceHost');
  GeneratedColumn<String> _deviceHost;
  @override
  GeneratedColumn<String> get deviceHost =>
      _deviceHost ??= GeneratedColumn<String>('device_host', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceTimeMeta = const VerificationMeta('deviceTime');
  GeneratedColumn<DateTime> _deviceTime;
  @override
  GeneratedColumn<DateTime> get deviceTime => _deviceTime ??=
      GeneratedColumn<DateTime>('device_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _deviceSerialMeta =
      const VerificationMeta('deviceSerial');
  GeneratedColumn<String> _deviceSerial;
  @override
  GeneratedColumn<String> get deviceSerial => _deviceSerial ??=
      GeneratedColumn<String>('device_serial', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceMacMeta = const VerificationMeta('deviceMac');
  GeneratedColumn<String> _deviceMac;
  @override
  GeneratedColumn<String> get deviceMac =>
      _deviceMac ??= GeneratedColumn<String>('device_mac', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceIpMeta = const VerificationMeta('deviceIp');
  GeneratedColumn<String> _deviceIp;
  @override
  GeneratedColumn<String> get deviceIp =>
      _deviceIp ??= GeneratedColumn<String>('device_ip', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceModeMeta = const VerificationMeta('deviceMode');
  GeneratedColumn<String> _deviceMode;
  @override
  GeneratedColumn<String> get deviceMode =>
      _deviceMode ??= GeneratedColumn<String>('device_mode', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _activationDateMeta =
      const VerificationMeta('activationDate');
  GeneratedColumn<DateTime> _activationDate;
  @override
  GeneratedColumn<DateTime> get activationDate => _activationDate ??=
      GeneratedColumn<DateTime>('activation_date', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _expirationDateMeta =
      const VerificationMeta('expirationDate');
  GeneratedColumn<DateTime> _expirationDate;
  @override
  GeneratedColumn<DateTime> get expirationDate => _expirationDate ??=
      GeneratedColumn<DateTime>('expiration_date', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _deviceStatusMeta =
      const VerificationMeta('deviceStatus');
  GeneratedColumn<int> _deviceStatus;
  @override
  GeneratedColumn<int> get deviceStatus =>
      _deviceStatus ??= GeneratedColumn<int>('device_status', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _companyNameMeta =
      const VerificationMeta('companyName');
  GeneratedColumn<String> _companyName;
  @override
  GeneratedColumn<String> get companyName => _companyName ??=
      GeneratedColumn<String>('company_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceNickNameMeta =
      const VerificationMeta('deviceNickName');
  GeneratedColumn<String> _deviceNickName;
  @override
  GeneratedColumn<String> get deviceNickName => _deviceNickName ??=
      GeneratedColumn<String>('device_nick_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _latitudeMeta = const VerificationMeta('latitude');
  GeneratedColumn<double> _latitude;
  @override
  GeneratedColumn<double> get latitude =>
      _latitude ??= GeneratedColumn<double>('latitude', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _longitudeMeta = const VerificationMeta('longitude');
  GeneratedColumn<double> _longitude;
  @override
  GeneratedColumn<double> get longitude =>
      _longitude ??= GeneratedColumn<double>('longitude', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        creationTime,
        deleteTime,
        createUserId,
        creatorUser,
        lastModifierUser,
        lastModifierUserId,
        deleteUserId,
        deleterUserId,
        isDeleted,
        importDateTime,
        exportDateTime,
        exportStatus,
        importStatus,
        syncError,
        deviceId,
        deviceName,
        versionRelease,
        versionEnvrement,
        bootLoader,
        manufacture,
        model,
        sdkNumber,
        hardware,
        deviceHost,
        deviceTime,
        deviceSerial,
        deviceMac,
        deviceIp,
        deviceMode,
        activationDate,
        expirationDate,
        deviceStatus,
        companyName,
        deviceNickName,
        latitude,
        longitude,
        tenantId
      ];
  @override
  String get aliasedName => _alias ?? 'mobile_device';
  @override
  String get actualTableName => 'mobile_device';
  @override
  VerificationContext validateIntegrity(Insertable<MobileDeviceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('creation_time')) {
      context.handle(
          _creationTimeMeta,
          creationTime.isAcceptableOrUnknown(
              data['creation_time'], _creationTimeMeta));
    }
    if (data.containsKey('delete_time')) {
      context.handle(
          _deleteTimeMeta,
          deleteTime.isAcceptableOrUnknown(
              data['delete_time'], _deleteTimeMeta));
    }
    if (data.containsKey('create_user_id')) {
      context.handle(
          _createUserIdMeta,
          createUserId.isAcceptableOrUnknown(
              data['create_user_id'], _createUserIdMeta));
    }
    if (data.containsKey('creator_user')) {
      context.handle(
          _creatorUserMeta,
          creatorUser.isAcceptableOrUnknown(
              data['creator_user'], _creatorUserMeta));
    }
    if (data.containsKey('last_modifier_user')) {
      context.handle(
          _lastModifierUserMeta,
          lastModifierUser.isAcceptableOrUnknown(
              data['last_modifier_user'], _lastModifierUserMeta));
    }
    if (data.containsKey('last_modifier_user_id')) {
      context.handle(
          _lastModifierUserIdMeta,
          lastModifierUserId.isAcceptableOrUnknown(
              data['last_modifier_user_id'], _lastModifierUserIdMeta));
    }
    if (data.containsKey('delete_user_id')) {
      context.handle(
          _deleteUserIdMeta,
          deleteUserId.isAcceptableOrUnknown(
              data['delete_user_id'], _deleteUserIdMeta));
    }
    if (data.containsKey('deleter_user_id')) {
      context.handle(
          _deleterUserIdMeta,
          deleterUserId.isAcceptableOrUnknown(
              data['deleter_user_id'], _deleterUserIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted'], _isDeletedMeta));
    }
    if (data.containsKey('import_date_time')) {
      context.handle(
          _importDateTimeMeta,
          importDateTime.isAcceptableOrUnknown(
              data['import_date_time'], _importDateTimeMeta));
    }
    if (data.containsKey('export_date_time')) {
      context.handle(
          _exportDateTimeMeta,
          exportDateTime.isAcceptableOrUnknown(
              data['export_date_time'], _exportDateTimeMeta));
    }
    if (data.containsKey('export_status')) {
      context.handle(
          _exportStatusMeta,
          exportStatus.isAcceptableOrUnknown(
              data['export_status'], _exportStatusMeta));
    }
    if (data.containsKey('import_status')) {
      context.handle(
          _importStatusMeta,
          importStatus.isAcceptableOrUnknown(
              data['import_status'], _importStatusMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error'], _syncErrorMeta));
    }
    if (data.containsKey('device_id')) {
      context.handle(_deviceIdMeta,
          deviceId.isAcceptableOrUnknown(data['device_id'], _deviceIdMeta));
    }
    if (data.containsKey('device_name')) {
      context.handle(
          _deviceNameMeta,
          deviceName.isAcceptableOrUnknown(
              data['device_name'], _deviceNameMeta));
    }
    if (data.containsKey('version_release')) {
      context.handle(
          _versionReleaseMeta,
          versionRelease.isAcceptableOrUnknown(
              data['version_release'], _versionReleaseMeta));
    }
    if (data.containsKey('version_envrement')) {
      context.handle(
          _versionEnvrementMeta,
          versionEnvrement.isAcceptableOrUnknown(
              data['version_envrement'], _versionEnvrementMeta));
    }
    if (data.containsKey('boot_loader')) {
      context.handle(
          _bootLoaderMeta,
          bootLoader.isAcceptableOrUnknown(
              data['boot_loader'], _bootLoaderMeta));
    }
    if (data.containsKey('manufacture')) {
      context.handle(
          _manufactureMeta,
          manufacture.isAcceptableOrUnknown(
              data['manufacture'], _manufactureMeta));
    }
    if (data.containsKey('model')) {
      context.handle(
          _modelMeta, model.isAcceptableOrUnknown(data['model'], _modelMeta));
    }
    if (data.containsKey('sdk_number')) {
      context.handle(_sdkNumberMeta,
          sdkNumber.isAcceptableOrUnknown(data['sdk_number'], _sdkNumberMeta));
    }
    if (data.containsKey('hardware')) {
      context.handle(_hardwareMeta,
          hardware.isAcceptableOrUnknown(data['hardware'], _hardwareMeta));
    }
    if (data.containsKey('device_host')) {
      context.handle(
          _deviceHostMeta,
          deviceHost.isAcceptableOrUnknown(
              data['device_host'], _deviceHostMeta));
    }
    if (data.containsKey('device_time')) {
      context.handle(
          _deviceTimeMeta,
          deviceTime.isAcceptableOrUnknown(
              data['device_time'], _deviceTimeMeta));
    }
    if (data.containsKey('device_serial')) {
      context.handle(
          _deviceSerialMeta,
          deviceSerial.isAcceptableOrUnknown(
              data['device_serial'], _deviceSerialMeta));
    }
    if (data.containsKey('device_mac')) {
      context.handle(_deviceMacMeta,
          deviceMac.isAcceptableOrUnknown(data['device_mac'], _deviceMacMeta));
    }
    if (data.containsKey('device_ip')) {
      context.handle(_deviceIpMeta,
          deviceIp.isAcceptableOrUnknown(data['device_ip'], _deviceIpMeta));
    }
    if (data.containsKey('device_mode')) {
      context.handle(
          _deviceModeMeta,
          deviceMode.isAcceptableOrUnknown(
              data['device_mode'], _deviceModeMeta));
    }
    if (data.containsKey('activation_date')) {
      context.handle(
          _activationDateMeta,
          activationDate.isAcceptableOrUnknown(
              data['activation_date'], _activationDateMeta));
    }
    if (data.containsKey('expiration_date')) {
      context.handle(
          _expirationDateMeta,
          expirationDate.isAcceptableOrUnknown(
              data['expiration_date'], _expirationDateMeta));
    }
    if (data.containsKey('device_status')) {
      context.handle(
          _deviceStatusMeta,
          deviceStatus.isAcceptableOrUnknown(
              data['device_status'], _deviceStatusMeta));
    }
    if (data.containsKey('company_name')) {
      context.handle(
          _companyNameMeta,
          companyName.isAcceptableOrUnknown(
              data['company_name'], _companyNameMeta));
    }
    if (data.containsKey('device_nick_name')) {
      context.handle(
          _deviceNickNameMeta,
          deviceNickName.isAcceptableOrUnknown(
              data['device_nick_name'], _deviceNickNameMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude'], _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude'], _longitudeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {deviceId};
  @override
  MobileDeviceData map(Map<String, dynamic> data, {String tablePrefix}) {
    return MobileDeviceData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $MobileDeviceTable createAlias(String alias) {
    return $MobileDeviceTable(_db, alias);
  }
}

class BusinessRuleData extends DataClass
    implements Insertable<BusinessRuleData> {
  final String code;
  final String ruleName;
  final String value;
  final String description;
  final bool isGlobalRule;
  final String deviceRule;
  final String userRule;
  final String domain;
  final DateTime expiredDateTime;
  final int tenantId;
  final String syncError;
  final String dataType;
  final String dataValue;
  final String groups;
  BusinessRuleData(
      {@required this.code,
      this.ruleName,
      @required this.value,
      this.description,
      @required this.isGlobalRule,
      this.deviceRule,
      this.userRule,
      this.domain,
      this.expiredDateTime,
      this.tenantId,
      this.syncError,
      this.dataType,
      this.dataValue,
      this.groups});
  factory BusinessRuleData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return BusinessRuleData(
      code: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}code']),
      ruleName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}rule_name']),
      value: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}value']),
      description: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}description']),
      isGlobalRule: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_global_rule']),
      deviceRule: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_rule']),
      userRule: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_rule']),
      domain: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}domain']),
      expiredDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}expired_date_time']),
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      syncError: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sync_error']),
      dataType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}data_type']),
      dataValue: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}data_value']),
      groups: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}groups']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || ruleName != null) {
      map['rule_name'] = Variable<String>(ruleName);
    }
    if (!nullToAbsent || value != null) {
      map['value'] = Variable<String>(value);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || isGlobalRule != null) {
      map['is_global_rule'] = Variable<bool>(isGlobalRule);
    }
    if (!nullToAbsent || deviceRule != null) {
      map['device_rule'] = Variable<String>(deviceRule);
    }
    if (!nullToAbsent || userRule != null) {
      map['user_rule'] = Variable<String>(userRule);
    }
    if (!nullToAbsent || domain != null) {
      map['domain'] = Variable<String>(domain);
    }
    if (!nullToAbsent || expiredDateTime != null) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || dataValue != null) {
      map['data_value'] = Variable<String>(dataValue);
    }
    if (!nullToAbsent || groups != null) {
      map['groups'] = Variable<String>(groups);
    }
    return map;
  }

  BusinessRuleCompanion toCompanion(bool nullToAbsent) {
    return BusinessRuleCompanion(
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      ruleName: ruleName == null && nullToAbsent
          ? const Value.absent()
          : Value(ruleName),
      value:
          value == null && nullToAbsent ? const Value.absent() : Value(value),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      isGlobalRule: isGlobalRule == null && nullToAbsent
          ? const Value.absent()
          : Value(isGlobalRule),
      deviceRule: deviceRule == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceRule),
      userRule: userRule == null && nullToAbsent
          ? const Value.absent()
          : Value(userRule),
      domain:
          domain == null && nullToAbsent ? const Value.absent() : Value(domain),
      expiredDateTime: expiredDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(expiredDateTime),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      dataValue: dataValue == null && nullToAbsent
          ? const Value.absent()
          : Value(dataValue),
      groups:
          groups == null && nullToAbsent ? const Value.absent() : Value(groups),
    );
  }

  factory BusinessRuleData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BusinessRuleData(
      code: serializer.fromJson<String>(json['code']),
      ruleName: serializer.fromJson<String>(json['ruleName']),
      value: serializer.fromJson<String>(json['value']),
      description: serializer.fromJson<String>(json['description']),
      isGlobalRule: serializer.fromJson<bool>(json['isGlobalRule']),
      deviceRule: serializer.fromJson<String>(json['deviceRule']),
      userRule: serializer.fromJson<String>(json['userRule']),
      domain: serializer.fromJson<String>(json['domain']),
      expiredDateTime: serializer.fromJson<DateTime>(json['expiredDateTime']),
      tenantId: serializer.fromJson<int>(json['tenantId']),
      syncError: serializer.fromJson<String>(json['syncError']),
      dataType: serializer.fromJson<String>(json['dataType']),
      dataValue: serializer.fromJson<String>(json['dataValue']),
      groups: serializer.fromJson<String>(json['groups']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'ruleName': serializer.toJson<String>(ruleName),
      'value': serializer.toJson<String>(value),
      'description': serializer.toJson<String>(description),
      'isGlobalRule': serializer.toJson<bool>(isGlobalRule),
      'deviceRule': serializer.toJson<String>(deviceRule),
      'userRule': serializer.toJson<String>(userRule),
      'domain': serializer.toJson<String>(domain),
      'expiredDateTime': serializer.toJson<DateTime>(expiredDateTime),
      'tenantId': serializer.toJson<int>(tenantId),
      'syncError': serializer.toJson<String>(syncError),
      'dataType': serializer.toJson<String>(dataType),
      'dataValue': serializer.toJson<String>(dataValue),
      'groups': serializer.toJson<String>(groups),
    };
  }

  BusinessRuleData copyWith(
          {String code,
          String ruleName,
          String value,
          String description,
          bool isGlobalRule,
          String deviceRule,
          String userRule,
          String domain,
          DateTime expiredDateTime,
          int tenantId,
          String syncError,
          String dataType,
          String dataValue,
          String groups}) =>
      BusinessRuleData(
        code: code ?? this.code,
        ruleName: ruleName ?? this.ruleName,
        value: value ?? this.value,
        description: description ?? this.description,
        isGlobalRule: isGlobalRule ?? this.isGlobalRule,
        deviceRule: deviceRule ?? this.deviceRule,
        userRule: userRule ?? this.userRule,
        domain: domain ?? this.domain,
        expiredDateTime: expiredDateTime ?? this.expiredDateTime,
        tenantId: tenantId ?? this.tenantId,
        syncError: syncError ?? this.syncError,
        dataType: dataType ?? this.dataType,
        dataValue: dataValue ?? this.dataValue,
        groups: groups ?? this.groups,
      );
  @override
  String toString() {
    return (StringBuffer('BusinessRuleData(')
          ..write('code: $code, ')
          ..write('ruleName: $ruleName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('isGlobalRule: $isGlobalRule, ')
          ..write('deviceRule: $deviceRule, ')
          ..write('userRule: $userRule, ')
          ..write('domain: $domain, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('syncError: $syncError, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      code,
      ruleName,
      value,
      description,
      isGlobalRule,
      deviceRule,
      userRule,
      domain,
      expiredDateTime,
      tenantId,
      syncError,
      dataType,
      dataValue,
      groups);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BusinessRuleData &&
          other.code == this.code &&
          other.ruleName == this.ruleName &&
          other.value == this.value &&
          other.description == this.description &&
          other.isGlobalRule == this.isGlobalRule &&
          other.deviceRule == this.deviceRule &&
          other.userRule == this.userRule &&
          other.domain == this.domain &&
          other.expiredDateTime == this.expiredDateTime &&
          other.tenantId == this.tenantId &&
          other.syncError == this.syncError &&
          other.dataType == this.dataType &&
          other.dataValue == this.dataValue &&
          other.groups == this.groups);
}

class BusinessRuleCompanion extends UpdateCompanion<BusinessRuleData> {
  final Value<String> code;
  final Value<String> ruleName;
  final Value<String> value;
  final Value<String> description;
  final Value<bool> isGlobalRule;
  final Value<String> deviceRule;
  final Value<String> userRule;
  final Value<String> domain;
  final Value<DateTime> expiredDateTime;
  final Value<int> tenantId;
  final Value<String> syncError;
  final Value<String> dataType;
  final Value<String> dataValue;
  final Value<String> groups;
  const BusinessRuleCompanion({
    this.code = const Value.absent(),
    this.ruleName = const Value.absent(),
    this.value = const Value.absent(),
    this.description = const Value.absent(),
    this.isGlobalRule = const Value.absent(),
    this.deviceRule = const Value.absent(),
    this.userRule = const Value.absent(),
    this.domain = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.syncError = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
  });
  BusinessRuleCompanion.insert({
    @required String code,
    this.ruleName = const Value.absent(),
    @required String value,
    this.description = const Value.absent(),
    this.isGlobalRule = const Value.absent(),
    this.deviceRule = const Value.absent(),
    this.userRule = const Value.absent(),
    this.domain = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.syncError = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
  })  : code = Value(code),
        value = Value(value);
  static Insertable<BusinessRuleData> custom({
    Expression<String> code,
    Expression<String> ruleName,
    Expression<String> value,
    Expression<String> description,
    Expression<bool> isGlobalRule,
    Expression<String> deviceRule,
    Expression<String> userRule,
    Expression<String> domain,
    Expression<DateTime> expiredDateTime,
    Expression<int> tenantId,
    Expression<String> syncError,
    Expression<String> dataType,
    Expression<String> dataValue,
    Expression<String> groups,
  }) {
    return RawValuesInsertable({
      if (code != null) 'code': code,
      if (ruleName != null) 'rule_name': ruleName,
      if (value != null) 'value': value,
      if (description != null) 'description': description,
      if (isGlobalRule != null) 'is_global_rule': isGlobalRule,
      if (deviceRule != null) 'device_rule': deviceRule,
      if (userRule != null) 'user_rule': userRule,
      if (domain != null) 'domain': domain,
      if (expiredDateTime != null) 'expired_date_time': expiredDateTime,
      if (tenantId != null) 'tenant_id': tenantId,
      if (syncError != null) 'sync_error': syncError,
      if (dataType != null) 'data_type': dataType,
      if (dataValue != null) 'data_value': dataValue,
      if (groups != null) 'groups': groups,
    });
  }

  BusinessRuleCompanion copyWith(
      {Value<String> code,
      Value<String> ruleName,
      Value<String> value,
      Value<String> description,
      Value<bool> isGlobalRule,
      Value<String> deviceRule,
      Value<String> userRule,
      Value<String> domain,
      Value<DateTime> expiredDateTime,
      Value<int> tenantId,
      Value<String> syncError,
      Value<String> dataType,
      Value<String> dataValue,
      Value<String> groups}) {
    return BusinessRuleCompanion(
      code: code ?? this.code,
      ruleName: ruleName ?? this.ruleName,
      value: value ?? this.value,
      description: description ?? this.description,
      isGlobalRule: isGlobalRule ?? this.isGlobalRule,
      deviceRule: deviceRule ?? this.deviceRule,
      userRule: userRule ?? this.userRule,
      domain: domain ?? this.domain,
      expiredDateTime: expiredDateTime ?? this.expiredDateTime,
      tenantId: tenantId ?? this.tenantId,
      syncError: syncError ?? this.syncError,
      dataType: dataType ?? this.dataType,
      dataValue: dataValue ?? this.dataValue,
      groups: groups ?? this.groups,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (ruleName.present) {
      map['rule_name'] = Variable<String>(ruleName.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (isGlobalRule.present) {
      map['is_global_rule'] = Variable<bool>(isGlobalRule.value);
    }
    if (deviceRule.present) {
      map['device_rule'] = Variable<String>(deviceRule.value);
    }
    if (userRule.present) {
      map['user_rule'] = Variable<String>(userRule.value);
    }
    if (domain.present) {
      map['domain'] = Variable<String>(domain.value);
    }
    if (expiredDateTime.present) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (dataValue.present) {
      map['data_value'] = Variable<String>(dataValue.value);
    }
    if (groups.present) {
      map['groups'] = Variable<String>(groups.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BusinessRuleCompanion(')
          ..write('code: $code, ')
          ..write('ruleName: $ruleName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('isGlobalRule: $isGlobalRule, ')
          ..write('deviceRule: $deviceRule, ')
          ..write('userRule: $userRule, ')
          ..write('domain: $domain, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('tenantId: $tenantId, ')
          ..write('syncError: $syncError, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups')
          ..write(')'))
        .toString();
  }
}

class $BusinessRuleTable extends BusinessRule
    with TableInfo<$BusinessRuleTable, BusinessRuleData> {
  final GeneratedDatabase _db;
  final String _alias;
  $BusinessRuleTable(this._db, [this._alias]);
  final VerificationMeta _codeMeta = const VerificationMeta('code');
  GeneratedColumn<String> _code;
  @override
  GeneratedColumn<String> get code =>
      _code ??= GeneratedColumn<String>('code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _ruleNameMeta = const VerificationMeta('ruleName');
  GeneratedColumn<String> _ruleName;
  @override
  GeneratedColumn<String> get ruleName =>
      _ruleName ??= GeneratedColumn<String>('rule_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _valueMeta = const VerificationMeta('value');
  GeneratedColumn<String> _value;
  @override
  GeneratedColumn<String> get value =>
      _value ??= GeneratedColumn<String>('value', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  GeneratedColumn<String> _description;
  @override
  GeneratedColumn<String> get description =>
      _description ??= GeneratedColumn<String>('description', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isGlobalRuleMeta =
      const VerificationMeta('isGlobalRule');
  GeneratedColumn<bool> _isGlobalRule;
  @override
  GeneratedColumn<bool> get isGlobalRule => _isGlobalRule ??=
      GeneratedColumn<bool>('is_global_rule', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_global_rule IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _deviceRuleMeta = const VerificationMeta('deviceRule');
  GeneratedColumn<String> _deviceRule;
  @override
  GeneratedColumn<String> get deviceRule =>
      _deviceRule ??= GeneratedColumn<String>('device_rule', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _userRuleMeta = const VerificationMeta('userRule');
  GeneratedColumn<String> _userRule;
  @override
  GeneratedColumn<String> get userRule =>
      _userRule ??= GeneratedColumn<String>('user_rule', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _domainMeta = const VerificationMeta('domain');
  GeneratedColumn<String> _domain;
  @override
  GeneratedColumn<String> get domain =>
      _domain ??= GeneratedColumn<String>('domain', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _expiredDateTimeMeta =
      const VerificationMeta('expiredDateTime');
  GeneratedColumn<DateTime> _expiredDateTime;
  @override
  GeneratedColumn<DateTime> get expiredDateTime => _expiredDateTime ??=
      GeneratedColumn<DateTime>('expired_date_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _syncErrorMeta = const VerificationMeta('syncError');
  GeneratedColumn<String> _syncError;
  @override
  GeneratedColumn<String> get syncError =>
      _syncError ??= GeneratedColumn<String>('sync_error', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _dataTypeMeta = const VerificationMeta('dataType');
  GeneratedColumn<String> _dataType;
  @override
  GeneratedColumn<String> get dataType =>
      _dataType ??= GeneratedColumn<String>('data_type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _dataValueMeta = const VerificationMeta('dataValue');
  GeneratedColumn<String> _dataValue;
  @override
  GeneratedColumn<String> get dataValue =>
      _dataValue ??= GeneratedColumn<String>('data_value', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _groupsMeta = const VerificationMeta('groups');
  GeneratedColumn<String> _groups;
  @override
  GeneratedColumn<String> get groups =>
      _groups ??= GeneratedColumn<String>('groups', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        code,
        ruleName,
        value,
        description,
        isGlobalRule,
        deviceRule,
        userRule,
        domain,
        expiredDateTime,
        tenantId,
        syncError,
        dataType,
        dataValue,
        groups
      ];
  @override
  String get aliasedName => _alias ?? 'business_rule';
  @override
  String get actualTableName => 'business_rule';
  @override
  VerificationContext validateIntegrity(Insertable<BusinessRuleData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code'], _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('rule_name')) {
      context.handle(_ruleNameMeta,
          ruleName.isAcceptableOrUnknown(data['rule_name'], _ruleNameMeta));
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value'], _valueMeta));
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description'], _descriptionMeta));
    }
    if (data.containsKey('is_global_rule')) {
      context.handle(
          _isGlobalRuleMeta,
          isGlobalRule.isAcceptableOrUnknown(
              data['is_global_rule'], _isGlobalRuleMeta));
    }
    if (data.containsKey('device_rule')) {
      context.handle(
          _deviceRuleMeta,
          deviceRule.isAcceptableOrUnknown(
              data['device_rule'], _deviceRuleMeta));
    }
    if (data.containsKey('user_rule')) {
      context.handle(_userRuleMeta,
          userRule.isAcceptableOrUnknown(data['user_rule'], _userRuleMeta));
    }
    if (data.containsKey('domain')) {
      context.handle(_domainMeta,
          domain.isAcceptableOrUnknown(data['domain'], _domainMeta));
    }
    if (data.containsKey('expired_date_time')) {
      context.handle(
          _expiredDateTimeMeta,
          expiredDateTime.isAcceptableOrUnknown(
              data['expired_date_time'], _expiredDateTimeMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error'], _syncErrorMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type'], _dataTypeMeta));
    }
    if (data.containsKey('data_value')) {
      context.handle(_dataValueMeta,
          dataValue.isAcceptableOrUnknown(data['data_value'], _dataValueMeta));
    }
    if (data.containsKey('groups')) {
      context.handle(_groupsMeta,
          groups.isAcceptableOrUnknown(data['groups'], _groupsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  BusinessRuleData map(Map<String, dynamic> data, {String tablePrefix}) {
    return BusinessRuleData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $BusinessRuleTable createAlias(String alias) {
    return $BusinessRuleTable(_db, alias);
  }
}

class NonGlobalBusinessRuleData extends DataClass
    implements Insertable<NonGlobalBusinessRuleData> {
  final String code;
  final String parentCode;
  final String ruleName;
  final String value;
  final String description;
  final String deviceRule;
  final String userRule;
  final String domain;
  final String deviceId;
  final String userName;
  final String screen;
  final bool isApply;
  final String syncError;
  final DateTime expiredDateTime;
  final String dataType;
  final String dataValue;
  final String groups;
  final int tenantId;
  NonGlobalBusinessRuleData(
      {@required this.code,
      @required this.parentCode,
      this.ruleName,
      @required this.value,
      this.description,
      this.deviceRule,
      this.userRule,
      this.domain,
      this.deviceId,
      this.userName,
      this.screen,
      @required this.isApply,
      this.syncError,
      this.expiredDateTime,
      this.dataType,
      this.dataValue,
      this.groups,
      this.tenantId});
  factory NonGlobalBusinessRuleData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return NonGlobalBusinessRuleData(
      code: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}code']),
      parentCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}parent_code']),
      ruleName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}rule_name']),
      value: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}value']),
      description: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}description']),
      deviceRule: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_rule']),
      userRule: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_rule']),
      domain: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}domain']),
      deviceId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_id']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      screen: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}screen']),
      isApply: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_apply']),
      syncError: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sync_error']),
      expiredDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}expired_date_time']),
      dataType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}data_type']),
      dataValue: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}data_value']),
      groups: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}groups']),
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || parentCode != null) {
      map['parent_code'] = Variable<String>(parentCode);
    }
    if (!nullToAbsent || ruleName != null) {
      map['rule_name'] = Variable<String>(ruleName);
    }
    if (!nullToAbsent || value != null) {
      map['value'] = Variable<String>(value);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || deviceRule != null) {
      map['device_rule'] = Variable<String>(deviceRule);
    }
    if (!nullToAbsent || userRule != null) {
      map['user_rule'] = Variable<String>(userRule);
    }
    if (!nullToAbsent || domain != null) {
      map['domain'] = Variable<String>(domain);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || screen != null) {
      map['screen'] = Variable<String>(screen);
    }
    if (!nullToAbsent || isApply != null) {
      map['is_apply'] = Variable<bool>(isApply);
    }
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || expiredDateTime != null) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || dataValue != null) {
      map['data_value'] = Variable<String>(dataValue);
    }
    if (!nullToAbsent || groups != null) {
      map['groups'] = Variable<String>(groups);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    return map;
  }

  NonGlobalBusinessRuleCompanion toCompanion(bool nullToAbsent) {
    return NonGlobalBusinessRuleCompanion(
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      parentCode: parentCode == null && nullToAbsent
          ? const Value.absent()
          : Value(parentCode),
      ruleName: ruleName == null && nullToAbsent
          ? const Value.absent()
          : Value(ruleName),
      value:
          value == null && nullToAbsent ? const Value.absent() : Value(value),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      deviceRule: deviceRule == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceRule),
      userRule: userRule == null && nullToAbsent
          ? const Value.absent()
          : Value(userRule),
      domain:
          domain == null && nullToAbsent ? const Value.absent() : Value(domain),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      screen:
          screen == null && nullToAbsent ? const Value.absent() : Value(screen),
      isApply: isApply == null && nullToAbsent
          ? const Value.absent()
          : Value(isApply),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      expiredDateTime: expiredDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(expiredDateTime),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      dataValue: dataValue == null && nullToAbsent
          ? const Value.absent()
          : Value(dataValue),
      groups:
          groups == null && nullToAbsent ? const Value.absent() : Value(groups),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory NonGlobalBusinessRuleData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NonGlobalBusinessRuleData(
      code: serializer.fromJson<String>(json['code']),
      parentCode: serializer.fromJson<String>(json['parentCode']),
      ruleName: serializer.fromJson<String>(json['ruleName']),
      value: serializer.fromJson<String>(json['value']),
      description: serializer.fromJson<String>(json['description']),
      deviceRule: serializer.fromJson<String>(json['deviceRule']),
      userRule: serializer.fromJson<String>(json['userRule']),
      domain: serializer.fromJson<String>(json['domain']),
      deviceId: serializer.fromJson<String>(json['deviceId']),
      userName: serializer.fromJson<String>(json['userName']),
      screen: serializer.fromJson<String>(json['screen']),
      isApply: serializer.fromJson<bool>(json['isApply']),
      syncError: serializer.fromJson<String>(json['syncError']),
      expiredDateTime: serializer.fromJson<DateTime>(json['expiredDateTime']),
      dataType: serializer.fromJson<String>(json['dataType']),
      dataValue: serializer.fromJson<String>(json['dataValue']),
      groups: serializer.fromJson<String>(json['groups']),
      tenantId: serializer.fromJson<int>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'code': serializer.toJson<String>(code),
      'parentCode': serializer.toJson<String>(parentCode),
      'ruleName': serializer.toJson<String>(ruleName),
      'value': serializer.toJson<String>(value),
      'description': serializer.toJson<String>(description),
      'deviceRule': serializer.toJson<String>(deviceRule),
      'userRule': serializer.toJson<String>(userRule),
      'domain': serializer.toJson<String>(domain),
      'deviceId': serializer.toJson<String>(deviceId),
      'userName': serializer.toJson<String>(userName),
      'screen': serializer.toJson<String>(screen),
      'isApply': serializer.toJson<bool>(isApply),
      'syncError': serializer.toJson<String>(syncError),
      'expiredDateTime': serializer.toJson<DateTime>(expiredDateTime),
      'dataType': serializer.toJson<String>(dataType),
      'dataValue': serializer.toJson<String>(dataValue),
      'groups': serializer.toJson<String>(groups),
      'tenantId': serializer.toJson<int>(tenantId),
    };
  }

  NonGlobalBusinessRuleData copyWith(
          {String code,
          String parentCode,
          String ruleName,
          String value,
          String description,
          String deviceRule,
          String userRule,
          String domain,
          String deviceId,
          String userName,
          String screen,
          bool isApply,
          String syncError,
          DateTime expiredDateTime,
          String dataType,
          String dataValue,
          String groups,
          int tenantId}) =>
      NonGlobalBusinessRuleData(
        code: code ?? this.code,
        parentCode: parentCode ?? this.parentCode,
        ruleName: ruleName ?? this.ruleName,
        value: value ?? this.value,
        description: description ?? this.description,
        deviceRule: deviceRule ?? this.deviceRule,
        userRule: userRule ?? this.userRule,
        domain: domain ?? this.domain,
        deviceId: deviceId ?? this.deviceId,
        userName: userName ?? this.userName,
        screen: screen ?? this.screen,
        isApply: isApply ?? this.isApply,
        syncError: syncError ?? this.syncError,
        expiredDateTime: expiredDateTime ?? this.expiredDateTime,
        dataType: dataType ?? this.dataType,
        dataValue: dataValue ?? this.dataValue,
        groups: groups ?? this.groups,
        tenantId: tenantId ?? this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('NonGlobalBusinessRuleData(')
          ..write('code: $code, ')
          ..write('parentCode: $parentCode, ')
          ..write('ruleName: $ruleName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('deviceRule: $deviceRule, ')
          ..write('userRule: $userRule, ')
          ..write('domain: $domain, ')
          ..write('deviceId: $deviceId, ')
          ..write('userName: $userName, ')
          ..write('screen: $screen, ')
          ..write('isApply: $isApply, ')
          ..write('syncError: $syncError, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      code,
      parentCode,
      ruleName,
      value,
      description,
      deviceRule,
      userRule,
      domain,
      deviceId,
      userName,
      screen,
      isApply,
      syncError,
      expiredDateTime,
      dataType,
      dataValue,
      groups,
      tenantId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NonGlobalBusinessRuleData &&
          other.code == this.code &&
          other.parentCode == this.parentCode &&
          other.ruleName == this.ruleName &&
          other.value == this.value &&
          other.description == this.description &&
          other.deviceRule == this.deviceRule &&
          other.userRule == this.userRule &&
          other.domain == this.domain &&
          other.deviceId == this.deviceId &&
          other.userName == this.userName &&
          other.screen == this.screen &&
          other.isApply == this.isApply &&
          other.syncError == this.syncError &&
          other.expiredDateTime == this.expiredDateTime &&
          other.dataType == this.dataType &&
          other.dataValue == this.dataValue &&
          other.groups == this.groups &&
          other.tenantId == this.tenantId);
}

class NonGlobalBusinessRuleCompanion
    extends UpdateCompanion<NonGlobalBusinessRuleData> {
  final Value<String> code;
  final Value<String> parentCode;
  final Value<String> ruleName;
  final Value<String> value;
  final Value<String> description;
  final Value<String> deviceRule;
  final Value<String> userRule;
  final Value<String> domain;
  final Value<String> deviceId;
  final Value<String> userName;
  final Value<String> screen;
  final Value<bool> isApply;
  final Value<String> syncError;
  final Value<DateTime> expiredDateTime;
  final Value<String> dataType;
  final Value<String> dataValue;
  final Value<String> groups;
  final Value<int> tenantId;
  const NonGlobalBusinessRuleCompanion({
    this.code = const Value.absent(),
    this.parentCode = const Value.absent(),
    this.ruleName = const Value.absent(),
    this.value = const Value.absent(),
    this.description = const Value.absent(),
    this.deviceRule = const Value.absent(),
    this.userRule = const Value.absent(),
    this.domain = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userName = const Value.absent(),
    this.screen = const Value.absent(),
    this.isApply = const Value.absent(),
    this.syncError = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.tenantId = const Value.absent(),
  });
  NonGlobalBusinessRuleCompanion.insert({
    @required String code,
    @required String parentCode,
    this.ruleName = const Value.absent(),
    @required String value,
    this.description = const Value.absent(),
    this.deviceRule = const Value.absent(),
    this.userRule = const Value.absent(),
    this.domain = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userName = const Value.absent(),
    this.screen = const Value.absent(),
    this.isApply = const Value.absent(),
    this.syncError = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.tenantId = const Value.absent(),
  })  : code = Value(code),
        parentCode = Value(parentCode),
        value = Value(value);
  static Insertable<NonGlobalBusinessRuleData> custom({
    Expression<String> code,
    Expression<String> parentCode,
    Expression<String> ruleName,
    Expression<String> value,
    Expression<String> description,
    Expression<String> deviceRule,
    Expression<String> userRule,
    Expression<String> domain,
    Expression<String> deviceId,
    Expression<String> userName,
    Expression<String> screen,
    Expression<bool> isApply,
    Expression<String> syncError,
    Expression<DateTime> expiredDateTime,
    Expression<String> dataType,
    Expression<String> dataValue,
    Expression<String> groups,
    Expression<int> tenantId,
  }) {
    return RawValuesInsertable({
      if (code != null) 'code': code,
      if (parentCode != null) 'parent_code': parentCode,
      if (ruleName != null) 'rule_name': ruleName,
      if (value != null) 'value': value,
      if (description != null) 'description': description,
      if (deviceRule != null) 'device_rule': deviceRule,
      if (userRule != null) 'user_rule': userRule,
      if (domain != null) 'domain': domain,
      if (deviceId != null) 'device_id': deviceId,
      if (userName != null) 'user_name': userName,
      if (screen != null) 'screen': screen,
      if (isApply != null) 'is_apply': isApply,
      if (syncError != null) 'sync_error': syncError,
      if (expiredDateTime != null) 'expired_date_time': expiredDateTime,
      if (dataType != null) 'data_type': dataType,
      if (dataValue != null) 'data_value': dataValue,
      if (groups != null) 'groups': groups,
      if (tenantId != null) 'tenant_id': tenantId,
    });
  }

  NonGlobalBusinessRuleCompanion copyWith(
      {Value<String> code,
      Value<String> parentCode,
      Value<String> ruleName,
      Value<String> value,
      Value<String> description,
      Value<String> deviceRule,
      Value<String> userRule,
      Value<String> domain,
      Value<String> deviceId,
      Value<String> userName,
      Value<String> screen,
      Value<bool> isApply,
      Value<String> syncError,
      Value<DateTime> expiredDateTime,
      Value<String> dataType,
      Value<String> dataValue,
      Value<String> groups,
      Value<int> tenantId}) {
    return NonGlobalBusinessRuleCompanion(
      code: code ?? this.code,
      parentCode: parentCode ?? this.parentCode,
      ruleName: ruleName ?? this.ruleName,
      value: value ?? this.value,
      description: description ?? this.description,
      deviceRule: deviceRule ?? this.deviceRule,
      userRule: userRule ?? this.userRule,
      domain: domain ?? this.domain,
      deviceId: deviceId ?? this.deviceId,
      userName: userName ?? this.userName,
      screen: screen ?? this.screen,
      isApply: isApply ?? this.isApply,
      syncError: syncError ?? this.syncError,
      expiredDateTime: expiredDateTime ?? this.expiredDateTime,
      dataType: dataType ?? this.dataType,
      dataValue: dataValue ?? this.dataValue,
      groups: groups ?? this.groups,
      tenantId: tenantId ?? this.tenantId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (parentCode.present) {
      map['parent_code'] = Variable<String>(parentCode.value);
    }
    if (ruleName.present) {
      map['rule_name'] = Variable<String>(ruleName.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (deviceRule.present) {
      map['device_rule'] = Variable<String>(deviceRule.value);
    }
    if (userRule.present) {
      map['user_rule'] = Variable<String>(userRule.value);
    }
    if (domain.present) {
      map['domain'] = Variable<String>(domain.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (screen.present) {
      map['screen'] = Variable<String>(screen.value);
    }
    if (isApply.present) {
      map['is_apply'] = Variable<bool>(isApply.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (expiredDateTime.present) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (dataValue.present) {
      map['data_value'] = Variable<String>(dataValue.value);
    }
    if (groups.present) {
      map['groups'] = Variable<String>(groups.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NonGlobalBusinessRuleCompanion(')
          ..write('code: $code, ')
          ..write('parentCode: $parentCode, ')
          ..write('ruleName: $ruleName, ')
          ..write('value: $value, ')
          ..write('description: $description, ')
          ..write('deviceRule: $deviceRule, ')
          ..write('userRule: $userRule, ')
          ..write('domain: $domain, ')
          ..write('deviceId: $deviceId, ')
          ..write('userName: $userName, ')
          ..write('screen: $screen, ')
          ..write('isApply: $isApply, ')
          ..write('syncError: $syncError, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }
}

class $NonGlobalBusinessRuleTable extends NonGlobalBusinessRule
    with TableInfo<$NonGlobalBusinessRuleTable, NonGlobalBusinessRuleData> {
  final GeneratedDatabase _db;
  final String _alias;
  $NonGlobalBusinessRuleTable(this._db, [this._alias]);
  final VerificationMeta _codeMeta = const VerificationMeta('code');
  GeneratedColumn<String> _code;
  @override
  GeneratedColumn<String> get code =>
      _code ??= GeneratedColumn<String>('code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _parentCodeMeta = const VerificationMeta('parentCode');
  GeneratedColumn<String> _parentCode;
  @override
  GeneratedColumn<String> get parentCode =>
      _parentCode ??= GeneratedColumn<String>('parent_code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _ruleNameMeta = const VerificationMeta('ruleName');
  GeneratedColumn<String> _ruleName;
  @override
  GeneratedColumn<String> get ruleName =>
      _ruleName ??= GeneratedColumn<String>('rule_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _valueMeta = const VerificationMeta('value');
  GeneratedColumn<String> _value;
  @override
  GeneratedColumn<String> get value =>
      _value ??= GeneratedColumn<String>('value', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  GeneratedColumn<String> _description;
  @override
  GeneratedColumn<String> get description =>
      _description ??= GeneratedColumn<String>('description', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceRuleMeta = const VerificationMeta('deviceRule');
  GeneratedColumn<String> _deviceRule;
  @override
  GeneratedColumn<String> get deviceRule =>
      _deviceRule ??= GeneratedColumn<String>('device_rule', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _userRuleMeta = const VerificationMeta('userRule');
  GeneratedColumn<String> _userRule;
  @override
  GeneratedColumn<String> get userRule =>
      _userRule ??= GeneratedColumn<String>('user_rule', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _domainMeta = const VerificationMeta('domain');
  GeneratedColumn<String> _domain;
  @override
  GeneratedColumn<String> get domain =>
      _domain ??= GeneratedColumn<String>('domain', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceIdMeta = const VerificationMeta('deviceId');
  GeneratedColumn<String> _deviceId;
  @override
  GeneratedColumn<String> get deviceId =>
      _deviceId ??= GeneratedColumn<String>('device_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _screenMeta = const VerificationMeta('screen');
  GeneratedColumn<String> _screen;
  @override
  GeneratedColumn<String> get screen =>
      _screen ??= GeneratedColumn<String>('screen', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isApplyMeta = const VerificationMeta('isApply');
  GeneratedColumn<bool> _isApply;
  @override
  GeneratedColumn<bool> get isApply =>
      _isApply ??= GeneratedColumn<bool>('is_apply', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_apply IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _syncErrorMeta = const VerificationMeta('syncError');
  GeneratedColumn<String> _syncError;
  @override
  GeneratedColumn<String> get syncError =>
      _syncError ??= GeneratedColumn<String>('sync_error', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _expiredDateTimeMeta =
      const VerificationMeta('expiredDateTime');
  GeneratedColumn<DateTime> _expiredDateTime;
  @override
  GeneratedColumn<DateTime> get expiredDateTime => _expiredDateTime ??=
      GeneratedColumn<DateTime>('expired_date_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _dataTypeMeta = const VerificationMeta('dataType');
  GeneratedColumn<String> _dataType;
  @override
  GeneratedColumn<String> get dataType =>
      _dataType ??= GeneratedColumn<String>('data_type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _dataValueMeta = const VerificationMeta('dataValue');
  GeneratedColumn<String> _dataValue;
  @override
  GeneratedColumn<String> get dataValue =>
      _dataValue ??= GeneratedColumn<String>('data_value', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _groupsMeta = const VerificationMeta('groups');
  GeneratedColumn<String> _groups;
  @override
  GeneratedColumn<String> get groups =>
      _groups ??= GeneratedColumn<String>('groups', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        code,
        parentCode,
        ruleName,
        value,
        description,
        deviceRule,
        userRule,
        domain,
        deviceId,
        userName,
        screen,
        isApply,
        syncError,
        expiredDateTime,
        dataType,
        dataValue,
        groups,
        tenantId
      ];
  @override
  String get aliasedName => _alias ?? 'non_global_business_rule';
  @override
  String get actualTableName => 'non_global_business_rule';
  @override
  VerificationContext validateIntegrity(
      Insertable<NonGlobalBusinessRuleData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code'], _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('parent_code')) {
      context.handle(
          _parentCodeMeta,
          parentCode.isAcceptableOrUnknown(
              data['parent_code'], _parentCodeMeta));
    } else if (isInserting) {
      context.missing(_parentCodeMeta);
    }
    if (data.containsKey('rule_name')) {
      context.handle(_ruleNameMeta,
          ruleName.isAcceptableOrUnknown(data['rule_name'], _ruleNameMeta));
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value'], _valueMeta));
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description'], _descriptionMeta));
    }
    if (data.containsKey('device_rule')) {
      context.handle(
          _deviceRuleMeta,
          deviceRule.isAcceptableOrUnknown(
              data['device_rule'], _deviceRuleMeta));
    }
    if (data.containsKey('user_rule')) {
      context.handle(_userRuleMeta,
          userRule.isAcceptableOrUnknown(data['user_rule'], _userRuleMeta));
    }
    if (data.containsKey('domain')) {
      context.handle(_domainMeta,
          domain.isAcceptableOrUnknown(data['domain'], _domainMeta));
    }
    if (data.containsKey('device_id')) {
      context.handle(_deviceIdMeta,
          deviceId.isAcceptableOrUnknown(data['device_id'], _deviceIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    }
    if (data.containsKey('screen')) {
      context.handle(_screenMeta,
          screen.isAcceptableOrUnknown(data['screen'], _screenMeta));
    }
    if (data.containsKey('is_apply')) {
      context.handle(_isApplyMeta,
          isApply.isAcceptableOrUnknown(data['is_apply'], _isApplyMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error'], _syncErrorMeta));
    }
    if (data.containsKey('expired_date_time')) {
      context.handle(
          _expiredDateTimeMeta,
          expiredDateTime.isAcceptableOrUnknown(
              data['expired_date_time'], _expiredDateTimeMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type'], _dataTypeMeta));
    }
    if (data.containsKey('data_value')) {
      context.handle(_dataValueMeta,
          dataValue.isAcceptableOrUnknown(data['data_value'], _dataValueMeta));
    }
    if (data.containsKey('groups')) {
      context.handle(_groupsMeta,
          groups.isAcceptableOrUnknown(data['groups'], _groupsMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  NonGlobalBusinessRuleData map(Map<String, dynamic> data,
      {String tablePrefix}) {
    return NonGlobalBusinessRuleData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $NonGlobalBusinessRuleTable createAlias(String alias) {
    return $NonGlobalBusinessRuleTable(_db, alias);
  }
}

class ApplicationLoggerData extends DataClass
    implements Insertable<ApplicationLoggerData> {
  final int tenantId;
  final String userName;
  final int userId;
  final int id;
  final String functionName;
  final DateTime logDateTime;
  final String syncFrequency;
  final String logDescription;
  final String documentNo;
  final String deviceId;
  final String logCode;
  final String logSeverity;
  final DateTime exportDateTime;
  final String exportStatus;
  final String syncError;
  ApplicationLoggerData(
      {this.tenantId,
      this.userName,
      this.userId,
      @required this.id,
      @required this.functionName,
      @required this.logDateTime,
      @required this.syncFrequency,
      @required this.logDescription,
      @required this.documentNo,
      @required this.deviceId,
      @required this.logCode,
      @required this.logSeverity,
      this.exportDateTime,
      @required this.exportStatus,
      this.syncError});
  factory ApplicationLoggerData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return ApplicationLoggerData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      userId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      functionName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}function_name']),
      logDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}log_date_time']),
      syncFrequency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sync_frequency']),
      logDescription: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}log_description']),
      documentNo: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}document_no']),
      deviceId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_id']),
      logCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}log_code']),
      logSeverity: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}log_severity']),
      exportDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}export_date_time']),
      exportStatus: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}export_status']),
      syncError: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sync_error']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<int>(userId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || functionName != null) {
      map['function_name'] = Variable<String>(functionName);
    }
    if (!nullToAbsent || logDateTime != null) {
      map['log_date_time'] = Variable<DateTime>(logDateTime);
    }
    if (!nullToAbsent || syncFrequency != null) {
      map['sync_frequency'] = Variable<String>(syncFrequency);
    }
    if (!nullToAbsent || logDescription != null) {
      map['log_description'] = Variable<String>(logDescription);
    }
    if (!nullToAbsent || documentNo != null) {
      map['document_no'] = Variable<String>(documentNo);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || logCode != null) {
      map['log_code'] = Variable<String>(logCode);
    }
    if (!nullToAbsent || logSeverity != null) {
      map['log_severity'] = Variable<String>(logSeverity);
    }
    if (!nullToAbsent || exportDateTime != null) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime);
    }
    if (!nullToAbsent || exportStatus != null) {
      map['export_status'] = Variable<String>(exportStatus);
    }
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    return map;
  }

  ApplicationLoggerCompanion toCompanion(bool nullToAbsent) {
    return ApplicationLoggerCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      functionName: functionName == null && nullToAbsent
          ? const Value.absent()
          : Value(functionName),
      logDateTime: logDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(logDateTime),
      syncFrequency: syncFrequency == null && nullToAbsent
          ? const Value.absent()
          : Value(syncFrequency),
      logDescription: logDescription == null && nullToAbsent
          ? const Value.absent()
          : Value(logDescription),
      documentNo: documentNo == null && nullToAbsent
          ? const Value.absent()
          : Value(documentNo),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      logCode: logCode == null && nullToAbsent
          ? const Value.absent()
          : Value(logCode),
      logSeverity: logSeverity == null && nullToAbsent
          ? const Value.absent()
          : Value(logSeverity),
      exportDateTime: exportDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(exportDateTime),
      exportStatus: exportStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(exportStatus),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
    );
  }

  factory ApplicationLoggerData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ApplicationLoggerData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      userName: serializer.fromJson<String>(json['userName']),
      userId: serializer.fromJson<int>(json['userId']),
      id: serializer.fromJson<int>(json['id']),
      functionName: serializer.fromJson<String>(json['functionName']),
      logDateTime: serializer.fromJson<DateTime>(json['logDateTime']),
      syncFrequency: serializer.fromJson<String>(json['syncFrequency']),
      logDescription: serializer.fromJson<String>(json['logDescription']),
      documentNo: serializer.fromJson<String>(json['documentNo']),
      deviceId: serializer.fromJson<String>(json['deviceId']),
      logCode: serializer.fromJson<String>(json['logCode']),
      logSeverity: serializer.fromJson<String>(json['logSeverity']),
      exportDateTime: serializer.fromJson<DateTime>(json['exportDateTime']),
      exportStatus: serializer.fromJson<String>(json['exportStatus']),
      syncError: serializer.fromJson<String>(json['syncError']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'userName': serializer.toJson<String>(userName),
      'userId': serializer.toJson<int>(userId),
      'id': serializer.toJson<int>(id),
      'functionName': serializer.toJson<String>(functionName),
      'logDateTime': serializer.toJson<DateTime>(logDateTime),
      'syncFrequency': serializer.toJson<String>(syncFrequency),
      'logDescription': serializer.toJson<String>(logDescription),
      'documentNo': serializer.toJson<String>(documentNo),
      'deviceId': serializer.toJson<String>(deviceId),
      'logCode': serializer.toJson<String>(logCode),
      'logSeverity': serializer.toJson<String>(logSeverity),
      'exportDateTime': serializer.toJson<DateTime>(exportDateTime),
      'exportStatus': serializer.toJson<String>(exportStatus),
      'syncError': serializer.toJson<String>(syncError),
    };
  }

  ApplicationLoggerData copyWith(
          {int tenantId,
          String userName,
          int userId,
          int id,
          String functionName,
          DateTime logDateTime,
          String syncFrequency,
          String logDescription,
          String documentNo,
          String deviceId,
          String logCode,
          String logSeverity,
          DateTime exportDateTime,
          String exportStatus,
          String syncError}) =>
      ApplicationLoggerData(
        tenantId: tenantId ?? this.tenantId,
        userName: userName ?? this.userName,
        userId: userId ?? this.userId,
        id: id ?? this.id,
        functionName: functionName ?? this.functionName,
        logDateTime: logDateTime ?? this.logDateTime,
        syncFrequency: syncFrequency ?? this.syncFrequency,
        logDescription: logDescription ?? this.logDescription,
        documentNo: documentNo ?? this.documentNo,
        deviceId: deviceId ?? this.deviceId,
        logCode: logCode ?? this.logCode,
        logSeverity: logSeverity ?? this.logSeverity,
        exportDateTime: exportDateTime ?? this.exportDateTime,
        exportStatus: exportStatus ?? this.exportStatus,
        syncError: syncError ?? this.syncError,
      );
  @override
  String toString() {
    return (StringBuffer('ApplicationLoggerData(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('functionName: $functionName, ')
          ..write('logDateTime: $logDateTime, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('logDescription: $logDescription, ')
          ..write('documentNo: $documentNo, ')
          ..write('deviceId: $deviceId, ')
          ..write('logCode: $logCode, ')
          ..write('logSeverity: $logSeverity, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('syncError: $syncError')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      userName,
      userId,
      id,
      functionName,
      logDateTime,
      syncFrequency,
      logDescription,
      documentNo,
      deviceId,
      logCode,
      logSeverity,
      exportDateTime,
      exportStatus,
      syncError);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ApplicationLoggerData &&
          other.tenantId == this.tenantId &&
          other.userName == this.userName &&
          other.userId == this.userId &&
          other.id == this.id &&
          other.functionName == this.functionName &&
          other.logDateTime == this.logDateTime &&
          other.syncFrequency == this.syncFrequency &&
          other.logDescription == this.logDescription &&
          other.documentNo == this.documentNo &&
          other.deviceId == this.deviceId &&
          other.logCode == this.logCode &&
          other.logSeverity == this.logSeverity &&
          other.exportDateTime == this.exportDateTime &&
          other.exportStatus == this.exportStatus &&
          other.syncError == this.syncError);
}

class ApplicationLoggerCompanion
    extends UpdateCompanion<ApplicationLoggerData> {
  final Value<int> tenantId;
  final Value<String> userName;
  final Value<int> userId;
  final Value<int> id;
  final Value<String> functionName;
  final Value<DateTime> logDateTime;
  final Value<String> syncFrequency;
  final Value<String> logDescription;
  final Value<String> documentNo;
  final Value<String> deviceId;
  final Value<String> logCode;
  final Value<String> logSeverity;
  final Value<DateTime> exportDateTime;
  final Value<String> exportStatus;
  final Value<String> syncError;
  const ApplicationLoggerCompanion({
    this.tenantId = const Value.absent(),
    this.userName = const Value.absent(),
    this.userId = const Value.absent(),
    this.id = const Value.absent(),
    this.functionName = const Value.absent(),
    this.logDateTime = const Value.absent(),
    this.syncFrequency = const Value.absent(),
    this.logDescription = const Value.absent(),
    this.documentNo = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.logCode = const Value.absent(),
    this.logSeverity = const Value.absent(),
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.syncError = const Value.absent(),
  });
  ApplicationLoggerCompanion.insert({
    this.tenantId = const Value.absent(),
    this.userName = const Value.absent(),
    this.userId = const Value.absent(),
    this.id = const Value.absent(),
    @required String functionName,
    @required DateTime logDateTime,
    @required String syncFrequency,
    @required String logDescription,
    @required String documentNo,
    @required String deviceId,
    @required String logCode,
    @required String logSeverity,
    this.exportDateTime = const Value.absent(),
    this.exportStatus = const Value.absent(),
    this.syncError = const Value.absent(),
  })  : functionName = Value(functionName),
        logDateTime = Value(logDateTime),
        syncFrequency = Value(syncFrequency),
        logDescription = Value(logDescription),
        documentNo = Value(documentNo),
        deviceId = Value(deviceId),
        logCode = Value(logCode),
        logSeverity = Value(logSeverity);
  static Insertable<ApplicationLoggerData> custom({
    Expression<int> tenantId,
    Expression<String> userName,
    Expression<int> userId,
    Expression<int> id,
    Expression<String> functionName,
    Expression<DateTime> logDateTime,
    Expression<String> syncFrequency,
    Expression<String> logDescription,
    Expression<String> documentNo,
    Expression<String> deviceId,
    Expression<String> logCode,
    Expression<String> logSeverity,
    Expression<DateTime> exportDateTime,
    Expression<String> exportStatus,
    Expression<String> syncError,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (userName != null) 'user_name': userName,
      if (userId != null) 'user_id': userId,
      if (id != null) 'id': id,
      if (functionName != null) 'function_name': functionName,
      if (logDateTime != null) 'log_date_time': logDateTime,
      if (syncFrequency != null) 'sync_frequency': syncFrequency,
      if (logDescription != null) 'log_description': logDescription,
      if (documentNo != null) 'document_no': documentNo,
      if (deviceId != null) 'device_id': deviceId,
      if (logCode != null) 'log_code': logCode,
      if (logSeverity != null) 'log_severity': logSeverity,
      if (exportDateTime != null) 'export_date_time': exportDateTime,
      if (exportStatus != null) 'export_status': exportStatus,
      if (syncError != null) 'sync_error': syncError,
    });
  }

  ApplicationLoggerCompanion copyWith(
      {Value<int> tenantId,
      Value<String> userName,
      Value<int> userId,
      Value<int> id,
      Value<String> functionName,
      Value<DateTime> logDateTime,
      Value<String> syncFrequency,
      Value<String> logDescription,
      Value<String> documentNo,
      Value<String> deviceId,
      Value<String> logCode,
      Value<String> logSeverity,
      Value<DateTime> exportDateTime,
      Value<String> exportStatus,
      Value<String> syncError}) {
    return ApplicationLoggerCompanion(
      tenantId: tenantId ?? this.tenantId,
      userName: userName ?? this.userName,
      userId: userId ?? this.userId,
      id: id ?? this.id,
      functionName: functionName ?? this.functionName,
      logDateTime: logDateTime ?? this.logDateTime,
      syncFrequency: syncFrequency ?? this.syncFrequency,
      logDescription: logDescription ?? this.logDescription,
      documentNo: documentNo ?? this.documentNo,
      deviceId: deviceId ?? this.deviceId,
      logCode: logCode ?? this.logCode,
      logSeverity: logSeverity ?? this.logSeverity,
      exportDateTime: exportDateTime ?? this.exportDateTime,
      exportStatus: exportStatus ?? this.exportStatus,
      syncError: syncError ?? this.syncError,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (functionName.present) {
      map['function_name'] = Variable<String>(functionName.value);
    }
    if (logDateTime.present) {
      map['log_date_time'] = Variable<DateTime>(logDateTime.value);
    }
    if (syncFrequency.present) {
      map['sync_frequency'] = Variable<String>(syncFrequency.value);
    }
    if (logDescription.present) {
      map['log_description'] = Variable<String>(logDescription.value);
    }
    if (documentNo.present) {
      map['document_no'] = Variable<String>(documentNo.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (logCode.present) {
      map['log_code'] = Variable<String>(logCode.value);
    }
    if (logSeverity.present) {
      map['log_severity'] = Variable<String>(logSeverity.value);
    }
    if (exportDateTime.present) {
      map['export_date_time'] = Variable<DateTime>(exportDateTime.value);
    }
    if (exportStatus.present) {
      map['export_status'] = Variable<String>(exportStatus.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ApplicationLoggerCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('functionName: $functionName, ')
          ..write('logDateTime: $logDateTime, ')
          ..write('syncFrequency: $syncFrequency, ')
          ..write('logDescription: $logDescription, ')
          ..write('documentNo: $documentNo, ')
          ..write('deviceId: $deviceId, ')
          ..write('logCode: $logCode, ')
          ..write('logSeverity: $logSeverity, ')
          ..write('exportDateTime: $exportDateTime, ')
          ..write('exportStatus: $exportStatus, ')
          ..write('syncError: $syncError')
          ..write(')'))
        .toString();
  }
}

class $ApplicationLoggerTable extends ApplicationLogger
    with TableInfo<$ApplicationLoggerTable, ApplicationLoggerData> {
  final GeneratedDatabase _db;
  final String _alias;
  $ApplicationLoggerTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _userIdMeta = const VerificationMeta('userId');
  GeneratedColumn<int> _userId;
  @override
  GeneratedColumn<int> get userId =>
      _userId ??= GeneratedColumn<int>('user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(),
          requiredDuringInsert: false,
          defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
  final VerificationMeta _functionNameMeta =
      const VerificationMeta('functionName');
  GeneratedColumn<String> _functionName;
  @override
  GeneratedColumn<String> get functionName => _functionName ??=
      GeneratedColumn<String>('function_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _logDateTimeMeta =
      const VerificationMeta('logDateTime');
  GeneratedColumn<DateTime> _logDateTime;
  @override
  GeneratedColumn<DateTime> get logDateTime => _logDateTime ??=
      GeneratedColumn<DateTime>('log_date_time', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _syncFrequencyMeta =
      const VerificationMeta('syncFrequency');
  GeneratedColumn<String> _syncFrequency;
  @override
  GeneratedColumn<String> get syncFrequency => _syncFrequency ??=
      GeneratedColumn<String>('sync_frequency', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _logDescriptionMeta =
      const VerificationMeta('logDescription');
  GeneratedColumn<String> _logDescription;
  @override
  GeneratedColumn<String> get logDescription => _logDescription ??=
      GeneratedColumn<String>('log_description', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _documentNoMeta = const VerificationMeta('documentNo');
  GeneratedColumn<String> _documentNo;
  @override
  GeneratedColumn<String> get documentNo =>
      _documentNo ??= GeneratedColumn<String>('document_no', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _deviceIdMeta = const VerificationMeta('deviceId');
  GeneratedColumn<String> _deviceId;
  @override
  GeneratedColumn<String> get deviceId =>
      _deviceId ??= GeneratedColumn<String>('device_id', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _logCodeMeta = const VerificationMeta('logCode');
  GeneratedColumn<String> _logCode;
  @override
  GeneratedColumn<String> get logCode =>
      _logCode ??= GeneratedColumn<String>('log_code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _logSeverityMeta =
      const VerificationMeta('logSeverity');
  GeneratedColumn<String> _logSeverity;
  @override
  GeneratedColumn<String> get logSeverity => _logSeverity ??=
      GeneratedColumn<String>('log_severity', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _exportDateTimeMeta =
      const VerificationMeta('exportDateTime');
  GeneratedColumn<DateTime> _exportDateTime;
  @override
  GeneratedColumn<DateTime> get exportDateTime => _exportDateTime ??=
      GeneratedColumn<DateTime>('export_date_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _exportStatusMeta =
      const VerificationMeta('exportStatus');
  GeneratedColumn<String> _exportStatus;
  @override
  GeneratedColumn<String> get exportStatus => _exportStatus ??=
      GeneratedColumn<String>('export_status', aliasedName, false,
          type: const StringType(),
          requiredDuringInsert: false,
          defaultValue: Constant('Pending'));
  final VerificationMeta _syncErrorMeta = const VerificationMeta('syncError');
  GeneratedColumn<String> _syncError;
  @override
  GeneratedColumn<String> get syncError =>
      _syncError ??= GeneratedColumn<String>('sync_error', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        userName,
        userId,
        id,
        functionName,
        logDateTime,
        syncFrequency,
        logDescription,
        documentNo,
        deviceId,
        logCode,
        logSeverity,
        exportDateTime,
        exportStatus,
        syncError
      ];
  @override
  String get aliasedName => _alias ?? 'application_logger';
  @override
  String get actualTableName => 'application_logger';
  @override
  VerificationContext validateIntegrity(
      Insertable<ApplicationLoggerData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id'], _userIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('function_name')) {
      context.handle(
          _functionNameMeta,
          functionName.isAcceptableOrUnknown(
              data['function_name'], _functionNameMeta));
    } else if (isInserting) {
      context.missing(_functionNameMeta);
    }
    if (data.containsKey('log_date_time')) {
      context.handle(
          _logDateTimeMeta,
          logDateTime.isAcceptableOrUnknown(
              data['log_date_time'], _logDateTimeMeta));
    } else if (isInserting) {
      context.missing(_logDateTimeMeta);
    }
    if (data.containsKey('sync_frequency')) {
      context.handle(
          _syncFrequencyMeta,
          syncFrequency.isAcceptableOrUnknown(
              data['sync_frequency'], _syncFrequencyMeta));
    } else if (isInserting) {
      context.missing(_syncFrequencyMeta);
    }
    if (data.containsKey('log_description')) {
      context.handle(
          _logDescriptionMeta,
          logDescription.isAcceptableOrUnknown(
              data['log_description'], _logDescriptionMeta));
    } else if (isInserting) {
      context.missing(_logDescriptionMeta);
    }
    if (data.containsKey('document_no')) {
      context.handle(
          _documentNoMeta,
          documentNo.isAcceptableOrUnknown(
              data['document_no'], _documentNoMeta));
    } else if (isInserting) {
      context.missing(_documentNoMeta);
    }
    if (data.containsKey('device_id')) {
      context.handle(_deviceIdMeta,
          deviceId.isAcceptableOrUnknown(data['device_id'], _deviceIdMeta));
    } else if (isInserting) {
      context.missing(_deviceIdMeta);
    }
    if (data.containsKey('log_code')) {
      context.handle(_logCodeMeta,
          logCode.isAcceptableOrUnknown(data['log_code'], _logCodeMeta));
    } else if (isInserting) {
      context.missing(_logCodeMeta);
    }
    if (data.containsKey('log_severity')) {
      context.handle(
          _logSeverityMeta,
          logSeverity.isAcceptableOrUnknown(
              data['log_severity'], _logSeverityMeta));
    } else if (isInserting) {
      context.missing(_logSeverityMeta);
    }
    if (data.containsKey('export_date_time')) {
      context.handle(
          _exportDateTimeMeta,
          exportDateTime.isAcceptableOrUnknown(
              data['export_date_time'], _exportDateTimeMeta));
    }
    if (data.containsKey('export_status')) {
      context.handle(
          _exportStatusMeta,
          exportStatus.isAcceptableOrUnknown(
              data['export_status'], _exportStatusMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error'], _syncErrorMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ApplicationLoggerData map(Map<String, dynamic> data, {String tablePrefix}) {
    return ApplicationLoggerData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $ApplicationLoggerTable createAlias(String alias) {
    return $ApplicationLoggerTable(_db, alias);
  }
}

class TenantData extends DataClass implements Insertable<TenantData> {
  final int tenantId;
  final String tenantName;
  final int tenantState;
  final int userId;
  final String userName;
  TenantData(
      {@required this.tenantId,
      this.tenantName,
      this.tenantState,
      this.userId,
      this.userName});
  factory TenantData.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return TenantData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      tenantName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_name']),
      tenantState: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_state']),
      userId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_id']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || tenantName != null) {
      map['tenant_name'] = Variable<String>(tenantName);
    }
    if (!nullToAbsent || tenantState != null) {
      map['tenant_state'] = Variable<int>(tenantState);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<int>(userId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    return map;
  }

  TenantCompanion toCompanion(bool nullToAbsent) {
    return TenantCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      tenantName: tenantName == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantName),
      tenantState: tenantState == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantState),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
    );
  }

  factory TenantData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TenantData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      tenantName: serializer.fromJson<String>(json['tenantName']),
      tenantState: serializer.fromJson<int>(json['tenantState']),
      userId: serializer.fromJson<int>(json['userId']),
      userName: serializer.fromJson<String>(json['userName']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'tenantName': serializer.toJson<String>(tenantName),
      'tenantState': serializer.toJson<int>(tenantState),
      'userId': serializer.toJson<int>(userId),
      'userName': serializer.toJson<String>(userName),
    };
  }

  TenantData copyWith(
          {int tenantId,
          String tenantName,
          int tenantState,
          int userId,
          String userName}) =>
      TenantData(
        tenantId: tenantId ?? this.tenantId,
        tenantName: tenantName ?? this.tenantName,
        tenantState: tenantState ?? this.tenantState,
        userId: userId ?? this.userId,
        userName: userName ?? this.userName,
      );
  @override
  String toString() {
    return (StringBuffer('TenantData(')
          ..write('tenantId: $tenantId, ')
          ..write('tenantName: $tenantName, ')
          ..write('tenantState: $tenantState, ')
          ..write('userId: $userId, ')
          ..write('userName: $userName')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(tenantId, tenantName, tenantState, userId, userName);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TenantData &&
          other.tenantId == this.tenantId &&
          other.tenantName == this.tenantName &&
          other.tenantState == this.tenantState &&
          other.userId == this.userId &&
          other.userName == this.userName);
}

class TenantCompanion extends UpdateCompanion<TenantData> {
  final Value<int> tenantId;
  final Value<String> tenantName;
  final Value<int> tenantState;
  final Value<int> userId;
  final Value<String> userName;
  const TenantCompanion({
    this.tenantId = const Value.absent(),
    this.tenantName = const Value.absent(),
    this.tenantState = const Value.absent(),
    this.userId = const Value.absent(),
    this.userName = const Value.absent(),
  });
  TenantCompanion.insert({
    this.tenantId = const Value.absent(),
    this.tenantName = const Value.absent(),
    this.tenantState = const Value.absent(),
    this.userId = const Value.absent(),
    this.userName = const Value.absent(),
  });
  static Insertable<TenantData> custom({
    Expression<int> tenantId,
    Expression<String> tenantName,
    Expression<int> tenantState,
    Expression<int> userId,
    Expression<String> userName,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (tenantName != null) 'tenant_name': tenantName,
      if (tenantState != null) 'tenant_state': tenantState,
      if (userId != null) 'user_id': userId,
      if (userName != null) 'user_name': userName,
    });
  }

  TenantCompanion copyWith(
      {Value<int> tenantId,
      Value<String> tenantName,
      Value<int> tenantState,
      Value<int> userId,
      Value<String> userName}) {
    return TenantCompanion(
      tenantId: tenantId ?? this.tenantId,
      tenantName: tenantName ?? this.tenantName,
      tenantState: tenantState ?? this.tenantState,
      userId: userId ?? this.userId,
      userName: userName ?? this.userName,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (tenantName.present) {
      map['tenant_name'] = Variable<String>(tenantName.value);
    }
    if (tenantState.present) {
      map['tenant_state'] = Variable<int>(tenantState.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TenantCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('tenantName: $tenantName, ')
          ..write('tenantState: $tenantState, ')
          ..write('userId: $userId, ')
          ..write('userName: $userName')
          ..write(')'))
        .toString();
  }
}

class $TenantTable extends Tenant with TableInfo<$TenantTable, TenantData> {
  final GeneratedDatabase _db;
  final String _alias;
  $TenantTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, false,
          type: const IntType(),
          requiredDuringInsert: false,
          defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
  final VerificationMeta _tenantNameMeta = const VerificationMeta('tenantName');
  GeneratedColumn<String> _tenantName;
  @override
  GeneratedColumn<String> get tenantName =>
      _tenantName ??= GeneratedColumn<String>('tenant_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _tenantStateMeta =
      const VerificationMeta('tenantState');
  GeneratedColumn<int> _tenantState;
  @override
  GeneratedColumn<int> get tenantState =>
      _tenantState ??= GeneratedColumn<int>('tenant_state', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _userIdMeta = const VerificationMeta('userId');
  GeneratedColumn<int> _userId;
  @override
  GeneratedColumn<int> get userId =>
      _userId ??= GeneratedColumn<int>('user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [tenantId, tenantName, tenantState, userId, userName];
  @override
  String get aliasedName => _alias ?? 'tenant';
  @override
  String get actualTableName => 'tenant';
  @override
  VerificationContext validateIntegrity(Insertable<TenantData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('tenant_name')) {
      context.handle(
          _tenantNameMeta,
          tenantName.isAcceptableOrUnknown(
              data['tenant_name'], _tenantNameMeta));
    }
    if (data.containsKey('tenant_state')) {
      context.handle(
          _tenantStateMeta,
          tenantState.isAcceptableOrUnknown(
              data['tenant_state'], _tenantStateMeta));
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id'], _userIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {tenantId};
  @override
  TenantData map(Map<String, dynamic> data, {String tablePrefix}) {
    return TenantData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $TenantTable createAlias(String alias) {
    return $TenantTable(_db, alias);
  }
}

class NonGlobalPreferenceData extends DataClass
    implements Insertable<NonGlobalPreferenceData> {
  final int id;
  final String parentCode;
  final String code;
  final String value;
  final String settingType;
  final String deviceId;
  final String userName;
  final String screen;
  final bool isApply;
  final DateTime expiredDateTime;
  final String syncError;
  final String dataType;
  final String dataValue;
  final String groups;
  final int tenantId;
  NonGlobalPreferenceData(
      {@required this.id,
      @required this.parentCode,
      @required this.code,
      @required this.value,
      this.settingType,
      this.deviceId,
      this.userName,
      this.screen,
      @required this.isApply,
      this.expiredDateTime,
      this.syncError,
      this.dataType,
      this.dataValue,
      this.groups,
      this.tenantId});
  factory NonGlobalPreferenceData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return NonGlobalPreferenceData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      parentCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}parent_code']),
      code: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}code']),
      value: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}value']),
      settingType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}setting_type']),
      deviceId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_id']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      screen: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}screen']),
      isApply: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_apply']),
      expiredDateTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}expired_date_time']),
      syncError: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sync_error']),
      dataType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}data_type']),
      dataValue: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}data_value']),
      groups: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}groups']),
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || parentCode != null) {
      map['parent_code'] = Variable<String>(parentCode);
    }
    if (!nullToAbsent || code != null) {
      map['code'] = Variable<String>(code);
    }
    if (!nullToAbsent || value != null) {
      map['value'] = Variable<String>(value);
    }
    if (!nullToAbsent || settingType != null) {
      map['setting_type'] = Variable<String>(settingType);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || screen != null) {
      map['screen'] = Variable<String>(screen);
    }
    if (!nullToAbsent || isApply != null) {
      map['is_apply'] = Variable<bool>(isApply);
    }
    if (!nullToAbsent || expiredDateTime != null) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime);
    }
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || dataType != null) {
      map['data_type'] = Variable<String>(dataType);
    }
    if (!nullToAbsent || dataValue != null) {
      map['data_value'] = Variable<String>(dataValue);
    }
    if (!nullToAbsent || groups != null) {
      map['groups'] = Variable<String>(groups);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    return map;
  }

  NonGlobalPreferenceCompanion toCompanion(bool nullToAbsent) {
    return NonGlobalPreferenceCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      parentCode: parentCode == null && nullToAbsent
          ? const Value.absent()
          : Value(parentCode),
      code: code == null && nullToAbsent ? const Value.absent() : Value(code),
      value:
          value == null && nullToAbsent ? const Value.absent() : Value(value),
      settingType: settingType == null && nullToAbsent
          ? const Value.absent()
          : Value(settingType),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      screen:
          screen == null && nullToAbsent ? const Value.absent() : Value(screen),
      isApply: isApply == null && nullToAbsent
          ? const Value.absent()
          : Value(isApply),
      expiredDateTime: expiredDateTime == null && nullToAbsent
          ? const Value.absent()
          : Value(expiredDateTime),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      dataType: dataType == null && nullToAbsent
          ? const Value.absent()
          : Value(dataType),
      dataValue: dataValue == null && nullToAbsent
          ? const Value.absent()
          : Value(dataValue),
      groups:
          groups == null && nullToAbsent ? const Value.absent() : Value(groups),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
    );
  }

  factory NonGlobalPreferenceData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return NonGlobalPreferenceData(
      id: serializer.fromJson<int>(json['id']),
      parentCode: serializer.fromJson<String>(json['parentCode']),
      code: serializer.fromJson<String>(json['code']),
      value: serializer.fromJson<String>(json['value']),
      settingType: serializer.fromJson<String>(json['settingType']),
      deviceId: serializer.fromJson<String>(json['deviceId']),
      userName: serializer.fromJson<String>(json['userName']),
      screen: serializer.fromJson<String>(json['screen']),
      isApply: serializer.fromJson<bool>(json['isApply']),
      expiredDateTime: serializer.fromJson<DateTime>(json['expiredDateTime']),
      syncError: serializer.fromJson<String>(json['syncError']),
      dataType: serializer.fromJson<String>(json['dataType']),
      dataValue: serializer.fromJson<String>(json['dataValue']),
      groups: serializer.fromJson<String>(json['groups']),
      tenantId: serializer.fromJson<int>(json['tenantId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'parentCode': serializer.toJson<String>(parentCode),
      'code': serializer.toJson<String>(code),
      'value': serializer.toJson<String>(value),
      'settingType': serializer.toJson<String>(settingType),
      'deviceId': serializer.toJson<String>(deviceId),
      'userName': serializer.toJson<String>(userName),
      'screen': serializer.toJson<String>(screen),
      'isApply': serializer.toJson<bool>(isApply),
      'expiredDateTime': serializer.toJson<DateTime>(expiredDateTime),
      'syncError': serializer.toJson<String>(syncError),
      'dataType': serializer.toJson<String>(dataType),
      'dataValue': serializer.toJson<String>(dataValue),
      'groups': serializer.toJson<String>(groups),
      'tenantId': serializer.toJson<int>(tenantId),
    };
  }

  NonGlobalPreferenceData copyWith(
          {int id,
          String parentCode,
          String code,
          String value,
          String settingType,
          String deviceId,
          String userName,
          String screen,
          bool isApply,
          DateTime expiredDateTime,
          String syncError,
          String dataType,
          String dataValue,
          String groups,
          int tenantId}) =>
      NonGlobalPreferenceData(
        id: id ?? this.id,
        parentCode: parentCode ?? this.parentCode,
        code: code ?? this.code,
        value: value ?? this.value,
        settingType: settingType ?? this.settingType,
        deviceId: deviceId ?? this.deviceId,
        userName: userName ?? this.userName,
        screen: screen ?? this.screen,
        isApply: isApply ?? this.isApply,
        expiredDateTime: expiredDateTime ?? this.expiredDateTime,
        syncError: syncError ?? this.syncError,
        dataType: dataType ?? this.dataType,
        dataValue: dataValue ?? this.dataValue,
        groups: groups ?? this.groups,
        tenantId: tenantId ?? this.tenantId,
      );
  @override
  String toString() {
    return (StringBuffer('NonGlobalPreferenceData(')
          ..write('id: $id, ')
          ..write('parentCode: $parentCode, ')
          ..write('code: $code, ')
          ..write('value: $value, ')
          ..write('settingType: $settingType, ')
          ..write('deviceId: $deviceId, ')
          ..write('userName: $userName, ')
          ..write('screen: $screen, ')
          ..write('isApply: $isApply, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('syncError: $syncError, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      parentCode,
      code,
      value,
      settingType,
      deviceId,
      userName,
      screen,
      isApply,
      expiredDateTime,
      syncError,
      dataType,
      dataValue,
      groups,
      tenantId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is NonGlobalPreferenceData &&
          other.id == this.id &&
          other.parentCode == this.parentCode &&
          other.code == this.code &&
          other.value == this.value &&
          other.settingType == this.settingType &&
          other.deviceId == this.deviceId &&
          other.userName == this.userName &&
          other.screen == this.screen &&
          other.isApply == this.isApply &&
          other.expiredDateTime == this.expiredDateTime &&
          other.syncError == this.syncError &&
          other.dataType == this.dataType &&
          other.dataValue == this.dataValue &&
          other.groups == this.groups &&
          other.tenantId == this.tenantId);
}

class NonGlobalPreferenceCompanion
    extends UpdateCompanion<NonGlobalPreferenceData> {
  final Value<int> id;
  final Value<String> parentCode;
  final Value<String> code;
  final Value<String> value;
  final Value<String> settingType;
  final Value<String> deviceId;
  final Value<String> userName;
  final Value<String> screen;
  final Value<bool> isApply;
  final Value<DateTime> expiredDateTime;
  final Value<String> syncError;
  final Value<String> dataType;
  final Value<String> dataValue;
  final Value<String> groups;
  final Value<int> tenantId;
  const NonGlobalPreferenceCompanion({
    this.id = const Value.absent(),
    this.parentCode = const Value.absent(),
    this.code = const Value.absent(),
    this.value = const Value.absent(),
    this.settingType = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userName = const Value.absent(),
    this.screen = const Value.absent(),
    this.isApply = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.syncError = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.tenantId = const Value.absent(),
  });
  NonGlobalPreferenceCompanion.insert({
    @required int id,
    @required String parentCode,
    @required String code,
    @required String value,
    this.settingType = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.userName = const Value.absent(),
    this.screen = const Value.absent(),
    this.isApply = const Value.absent(),
    this.expiredDateTime = const Value.absent(),
    this.syncError = const Value.absent(),
    this.dataType = const Value.absent(),
    this.dataValue = const Value.absent(),
    this.groups = const Value.absent(),
    this.tenantId = const Value.absent(),
  })  : id = Value(id),
        parentCode = Value(parentCode),
        code = Value(code),
        value = Value(value);
  static Insertable<NonGlobalPreferenceData> custom({
    Expression<int> id,
    Expression<String> parentCode,
    Expression<String> code,
    Expression<String> value,
    Expression<String> settingType,
    Expression<String> deviceId,
    Expression<String> userName,
    Expression<String> screen,
    Expression<bool> isApply,
    Expression<DateTime> expiredDateTime,
    Expression<String> syncError,
    Expression<String> dataType,
    Expression<String> dataValue,
    Expression<String> groups,
    Expression<int> tenantId,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (parentCode != null) 'parent_code': parentCode,
      if (code != null) 'code': code,
      if (value != null) 'value': value,
      if (settingType != null) 'setting_type': settingType,
      if (deviceId != null) 'device_id': deviceId,
      if (userName != null) 'user_name': userName,
      if (screen != null) 'screen': screen,
      if (isApply != null) 'is_apply': isApply,
      if (expiredDateTime != null) 'expired_date_time': expiredDateTime,
      if (syncError != null) 'sync_error': syncError,
      if (dataType != null) 'data_type': dataType,
      if (dataValue != null) 'data_value': dataValue,
      if (groups != null) 'groups': groups,
      if (tenantId != null) 'tenant_id': tenantId,
    });
  }

  NonGlobalPreferenceCompanion copyWith(
      {Value<int> id,
      Value<String> parentCode,
      Value<String> code,
      Value<String> value,
      Value<String> settingType,
      Value<String> deviceId,
      Value<String> userName,
      Value<String> screen,
      Value<bool> isApply,
      Value<DateTime> expiredDateTime,
      Value<String> syncError,
      Value<String> dataType,
      Value<String> dataValue,
      Value<String> groups,
      Value<int> tenantId}) {
    return NonGlobalPreferenceCompanion(
      id: id ?? this.id,
      parentCode: parentCode ?? this.parentCode,
      code: code ?? this.code,
      value: value ?? this.value,
      settingType: settingType ?? this.settingType,
      deviceId: deviceId ?? this.deviceId,
      userName: userName ?? this.userName,
      screen: screen ?? this.screen,
      isApply: isApply ?? this.isApply,
      expiredDateTime: expiredDateTime ?? this.expiredDateTime,
      syncError: syncError ?? this.syncError,
      dataType: dataType ?? this.dataType,
      dataValue: dataValue ?? this.dataValue,
      groups: groups ?? this.groups,
      tenantId: tenantId ?? this.tenantId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (parentCode.present) {
      map['parent_code'] = Variable<String>(parentCode.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (settingType.present) {
      map['setting_type'] = Variable<String>(settingType.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (screen.present) {
      map['screen'] = Variable<String>(screen.value);
    }
    if (isApply.present) {
      map['is_apply'] = Variable<bool>(isApply.value);
    }
    if (expiredDateTime.present) {
      map['expired_date_time'] = Variable<DateTime>(expiredDateTime.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (dataType.present) {
      map['data_type'] = Variable<String>(dataType.value);
    }
    if (dataValue.present) {
      map['data_value'] = Variable<String>(dataValue.value);
    }
    if (groups.present) {
      map['groups'] = Variable<String>(groups.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('NonGlobalPreferenceCompanion(')
          ..write('id: $id, ')
          ..write('parentCode: $parentCode, ')
          ..write('code: $code, ')
          ..write('value: $value, ')
          ..write('settingType: $settingType, ')
          ..write('deviceId: $deviceId, ')
          ..write('userName: $userName, ')
          ..write('screen: $screen, ')
          ..write('isApply: $isApply, ')
          ..write('expiredDateTime: $expiredDateTime, ')
          ..write('syncError: $syncError, ')
          ..write('dataType: $dataType, ')
          ..write('dataValue: $dataValue, ')
          ..write('groups: $groups, ')
          ..write('tenantId: $tenantId')
          ..write(')'))
        .toString();
  }
}

class $NonGlobalPreferenceTable extends NonGlobalPreference
    with TableInfo<$NonGlobalPreferenceTable, NonGlobalPreferenceData> {
  final GeneratedDatabase _db;
  final String _alias;
  $NonGlobalPreferenceTable(this._db, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _parentCodeMeta = const VerificationMeta('parentCode');
  GeneratedColumn<String> _parentCode;
  @override
  GeneratedColumn<String> get parentCode =>
      _parentCode ??= GeneratedColumn<String>('parent_code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _codeMeta = const VerificationMeta('code');
  GeneratedColumn<String> _code;
  @override
  GeneratedColumn<String> get code =>
      _code ??= GeneratedColumn<String>('code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _valueMeta = const VerificationMeta('value');
  GeneratedColumn<String> _value;
  @override
  GeneratedColumn<String> get value =>
      _value ??= GeneratedColumn<String>('value', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _settingTypeMeta =
      const VerificationMeta('settingType');
  GeneratedColumn<String> _settingType;
  @override
  GeneratedColumn<String> get settingType => _settingType ??=
      GeneratedColumn<String>('setting_type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceIdMeta = const VerificationMeta('deviceId');
  GeneratedColumn<String> _deviceId;
  @override
  GeneratedColumn<String> get deviceId =>
      _deviceId ??= GeneratedColumn<String>('device_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _screenMeta = const VerificationMeta('screen');
  GeneratedColumn<String> _screen;
  @override
  GeneratedColumn<String> get screen =>
      _screen ??= GeneratedColumn<String>('screen', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isApplyMeta = const VerificationMeta('isApply');
  GeneratedColumn<bool> _isApply;
  @override
  GeneratedColumn<bool> get isApply =>
      _isApply ??= GeneratedColumn<bool>('is_apply', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_apply IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _expiredDateTimeMeta =
      const VerificationMeta('expiredDateTime');
  GeneratedColumn<DateTime> _expiredDateTime;
  @override
  GeneratedColumn<DateTime> get expiredDateTime => _expiredDateTime ??=
      GeneratedColumn<DateTime>('expired_date_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _syncErrorMeta = const VerificationMeta('syncError');
  GeneratedColumn<String> _syncError;
  @override
  GeneratedColumn<String> get syncError =>
      _syncError ??= GeneratedColumn<String>('sync_error', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _dataTypeMeta = const VerificationMeta('dataType');
  GeneratedColumn<String> _dataType;
  @override
  GeneratedColumn<String> get dataType =>
      _dataType ??= GeneratedColumn<String>('data_type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _dataValueMeta = const VerificationMeta('dataValue');
  GeneratedColumn<String> _dataValue;
  @override
  GeneratedColumn<String> get dataValue =>
      _dataValue ??= GeneratedColumn<String>('data_value', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _groupsMeta = const VerificationMeta('groups');
  GeneratedColumn<String> _groups;
  @override
  GeneratedColumn<String> get groups =>
      _groups ??= GeneratedColumn<String>('groups', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        parentCode,
        code,
        value,
        settingType,
        deviceId,
        userName,
        screen,
        isApply,
        expiredDateTime,
        syncError,
        dataType,
        dataValue,
        groups,
        tenantId
      ];
  @override
  String get aliasedName => _alias ?? 'non_global_preference';
  @override
  String get actualTableName => 'non_global_preference';
  @override
  VerificationContext validateIntegrity(
      Insertable<NonGlobalPreferenceData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('parent_code')) {
      context.handle(
          _parentCodeMeta,
          parentCode.isAcceptableOrUnknown(
              data['parent_code'], _parentCodeMeta));
    } else if (isInserting) {
      context.missing(_parentCodeMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code'], _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
          _valueMeta, value.isAcceptableOrUnknown(data['value'], _valueMeta));
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('setting_type')) {
      context.handle(
          _settingTypeMeta,
          settingType.isAcceptableOrUnknown(
              data['setting_type'], _settingTypeMeta));
    }
    if (data.containsKey('device_id')) {
      context.handle(_deviceIdMeta,
          deviceId.isAcceptableOrUnknown(data['device_id'], _deviceIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    }
    if (data.containsKey('screen')) {
      context.handle(_screenMeta,
          screen.isAcceptableOrUnknown(data['screen'], _screenMeta));
    }
    if (data.containsKey('is_apply')) {
      context.handle(_isApplyMeta,
          isApply.isAcceptableOrUnknown(data['is_apply'], _isApplyMeta));
    }
    if (data.containsKey('expired_date_time')) {
      context.handle(
          _expiredDateTimeMeta,
          expiredDateTime.isAcceptableOrUnknown(
              data['expired_date_time'], _expiredDateTimeMeta));
    }
    if (data.containsKey('sync_error')) {
      context.handle(_syncErrorMeta,
          syncError.isAcceptableOrUnknown(data['sync_error'], _syncErrorMeta));
    }
    if (data.containsKey('data_type')) {
      context.handle(_dataTypeMeta,
          dataType.isAcceptableOrUnknown(data['data_type'], _dataTypeMeta));
    }
    if (data.containsKey('data_value')) {
      context.handle(_dataValueMeta,
          dataValue.isAcceptableOrUnknown(data['data_value'], _dataValueMeta));
    }
    if (data.containsKey('groups')) {
      context.handle(_groupsMeta,
          groups.isAcceptableOrUnknown(data['groups'], _groupsMeta));
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {code};
  @override
  NonGlobalPreferenceData map(Map<String, dynamic> data, {String tablePrefix}) {
    return NonGlobalPreferenceData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $NonGlobalPreferenceTable createAlias(String alias) {
    return $NonGlobalPreferenceTable(_db, alias);
  }
}

class DesktopData extends DataClass implements Insertable<DesktopData> {
  final int id;
  final String featureCode;
  final String showInLocation;
  final String iconName;
  final String iconCode;
  final String iconColour;
  final String iconFamily;
  final String navigationRoute;
  final String iconGroup;
  final bool isFavorit;
  final String userPermission;
  final int tenantId;
  final String tag;
  final bool isDeleted;
  final bool isFreeTrial;
  final DateTime validFrom;
  final DateTime validTo;
  DesktopData(
      {@required this.id,
      @required this.featureCode,
      @required this.showInLocation,
      @required this.iconName,
      @required this.iconCode,
      @required this.iconColour,
      @required this.iconFamily,
      @required this.navigationRoute,
      @required this.iconGroup,
      @required this.isFavorit,
      @required this.userPermission,
      this.tenantId,
      @required this.tag,
      @required this.isDeleted,
      @required this.isFreeTrial,
      this.validFrom,
      this.validTo});
  factory DesktopData.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return DesktopData(
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      featureCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}feature_code']),
      showInLocation: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}show_in_location']),
      iconName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}icon_name']),
      iconCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}icon_code']),
      iconColour: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}icon_colour']),
      iconFamily: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}icon_family']),
      navigationRoute: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}navigation_route']),
      iconGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}icon_group']),
      isFavorit: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_favorit']),
      userPermission: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_permission']),
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      tag: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tag']),
      isDeleted: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_deleted']),
      isFreeTrial: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_free_trial']),
      validFrom: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}valid_from']),
      validTo: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}valid_to']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || featureCode != null) {
      map['feature_code'] = Variable<String>(featureCode);
    }
    if (!nullToAbsent || showInLocation != null) {
      map['show_in_location'] = Variable<String>(showInLocation);
    }
    if (!nullToAbsent || iconName != null) {
      map['icon_name'] = Variable<String>(iconName);
    }
    if (!nullToAbsent || iconCode != null) {
      map['icon_code'] = Variable<String>(iconCode);
    }
    if (!nullToAbsent || iconColour != null) {
      map['icon_colour'] = Variable<String>(iconColour);
    }
    if (!nullToAbsent || iconFamily != null) {
      map['icon_family'] = Variable<String>(iconFamily);
    }
    if (!nullToAbsent || navigationRoute != null) {
      map['navigation_route'] = Variable<String>(navigationRoute);
    }
    if (!nullToAbsent || iconGroup != null) {
      map['icon_group'] = Variable<String>(iconGroup);
    }
    if (!nullToAbsent || isFavorit != null) {
      map['is_favorit'] = Variable<bool>(isFavorit);
    }
    if (!nullToAbsent || userPermission != null) {
      map['user_permission'] = Variable<String>(userPermission);
    }
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || tag != null) {
      map['tag'] = Variable<String>(tag);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || isFreeTrial != null) {
      map['is_free_trial'] = Variable<bool>(isFreeTrial);
    }
    if (!nullToAbsent || validFrom != null) {
      map['valid_from'] = Variable<DateTime>(validFrom);
    }
    if (!nullToAbsent || validTo != null) {
      map['valid_to'] = Variable<DateTime>(validTo);
    }
    return map;
  }

  DesktopCompanion toCompanion(bool nullToAbsent) {
    return DesktopCompanion(
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      featureCode: featureCode == null && nullToAbsent
          ? const Value.absent()
          : Value(featureCode),
      showInLocation: showInLocation == null && nullToAbsent
          ? const Value.absent()
          : Value(showInLocation),
      iconName: iconName == null && nullToAbsent
          ? const Value.absent()
          : Value(iconName),
      iconCode: iconCode == null && nullToAbsent
          ? const Value.absent()
          : Value(iconCode),
      iconColour: iconColour == null && nullToAbsent
          ? const Value.absent()
          : Value(iconColour),
      iconFamily: iconFamily == null && nullToAbsent
          ? const Value.absent()
          : Value(iconFamily),
      navigationRoute: navigationRoute == null && nullToAbsent
          ? const Value.absent()
          : Value(navigationRoute),
      iconGroup: iconGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(iconGroup),
      isFavorit: isFavorit == null && nullToAbsent
          ? const Value.absent()
          : Value(isFavorit),
      userPermission: userPermission == null && nullToAbsent
          ? const Value.absent()
          : Value(userPermission),
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      tag: tag == null && nullToAbsent ? const Value.absent() : Value(tag),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      isFreeTrial: isFreeTrial == null && nullToAbsent
          ? const Value.absent()
          : Value(isFreeTrial),
      validFrom: validFrom == null && nullToAbsent
          ? const Value.absent()
          : Value(validFrom),
      validTo: validTo == null && nullToAbsent
          ? const Value.absent()
          : Value(validTo),
    );
  }

  factory DesktopData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DesktopData(
      id: serializer.fromJson<int>(json['id']),
      featureCode: serializer.fromJson<String>(json['featureCode']),
      showInLocation: serializer.fromJson<String>(json['showInLocation']),
      iconName: serializer.fromJson<String>(json['iconName']),
      iconCode: serializer.fromJson<String>(json['iconCode']),
      iconColour: serializer.fromJson<String>(json['iconColour']),
      iconFamily: serializer.fromJson<String>(json['iconFamily']),
      navigationRoute: serializer.fromJson<String>(json['navigationRoute']),
      iconGroup: serializer.fromJson<String>(json['iconGroup']),
      isFavorit: serializer.fromJson<bool>(json['isFavorit']),
      userPermission: serializer.fromJson<String>(json['userPermission']),
      tenantId: serializer.fromJson<int>(json['tenantId']),
      tag: serializer.fromJson<String>(json['tag']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      isFreeTrial: serializer.fromJson<bool>(json['isFreeTrial']),
      validFrom: serializer.fromJson<DateTime>(json['validFrom']),
      validTo: serializer.fromJson<DateTime>(json['validTo']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'featureCode': serializer.toJson<String>(featureCode),
      'showInLocation': serializer.toJson<String>(showInLocation),
      'iconName': serializer.toJson<String>(iconName),
      'iconCode': serializer.toJson<String>(iconCode),
      'iconColour': serializer.toJson<String>(iconColour),
      'iconFamily': serializer.toJson<String>(iconFamily),
      'navigationRoute': serializer.toJson<String>(navigationRoute),
      'iconGroup': serializer.toJson<String>(iconGroup),
      'isFavorit': serializer.toJson<bool>(isFavorit),
      'userPermission': serializer.toJson<String>(userPermission),
      'tenantId': serializer.toJson<int>(tenantId),
      'tag': serializer.toJson<String>(tag),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'isFreeTrial': serializer.toJson<bool>(isFreeTrial),
      'validFrom': serializer.toJson<DateTime>(validFrom),
      'validTo': serializer.toJson<DateTime>(validTo),
    };
  }

  DesktopData copyWith(
          {int id,
          String featureCode,
          String showInLocation,
          String iconName,
          String iconCode,
          String iconColour,
          String iconFamily,
          String navigationRoute,
          String iconGroup,
          bool isFavorit,
          String userPermission,
          int tenantId,
          String tag,
          bool isDeleted,
          bool isFreeTrial,
          DateTime validFrom,
          DateTime validTo}) =>
      DesktopData(
        id: id ?? this.id,
        featureCode: featureCode ?? this.featureCode,
        showInLocation: showInLocation ?? this.showInLocation,
        iconName: iconName ?? this.iconName,
        iconCode: iconCode ?? this.iconCode,
        iconColour: iconColour ?? this.iconColour,
        iconFamily: iconFamily ?? this.iconFamily,
        navigationRoute: navigationRoute ?? this.navigationRoute,
        iconGroup: iconGroup ?? this.iconGroup,
        isFavorit: isFavorit ?? this.isFavorit,
        userPermission: userPermission ?? this.userPermission,
        tenantId: tenantId ?? this.tenantId,
        tag: tag ?? this.tag,
        isDeleted: isDeleted ?? this.isDeleted,
        isFreeTrial: isFreeTrial ?? this.isFreeTrial,
        validFrom: validFrom ?? this.validFrom,
        validTo: validTo ?? this.validTo,
      );
  @override
  String toString() {
    return (StringBuffer('DesktopData(')
          ..write('id: $id, ')
          ..write('featureCode: $featureCode, ')
          ..write('showInLocation: $showInLocation, ')
          ..write('iconName: $iconName, ')
          ..write('iconCode: $iconCode, ')
          ..write('iconColour: $iconColour, ')
          ..write('iconFamily: $iconFamily, ')
          ..write('navigationRoute: $navigationRoute, ')
          ..write('iconGroup: $iconGroup, ')
          ..write('isFavorit: $isFavorit, ')
          ..write('userPermission: $userPermission, ')
          ..write('tenantId: $tenantId, ')
          ..write('tag: $tag, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('isFreeTrial: $isFreeTrial, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      featureCode,
      showInLocation,
      iconName,
      iconCode,
      iconColour,
      iconFamily,
      navigationRoute,
      iconGroup,
      isFavorit,
      userPermission,
      tenantId,
      tag,
      isDeleted,
      isFreeTrial,
      validFrom,
      validTo);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DesktopData &&
          other.id == this.id &&
          other.featureCode == this.featureCode &&
          other.showInLocation == this.showInLocation &&
          other.iconName == this.iconName &&
          other.iconCode == this.iconCode &&
          other.iconColour == this.iconColour &&
          other.iconFamily == this.iconFamily &&
          other.navigationRoute == this.navigationRoute &&
          other.iconGroup == this.iconGroup &&
          other.isFavorit == this.isFavorit &&
          other.userPermission == this.userPermission &&
          other.tenantId == this.tenantId &&
          other.tag == this.tag &&
          other.isDeleted == this.isDeleted &&
          other.isFreeTrial == this.isFreeTrial &&
          other.validFrom == this.validFrom &&
          other.validTo == this.validTo);
}

class DesktopCompanion extends UpdateCompanion<DesktopData> {
  final Value<int> id;
  final Value<String> featureCode;
  final Value<String> showInLocation;
  final Value<String> iconName;
  final Value<String> iconCode;
  final Value<String> iconColour;
  final Value<String> iconFamily;
  final Value<String> navigationRoute;
  final Value<String> iconGroup;
  final Value<bool> isFavorit;
  final Value<String> userPermission;
  final Value<int> tenantId;
  final Value<String> tag;
  final Value<bool> isDeleted;
  final Value<bool> isFreeTrial;
  final Value<DateTime> validFrom;
  final Value<DateTime> validTo;
  const DesktopCompanion({
    this.id = const Value.absent(),
    this.featureCode = const Value.absent(),
    this.showInLocation = const Value.absent(),
    this.iconName = const Value.absent(),
    this.iconCode = const Value.absent(),
    this.iconColour = const Value.absent(),
    this.iconFamily = const Value.absent(),
    this.navigationRoute = const Value.absent(),
    this.iconGroup = const Value.absent(),
    this.isFavorit = const Value.absent(),
    this.userPermission = const Value.absent(),
    this.tenantId = const Value.absent(),
    this.tag = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.isFreeTrial = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  });
  DesktopCompanion.insert({
    this.id = const Value.absent(),
    @required String featureCode,
    @required String showInLocation,
    @required String iconName,
    @required String iconCode,
    @required String iconColour,
    @required String iconFamily,
    @required String navigationRoute,
    @required String iconGroup,
    this.isFavorit = const Value.absent(),
    @required String userPermission,
    this.tenantId = const Value.absent(),
    @required String tag,
    this.isDeleted = const Value.absent(),
    this.isFreeTrial = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  })  : featureCode = Value(featureCode),
        showInLocation = Value(showInLocation),
        iconName = Value(iconName),
        iconCode = Value(iconCode),
        iconColour = Value(iconColour),
        iconFamily = Value(iconFamily),
        navigationRoute = Value(navigationRoute),
        iconGroup = Value(iconGroup),
        userPermission = Value(userPermission),
        tag = Value(tag);
  static Insertable<DesktopData> custom({
    Expression<int> id,
    Expression<String> featureCode,
    Expression<String> showInLocation,
    Expression<String> iconName,
    Expression<String> iconCode,
    Expression<String> iconColour,
    Expression<String> iconFamily,
    Expression<String> navigationRoute,
    Expression<String> iconGroup,
    Expression<bool> isFavorit,
    Expression<String> userPermission,
    Expression<int> tenantId,
    Expression<String> tag,
    Expression<bool> isDeleted,
    Expression<bool> isFreeTrial,
    Expression<DateTime> validFrom,
    Expression<DateTime> validTo,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (featureCode != null) 'feature_code': featureCode,
      if (showInLocation != null) 'show_in_location': showInLocation,
      if (iconName != null) 'icon_name': iconName,
      if (iconCode != null) 'icon_code': iconCode,
      if (iconColour != null) 'icon_colour': iconColour,
      if (iconFamily != null) 'icon_family': iconFamily,
      if (navigationRoute != null) 'navigation_route': navigationRoute,
      if (iconGroup != null) 'icon_group': iconGroup,
      if (isFavorit != null) 'is_favorit': isFavorit,
      if (userPermission != null) 'user_permission': userPermission,
      if (tenantId != null) 'tenant_id': tenantId,
      if (tag != null) 'tag': tag,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (isFreeTrial != null) 'is_free_trial': isFreeTrial,
      if (validFrom != null) 'valid_from': validFrom,
      if (validTo != null) 'valid_to': validTo,
    });
  }

  DesktopCompanion copyWith(
      {Value<int> id,
      Value<String> featureCode,
      Value<String> showInLocation,
      Value<String> iconName,
      Value<String> iconCode,
      Value<String> iconColour,
      Value<String> iconFamily,
      Value<String> navigationRoute,
      Value<String> iconGroup,
      Value<bool> isFavorit,
      Value<String> userPermission,
      Value<int> tenantId,
      Value<String> tag,
      Value<bool> isDeleted,
      Value<bool> isFreeTrial,
      Value<DateTime> validFrom,
      Value<DateTime> validTo}) {
    return DesktopCompanion(
      id: id ?? this.id,
      featureCode: featureCode ?? this.featureCode,
      showInLocation: showInLocation ?? this.showInLocation,
      iconName: iconName ?? this.iconName,
      iconCode: iconCode ?? this.iconCode,
      iconColour: iconColour ?? this.iconColour,
      iconFamily: iconFamily ?? this.iconFamily,
      navigationRoute: navigationRoute ?? this.navigationRoute,
      iconGroup: iconGroup ?? this.iconGroup,
      isFavorit: isFavorit ?? this.isFavorit,
      userPermission: userPermission ?? this.userPermission,
      tenantId: tenantId ?? this.tenantId,
      tag: tag ?? this.tag,
      isDeleted: isDeleted ?? this.isDeleted,
      isFreeTrial: isFreeTrial ?? this.isFreeTrial,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo ?? this.validTo,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (featureCode.present) {
      map['feature_code'] = Variable<String>(featureCode.value);
    }
    if (showInLocation.present) {
      map['show_in_location'] = Variable<String>(showInLocation.value);
    }
    if (iconName.present) {
      map['icon_name'] = Variable<String>(iconName.value);
    }
    if (iconCode.present) {
      map['icon_code'] = Variable<String>(iconCode.value);
    }
    if (iconColour.present) {
      map['icon_colour'] = Variable<String>(iconColour.value);
    }
    if (iconFamily.present) {
      map['icon_family'] = Variable<String>(iconFamily.value);
    }
    if (navigationRoute.present) {
      map['navigation_route'] = Variable<String>(navigationRoute.value);
    }
    if (iconGroup.present) {
      map['icon_group'] = Variable<String>(iconGroup.value);
    }
    if (isFavorit.present) {
      map['is_favorit'] = Variable<bool>(isFavorit.value);
    }
    if (userPermission.present) {
      map['user_permission'] = Variable<String>(userPermission.value);
    }
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (tag.present) {
      map['tag'] = Variable<String>(tag.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (isFreeTrial.present) {
      map['is_free_trial'] = Variable<bool>(isFreeTrial.value);
    }
    if (validFrom.present) {
      map['valid_from'] = Variable<DateTime>(validFrom.value);
    }
    if (validTo.present) {
      map['valid_to'] = Variable<DateTime>(validTo.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DesktopCompanion(')
          ..write('id: $id, ')
          ..write('featureCode: $featureCode, ')
          ..write('showInLocation: $showInLocation, ')
          ..write('iconName: $iconName, ')
          ..write('iconCode: $iconCode, ')
          ..write('iconColour: $iconColour, ')
          ..write('iconFamily: $iconFamily, ')
          ..write('navigationRoute: $navigationRoute, ')
          ..write('iconGroup: $iconGroup, ')
          ..write('isFavorit: $isFavorit, ')
          ..write('userPermission: $userPermission, ')
          ..write('tenantId: $tenantId, ')
          ..write('tag: $tag, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('isFreeTrial: $isFreeTrial, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }
}

class $DesktopTable extends Desktop with TableInfo<$DesktopTable, DesktopData> {
  final GeneratedDatabase _db;
  final String _alias;
  $DesktopTable(this._db, [this._alias]);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _featureCodeMeta =
      const VerificationMeta('featureCode');
  GeneratedColumn<String> _featureCode;
  @override
  GeneratedColumn<String> get featureCode => _featureCode ??=
      GeneratedColumn<String>('feature_code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _showInLocationMeta =
      const VerificationMeta('showInLocation');
  GeneratedColumn<String> _showInLocation;
  @override
  GeneratedColumn<String> get showInLocation => _showInLocation ??=
      GeneratedColumn<String>('show_in_location', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _iconNameMeta = const VerificationMeta('iconName');
  GeneratedColumn<String> _iconName;
  @override
  GeneratedColumn<String> get iconName =>
      _iconName ??= GeneratedColumn<String>('icon_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _iconCodeMeta = const VerificationMeta('iconCode');
  GeneratedColumn<String> _iconCode;
  @override
  GeneratedColumn<String> get iconCode =>
      _iconCode ??= GeneratedColumn<String>('icon_code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _iconColourMeta = const VerificationMeta('iconColour');
  GeneratedColumn<String> _iconColour;
  @override
  GeneratedColumn<String> get iconColour =>
      _iconColour ??= GeneratedColumn<String>('icon_colour', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _iconFamilyMeta = const VerificationMeta('iconFamily');
  GeneratedColumn<String> _iconFamily;
  @override
  GeneratedColumn<String> get iconFamily =>
      _iconFamily ??= GeneratedColumn<String>('icon_family', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _navigationRouteMeta =
      const VerificationMeta('navigationRoute');
  GeneratedColumn<String> _navigationRoute;
  @override
  GeneratedColumn<String> get navigationRoute => _navigationRoute ??=
      GeneratedColumn<String>('navigation_route', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _iconGroupMeta = const VerificationMeta('iconGroup');
  GeneratedColumn<String> _iconGroup;
  @override
  GeneratedColumn<String> get iconGroup =>
      _iconGroup ??= GeneratedColumn<String>('icon_group', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _isFavoritMeta = const VerificationMeta('isFavorit');
  GeneratedColumn<bool> _isFavorit;
  @override
  GeneratedColumn<bool> get isFavorit =>
      _isFavorit ??= GeneratedColumn<bool>('is_favorit', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_favorit IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _userPermissionMeta =
      const VerificationMeta('userPermission');
  GeneratedColumn<String> _userPermission;
  @override
  GeneratedColumn<String> get userPermission => _userPermission ??=
      GeneratedColumn<String>('user_permission', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _tagMeta = const VerificationMeta('tag');
  GeneratedColumn<String> _tag;
  @override
  GeneratedColumn<String> get tag =>
      _tag ??= GeneratedColumn<String>('tag', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _isDeletedMeta = const VerificationMeta('isDeleted');
  GeneratedColumn<bool> _isDeleted;
  @override
  GeneratedColumn<bool> get isDeleted =>
      _isDeleted ??= GeneratedColumn<bool>('is_deleted', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_deleted IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isFreeTrialMeta =
      const VerificationMeta('isFreeTrial');
  GeneratedColumn<bool> _isFreeTrial;
  @override
  GeneratedColumn<bool> get isFreeTrial => _isFreeTrial ??=
      GeneratedColumn<bool>('is_free_trial', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_free_trial IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _validFromMeta = const VerificationMeta('validFrom');
  GeneratedColumn<DateTime> _validFrom;
  @override
  GeneratedColumn<DateTime> get validFrom =>
      _validFrom ??= GeneratedColumn<DateTime>('valid_from', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _validToMeta = const VerificationMeta('validTo');
  GeneratedColumn<DateTime> _validTo;
  @override
  GeneratedColumn<DateTime> get validTo =>
      _validTo ??= GeneratedColumn<DateTime>('valid_to', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        featureCode,
        showInLocation,
        iconName,
        iconCode,
        iconColour,
        iconFamily,
        navigationRoute,
        iconGroup,
        isFavorit,
        userPermission,
        tenantId,
        tag,
        isDeleted,
        isFreeTrial,
        validFrom,
        validTo
      ];
  @override
  String get aliasedName => _alias ?? 'desktop';
  @override
  String get actualTableName => 'desktop';
  @override
  VerificationContext validateIntegrity(Insertable<DesktopData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('feature_code')) {
      context.handle(
          _featureCodeMeta,
          featureCode.isAcceptableOrUnknown(
              data['feature_code'], _featureCodeMeta));
    } else if (isInserting) {
      context.missing(_featureCodeMeta);
    }
    if (data.containsKey('show_in_location')) {
      context.handle(
          _showInLocationMeta,
          showInLocation.isAcceptableOrUnknown(
              data['show_in_location'], _showInLocationMeta));
    } else if (isInserting) {
      context.missing(_showInLocationMeta);
    }
    if (data.containsKey('icon_name')) {
      context.handle(_iconNameMeta,
          iconName.isAcceptableOrUnknown(data['icon_name'], _iconNameMeta));
    } else if (isInserting) {
      context.missing(_iconNameMeta);
    }
    if (data.containsKey('icon_code')) {
      context.handle(_iconCodeMeta,
          iconCode.isAcceptableOrUnknown(data['icon_code'], _iconCodeMeta));
    } else if (isInserting) {
      context.missing(_iconCodeMeta);
    }
    if (data.containsKey('icon_colour')) {
      context.handle(
          _iconColourMeta,
          iconColour.isAcceptableOrUnknown(
              data['icon_colour'], _iconColourMeta));
    } else if (isInserting) {
      context.missing(_iconColourMeta);
    }
    if (data.containsKey('icon_family')) {
      context.handle(
          _iconFamilyMeta,
          iconFamily.isAcceptableOrUnknown(
              data['icon_family'], _iconFamilyMeta));
    } else if (isInserting) {
      context.missing(_iconFamilyMeta);
    }
    if (data.containsKey('navigation_route')) {
      context.handle(
          _navigationRouteMeta,
          navigationRoute.isAcceptableOrUnknown(
              data['navigation_route'], _navigationRouteMeta));
    } else if (isInserting) {
      context.missing(_navigationRouteMeta);
    }
    if (data.containsKey('icon_group')) {
      context.handle(_iconGroupMeta,
          iconGroup.isAcceptableOrUnknown(data['icon_group'], _iconGroupMeta));
    } else if (isInserting) {
      context.missing(_iconGroupMeta);
    }
    if (data.containsKey('is_favorit')) {
      context.handle(_isFavoritMeta,
          isFavorit.isAcceptableOrUnknown(data['is_favorit'], _isFavoritMeta));
    }
    if (data.containsKey('user_permission')) {
      context.handle(
          _userPermissionMeta,
          userPermission.isAcceptableOrUnknown(
              data['user_permission'], _userPermissionMeta));
    } else if (isInserting) {
      context.missing(_userPermissionMeta);
    }
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('tag')) {
      context.handle(
          _tagMeta, tag.isAcceptableOrUnknown(data['tag'], _tagMeta));
    } else if (isInserting) {
      context.missing(_tagMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted'], _isDeletedMeta));
    }
    if (data.containsKey('is_free_trial')) {
      context.handle(
          _isFreeTrialMeta,
          isFreeTrial.isAcceptableOrUnknown(
              data['is_free_trial'], _isFreeTrialMeta));
    }
    if (data.containsKey('valid_from')) {
      context.handle(_validFromMeta,
          validFrom.isAcceptableOrUnknown(data['valid_from'], _validFromMeta));
    }
    if (data.containsKey('valid_to')) {
      context.handle(_validToMeta,
          validTo.isAcceptableOrUnknown(data['valid_to'], _validToMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  DesktopData map(Map<String, dynamic> data, {String tablePrefix}) {
    return DesktopData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $DesktopTable createAlias(String alias) {
    return $DesktopTable(_db, alias);
  }
}

class SalesOrderHeaderData extends DataClass
    implements Insertable<SalesOrderHeaderData> {
  final int tenantId;
  final String userName;
  final int userId;
  final int id;
  final String transactionNumber;
  final String transactionStatus;
  final String inventoryCycleNumber;
  final String daySessionNumber;
  final String customerId;
  final String soldTo;
  final DateTime orderDate;
  final DateTime deliveryDate;
  final String orderType;
  final String orderStatus;
  final String purchaseOrderNo;
  final String currency;
  final double exchangeRate;
  final int couponCode;
  final String billingAddressName;
  final String shippingAddressName;
  final String yourInitial;
  final double subTotal;
  final double taxTotal;
  final double depositTotal;
  final double discountTotal;
  final double shippingTotal;
  final int itemCount;
  final double grandTotal;
  final String discountType;
  final double discountPercentage;
  final double discountAmount;
  final double latitude;
  final double longitude;
  final DateTime transactionStart;
  final DateTime transactionEnd;
  SalesOrderHeaderData(
      {this.tenantId,
      @required this.userName,
      @required this.userId,
      @required this.id,
      @required this.transactionNumber,
      this.transactionStatus,
      @required this.inventoryCycleNumber,
      @required this.daySessionNumber,
      @required this.customerId,
      this.soldTo,
      @required this.orderDate,
      @required this.deliveryDate,
      @required this.orderType,
      @required this.orderStatus,
      this.purchaseOrderNo,
      @required this.currency,
      @required this.exchangeRate,
      this.couponCode,
      this.billingAddressName,
      this.shippingAddressName,
      this.yourInitial,
      @required this.subTotal,
      @required this.taxTotal,
      @required this.depositTotal,
      @required this.discountTotal,
      @required this.shippingTotal,
      @required this.itemCount,
      @required this.grandTotal,
      @required this.discountType,
      @required this.discountPercentage,
      @required this.discountAmount,
      this.latitude,
      this.longitude,
      this.transactionStart,
      this.transactionEnd});
  factory SalesOrderHeaderData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return SalesOrderHeaderData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      userId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      transactionNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}transaction_number']),
      transactionStatus: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}transaction_status']),
      inventoryCycleNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}inventory_cycle_number']),
      daySessionNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}day_session_number']),
      customerId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_id']),
      soldTo: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sold_to']),
      orderDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}order_date']),
      deliveryDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}delivery_date']),
      orderType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}order_type']),
      orderStatus: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}order_status']),
      purchaseOrderNo: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}purchase_order_no']),
      currency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}currency']),
      exchangeRate: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}exchange_rate']),
      couponCode: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}coupon_code']),
      billingAddressName: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}billing_address_name']),
      shippingAddressName: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}shipping_address_name']),
      yourInitial: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}your_initial']),
      subTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sub_total']),
      taxTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_total']),
      depositTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}deposit_total']),
      discountTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}discount_total']),
      shippingTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}shipping_total']),
      itemCount: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_count']),
      grandTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}grand_total']),
      discountType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}discount_type']),
      discountPercentage: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}discount_percentage']),
      discountAmount: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}discount_amount']),
      latitude: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}latitude']),
      longitude: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}longitude']),
      transactionStart: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}transaction_start']),
      transactionEnd: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}transaction_end']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<int>(userId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || transactionNumber != null) {
      map['transaction_number'] = Variable<String>(transactionNumber);
    }
    if (!nullToAbsent || transactionStatus != null) {
      map['transaction_status'] = Variable<String>(transactionStatus);
    }
    if (!nullToAbsent || inventoryCycleNumber != null) {
      map['inventory_cycle_number'] = Variable<String>(inventoryCycleNumber);
    }
    if (!nullToAbsent || daySessionNumber != null) {
      map['day_session_number'] = Variable<String>(daySessionNumber);
    }
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || soldTo != null) {
      map['sold_to'] = Variable<String>(soldTo);
    }
    if (!nullToAbsent || orderDate != null) {
      map['order_date'] = Variable<DateTime>(orderDate);
    }
    if (!nullToAbsent || deliveryDate != null) {
      map['delivery_date'] = Variable<DateTime>(deliveryDate);
    }
    if (!nullToAbsent || orderType != null) {
      map['order_type'] = Variable<String>(orderType);
    }
    if (!nullToAbsent || orderStatus != null) {
      map['order_status'] = Variable<String>(orderStatus);
    }
    if (!nullToAbsent || purchaseOrderNo != null) {
      map['purchase_order_no'] = Variable<String>(purchaseOrderNo);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    if (!nullToAbsent || exchangeRate != null) {
      map['exchange_rate'] = Variable<double>(exchangeRate);
    }
    if (!nullToAbsent || couponCode != null) {
      map['coupon_code'] = Variable<int>(couponCode);
    }
    if (!nullToAbsent || billingAddressName != null) {
      map['billing_address_name'] = Variable<String>(billingAddressName);
    }
    if (!nullToAbsent || shippingAddressName != null) {
      map['shipping_address_name'] = Variable<String>(shippingAddressName);
    }
    if (!nullToAbsent || yourInitial != null) {
      map['your_initial'] = Variable<String>(yourInitial);
    }
    if (!nullToAbsent || subTotal != null) {
      map['sub_total'] = Variable<double>(subTotal);
    }
    if (!nullToAbsent || taxTotal != null) {
      map['tax_total'] = Variable<double>(taxTotal);
    }
    if (!nullToAbsent || depositTotal != null) {
      map['deposit_total'] = Variable<double>(depositTotal);
    }
    if (!nullToAbsent || discountTotal != null) {
      map['discount_total'] = Variable<double>(discountTotal);
    }
    if (!nullToAbsent || shippingTotal != null) {
      map['shipping_total'] = Variable<double>(shippingTotal);
    }
    if (!nullToAbsent || itemCount != null) {
      map['item_count'] = Variable<int>(itemCount);
    }
    if (!nullToAbsent || grandTotal != null) {
      map['grand_total'] = Variable<double>(grandTotal);
    }
    if (!nullToAbsent || discountType != null) {
      map['discount_type'] = Variable<String>(discountType);
    }
    if (!nullToAbsent || discountPercentage != null) {
      map['discount_percentage'] = Variable<double>(discountPercentage);
    }
    if (!nullToAbsent || discountAmount != null) {
      map['discount_amount'] = Variable<double>(discountAmount);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || transactionStart != null) {
      map['transaction_start'] = Variable<DateTime>(transactionStart);
    }
    if (!nullToAbsent || transactionEnd != null) {
      map['transaction_end'] = Variable<DateTime>(transactionEnd);
    }
    return map;
  }

  SalesOrderHeaderCompanion toCompanion(bool nullToAbsent) {
    return SalesOrderHeaderCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      transactionNumber: transactionNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionNumber),
      transactionStatus: transactionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionStatus),
      inventoryCycleNumber: inventoryCycleNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(inventoryCycleNumber),
      daySessionNumber: daySessionNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(daySessionNumber),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      soldTo:
          soldTo == null && nullToAbsent ? const Value.absent() : Value(soldTo),
      orderDate: orderDate == null && nullToAbsent
          ? const Value.absent()
          : Value(orderDate),
      deliveryDate: deliveryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(deliveryDate),
      orderType: orderType == null && nullToAbsent
          ? const Value.absent()
          : Value(orderType),
      orderStatus: orderStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(orderStatus),
      purchaseOrderNo: purchaseOrderNo == null && nullToAbsent
          ? const Value.absent()
          : Value(purchaseOrderNo),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      exchangeRate: exchangeRate == null && nullToAbsent
          ? const Value.absent()
          : Value(exchangeRate),
      couponCode: couponCode == null && nullToAbsent
          ? const Value.absent()
          : Value(couponCode),
      billingAddressName: billingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(billingAddressName),
      shippingAddressName: shippingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(shippingAddressName),
      yourInitial: yourInitial == null && nullToAbsent
          ? const Value.absent()
          : Value(yourInitial),
      subTotal: subTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(subTotal),
      taxTotal: taxTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(taxTotal),
      depositTotal: depositTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(depositTotal),
      discountTotal: discountTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(discountTotal),
      shippingTotal: shippingTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(shippingTotal),
      itemCount: itemCount == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCount),
      grandTotal: grandTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(grandTotal),
      discountType: discountType == null && nullToAbsent
          ? const Value.absent()
          : Value(discountType),
      discountPercentage: discountPercentage == null && nullToAbsent
          ? const Value.absent()
          : Value(discountPercentage),
      discountAmount: discountAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(discountAmount),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      transactionStart: transactionStart == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionStart),
      transactionEnd: transactionEnd == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionEnd),
    );
  }

  factory SalesOrderHeaderData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesOrderHeaderData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      userName: serializer.fromJson<String>(json['userName']),
      userId: serializer.fromJson<int>(json['userId']),
      id: serializer.fromJson<int>(json['id']),
      transactionNumber: serializer.fromJson<String>(json['transactionNumber']),
      transactionStatus: serializer.fromJson<String>(json['transactionStatus']),
      inventoryCycleNumber:
          serializer.fromJson<String>(json['inventoryCycleNumber']),
      daySessionNumber: serializer.fromJson<String>(json['daySessionNumber']),
      customerId: serializer.fromJson<String>(json['customerId']),
      soldTo: serializer.fromJson<String>(json['soldTo']),
      orderDate: serializer.fromJson<DateTime>(json['orderDate']),
      deliveryDate: serializer.fromJson<DateTime>(json['deliveryDate']),
      orderType: serializer.fromJson<String>(json['orderType']),
      orderStatus: serializer.fromJson<String>(json['orderStatus']),
      purchaseOrderNo: serializer.fromJson<String>(json['purchaseOrderNo']),
      currency: serializer.fromJson<String>(json['currency']),
      exchangeRate: serializer.fromJson<double>(json['exchangeRate']),
      couponCode: serializer.fromJson<int>(json['couponCode']),
      billingAddressName:
          serializer.fromJson<String>(json['billingAddressName']),
      shippingAddressName:
          serializer.fromJson<String>(json['shippingAddressName']),
      yourInitial: serializer.fromJson<String>(json['yourInitial']),
      subTotal: serializer.fromJson<double>(json['subTotal']),
      taxTotal: serializer.fromJson<double>(json['taxTotal']),
      depositTotal: serializer.fromJson<double>(json['depositTotal']),
      discountTotal: serializer.fromJson<double>(json['discountTotal']),
      shippingTotal: serializer.fromJson<double>(json['shippingTotal']),
      itemCount: serializer.fromJson<int>(json['itemCount']),
      grandTotal: serializer.fromJson<double>(json['grandTotal']),
      discountType: serializer.fromJson<String>(json['discountType']),
      discountPercentage:
          serializer.fromJson<double>(json['discountPercentage']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      transactionStart: serializer.fromJson<DateTime>(json['transactionStart']),
      transactionEnd: serializer.fromJson<DateTime>(json['transactionEnd']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'userName': serializer.toJson<String>(userName),
      'userId': serializer.toJson<int>(userId),
      'id': serializer.toJson<int>(id),
      'transactionNumber': serializer.toJson<String>(transactionNumber),
      'transactionStatus': serializer.toJson<String>(transactionStatus),
      'inventoryCycleNumber': serializer.toJson<String>(inventoryCycleNumber),
      'daySessionNumber': serializer.toJson<String>(daySessionNumber),
      'customerId': serializer.toJson<String>(customerId),
      'soldTo': serializer.toJson<String>(soldTo),
      'orderDate': serializer.toJson<DateTime>(orderDate),
      'deliveryDate': serializer.toJson<DateTime>(deliveryDate),
      'orderType': serializer.toJson<String>(orderType),
      'orderStatus': serializer.toJson<String>(orderStatus),
      'purchaseOrderNo': serializer.toJson<String>(purchaseOrderNo),
      'currency': serializer.toJson<String>(currency),
      'exchangeRate': serializer.toJson<double>(exchangeRate),
      'couponCode': serializer.toJson<int>(couponCode),
      'billingAddressName': serializer.toJson<String>(billingAddressName),
      'shippingAddressName': serializer.toJson<String>(shippingAddressName),
      'yourInitial': serializer.toJson<String>(yourInitial),
      'subTotal': serializer.toJson<double>(subTotal),
      'taxTotal': serializer.toJson<double>(taxTotal),
      'depositTotal': serializer.toJson<double>(depositTotal),
      'discountTotal': serializer.toJson<double>(discountTotal),
      'shippingTotal': serializer.toJson<double>(shippingTotal),
      'itemCount': serializer.toJson<int>(itemCount),
      'grandTotal': serializer.toJson<double>(grandTotal),
      'discountType': serializer.toJson<String>(discountType),
      'discountPercentage': serializer.toJson<double>(discountPercentage),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'transactionStart': serializer.toJson<DateTime>(transactionStart),
      'transactionEnd': serializer.toJson<DateTime>(transactionEnd),
    };
  }

  SalesOrderHeaderData copyWith(
          {int tenantId,
          String userName,
          int userId,
          int id,
          String transactionNumber,
          String transactionStatus,
          String inventoryCycleNumber,
          String daySessionNumber,
          String customerId,
          String soldTo,
          DateTime orderDate,
          DateTime deliveryDate,
          String orderType,
          String orderStatus,
          String purchaseOrderNo,
          String currency,
          double exchangeRate,
          int couponCode,
          String billingAddressName,
          String shippingAddressName,
          String yourInitial,
          double subTotal,
          double taxTotal,
          double depositTotal,
          double discountTotal,
          double shippingTotal,
          int itemCount,
          double grandTotal,
          String discountType,
          double discountPercentage,
          double discountAmount,
          double latitude,
          double longitude,
          DateTime transactionStart,
          DateTime transactionEnd}) =>
      SalesOrderHeaderData(
        tenantId: tenantId ?? this.tenantId,
        userName: userName ?? this.userName,
        userId: userId ?? this.userId,
        id: id ?? this.id,
        transactionNumber: transactionNumber ?? this.transactionNumber,
        transactionStatus: transactionStatus ?? this.transactionStatus,
        inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
        daySessionNumber: daySessionNumber ?? this.daySessionNumber,
        customerId: customerId ?? this.customerId,
        soldTo: soldTo ?? this.soldTo,
        orderDate: orderDate ?? this.orderDate,
        deliveryDate: deliveryDate ?? this.deliveryDate,
        orderType: orderType ?? this.orderType,
        orderStatus: orderStatus ?? this.orderStatus,
        purchaseOrderNo: purchaseOrderNo ?? this.purchaseOrderNo,
        currency: currency ?? this.currency,
        exchangeRate: exchangeRate ?? this.exchangeRate,
        couponCode: couponCode ?? this.couponCode,
        billingAddressName: billingAddressName ?? this.billingAddressName,
        shippingAddressName: shippingAddressName ?? this.shippingAddressName,
        yourInitial: yourInitial ?? this.yourInitial,
        subTotal: subTotal ?? this.subTotal,
        taxTotal: taxTotal ?? this.taxTotal,
        depositTotal: depositTotal ?? this.depositTotal,
        discountTotal: discountTotal ?? this.discountTotal,
        shippingTotal: shippingTotal ?? this.shippingTotal,
        itemCount: itemCount ?? this.itemCount,
        grandTotal: grandTotal ?? this.grandTotal,
        discountType: discountType ?? this.discountType,
        discountPercentage: discountPercentage ?? this.discountPercentage,
        discountAmount: discountAmount ?? this.discountAmount,
        latitude: latitude ?? this.latitude,
        longitude: longitude ?? this.longitude,
        transactionStart: transactionStart ?? this.transactionStart,
        transactionEnd: transactionEnd ?? this.transactionEnd,
      );
  @override
  String toString() {
    return (StringBuffer('SalesOrderHeaderData(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('customerId: $customerId, ')
          ..write('soldTo: $soldTo, ')
          ..write('orderDate: $orderDate, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('orderType: $orderType, ')
          ..write('orderStatus: $orderStatus, ')
          ..write('purchaseOrderNo: $purchaseOrderNo, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('couponCode: $couponCode, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('yourInitial: $yourInitial, ')
          ..write('subTotal: $subTotal, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('discountTotal: $discountTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('transactionStart: $transactionStart, ')
          ..write('transactionEnd: $transactionEnd')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        transactionStatus,
        inventoryCycleNumber,
        daySessionNumber,
        customerId,
        soldTo,
        orderDate,
        deliveryDate,
        orderType,
        orderStatus,
        purchaseOrderNo,
        currency,
        exchangeRate,
        couponCode,
        billingAddressName,
        shippingAddressName,
        yourInitial,
        subTotal,
        taxTotal,
        depositTotal,
        discountTotal,
        shippingTotal,
        itemCount,
        grandTotal,
        discountType,
        discountPercentage,
        discountAmount,
        latitude,
        longitude,
        transactionStart,
        transactionEnd
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesOrderHeaderData &&
          other.tenantId == this.tenantId &&
          other.userName == this.userName &&
          other.userId == this.userId &&
          other.id == this.id &&
          other.transactionNumber == this.transactionNumber &&
          other.transactionStatus == this.transactionStatus &&
          other.inventoryCycleNumber == this.inventoryCycleNumber &&
          other.daySessionNumber == this.daySessionNumber &&
          other.customerId == this.customerId &&
          other.soldTo == this.soldTo &&
          other.orderDate == this.orderDate &&
          other.deliveryDate == this.deliveryDate &&
          other.orderType == this.orderType &&
          other.orderStatus == this.orderStatus &&
          other.purchaseOrderNo == this.purchaseOrderNo &&
          other.currency == this.currency &&
          other.exchangeRate == this.exchangeRate &&
          other.couponCode == this.couponCode &&
          other.billingAddressName == this.billingAddressName &&
          other.shippingAddressName == this.shippingAddressName &&
          other.yourInitial == this.yourInitial &&
          other.subTotal == this.subTotal &&
          other.taxTotal == this.taxTotal &&
          other.depositTotal == this.depositTotal &&
          other.discountTotal == this.discountTotal &&
          other.shippingTotal == this.shippingTotal &&
          other.itemCount == this.itemCount &&
          other.grandTotal == this.grandTotal &&
          other.discountType == this.discountType &&
          other.discountPercentage == this.discountPercentage &&
          other.discountAmount == this.discountAmount &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.transactionStart == this.transactionStart &&
          other.transactionEnd == this.transactionEnd);
}

class SalesOrderHeaderCompanion extends UpdateCompanion<SalesOrderHeaderData> {
  final Value<int> tenantId;
  final Value<String> userName;
  final Value<int> userId;
  final Value<int> id;
  final Value<String> transactionNumber;
  final Value<String> transactionStatus;
  final Value<String> inventoryCycleNumber;
  final Value<String> daySessionNumber;
  final Value<String> customerId;
  final Value<String> soldTo;
  final Value<DateTime> orderDate;
  final Value<DateTime> deliveryDate;
  final Value<String> orderType;
  final Value<String> orderStatus;
  final Value<String> purchaseOrderNo;
  final Value<String> currency;
  final Value<double> exchangeRate;
  final Value<int> couponCode;
  final Value<String> billingAddressName;
  final Value<String> shippingAddressName;
  final Value<String> yourInitial;
  final Value<double> subTotal;
  final Value<double> taxTotal;
  final Value<double> depositTotal;
  final Value<double> discountTotal;
  final Value<double> shippingTotal;
  final Value<int> itemCount;
  final Value<double> grandTotal;
  final Value<String> discountType;
  final Value<double> discountPercentage;
  final Value<double> discountAmount;
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<DateTime> transactionStart;
  final Value<DateTime> transactionEnd;
  const SalesOrderHeaderCompanion({
    this.tenantId = const Value.absent(),
    this.userName = const Value.absent(),
    this.userId = const Value.absent(),
    this.id = const Value.absent(),
    this.transactionNumber = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.inventoryCycleNumber = const Value.absent(),
    this.daySessionNumber = const Value.absent(),
    this.customerId = const Value.absent(),
    this.soldTo = const Value.absent(),
    this.orderDate = const Value.absent(),
    this.deliveryDate = const Value.absent(),
    this.orderType = const Value.absent(),
    this.orderStatus = const Value.absent(),
    this.purchaseOrderNo = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.couponCode = const Value.absent(),
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.yourInitial = const Value.absent(),
    this.subTotal = const Value.absent(),
    this.taxTotal = const Value.absent(),
    this.depositTotal = const Value.absent(),
    this.discountTotal = const Value.absent(),
    this.shippingTotal = const Value.absent(),
    this.itemCount = const Value.absent(),
    this.grandTotal = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.transactionStart = const Value.absent(),
    this.transactionEnd = const Value.absent(),
  });
  SalesOrderHeaderCompanion.insert({
    this.tenantId = const Value.absent(),
    @required String userName,
    @required int userId,
    this.id = const Value.absent(),
    @required String transactionNumber,
    this.transactionStatus = const Value.absent(),
    @required String inventoryCycleNumber,
    @required String daySessionNumber,
    @required String customerId,
    this.soldTo = const Value.absent(),
    @required DateTime orderDate,
    @required DateTime deliveryDate,
    @required String orderType,
    @required String orderStatus,
    this.purchaseOrderNo = const Value.absent(),
    @required String currency,
    @required double exchangeRate,
    this.couponCode = const Value.absent(),
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.yourInitial = const Value.absent(),
    @required double subTotal,
    @required double taxTotal,
    @required double depositTotal,
    @required double discountTotal,
    @required double shippingTotal,
    @required int itemCount,
    @required double grandTotal,
    @required String discountType,
    @required double discountPercentage,
    @required double discountAmount,
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.transactionStart = const Value.absent(),
    this.transactionEnd = const Value.absent(),
  })  : userName = Value(userName),
        userId = Value(userId),
        transactionNumber = Value(transactionNumber),
        inventoryCycleNumber = Value(inventoryCycleNumber),
        daySessionNumber = Value(daySessionNumber),
        customerId = Value(customerId),
        orderDate = Value(orderDate),
        deliveryDate = Value(deliveryDate),
        orderType = Value(orderType),
        orderStatus = Value(orderStatus),
        currency = Value(currency),
        exchangeRate = Value(exchangeRate),
        subTotal = Value(subTotal),
        taxTotal = Value(taxTotal),
        depositTotal = Value(depositTotal),
        discountTotal = Value(discountTotal),
        shippingTotal = Value(shippingTotal),
        itemCount = Value(itemCount),
        grandTotal = Value(grandTotal),
        discountType = Value(discountType),
        discountPercentage = Value(discountPercentage),
        discountAmount = Value(discountAmount);
  static Insertable<SalesOrderHeaderData> custom({
    Expression<int> tenantId,
    Expression<String> userName,
    Expression<int> userId,
    Expression<int> id,
    Expression<String> transactionNumber,
    Expression<String> transactionStatus,
    Expression<String> inventoryCycleNumber,
    Expression<String> daySessionNumber,
    Expression<String> customerId,
    Expression<String> soldTo,
    Expression<DateTime> orderDate,
    Expression<DateTime> deliveryDate,
    Expression<String> orderType,
    Expression<String> orderStatus,
    Expression<String> purchaseOrderNo,
    Expression<String> currency,
    Expression<double> exchangeRate,
    Expression<int> couponCode,
    Expression<String> billingAddressName,
    Expression<String> shippingAddressName,
    Expression<String> yourInitial,
    Expression<double> subTotal,
    Expression<double> taxTotal,
    Expression<double> depositTotal,
    Expression<double> discountTotal,
    Expression<double> shippingTotal,
    Expression<int> itemCount,
    Expression<double> grandTotal,
    Expression<String> discountType,
    Expression<double> discountPercentage,
    Expression<double> discountAmount,
    Expression<double> latitude,
    Expression<double> longitude,
    Expression<DateTime> transactionStart,
    Expression<DateTime> transactionEnd,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (userName != null) 'user_name': userName,
      if (userId != null) 'user_id': userId,
      if (id != null) 'id': id,
      if (transactionNumber != null) 'transaction_number': transactionNumber,
      if (transactionStatus != null) 'transaction_status': transactionStatus,
      if (inventoryCycleNumber != null)
        'inventory_cycle_number': inventoryCycleNumber,
      if (daySessionNumber != null) 'day_session_number': daySessionNumber,
      if (customerId != null) 'customer_id': customerId,
      if (soldTo != null) 'sold_to': soldTo,
      if (orderDate != null) 'order_date': orderDate,
      if (deliveryDate != null) 'delivery_date': deliveryDate,
      if (orderType != null) 'order_type': orderType,
      if (orderStatus != null) 'order_status': orderStatus,
      if (purchaseOrderNo != null) 'purchase_order_no': purchaseOrderNo,
      if (currency != null) 'currency': currency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (couponCode != null) 'coupon_code': couponCode,
      if (billingAddressName != null)
        'billing_address_name': billingAddressName,
      if (shippingAddressName != null)
        'shipping_address_name': shippingAddressName,
      if (yourInitial != null) 'your_initial': yourInitial,
      if (subTotal != null) 'sub_total': subTotal,
      if (taxTotal != null) 'tax_total': taxTotal,
      if (depositTotal != null) 'deposit_total': depositTotal,
      if (discountTotal != null) 'discount_total': discountTotal,
      if (shippingTotal != null) 'shipping_total': shippingTotal,
      if (itemCount != null) 'item_count': itemCount,
      if (grandTotal != null) 'grand_total': grandTotal,
      if (discountType != null) 'discount_type': discountType,
      if (discountPercentage != null) 'discount_percentage': discountPercentage,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (transactionStart != null) 'transaction_start': transactionStart,
      if (transactionEnd != null) 'transaction_end': transactionEnd,
    });
  }

  SalesOrderHeaderCompanion copyWith(
      {Value<int> tenantId,
      Value<String> userName,
      Value<int> userId,
      Value<int> id,
      Value<String> transactionNumber,
      Value<String> transactionStatus,
      Value<String> inventoryCycleNumber,
      Value<String> daySessionNumber,
      Value<String> customerId,
      Value<String> soldTo,
      Value<DateTime> orderDate,
      Value<DateTime> deliveryDate,
      Value<String> orderType,
      Value<String> orderStatus,
      Value<String> purchaseOrderNo,
      Value<String> currency,
      Value<double> exchangeRate,
      Value<int> couponCode,
      Value<String> billingAddressName,
      Value<String> shippingAddressName,
      Value<String> yourInitial,
      Value<double> subTotal,
      Value<double> taxTotal,
      Value<double> depositTotal,
      Value<double> discountTotal,
      Value<double> shippingTotal,
      Value<int> itemCount,
      Value<double> grandTotal,
      Value<String> discountType,
      Value<double> discountPercentage,
      Value<double> discountAmount,
      Value<double> latitude,
      Value<double> longitude,
      Value<DateTime> transactionStart,
      Value<DateTime> transactionEnd}) {
    return SalesOrderHeaderCompanion(
      tenantId: tenantId ?? this.tenantId,
      userName: userName ?? this.userName,
      userId: userId ?? this.userId,
      id: id ?? this.id,
      transactionNumber: transactionNumber ?? this.transactionNumber,
      transactionStatus: transactionStatus ?? this.transactionStatus,
      inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
      daySessionNumber: daySessionNumber ?? this.daySessionNumber,
      customerId: customerId ?? this.customerId,
      soldTo: soldTo ?? this.soldTo,
      orderDate: orderDate ?? this.orderDate,
      deliveryDate: deliveryDate ?? this.deliveryDate,
      orderType: orderType ?? this.orderType,
      orderStatus: orderStatus ?? this.orderStatus,
      purchaseOrderNo: purchaseOrderNo ?? this.purchaseOrderNo,
      currency: currency ?? this.currency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      couponCode: couponCode ?? this.couponCode,
      billingAddressName: billingAddressName ?? this.billingAddressName,
      shippingAddressName: shippingAddressName ?? this.shippingAddressName,
      yourInitial: yourInitial ?? this.yourInitial,
      subTotal: subTotal ?? this.subTotal,
      taxTotal: taxTotal ?? this.taxTotal,
      depositTotal: depositTotal ?? this.depositTotal,
      discountTotal: discountTotal ?? this.discountTotal,
      shippingTotal: shippingTotal ?? this.shippingTotal,
      itemCount: itemCount ?? this.itemCount,
      grandTotal: grandTotal ?? this.grandTotal,
      discountType: discountType ?? this.discountType,
      discountPercentage: discountPercentage ?? this.discountPercentage,
      discountAmount: discountAmount ?? this.discountAmount,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      transactionStart: transactionStart ?? this.transactionStart,
      transactionEnd: transactionEnd ?? this.transactionEnd,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (transactionNumber.present) {
      map['transaction_number'] = Variable<String>(transactionNumber.value);
    }
    if (transactionStatus.present) {
      map['transaction_status'] = Variable<String>(transactionStatus.value);
    }
    if (inventoryCycleNumber.present) {
      map['inventory_cycle_number'] =
          Variable<String>(inventoryCycleNumber.value);
    }
    if (daySessionNumber.present) {
      map['day_session_number'] = Variable<String>(daySessionNumber.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (soldTo.present) {
      map['sold_to'] = Variable<String>(soldTo.value);
    }
    if (orderDate.present) {
      map['order_date'] = Variable<DateTime>(orderDate.value);
    }
    if (deliveryDate.present) {
      map['delivery_date'] = Variable<DateTime>(deliveryDate.value);
    }
    if (orderType.present) {
      map['order_type'] = Variable<String>(orderType.value);
    }
    if (orderStatus.present) {
      map['order_status'] = Variable<String>(orderStatus.value);
    }
    if (purchaseOrderNo.present) {
      map['purchase_order_no'] = Variable<String>(purchaseOrderNo.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (couponCode.present) {
      map['coupon_code'] = Variable<int>(couponCode.value);
    }
    if (billingAddressName.present) {
      map['billing_address_name'] = Variable<String>(billingAddressName.value);
    }
    if (shippingAddressName.present) {
      map['shipping_address_name'] =
          Variable<String>(shippingAddressName.value);
    }
    if (yourInitial.present) {
      map['your_initial'] = Variable<String>(yourInitial.value);
    }
    if (subTotal.present) {
      map['sub_total'] = Variable<double>(subTotal.value);
    }
    if (taxTotal.present) {
      map['tax_total'] = Variable<double>(taxTotal.value);
    }
    if (depositTotal.present) {
      map['deposit_total'] = Variable<double>(depositTotal.value);
    }
    if (discountTotal.present) {
      map['discount_total'] = Variable<double>(discountTotal.value);
    }
    if (shippingTotal.present) {
      map['shipping_total'] = Variable<double>(shippingTotal.value);
    }
    if (itemCount.present) {
      map['item_count'] = Variable<int>(itemCount.value);
    }
    if (grandTotal.present) {
      map['grand_total'] = Variable<double>(grandTotal.value);
    }
    if (discountType.present) {
      map['discount_type'] = Variable<String>(discountType.value);
    }
    if (discountPercentage.present) {
      map['discount_percentage'] = Variable<double>(discountPercentage.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (transactionStart.present) {
      map['transaction_start'] = Variable<DateTime>(transactionStart.value);
    }
    if (transactionEnd.present) {
      map['transaction_end'] = Variable<DateTime>(transactionEnd.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesOrderHeaderCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('customerId: $customerId, ')
          ..write('soldTo: $soldTo, ')
          ..write('orderDate: $orderDate, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('orderType: $orderType, ')
          ..write('orderStatus: $orderStatus, ')
          ..write('purchaseOrderNo: $purchaseOrderNo, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('couponCode: $couponCode, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('yourInitial: $yourInitial, ')
          ..write('subTotal: $subTotal, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('discountTotal: $discountTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('transactionStart: $transactionStart, ')
          ..write('transactionEnd: $transactionEnd')
          ..write(')'))
        .toString();
  }
}

class $SalesOrderHeaderTable extends SalesOrderHeader
    with TableInfo<$SalesOrderHeaderTable, SalesOrderHeaderData> {
  final GeneratedDatabase _db;
  final String _alias;
  $SalesOrderHeaderTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _userIdMeta = const VerificationMeta('userId');
  GeneratedColumn<int> _userId;
  @override
  GeneratedColumn<int> get userId =>
      _userId ??= GeneratedColumn<int>('user_id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _transactionNumberMeta =
      const VerificationMeta('transactionNumber');
  GeneratedColumn<String> _transactionNumber;
  @override
  GeneratedColumn<String> get transactionNumber => _transactionNumber ??=
      GeneratedColumn<String>('transaction_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _transactionStatusMeta =
      const VerificationMeta('transactionStatus');
  GeneratedColumn<String> _transactionStatus;
  @override
  GeneratedColumn<String> get transactionStatus => _transactionStatus ??=
      GeneratedColumn<String>('transaction_status', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _inventoryCycleNumberMeta =
      const VerificationMeta('inventoryCycleNumber');
  GeneratedColumn<String> _inventoryCycleNumber;
  @override
  GeneratedColumn<String> get inventoryCycleNumber => _inventoryCycleNumber ??=
      GeneratedColumn<String>('inventory_cycle_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _daySessionNumberMeta =
      const VerificationMeta('daySessionNumber');
  GeneratedColumn<String> _daySessionNumber;
  @override
  GeneratedColumn<String> get daySessionNumber => _daySessionNumber ??=
      GeneratedColumn<String>('day_session_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _customerIdMeta = const VerificationMeta('customerId');
  GeneratedColumn<String> _customerId;
  @override
  GeneratedColumn<String> get customerId =>
      _customerId ??= GeneratedColumn<String>('customer_id', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _soldToMeta = const VerificationMeta('soldTo');
  GeneratedColumn<String> _soldTo;
  @override
  GeneratedColumn<String> get soldTo =>
      _soldTo ??= GeneratedColumn<String>('sold_to', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _orderDateMeta = const VerificationMeta('orderDate');
  GeneratedColumn<DateTime> _orderDate;
  @override
  GeneratedColumn<DateTime> get orderDate =>
      _orderDate ??= GeneratedColumn<DateTime>('order_date', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _deliveryDateMeta =
      const VerificationMeta('deliveryDate');
  GeneratedColumn<DateTime> _deliveryDate;
  @override
  GeneratedColumn<DateTime> get deliveryDate => _deliveryDate ??=
      GeneratedColumn<DateTime>('delivery_date', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _orderTypeMeta = const VerificationMeta('orderType');
  GeneratedColumn<String> _orderType;
  @override
  GeneratedColumn<String> get orderType =>
      _orderType ??= GeneratedColumn<String>('order_type', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _orderStatusMeta =
      const VerificationMeta('orderStatus');
  GeneratedColumn<String> _orderStatus;
  @override
  GeneratedColumn<String> get orderStatus => _orderStatus ??=
      GeneratedColumn<String>('order_status', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _purchaseOrderNoMeta =
      const VerificationMeta('purchaseOrderNo');
  GeneratedColumn<String> _purchaseOrderNo;
  @override
  GeneratedColumn<String> get purchaseOrderNo => _purchaseOrderNo ??=
      GeneratedColumn<String>('purchase_order_no', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _currencyMeta = const VerificationMeta('currency');
  GeneratedColumn<String> _currency;
  @override
  GeneratedColumn<String> get currency =>
      _currency ??= GeneratedColumn<String>('currency', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  GeneratedColumn<double> _exchangeRate;
  @override
  GeneratedColumn<double> get exchangeRate => _exchangeRate ??=
      GeneratedColumn<double>('exchange_rate', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _couponCodeMeta = const VerificationMeta('couponCode');
  GeneratedColumn<int> _couponCode;
  @override
  GeneratedColumn<int> get couponCode =>
      _couponCode ??= GeneratedColumn<int>('coupon_code', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _billingAddressNameMeta =
      const VerificationMeta('billingAddressName');
  GeneratedColumn<String> _billingAddressName;
  @override
  GeneratedColumn<String> get billingAddressName => _billingAddressName ??=
      GeneratedColumn<String>('billing_address_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _shippingAddressNameMeta =
      const VerificationMeta('shippingAddressName');
  GeneratedColumn<String> _shippingAddressName;
  @override
  GeneratedColumn<String> get shippingAddressName => _shippingAddressName ??=
      GeneratedColumn<String>('shipping_address_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _yourInitialMeta =
      const VerificationMeta('yourInitial');
  GeneratedColumn<String> _yourInitial;
  @override
  GeneratedColumn<String> get yourInitial => _yourInitial ??=
      GeneratedColumn<String>('your_initial', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _subTotalMeta = const VerificationMeta('subTotal');
  GeneratedColumn<double> _subTotal;
  @override
  GeneratedColumn<double> get subTotal =>
      _subTotal ??= GeneratedColumn<double>('sub_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _taxTotalMeta = const VerificationMeta('taxTotal');
  GeneratedColumn<double> _taxTotal;
  @override
  GeneratedColumn<double> get taxTotal =>
      _taxTotal ??= GeneratedColumn<double>('tax_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _depositTotalMeta =
      const VerificationMeta('depositTotal');
  GeneratedColumn<double> _depositTotal;
  @override
  GeneratedColumn<double> get depositTotal => _depositTotal ??=
      GeneratedColumn<double>('deposit_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _discountTotalMeta =
      const VerificationMeta('discountTotal');
  GeneratedColumn<double> _discountTotal;
  @override
  GeneratedColumn<double> get discountTotal => _discountTotal ??=
      GeneratedColumn<double>('discount_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _shippingTotalMeta =
      const VerificationMeta('shippingTotal');
  GeneratedColumn<double> _shippingTotal;
  @override
  GeneratedColumn<double> get shippingTotal => _shippingTotal ??=
      GeneratedColumn<double>('shipping_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _itemCountMeta = const VerificationMeta('itemCount');
  GeneratedColumn<int> _itemCount;
  @override
  GeneratedColumn<int> get itemCount =>
      _itemCount ??= GeneratedColumn<int>('item_count', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _grandTotalMeta = const VerificationMeta('grandTotal');
  GeneratedColumn<double> _grandTotal;
  @override
  GeneratedColumn<double> get grandTotal =>
      _grandTotal ??= GeneratedColumn<double>('grand_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _discountTypeMeta =
      const VerificationMeta('discountType');
  GeneratedColumn<String> _discountType;
  @override
  GeneratedColumn<String> get discountType => _discountType ??=
      GeneratedColumn<String>('discount_type', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _discountPercentageMeta =
      const VerificationMeta('discountPercentage');
  GeneratedColumn<double> _discountPercentage;
  @override
  GeneratedColumn<double> get discountPercentage => _discountPercentage ??=
      GeneratedColumn<double>('discount_percentage', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _discountAmountMeta =
      const VerificationMeta('discountAmount');
  GeneratedColumn<double> _discountAmount;
  @override
  GeneratedColumn<double> get discountAmount => _discountAmount ??=
      GeneratedColumn<double>('discount_amount', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _latitudeMeta = const VerificationMeta('latitude');
  GeneratedColumn<double> _latitude;
  @override
  GeneratedColumn<double> get latitude =>
      _latitude ??= GeneratedColumn<double>('latitude', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _longitudeMeta = const VerificationMeta('longitude');
  GeneratedColumn<double> _longitude;
  @override
  GeneratedColumn<double> get longitude =>
      _longitude ??= GeneratedColumn<double>('longitude', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _transactionStartMeta =
      const VerificationMeta('transactionStart');
  GeneratedColumn<DateTime> _transactionStart;
  @override
  GeneratedColumn<DateTime> get transactionStart => _transactionStart ??=
      GeneratedColumn<DateTime>('transaction_start', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _transactionEndMeta =
      const VerificationMeta('transactionEnd');
  GeneratedColumn<DateTime> _transactionEnd;
  @override
  GeneratedColumn<DateTime> get transactionEnd => _transactionEnd ??=
      GeneratedColumn<DateTime>('transaction_end', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        transactionStatus,
        inventoryCycleNumber,
        daySessionNumber,
        customerId,
        soldTo,
        orderDate,
        deliveryDate,
        orderType,
        orderStatus,
        purchaseOrderNo,
        currency,
        exchangeRate,
        couponCode,
        billingAddressName,
        shippingAddressName,
        yourInitial,
        subTotal,
        taxTotal,
        depositTotal,
        discountTotal,
        shippingTotal,
        itemCount,
        grandTotal,
        discountType,
        discountPercentage,
        discountAmount,
        latitude,
        longitude,
        transactionStart,
        transactionEnd
      ];
  @override
  String get aliasedName => _alias ?? 'sales_order_header';
  @override
  String get actualTableName => 'sales_order_header';
  @override
  VerificationContext validateIntegrity(
      Insertable<SalesOrderHeaderData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    } else if (isInserting) {
      context.missing(_userNameMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id'], _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('transaction_number')) {
      context.handle(
          _transactionNumberMeta,
          transactionNumber.isAcceptableOrUnknown(
              data['transaction_number'], _transactionNumberMeta));
    } else if (isInserting) {
      context.missing(_transactionNumberMeta);
    }
    if (data.containsKey('transaction_status')) {
      context.handle(
          _transactionStatusMeta,
          transactionStatus.isAcceptableOrUnknown(
              data['transaction_status'], _transactionStatusMeta));
    }
    if (data.containsKey('inventory_cycle_number')) {
      context.handle(
          _inventoryCycleNumberMeta,
          inventoryCycleNumber.isAcceptableOrUnknown(
              data['inventory_cycle_number'], _inventoryCycleNumberMeta));
    } else if (isInserting) {
      context.missing(_inventoryCycleNumberMeta);
    }
    if (data.containsKey('day_session_number')) {
      context.handle(
          _daySessionNumberMeta,
          daySessionNumber.isAcceptableOrUnknown(
              data['day_session_number'], _daySessionNumberMeta));
    } else if (isInserting) {
      context.missing(_daySessionNumberMeta);
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id'], _customerIdMeta));
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('sold_to')) {
      context.handle(_soldToMeta,
          soldTo.isAcceptableOrUnknown(data['sold_to'], _soldToMeta));
    }
    if (data.containsKey('order_date')) {
      context.handle(_orderDateMeta,
          orderDate.isAcceptableOrUnknown(data['order_date'], _orderDateMeta));
    } else if (isInserting) {
      context.missing(_orderDateMeta);
    }
    if (data.containsKey('delivery_date')) {
      context.handle(
          _deliveryDateMeta,
          deliveryDate.isAcceptableOrUnknown(
              data['delivery_date'], _deliveryDateMeta));
    } else if (isInserting) {
      context.missing(_deliveryDateMeta);
    }
    if (data.containsKey('order_type')) {
      context.handle(_orderTypeMeta,
          orderType.isAcceptableOrUnknown(data['order_type'], _orderTypeMeta));
    } else if (isInserting) {
      context.missing(_orderTypeMeta);
    }
    if (data.containsKey('order_status')) {
      context.handle(
          _orderStatusMeta,
          orderStatus.isAcceptableOrUnknown(
              data['order_status'], _orderStatusMeta));
    } else if (isInserting) {
      context.missing(_orderStatusMeta);
    }
    if (data.containsKey('purchase_order_no')) {
      context.handle(
          _purchaseOrderNoMeta,
          purchaseOrderNo.isAcceptableOrUnknown(
              data['purchase_order_no'], _purchaseOrderNoMeta));
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency'], _currencyMeta));
    } else if (isInserting) {
      context.missing(_currencyMeta);
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate'], _exchangeRateMeta));
    } else if (isInserting) {
      context.missing(_exchangeRateMeta);
    }
    if (data.containsKey('coupon_code')) {
      context.handle(
          _couponCodeMeta,
          couponCode.isAcceptableOrUnknown(
              data['coupon_code'], _couponCodeMeta));
    }
    if (data.containsKey('billing_address_name')) {
      context.handle(
          _billingAddressNameMeta,
          billingAddressName.isAcceptableOrUnknown(
              data['billing_address_name'], _billingAddressNameMeta));
    }
    if (data.containsKey('shipping_address_name')) {
      context.handle(
          _shippingAddressNameMeta,
          shippingAddressName.isAcceptableOrUnknown(
              data['shipping_address_name'], _shippingAddressNameMeta));
    }
    if (data.containsKey('your_initial')) {
      context.handle(
          _yourInitialMeta,
          yourInitial.isAcceptableOrUnknown(
              data['your_initial'], _yourInitialMeta));
    }
    if (data.containsKey('sub_total')) {
      context.handle(_subTotalMeta,
          subTotal.isAcceptableOrUnknown(data['sub_total'], _subTotalMeta));
    } else if (isInserting) {
      context.missing(_subTotalMeta);
    }
    if (data.containsKey('tax_total')) {
      context.handle(_taxTotalMeta,
          taxTotal.isAcceptableOrUnknown(data['tax_total'], _taxTotalMeta));
    } else if (isInserting) {
      context.missing(_taxTotalMeta);
    }
    if (data.containsKey('deposit_total')) {
      context.handle(
          _depositTotalMeta,
          depositTotal.isAcceptableOrUnknown(
              data['deposit_total'], _depositTotalMeta));
    } else if (isInserting) {
      context.missing(_depositTotalMeta);
    }
    if (data.containsKey('discount_total')) {
      context.handle(
          _discountTotalMeta,
          discountTotal.isAcceptableOrUnknown(
              data['discount_total'], _discountTotalMeta));
    } else if (isInserting) {
      context.missing(_discountTotalMeta);
    }
    if (data.containsKey('shipping_total')) {
      context.handle(
          _shippingTotalMeta,
          shippingTotal.isAcceptableOrUnknown(
              data['shipping_total'], _shippingTotalMeta));
    } else if (isInserting) {
      context.missing(_shippingTotalMeta);
    }
    if (data.containsKey('item_count')) {
      context.handle(_itemCountMeta,
          itemCount.isAcceptableOrUnknown(data['item_count'], _itemCountMeta));
    } else if (isInserting) {
      context.missing(_itemCountMeta);
    }
    if (data.containsKey('grand_total')) {
      context.handle(
          _grandTotalMeta,
          grandTotal.isAcceptableOrUnknown(
              data['grand_total'], _grandTotalMeta));
    } else if (isInserting) {
      context.missing(_grandTotalMeta);
    }
    if (data.containsKey('discount_type')) {
      context.handle(
          _discountTypeMeta,
          discountType.isAcceptableOrUnknown(
              data['discount_type'], _discountTypeMeta));
    } else if (isInserting) {
      context.missing(_discountTypeMeta);
    }
    if (data.containsKey('discount_percentage')) {
      context.handle(
          _discountPercentageMeta,
          discountPercentage.isAcceptableOrUnknown(
              data['discount_percentage'], _discountPercentageMeta));
    } else if (isInserting) {
      context.missing(_discountPercentageMeta);
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
          _discountAmountMeta,
          discountAmount.isAcceptableOrUnknown(
              data['discount_amount'], _discountAmountMeta));
    } else if (isInserting) {
      context.missing(_discountAmountMeta);
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude'], _latitudeMeta));
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude'], _longitudeMeta));
    }
    if (data.containsKey('transaction_start')) {
      context.handle(
          _transactionStartMeta,
          transactionStart.isAcceptableOrUnknown(
              data['transaction_start'], _transactionStartMeta));
    }
    if (data.containsKey('transaction_end')) {
      context.handle(
          _transactionEndMeta,
          transactionEnd.isAcceptableOrUnknown(
              data['transaction_end'], _transactionEndMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SalesOrderHeaderData map(Map<String, dynamic> data, {String tablePrefix}) {
    return SalesOrderHeaderData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $SalesOrderHeaderTable createAlias(String alias) {
    return $SalesOrderHeaderTable(_db, alias);
  }
}

class SalesOrderDetailData extends DataClass
    implements Insertable<SalesOrderDetailData> {
  final int tenantId;
  final String userName;
  final int userId;
  final int id;
  final String transactionNumber;
  final String inventoryCycleNumber;
  final String daySessionNumber;
  final DateTime deliveryDate;
  final String currency;
  final double exchangeRate;
  final String transactionStatus;
  final String itemId;
  final String itemCode;
  final String upcCode;
  final String description;
  final String itemGroup;
  final String category;
  final String salesUOM;
  final String stockUOM;
  final String taxGroup;
  final String warehouse;
  final String discountType;
  final double discountPercentage;
  final double discountAmount;
  final double lineDiscountTotal;
  final String taxIndicator;
  final double unitPrice;
  final double costPrice;
  final double listPrice;
  final double quantity;
  final double subTotal;
  final double grandTotal;
  final double fxGrandTotal;
  final int itemCount;
  final double depositTotal;
  final int lineId;
  final double taxTotal;
  final double shippingTotal;
  final double conversionFactor;
  SalesOrderDetailData(
      {this.tenantId,
      @required this.userName,
      @required this.userId,
      @required this.id,
      @required this.transactionNumber,
      @required this.inventoryCycleNumber,
      @required this.daySessionNumber,
      @required this.deliveryDate,
      @required this.currency,
      @required this.exchangeRate,
      this.transactionStatus,
      this.itemId,
      @required this.itemCode,
      @required this.upcCode,
      @required this.description,
      @required this.itemGroup,
      @required this.category,
      @required this.salesUOM,
      @required this.stockUOM,
      @required this.taxGroup,
      @required this.warehouse,
      @required this.discountType,
      @required this.discountPercentage,
      @required this.discountAmount,
      @required this.lineDiscountTotal,
      this.taxIndicator,
      @required this.unitPrice,
      @required this.costPrice,
      @required this.listPrice,
      @required this.quantity,
      @required this.subTotal,
      @required this.grandTotal,
      @required this.fxGrandTotal,
      this.itemCount,
      this.depositTotal,
      this.lineId,
      @required this.taxTotal,
      @required this.shippingTotal,
      @required this.conversionFactor});
  factory SalesOrderDetailData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return SalesOrderDetailData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      userId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      transactionNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}transaction_number']),
      inventoryCycleNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}inventory_cycle_number']),
      daySessionNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}day_session_number']),
      deliveryDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}delivery_date']),
      currency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}currency']),
      exchangeRate: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}exchange_rate']),
      transactionStatus: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}transaction_status']),
      itemId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_id']),
      itemCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_code']),
      upcCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}upc_code']),
      description: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}description']),
      itemGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_group']),
      category: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}category']),
      salesUOM: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sales_u_o_m']),
      stockUOM: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}stock_u_o_m']),
      taxGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_group']),
      warehouse: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}warehouse']),
      discountType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}discount_type']),
      discountPercentage: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}discount_percentage']),
      discountAmount: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}discount_amount']),
      lineDiscountTotal: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}line_discount_total']),
      taxIndicator: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_indicator']),
      unitPrice: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}unit_price']),
      costPrice: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}cost_price']),
      listPrice: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}list_price']),
      quantity: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}quantity']),
      subTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sub_total']),
      grandTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}grand_total']),
      fxGrandTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}fx_grand_total']),
      itemCount: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_count']),
      depositTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}deposit_total']),
      lineId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}line_id']),
      taxTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_total']),
      shippingTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}shipping_total']),
      conversionFactor: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}conversion_factor']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<int>(userId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || transactionNumber != null) {
      map['transaction_number'] = Variable<String>(transactionNumber);
    }
    if (!nullToAbsent || inventoryCycleNumber != null) {
      map['inventory_cycle_number'] = Variable<String>(inventoryCycleNumber);
    }
    if (!nullToAbsent || daySessionNumber != null) {
      map['day_session_number'] = Variable<String>(daySessionNumber);
    }
    if (!nullToAbsent || deliveryDate != null) {
      map['delivery_date'] = Variable<DateTime>(deliveryDate);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    if (!nullToAbsent || exchangeRate != null) {
      map['exchange_rate'] = Variable<double>(exchangeRate);
    }
    if (!nullToAbsent || transactionStatus != null) {
      map['transaction_status'] = Variable<String>(transactionStatus);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || upcCode != null) {
      map['upc_code'] = Variable<String>(upcCode);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || itemGroup != null) {
      map['item_group'] = Variable<String>(itemGroup);
    }
    if (!nullToAbsent || category != null) {
      map['category'] = Variable<String>(category);
    }
    if (!nullToAbsent || salesUOM != null) {
      map['sales_u_o_m'] = Variable<String>(salesUOM);
    }
    if (!nullToAbsent || stockUOM != null) {
      map['stock_u_o_m'] = Variable<String>(stockUOM);
    }
    if (!nullToAbsent || taxGroup != null) {
      map['tax_group'] = Variable<String>(taxGroup);
    }
    if (!nullToAbsent || warehouse != null) {
      map['warehouse'] = Variable<String>(warehouse);
    }
    if (!nullToAbsent || discountType != null) {
      map['discount_type'] = Variable<String>(discountType);
    }
    if (!nullToAbsent || discountPercentage != null) {
      map['discount_percentage'] = Variable<double>(discountPercentage);
    }
    if (!nullToAbsent || discountAmount != null) {
      map['discount_amount'] = Variable<double>(discountAmount);
    }
    if (!nullToAbsent || lineDiscountTotal != null) {
      map['line_discount_total'] = Variable<double>(lineDiscountTotal);
    }
    if (!nullToAbsent || taxIndicator != null) {
      map['tax_indicator'] = Variable<String>(taxIndicator);
    }
    if (!nullToAbsent || unitPrice != null) {
      map['unit_price'] = Variable<double>(unitPrice);
    }
    if (!nullToAbsent || costPrice != null) {
      map['cost_price'] = Variable<double>(costPrice);
    }
    if (!nullToAbsent || listPrice != null) {
      map['list_price'] = Variable<double>(listPrice);
    }
    if (!nullToAbsent || quantity != null) {
      map['quantity'] = Variable<double>(quantity);
    }
    if (!nullToAbsent || subTotal != null) {
      map['sub_total'] = Variable<double>(subTotal);
    }
    if (!nullToAbsent || grandTotal != null) {
      map['grand_total'] = Variable<double>(grandTotal);
    }
    if (!nullToAbsent || fxGrandTotal != null) {
      map['fx_grand_total'] = Variable<double>(fxGrandTotal);
    }
    if (!nullToAbsent || itemCount != null) {
      map['item_count'] = Variable<int>(itemCount);
    }
    if (!nullToAbsent || depositTotal != null) {
      map['deposit_total'] = Variable<double>(depositTotal);
    }
    if (!nullToAbsent || lineId != null) {
      map['line_id'] = Variable<int>(lineId);
    }
    if (!nullToAbsent || taxTotal != null) {
      map['tax_total'] = Variable<double>(taxTotal);
    }
    if (!nullToAbsent || shippingTotal != null) {
      map['shipping_total'] = Variable<double>(shippingTotal);
    }
    if (!nullToAbsent || conversionFactor != null) {
      map['conversion_factor'] = Variable<double>(conversionFactor);
    }
    return map;
  }

  SalesOrderDetailCompanion toCompanion(bool nullToAbsent) {
    return SalesOrderDetailCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      transactionNumber: transactionNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionNumber),
      inventoryCycleNumber: inventoryCycleNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(inventoryCycleNumber),
      daySessionNumber: daySessionNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(daySessionNumber),
      deliveryDate: deliveryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(deliveryDate),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      exchangeRate: exchangeRate == null && nullToAbsent
          ? const Value.absent()
          : Value(exchangeRate),
      transactionStatus: transactionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionStatus),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      upcCode: upcCode == null && nullToAbsent
          ? const Value.absent()
          : Value(upcCode),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      itemGroup: itemGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(itemGroup),
      category: category == null && nullToAbsent
          ? const Value.absent()
          : Value(category),
      salesUOM: salesUOM == null && nullToAbsent
          ? const Value.absent()
          : Value(salesUOM),
      stockUOM: stockUOM == null && nullToAbsent
          ? const Value.absent()
          : Value(stockUOM),
      taxGroup: taxGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(taxGroup),
      warehouse: warehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(warehouse),
      discountType: discountType == null && nullToAbsent
          ? const Value.absent()
          : Value(discountType),
      discountPercentage: discountPercentage == null && nullToAbsent
          ? const Value.absent()
          : Value(discountPercentage),
      discountAmount: discountAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(discountAmount),
      lineDiscountTotal: lineDiscountTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(lineDiscountTotal),
      taxIndicator: taxIndicator == null && nullToAbsent
          ? const Value.absent()
          : Value(taxIndicator),
      unitPrice: unitPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(unitPrice),
      costPrice: costPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(costPrice),
      listPrice: listPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(listPrice),
      quantity: quantity == null && nullToAbsent
          ? const Value.absent()
          : Value(quantity),
      subTotal: subTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(subTotal),
      grandTotal: grandTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(grandTotal),
      fxGrandTotal: fxGrandTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(fxGrandTotal),
      itemCount: itemCount == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCount),
      depositTotal: depositTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(depositTotal),
      lineId:
          lineId == null && nullToAbsent ? const Value.absent() : Value(lineId),
      taxTotal: taxTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(taxTotal),
      shippingTotal: shippingTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(shippingTotal),
      conversionFactor: conversionFactor == null && nullToAbsent
          ? const Value.absent()
          : Value(conversionFactor),
    );
  }

  factory SalesOrderDetailData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesOrderDetailData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      userName: serializer.fromJson<String>(json['userName']),
      userId: serializer.fromJson<int>(json['userId']),
      id: serializer.fromJson<int>(json['id']),
      transactionNumber: serializer.fromJson<String>(json['transactionNumber']),
      inventoryCycleNumber:
          serializer.fromJson<String>(json['inventoryCycleNumber']),
      daySessionNumber: serializer.fromJson<String>(json['daySessionNumber']),
      deliveryDate: serializer.fromJson<DateTime>(json['deliveryDate']),
      currency: serializer.fromJson<String>(json['currency']),
      exchangeRate: serializer.fromJson<double>(json['exchangeRate']),
      transactionStatus: serializer.fromJson<String>(json['transactionStatus']),
      itemId: serializer.fromJson<String>(json['itemId']),
      itemCode: serializer.fromJson<String>(json['itemCode']),
      upcCode: serializer.fromJson<String>(json['upcCode']),
      description: serializer.fromJson<String>(json['description']),
      itemGroup: serializer.fromJson<String>(json['itemGroup']),
      category: serializer.fromJson<String>(json['category']),
      salesUOM: serializer.fromJson<String>(json['salesUOM']),
      stockUOM: serializer.fromJson<String>(json['stockUOM']),
      taxGroup: serializer.fromJson<String>(json['taxGroup']),
      warehouse: serializer.fromJson<String>(json['warehouse']),
      discountType: serializer.fromJson<String>(json['discountType']),
      discountPercentage:
          serializer.fromJson<double>(json['discountPercentage']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      lineDiscountTotal: serializer.fromJson<double>(json['lineDiscountTotal']),
      taxIndicator: serializer.fromJson<String>(json['taxIndicator']),
      unitPrice: serializer.fromJson<double>(json['unitPrice']),
      costPrice: serializer.fromJson<double>(json['costPrice']),
      listPrice: serializer.fromJson<double>(json['listPrice']),
      quantity: serializer.fromJson<double>(json['quantity']),
      subTotal: serializer.fromJson<double>(json['subTotal']),
      grandTotal: serializer.fromJson<double>(json['grandTotal']),
      fxGrandTotal: serializer.fromJson<double>(json['fxGrandTotal']),
      itemCount: serializer.fromJson<int>(json['itemCount']),
      depositTotal: serializer.fromJson<double>(json['depositTotal']),
      lineId: serializer.fromJson<int>(json['lineId']),
      taxTotal: serializer.fromJson<double>(json['taxTotal']),
      shippingTotal: serializer.fromJson<double>(json['shippingTotal']),
      conversionFactor: serializer.fromJson<double>(json['conversionFactor']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'userName': serializer.toJson<String>(userName),
      'userId': serializer.toJson<int>(userId),
      'id': serializer.toJson<int>(id),
      'transactionNumber': serializer.toJson<String>(transactionNumber),
      'inventoryCycleNumber': serializer.toJson<String>(inventoryCycleNumber),
      'daySessionNumber': serializer.toJson<String>(daySessionNumber),
      'deliveryDate': serializer.toJson<DateTime>(deliveryDate),
      'currency': serializer.toJson<String>(currency),
      'exchangeRate': serializer.toJson<double>(exchangeRate),
      'transactionStatus': serializer.toJson<String>(transactionStatus),
      'itemId': serializer.toJson<String>(itemId),
      'itemCode': serializer.toJson<String>(itemCode),
      'upcCode': serializer.toJson<String>(upcCode),
      'description': serializer.toJson<String>(description),
      'itemGroup': serializer.toJson<String>(itemGroup),
      'category': serializer.toJson<String>(category),
      'salesUOM': serializer.toJson<String>(salesUOM),
      'stockUOM': serializer.toJson<String>(stockUOM),
      'taxGroup': serializer.toJson<String>(taxGroup),
      'warehouse': serializer.toJson<String>(warehouse),
      'discountType': serializer.toJson<String>(discountType),
      'discountPercentage': serializer.toJson<double>(discountPercentage),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'lineDiscountTotal': serializer.toJson<double>(lineDiscountTotal),
      'taxIndicator': serializer.toJson<String>(taxIndicator),
      'unitPrice': serializer.toJson<double>(unitPrice),
      'costPrice': serializer.toJson<double>(costPrice),
      'listPrice': serializer.toJson<double>(listPrice),
      'quantity': serializer.toJson<double>(quantity),
      'subTotal': serializer.toJson<double>(subTotal),
      'grandTotal': serializer.toJson<double>(grandTotal),
      'fxGrandTotal': serializer.toJson<double>(fxGrandTotal),
      'itemCount': serializer.toJson<int>(itemCount),
      'depositTotal': serializer.toJson<double>(depositTotal),
      'lineId': serializer.toJson<int>(lineId),
      'taxTotal': serializer.toJson<double>(taxTotal),
      'shippingTotal': serializer.toJson<double>(shippingTotal),
      'conversionFactor': serializer.toJson<double>(conversionFactor),
    };
  }

  SalesOrderDetailData copyWith(
          {int tenantId,
          String userName,
          int userId,
          int id,
          String transactionNumber,
          String inventoryCycleNumber,
          String daySessionNumber,
          DateTime deliveryDate,
          String currency,
          double exchangeRate,
          String transactionStatus,
          String itemId,
          String itemCode,
          String upcCode,
          String description,
          String itemGroup,
          String category,
          String salesUOM,
          String stockUOM,
          String taxGroup,
          String warehouse,
          String discountType,
          double discountPercentage,
          double discountAmount,
          double lineDiscountTotal,
          String taxIndicator,
          double unitPrice,
          double costPrice,
          double listPrice,
          double quantity,
          double subTotal,
          double grandTotal,
          double fxGrandTotal,
          int itemCount,
          double depositTotal,
          int lineId,
          double taxTotal,
          double shippingTotal,
          double conversionFactor}) =>
      SalesOrderDetailData(
        tenantId: tenantId ?? this.tenantId,
        userName: userName ?? this.userName,
        userId: userId ?? this.userId,
        id: id ?? this.id,
        transactionNumber: transactionNumber ?? this.transactionNumber,
        inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
        daySessionNumber: daySessionNumber ?? this.daySessionNumber,
        deliveryDate: deliveryDate ?? this.deliveryDate,
        currency: currency ?? this.currency,
        exchangeRate: exchangeRate ?? this.exchangeRate,
        transactionStatus: transactionStatus ?? this.transactionStatus,
        itemId: itemId ?? this.itemId,
        itemCode: itemCode ?? this.itemCode,
        upcCode: upcCode ?? this.upcCode,
        description: description ?? this.description,
        itemGroup: itemGroup ?? this.itemGroup,
        category: category ?? this.category,
        salesUOM: salesUOM ?? this.salesUOM,
        stockUOM: stockUOM ?? this.stockUOM,
        taxGroup: taxGroup ?? this.taxGroup,
        warehouse: warehouse ?? this.warehouse,
        discountType: discountType ?? this.discountType,
        discountPercentage: discountPercentage ?? this.discountPercentage,
        discountAmount: discountAmount ?? this.discountAmount,
        lineDiscountTotal: lineDiscountTotal ?? this.lineDiscountTotal,
        taxIndicator: taxIndicator ?? this.taxIndicator,
        unitPrice: unitPrice ?? this.unitPrice,
        costPrice: costPrice ?? this.costPrice,
        listPrice: listPrice ?? this.listPrice,
        quantity: quantity ?? this.quantity,
        subTotal: subTotal ?? this.subTotal,
        grandTotal: grandTotal ?? this.grandTotal,
        fxGrandTotal: fxGrandTotal ?? this.fxGrandTotal,
        itemCount: itemCount ?? this.itemCount,
        depositTotal: depositTotal ?? this.depositTotal,
        lineId: lineId ?? this.lineId,
        taxTotal: taxTotal ?? this.taxTotal,
        shippingTotal: shippingTotal ?? this.shippingTotal,
        conversionFactor: conversionFactor ?? this.conversionFactor,
      );
  @override
  String toString() {
    return (StringBuffer('SalesOrderDetailData(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('upcCode: $upcCode, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('salesUOM: $salesUOM, ')
          ..write('stockUOM: $stockUOM, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('warehouse: $warehouse, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('lineDiscountTotal: $lineDiscountTotal, ')
          ..write('taxIndicator: $taxIndicator, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('costPrice: $costPrice, ')
          ..write('listPrice: $listPrice, ')
          ..write('quantity: $quantity, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('fxGrandTotal: $fxGrandTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('lineId: $lineId, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('conversionFactor: $conversionFactor')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        inventoryCycleNumber,
        daySessionNumber,
        deliveryDate,
        currency,
        exchangeRate,
        transactionStatus,
        itemId,
        itemCode,
        upcCode,
        description,
        itemGroup,
        category,
        salesUOM,
        stockUOM,
        taxGroup,
        warehouse,
        discountType,
        discountPercentage,
        discountAmount,
        lineDiscountTotal,
        taxIndicator,
        unitPrice,
        costPrice,
        listPrice,
        quantity,
        subTotal,
        grandTotal,
        fxGrandTotal,
        itemCount,
        depositTotal,
        lineId,
        taxTotal,
        shippingTotal,
        conversionFactor
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesOrderDetailData &&
          other.tenantId == this.tenantId &&
          other.userName == this.userName &&
          other.userId == this.userId &&
          other.id == this.id &&
          other.transactionNumber == this.transactionNumber &&
          other.inventoryCycleNumber == this.inventoryCycleNumber &&
          other.daySessionNumber == this.daySessionNumber &&
          other.deliveryDate == this.deliveryDate &&
          other.currency == this.currency &&
          other.exchangeRate == this.exchangeRate &&
          other.transactionStatus == this.transactionStatus &&
          other.itemId == this.itemId &&
          other.itemCode == this.itemCode &&
          other.upcCode == this.upcCode &&
          other.description == this.description &&
          other.itemGroup == this.itemGroup &&
          other.category == this.category &&
          other.salesUOM == this.salesUOM &&
          other.stockUOM == this.stockUOM &&
          other.taxGroup == this.taxGroup &&
          other.warehouse == this.warehouse &&
          other.discountType == this.discountType &&
          other.discountPercentage == this.discountPercentage &&
          other.discountAmount == this.discountAmount &&
          other.lineDiscountTotal == this.lineDiscountTotal &&
          other.taxIndicator == this.taxIndicator &&
          other.unitPrice == this.unitPrice &&
          other.costPrice == this.costPrice &&
          other.listPrice == this.listPrice &&
          other.quantity == this.quantity &&
          other.subTotal == this.subTotal &&
          other.grandTotal == this.grandTotal &&
          other.fxGrandTotal == this.fxGrandTotal &&
          other.itemCount == this.itemCount &&
          other.depositTotal == this.depositTotal &&
          other.lineId == this.lineId &&
          other.taxTotal == this.taxTotal &&
          other.shippingTotal == this.shippingTotal &&
          other.conversionFactor == this.conversionFactor);
}

class SalesOrderDetailCompanion extends UpdateCompanion<SalesOrderDetailData> {
  final Value<int> tenantId;
  final Value<String> userName;
  final Value<int> userId;
  final Value<int> id;
  final Value<String> transactionNumber;
  final Value<String> inventoryCycleNumber;
  final Value<String> daySessionNumber;
  final Value<DateTime> deliveryDate;
  final Value<String> currency;
  final Value<double> exchangeRate;
  final Value<String> transactionStatus;
  final Value<String> itemId;
  final Value<String> itemCode;
  final Value<String> upcCode;
  final Value<String> description;
  final Value<String> itemGroup;
  final Value<String> category;
  final Value<String> salesUOM;
  final Value<String> stockUOM;
  final Value<String> taxGroup;
  final Value<String> warehouse;
  final Value<String> discountType;
  final Value<double> discountPercentage;
  final Value<double> discountAmount;
  final Value<double> lineDiscountTotal;
  final Value<String> taxIndicator;
  final Value<double> unitPrice;
  final Value<double> costPrice;
  final Value<double> listPrice;
  final Value<double> quantity;
  final Value<double> subTotal;
  final Value<double> grandTotal;
  final Value<double> fxGrandTotal;
  final Value<int> itemCount;
  final Value<double> depositTotal;
  final Value<int> lineId;
  final Value<double> taxTotal;
  final Value<double> shippingTotal;
  final Value<double> conversionFactor;
  const SalesOrderDetailCompanion({
    this.tenantId = const Value.absent(),
    this.userName = const Value.absent(),
    this.userId = const Value.absent(),
    this.id = const Value.absent(),
    this.transactionNumber = const Value.absent(),
    this.inventoryCycleNumber = const Value.absent(),
    this.daySessionNumber = const Value.absent(),
    this.deliveryDate = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.itemId = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.upcCode = const Value.absent(),
    this.description = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.category = const Value.absent(),
    this.salesUOM = const Value.absent(),
    this.stockUOM = const Value.absent(),
    this.taxGroup = const Value.absent(),
    this.warehouse = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.lineDiscountTotal = const Value.absent(),
    this.taxIndicator = const Value.absent(),
    this.unitPrice = const Value.absent(),
    this.costPrice = const Value.absent(),
    this.listPrice = const Value.absent(),
    this.quantity = const Value.absent(),
    this.subTotal = const Value.absent(),
    this.grandTotal = const Value.absent(),
    this.fxGrandTotal = const Value.absent(),
    this.itemCount = const Value.absent(),
    this.depositTotal = const Value.absent(),
    this.lineId = const Value.absent(),
    this.taxTotal = const Value.absent(),
    this.shippingTotal = const Value.absent(),
    this.conversionFactor = const Value.absent(),
  });
  SalesOrderDetailCompanion.insert({
    this.tenantId = const Value.absent(),
    @required String userName,
    @required int userId,
    this.id = const Value.absent(),
    @required String transactionNumber,
    @required String inventoryCycleNumber,
    @required String daySessionNumber,
    @required DateTime deliveryDate,
    @required String currency,
    @required double exchangeRate,
    this.transactionStatus = const Value.absent(),
    this.itemId = const Value.absent(),
    @required String itemCode,
    @required String upcCode,
    @required String description,
    @required String itemGroup,
    @required String category,
    @required String salesUOM,
    @required String stockUOM,
    @required String taxGroup,
    @required String warehouse,
    @required String discountType,
    @required double discountPercentage,
    @required double discountAmount,
    @required double lineDiscountTotal,
    this.taxIndicator = const Value.absent(),
    @required double unitPrice,
    @required double costPrice,
    @required double listPrice,
    @required double quantity,
    @required double subTotal,
    @required double grandTotal,
    @required double fxGrandTotal,
    this.itemCount = const Value.absent(),
    this.depositTotal = const Value.absent(),
    this.lineId = const Value.absent(),
    @required double taxTotal,
    @required double shippingTotal,
    @required double conversionFactor,
  })  : userName = Value(userName),
        userId = Value(userId),
        transactionNumber = Value(transactionNumber),
        inventoryCycleNumber = Value(inventoryCycleNumber),
        daySessionNumber = Value(daySessionNumber),
        deliveryDate = Value(deliveryDate),
        currency = Value(currency),
        exchangeRate = Value(exchangeRate),
        itemCode = Value(itemCode),
        upcCode = Value(upcCode),
        description = Value(description),
        itemGroup = Value(itemGroup),
        category = Value(category),
        salesUOM = Value(salesUOM),
        stockUOM = Value(stockUOM),
        taxGroup = Value(taxGroup),
        warehouse = Value(warehouse),
        discountType = Value(discountType),
        discountPercentage = Value(discountPercentage),
        discountAmount = Value(discountAmount),
        lineDiscountTotal = Value(lineDiscountTotal),
        unitPrice = Value(unitPrice),
        costPrice = Value(costPrice),
        listPrice = Value(listPrice),
        quantity = Value(quantity),
        subTotal = Value(subTotal),
        grandTotal = Value(grandTotal),
        fxGrandTotal = Value(fxGrandTotal),
        taxTotal = Value(taxTotal),
        shippingTotal = Value(shippingTotal),
        conversionFactor = Value(conversionFactor);
  static Insertable<SalesOrderDetailData> custom({
    Expression<int> tenantId,
    Expression<String> userName,
    Expression<int> userId,
    Expression<int> id,
    Expression<String> transactionNumber,
    Expression<String> inventoryCycleNumber,
    Expression<String> daySessionNumber,
    Expression<DateTime> deliveryDate,
    Expression<String> currency,
    Expression<double> exchangeRate,
    Expression<String> transactionStatus,
    Expression<String> itemId,
    Expression<String> itemCode,
    Expression<String> upcCode,
    Expression<String> description,
    Expression<String> itemGroup,
    Expression<String> category,
    Expression<String> salesUOM,
    Expression<String> stockUOM,
    Expression<String> taxGroup,
    Expression<String> warehouse,
    Expression<String> discountType,
    Expression<double> discountPercentage,
    Expression<double> discountAmount,
    Expression<double> lineDiscountTotal,
    Expression<String> taxIndicator,
    Expression<double> unitPrice,
    Expression<double> costPrice,
    Expression<double> listPrice,
    Expression<double> quantity,
    Expression<double> subTotal,
    Expression<double> grandTotal,
    Expression<double> fxGrandTotal,
    Expression<int> itemCount,
    Expression<double> depositTotal,
    Expression<int> lineId,
    Expression<double> taxTotal,
    Expression<double> shippingTotal,
    Expression<double> conversionFactor,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (userName != null) 'user_name': userName,
      if (userId != null) 'user_id': userId,
      if (id != null) 'id': id,
      if (transactionNumber != null) 'transaction_number': transactionNumber,
      if (inventoryCycleNumber != null)
        'inventory_cycle_number': inventoryCycleNumber,
      if (daySessionNumber != null) 'day_session_number': daySessionNumber,
      if (deliveryDate != null) 'delivery_date': deliveryDate,
      if (currency != null) 'currency': currency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (transactionStatus != null) 'transaction_status': transactionStatus,
      if (itemId != null) 'item_id': itemId,
      if (itemCode != null) 'item_code': itemCode,
      if (upcCode != null) 'upc_code': upcCode,
      if (description != null) 'description': description,
      if (itemGroup != null) 'item_group': itemGroup,
      if (category != null) 'category': category,
      if (salesUOM != null) 'sales_u_o_m': salesUOM,
      if (stockUOM != null) 'stock_u_o_m': stockUOM,
      if (taxGroup != null) 'tax_group': taxGroup,
      if (warehouse != null) 'warehouse': warehouse,
      if (discountType != null) 'discount_type': discountType,
      if (discountPercentage != null) 'discount_percentage': discountPercentage,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (lineDiscountTotal != null) 'line_discount_total': lineDiscountTotal,
      if (taxIndicator != null) 'tax_indicator': taxIndicator,
      if (unitPrice != null) 'unit_price': unitPrice,
      if (costPrice != null) 'cost_price': costPrice,
      if (listPrice != null) 'list_price': listPrice,
      if (quantity != null) 'quantity': quantity,
      if (subTotal != null) 'sub_total': subTotal,
      if (grandTotal != null) 'grand_total': grandTotal,
      if (fxGrandTotal != null) 'fx_grand_total': fxGrandTotal,
      if (itemCount != null) 'item_count': itemCount,
      if (depositTotal != null) 'deposit_total': depositTotal,
      if (lineId != null) 'line_id': lineId,
      if (taxTotal != null) 'tax_total': taxTotal,
      if (shippingTotal != null) 'shipping_total': shippingTotal,
      if (conversionFactor != null) 'conversion_factor': conversionFactor,
    });
  }

  SalesOrderDetailCompanion copyWith(
      {Value<int> tenantId,
      Value<String> userName,
      Value<int> userId,
      Value<int> id,
      Value<String> transactionNumber,
      Value<String> inventoryCycleNumber,
      Value<String> daySessionNumber,
      Value<DateTime> deliveryDate,
      Value<String> currency,
      Value<double> exchangeRate,
      Value<String> transactionStatus,
      Value<String> itemId,
      Value<String> itemCode,
      Value<String> upcCode,
      Value<String> description,
      Value<String> itemGroup,
      Value<String> category,
      Value<String> salesUOM,
      Value<String> stockUOM,
      Value<String> taxGroup,
      Value<String> warehouse,
      Value<String> discountType,
      Value<double> discountPercentage,
      Value<double> discountAmount,
      Value<double> lineDiscountTotal,
      Value<String> taxIndicator,
      Value<double> unitPrice,
      Value<double> costPrice,
      Value<double> listPrice,
      Value<double> quantity,
      Value<double> subTotal,
      Value<double> grandTotal,
      Value<double> fxGrandTotal,
      Value<int> itemCount,
      Value<double> depositTotal,
      Value<int> lineId,
      Value<double> taxTotal,
      Value<double> shippingTotal,
      Value<double> conversionFactor}) {
    return SalesOrderDetailCompanion(
      tenantId: tenantId ?? this.tenantId,
      userName: userName ?? this.userName,
      userId: userId ?? this.userId,
      id: id ?? this.id,
      transactionNumber: transactionNumber ?? this.transactionNumber,
      inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
      daySessionNumber: daySessionNumber ?? this.daySessionNumber,
      deliveryDate: deliveryDate ?? this.deliveryDate,
      currency: currency ?? this.currency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      transactionStatus: transactionStatus ?? this.transactionStatus,
      itemId: itemId ?? this.itemId,
      itemCode: itemCode ?? this.itemCode,
      upcCode: upcCode ?? this.upcCode,
      description: description ?? this.description,
      itemGroup: itemGroup ?? this.itemGroup,
      category: category ?? this.category,
      salesUOM: salesUOM ?? this.salesUOM,
      stockUOM: stockUOM ?? this.stockUOM,
      taxGroup: taxGroup ?? this.taxGroup,
      warehouse: warehouse ?? this.warehouse,
      discountType: discountType ?? this.discountType,
      discountPercentage: discountPercentage ?? this.discountPercentage,
      discountAmount: discountAmount ?? this.discountAmount,
      lineDiscountTotal: lineDiscountTotal ?? this.lineDiscountTotal,
      taxIndicator: taxIndicator ?? this.taxIndicator,
      unitPrice: unitPrice ?? this.unitPrice,
      costPrice: costPrice ?? this.costPrice,
      listPrice: listPrice ?? this.listPrice,
      quantity: quantity ?? this.quantity,
      subTotal: subTotal ?? this.subTotal,
      grandTotal: grandTotal ?? this.grandTotal,
      fxGrandTotal: fxGrandTotal ?? this.fxGrandTotal,
      itemCount: itemCount ?? this.itemCount,
      depositTotal: depositTotal ?? this.depositTotal,
      lineId: lineId ?? this.lineId,
      taxTotal: taxTotal ?? this.taxTotal,
      shippingTotal: shippingTotal ?? this.shippingTotal,
      conversionFactor: conversionFactor ?? this.conversionFactor,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (transactionNumber.present) {
      map['transaction_number'] = Variable<String>(transactionNumber.value);
    }
    if (inventoryCycleNumber.present) {
      map['inventory_cycle_number'] =
          Variable<String>(inventoryCycleNumber.value);
    }
    if (daySessionNumber.present) {
      map['day_session_number'] = Variable<String>(daySessionNumber.value);
    }
    if (deliveryDate.present) {
      map['delivery_date'] = Variable<DateTime>(deliveryDate.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (transactionStatus.present) {
      map['transaction_status'] = Variable<String>(transactionStatus.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (upcCode.present) {
      map['upc_code'] = Variable<String>(upcCode.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (itemGroup.present) {
      map['item_group'] = Variable<String>(itemGroup.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (salesUOM.present) {
      map['sales_u_o_m'] = Variable<String>(salesUOM.value);
    }
    if (stockUOM.present) {
      map['stock_u_o_m'] = Variable<String>(stockUOM.value);
    }
    if (taxGroup.present) {
      map['tax_group'] = Variable<String>(taxGroup.value);
    }
    if (warehouse.present) {
      map['warehouse'] = Variable<String>(warehouse.value);
    }
    if (discountType.present) {
      map['discount_type'] = Variable<String>(discountType.value);
    }
    if (discountPercentage.present) {
      map['discount_percentage'] = Variable<double>(discountPercentage.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (lineDiscountTotal.present) {
      map['line_discount_total'] = Variable<double>(lineDiscountTotal.value);
    }
    if (taxIndicator.present) {
      map['tax_indicator'] = Variable<String>(taxIndicator.value);
    }
    if (unitPrice.present) {
      map['unit_price'] = Variable<double>(unitPrice.value);
    }
    if (costPrice.present) {
      map['cost_price'] = Variable<double>(costPrice.value);
    }
    if (listPrice.present) {
      map['list_price'] = Variable<double>(listPrice.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (subTotal.present) {
      map['sub_total'] = Variable<double>(subTotal.value);
    }
    if (grandTotal.present) {
      map['grand_total'] = Variable<double>(grandTotal.value);
    }
    if (fxGrandTotal.present) {
      map['fx_grand_total'] = Variable<double>(fxGrandTotal.value);
    }
    if (itemCount.present) {
      map['item_count'] = Variable<int>(itemCount.value);
    }
    if (depositTotal.present) {
      map['deposit_total'] = Variable<double>(depositTotal.value);
    }
    if (lineId.present) {
      map['line_id'] = Variable<int>(lineId.value);
    }
    if (taxTotal.present) {
      map['tax_total'] = Variable<double>(taxTotal.value);
    }
    if (shippingTotal.present) {
      map['shipping_total'] = Variable<double>(shippingTotal.value);
    }
    if (conversionFactor.present) {
      map['conversion_factor'] = Variable<double>(conversionFactor.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesOrderDetailCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('upcCode: $upcCode, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('salesUOM: $salesUOM, ')
          ..write('stockUOM: $stockUOM, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('warehouse: $warehouse, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('lineDiscountTotal: $lineDiscountTotal, ')
          ..write('taxIndicator: $taxIndicator, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('costPrice: $costPrice, ')
          ..write('listPrice: $listPrice, ')
          ..write('quantity: $quantity, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('fxGrandTotal: $fxGrandTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('lineId: $lineId, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('conversionFactor: $conversionFactor')
          ..write(')'))
        .toString();
  }
}

class $SalesOrderDetailTable extends SalesOrderDetail
    with TableInfo<$SalesOrderDetailTable, SalesOrderDetailData> {
  final GeneratedDatabase _db;
  final String _alias;
  $SalesOrderDetailTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _userIdMeta = const VerificationMeta('userId');
  GeneratedColumn<int> _userId;
  @override
  GeneratedColumn<int> get userId =>
      _userId ??= GeneratedColumn<int>('user_id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _transactionNumberMeta =
      const VerificationMeta('transactionNumber');
  GeneratedColumn<String> _transactionNumber;
  @override
  GeneratedColumn<String> get transactionNumber => _transactionNumber ??=
      GeneratedColumn<String>('transaction_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _inventoryCycleNumberMeta =
      const VerificationMeta('inventoryCycleNumber');
  GeneratedColumn<String> _inventoryCycleNumber;
  @override
  GeneratedColumn<String> get inventoryCycleNumber => _inventoryCycleNumber ??=
      GeneratedColumn<String>('inventory_cycle_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _daySessionNumberMeta =
      const VerificationMeta('daySessionNumber');
  GeneratedColumn<String> _daySessionNumber;
  @override
  GeneratedColumn<String> get daySessionNumber => _daySessionNumber ??=
      GeneratedColumn<String>('day_session_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _deliveryDateMeta =
      const VerificationMeta('deliveryDate');
  GeneratedColumn<DateTime> _deliveryDate;
  @override
  GeneratedColumn<DateTime> get deliveryDate => _deliveryDate ??=
      GeneratedColumn<DateTime>('delivery_date', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _currencyMeta = const VerificationMeta('currency');
  GeneratedColumn<String> _currency;
  @override
  GeneratedColumn<String> get currency =>
      _currency ??= GeneratedColumn<String>('currency', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  GeneratedColumn<double> _exchangeRate;
  @override
  GeneratedColumn<double> get exchangeRate => _exchangeRate ??=
      GeneratedColumn<double>('exchange_rate', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _transactionStatusMeta =
      const VerificationMeta('transactionStatus');
  GeneratedColumn<String> _transactionStatus;
  @override
  GeneratedColumn<String> get transactionStatus => _transactionStatus ??=
      GeneratedColumn<String>('transaction_status', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  GeneratedColumn<String> _itemId;
  @override
  GeneratedColumn<String> get itemId =>
      _itemId ??= GeneratedColumn<String>('item_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemCodeMeta = const VerificationMeta('itemCode');
  GeneratedColumn<String> _itemCode;
  @override
  GeneratedColumn<String> get itemCode =>
      _itemCode ??= GeneratedColumn<String>('item_code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _upcCodeMeta = const VerificationMeta('upcCode');
  GeneratedColumn<String> _upcCode;
  @override
  GeneratedColumn<String> get upcCode =>
      _upcCode ??= GeneratedColumn<String>('upc_code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  GeneratedColumn<String> _description;
  @override
  GeneratedColumn<String> get description => _description ??=
      GeneratedColumn<String>('description', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _itemGroupMeta = const VerificationMeta('itemGroup');
  GeneratedColumn<String> _itemGroup;
  @override
  GeneratedColumn<String> get itemGroup =>
      _itemGroup ??= GeneratedColumn<String>('item_group', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _categoryMeta = const VerificationMeta('category');
  GeneratedColumn<String> _category;
  @override
  GeneratedColumn<String> get category =>
      _category ??= GeneratedColumn<String>('category', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _salesUOMMeta = const VerificationMeta('salesUOM');
  GeneratedColumn<String> _salesUOM;
  @override
  GeneratedColumn<String> get salesUOM =>
      _salesUOM ??= GeneratedColumn<String>('sales_u_o_m', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _stockUOMMeta = const VerificationMeta('stockUOM');
  GeneratedColumn<String> _stockUOM;
  @override
  GeneratedColumn<String> get stockUOM =>
      _stockUOM ??= GeneratedColumn<String>('stock_u_o_m', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _taxGroupMeta = const VerificationMeta('taxGroup');
  GeneratedColumn<String> _taxGroup;
  @override
  GeneratedColumn<String> get taxGroup =>
      _taxGroup ??= GeneratedColumn<String>('tax_group', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _warehouseMeta = const VerificationMeta('warehouse');
  GeneratedColumn<String> _warehouse;
  @override
  GeneratedColumn<String> get warehouse =>
      _warehouse ??= GeneratedColumn<String>('warehouse', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _discountTypeMeta =
      const VerificationMeta('discountType');
  GeneratedColumn<String> _discountType;
  @override
  GeneratedColumn<String> get discountType => _discountType ??=
      GeneratedColumn<String>('discount_type', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _discountPercentageMeta =
      const VerificationMeta('discountPercentage');
  GeneratedColumn<double> _discountPercentage;
  @override
  GeneratedColumn<double> get discountPercentage => _discountPercentage ??=
      GeneratedColumn<double>('discount_percentage', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _discountAmountMeta =
      const VerificationMeta('discountAmount');
  GeneratedColumn<double> _discountAmount;
  @override
  GeneratedColumn<double> get discountAmount => _discountAmount ??=
      GeneratedColumn<double>('discount_amount', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _lineDiscountTotalMeta =
      const VerificationMeta('lineDiscountTotal');
  GeneratedColumn<double> _lineDiscountTotal;
  @override
  GeneratedColumn<double> get lineDiscountTotal => _lineDiscountTotal ??=
      GeneratedColumn<double>('line_discount_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _taxIndicatorMeta =
      const VerificationMeta('taxIndicator');
  GeneratedColumn<String> _taxIndicator;
  @override
  GeneratedColumn<String> get taxIndicator => _taxIndicator ??=
      GeneratedColumn<String>('tax_indicator', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _unitPriceMeta = const VerificationMeta('unitPrice');
  GeneratedColumn<double> _unitPrice;
  @override
  GeneratedColumn<double> get unitPrice =>
      _unitPrice ??= GeneratedColumn<double>('unit_price', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _costPriceMeta = const VerificationMeta('costPrice');
  GeneratedColumn<double> _costPrice;
  @override
  GeneratedColumn<double> get costPrice =>
      _costPrice ??= GeneratedColumn<double>('cost_price', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _listPriceMeta = const VerificationMeta('listPrice');
  GeneratedColumn<double> _listPrice;
  @override
  GeneratedColumn<double> get listPrice =>
      _listPrice ??= GeneratedColumn<double>('list_price', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _quantityMeta = const VerificationMeta('quantity');
  GeneratedColumn<double> _quantity;
  @override
  GeneratedColumn<double> get quantity =>
      _quantity ??= GeneratedColumn<double>('quantity', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _subTotalMeta = const VerificationMeta('subTotal');
  GeneratedColumn<double> _subTotal;
  @override
  GeneratedColumn<double> get subTotal =>
      _subTotal ??= GeneratedColumn<double>('sub_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _grandTotalMeta = const VerificationMeta('grandTotal');
  GeneratedColumn<double> _grandTotal;
  @override
  GeneratedColumn<double> get grandTotal =>
      _grandTotal ??= GeneratedColumn<double>('grand_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _fxGrandTotalMeta =
      const VerificationMeta('fxGrandTotal');
  GeneratedColumn<double> _fxGrandTotal;
  @override
  GeneratedColumn<double> get fxGrandTotal => _fxGrandTotal ??=
      GeneratedColumn<double>('fx_grand_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _itemCountMeta = const VerificationMeta('itemCount');
  GeneratedColumn<int> _itemCount;
  @override
  GeneratedColumn<int> get itemCount =>
      _itemCount ??= GeneratedColumn<int>('item_count', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _depositTotalMeta =
      const VerificationMeta('depositTotal');
  GeneratedColumn<double> _depositTotal;
  @override
  GeneratedColumn<double> get depositTotal => _depositTotal ??=
      GeneratedColumn<double>('deposit_total', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _lineIdMeta = const VerificationMeta('lineId');
  GeneratedColumn<int> _lineId;
  @override
  GeneratedColumn<int> get lineId =>
      _lineId ??= GeneratedColumn<int>('line_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _taxTotalMeta = const VerificationMeta('taxTotal');
  GeneratedColumn<double> _taxTotal;
  @override
  GeneratedColumn<double> get taxTotal =>
      _taxTotal ??= GeneratedColumn<double>('tax_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _shippingTotalMeta =
      const VerificationMeta('shippingTotal');
  GeneratedColumn<double> _shippingTotal;
  @override
  GeneratedColumn<double> get shippingTotal => _shippingTotal ??=
      GeneratedColumn<double>('shipping_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _conversionFactorMeta =
      const VerificationMeta('conversionFactor');
  GeneratedColumn<double> _conversionFactor;
  @override
  GeneratedColumn<double> get conversionFactor => _conversionFactor ??=
      GeneratedColumn<double>('conversion_factor', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        inventoryCycleNumber,
        daySessionNumber,
        deliveryDate,
        currency,
        exchangeRate,
        transactionStatus,
        itemId,
        itemCode,
        upcCode,
        description,
        itemGroup,
        category,
        salesUOM,
        stockUOM,
        taxGroup,
        warehouse,
        discountType,
        discountPercentage,
        discountAmount,
        lineDiscountTotal,
        taxIndicator,
        unitPrice,
        costPrice,
        listPrice,
        quantity,
        subTotal,
        grandTotal,
        fxGrandTotal,
        itemCount,
        depositTotal,
        lineId,
        taxTotal,
        shippingTotal,
        conversionFactor
      ];
  @override
  String get aliasedName => _alias ?? 'sales_order_detail';
  @override
  String get actualTableName => 'sales_order_detail';
  @override
  VerificationContext validateIntegrity(
      Insertable<SalesOrderDetailData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    } else if (isInserting) {
      context.missing(_userNameMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id'], _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('transaction_number')) {
      context.handle(
          _transactionNumberMeta,
          transactionNumber.isAcceptableOrUnknown(
              data['transaction_number'], _transactionNumberMeta));
    } else if (isInserting) {
      context.missing(_transactionNumberMeta);
    }
    if (data.containsKey('inventory_cycle_number')) {
      context.handle(
          _inventoryCycleNumberMeta,
          inventoryCycleNumber.isAcceptableOrUnknown(
              data['inventory_cycle_number'], _inventoryCycleNumberMeta));
    } else if (isInserting) {
      context.missing(_inventoryCycleNumberMeta);
    }
    if (data.containsKey('day_session_number')) {
      context.handle(
          _daySessionNumberMeta,
          daySessionNumber.isAcceptableOrUnknown(
              data['day_session_number'], _daySessionNumberMeta));
    } else if (isInserting) {
      context.missing(_daySessionNumberMeta);
    }
    if (data.containsKey('delivery_date')) {
      context.handle(
          _deliveryDateMeta,
          deliveryDate.isAcceptableOrUnknown(
              data['delivery_date'], _deliveryDateMeta));
    } else if (isInserting) {
      context.missing(_deliveryDateMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency'], _currencyMeta));
    } else if (isInserting) {
      context.missing(_currencyMeta);
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate'], _exchangeRateMeta));
    } else if (isInserting) {
      context.missing(_exchangeRateMeta);
    }
    if (data.containsKey('transaction_status')) {
      context.handle(
          _transactionStatusMeta,
          transactionStatus.isAcceptableOrUnknown(
              data['transaction_status'], _transactionStatusMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id'], _itemIdMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code'], _itemCodeMeta));
    } else if (isInserting) {
      context.missing(_itemCodeMeta);
    }
    if (data.containsKey('upc_code')) {
      context.handle(_upcCodeMeta,
          upcCode.isAcceptableOrUnknown(data['upc_code'], _upcCodeMeta));
    } else if (isInserting) {
      context.missing(_upcCodeMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description'], _descriptionMeta));
    } else if (isInserting) {
      context.missing(_descriptionMeta);
    }
    if (data.containsKey('item_group')) {
      context.handle(_itemGroupMeta,
          itemGroup.isAcceptableOrUnknown(data['item_group'], _itemGroupMeta));
    } else if (isInserting) {
      context.missing(_itemGroupMeta);
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category'], _categoryMeta));
    } else if (isInserting) {
      context.missing(_categoryMeta);
    }
    if (data.containsKey('sales_u_o_m')) {
      context.handle(_salesUOMMeta,
          salesUOM.isAcceptableOrUnknown(data['sales_u_o_m'], _salesUOMMeta));
    } else if (isInserting) {
      context.missing(_salesUOMMeta);
    }
    if (data.containsKey('stock_u_o_m')) {
      context.handle(_stockUOMMeta,
          stockUOM.isAcceptableOrUnknown(data['stock_u_o_m'], _stockUOMMeta));
    } else if (isInserting) {
      context.missing(_stockUOMMeta);
    }
    if (data.containsKey('tax_group')) {
      context.handle(_taxGroupMeta,
          taxGroup.isAcceptableOrUnknown(data['tax_group'], _taxGroupMeta));
    } else if (isInserting) {
      context.missing(_taxGroupMeta);
    }
    if (data.containsKey('warehouse')) {
      context.handle(_warehouseMeta,
          warehouse.isAcceptableOrUnknown(data['warehouse'], _warehouseMeta));
    } else if (isInserting) {
      context.missing(_warehouseMeta);
    }
    if (data.containsKey('discount_type')) {
      context.handle(
          _discountTypeMeta,
          discountType.isAcceptableOrUnknown(
              data['discount_type'], _discountTypeMeta));
    } else if (isInserting) {
      context.missing(_discountTypeMeta);
    }
    if (data.containsKey('discount_percentage')) {
      context.handle(
          _discountPercentageMeta,
          discountPercentage.isAcceptableOrUnknown(
              data['discount_percentage'], _discountPercentageMeta));
    } else if (isInserting) {
      context.missing(_discountPercentageMeta);
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
          _discountAmountMeta,
          discountAmount.isAcceptableOrUnknown(
              data['discount_amount'], _discountAmountMeta));
    } else if (isInserting) {
      context.missing(_discountAmountMeta);
    }
    if (data.containsKey('line_discount_total')) {
      context.handle(
          _lineDiscountTotalMeta,
          lineDiscountTotal.isAcceptableOrUnknown(
              data['line_discount_total'], _lineDiscountTotalMeta));
    } else if (isInserting) {
      context.missing(_lineDiscountTotalMeta);
    }
    if (data.containsKey('tax_indicator')) {
      context.handle(
          _taxIndicatorMeta,
          taxIndicator.isAcceptableOrUnknown(
              data['tax_indicator'], _taxIndicatorMeta));
    }
    if (data.containsKey('unit_price')) {
      context.handle(_unitPriceMeta,
          unitPrice.isAcceptableOrUnknown(data['unit_price'], _unitPriceMeta));
    } else if (isInserting) {
      context.missing(_unitPriceMeta);
    }
    if (data.containsKey('cost_price')) {
      context.handle(_costPriceMeta,
          costPrice.isAcceptableOrUnknown(data['cost_price'], _costPriceMeta));
    } else if (isInserting) {
      context.missing(_costPriceMeta);
    }
    if (data.containsKey('list_price')) {
      context.handle(_listPriceMeta,
          listPrice.isAcceptableOrUnknown(data['list_price'], _listPriceMeta));
    } else if (isInserting) {
      context.missing(_listPriceMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity'], _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('sub_total')) {
      context.handle(_subTotalMeta,
          subTotal.isAcceptableOrUnknown(data['sub_total'], _subTotalMeta));
    } else if (isInserting) {
      context.missing(_subTotalMeta);
    }
    if (data.containsKey('grand_total')) {
      context.handle(
          _grandTotalMeta,
          grandTotal.isAcceptableOrUnknown(
              data['grand_total'], _grandTotalMeta));
    } else if (isInserting) {
      context.missing(_grandTotalMeta);
    }
    if (data.containsKey('fx_grand_total')) {
      context.handle(
          _fxGrandTotalMeta,
          fxGrandTotal.isAcceptableOrUnknown(
              data['fx_grand_total'], _fxGrandTotalMeta));
    } else if (isInserting) {
      context.missing(_fxGrandTotalMeta);
    }
    if (data.containsKey('item_count')) {
      context.handle(_itemCountMeta,
          itemCount.isAcceptableOrUnknown(data['item_count'], _itemCountMeta));
    }
    if (data.containsKey('deposit_total')) {
      context.handle(
          _depositTotalMeta,
          depositTotal.isAcceptableOrUnknown(
              data['deposit_total'], _depositTotalMeta));
    }
    if (data.containsKey('line_id')) {
      context.handle(_lineIdMeta,
          lineId.isAcceptableOrUnknown(data['line_id'], _lineIdMeta));
    }
    if (data.containsKey('tax_total')) {
      context.handle(_taxTotalMeta,
          taxTotal.isAcceptableOrUnknown(data['tax_total'], _taxTotalMeta));
    } else if (isInserting) {
      context.missing(_taxTotalMeta);
    }
    if (data.containsKey('shipping_total')) {
      context.handle(
          _shippingTotalMeta,
          shippingTotal.isAcceptableOrUnknown(
              data['shipping_total'], _shippingTotalMeta));
    } else if (isInserting) {
      context.missing(_shippingTotalMeta);
    }
    if (data.containsKey('conversion_factor')) {
      context.handle(
          _conversionFactorMeta,
          conversionFactor.isAcceptableOrUnknown(
              data['conversion_factor'], _conversionFactorMeta));
    } else if (isInserting) {
      context.missing(_conversionFactorMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SalesOrderDetailData map(Map<String, dynamic> data, {String tablePrefix}) {
    return SalesOrderDetailData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $SalesOrderDetailTable createAlias(String alias) {
    return $SalesOrderDetailTable(_db, alias);
  }
}

class SalesOrderDetailTempData extends DataClass
    implements Insertable<SalesOrderDetailTempData> {
  final int tenantId;
  final String userName;
  final int userId;
  final int id;
  final String transactionNumber;
  final String inventoryCycleNumber;
  final String daySessionNumber;
  final DateTime deliveryDate;
  final String currency;
  final double exchangeRate;
  final String transactionStatus;
  final String itemId;
  final String itemCode;
  final String upcCode;
  final String description;
  final String itemGroup;
  final String category;
  final String salesUOM;
  final String stockUOM;
  final String taxGroup;
  final String warehouse;
  final String discountType;
  final double discountPercentage;
  final double discountAmount;
  final double lineDiscountTotal;
  final String taxIndicator;
  final double unitPrice;
  final double costPrice;
  final double listPrice;
  final double quantity;
  final double subTotal;
  final double grandTotal;
  final int itemCount;
  final double depositTotal;
  final int lineId;
  final double taxTotal;
  final double shippingTotal;
  final double conversionFactor;
  SalesOrderDetailTempData(
      {this.tenantId,
      @required this.userName,
      @required this.userId,
      @required this.id,
      @required this.transactionNumber,
      this.inventoryCycleNumber,
      this.daySessionNumber,
      this.deliveryDate,
      this.currency,
      this.exchangeRate,
      this.transactionStatus,
      this.itemId,
      @required this.itemCode,
      this.upcCode,
      @required this.description,
      this.itemGroup,
      this.category,
      this.salesUOM,
      this.stockUOM,
      this.taxGroup,
      this.warehouse,
      this.discountType,
      this.discountPercentage,
      this.discountAmount,
      this.lineDiscountTotal,
      this.taxIndicator,
      @required this.unitPrice,
      this.costPrice,
      this.listPrice,
      @required this.quantity,
      @required this.subTotal,
      @required this.grandTotal,
      this.itemCount,
      this.depositTotal,
      this.lineId,
      this.taxTotal,
      @required this.shippingTotal,
      this.conversionFactor});
  factory SalesOrderDetailTempData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return SalesOrderDetailTempData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      userId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      transactionNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}transaction_number']),
      inventoryCycleNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}inventory_cycle_number']),
      daySessionNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}day_session_number']),
      deliveryDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}delivery_date']),
      currency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}currency']),
      exchangeRate: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}exchange_rate']),
      transactionStatus: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}transaction_status']),
      itemId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_id']),
      itemCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_code']),
      upcCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}upc_code']),
      description: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}description']),
      itemGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_group']),
      category: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}category']),
      salesUOM: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sales_u_o_m']),
      stockUOM: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}stock_u_o_m']),
      taxGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_group']),
      warehouse: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}warehouse']),
      discountType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}discount_type']),
      discountPercentage: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}discount_percentage']),
      discountAmount: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}discount_amount']),
      lineDiscountTotal: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}line_discount_total']),
      taxIndicator: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_indicator']),
      unitPrice: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}unit_price']),
      costPrice: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}cost_price']),
      listPrice: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}list_price']),
      quantity: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}quantity']),
      subTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sub_total']),
      grandTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}grand_total']),
      itemCount: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_count']),
      depositTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}deposit_total']),
      lineId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}line_id']),
      taxTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_total']),
      shippingTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}shipping_total']),
      conversionFactor: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}conversion_factor']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<int>(userId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || transactionNumber != null) {
      map['transaction_number'] = Variable<String>(transactionNumber);
    }
    if (!nullToAbsent || inventoryCycleNumber != null) {
      map['inventory_cycle_number'] = Variable<String>(inventoryCycleNumber);
    }
    if (!nullToAbsent || daySessionNumber != null) {
      map['day_session_number'] = Variable<String>(daySessionNumber);
    }
    if (!nullToAbsent || deliveryDate != null) {
      map['delivery_date'] = Variable<DateTime>(deliveryDate);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    if (!nullToAbsent || exchangeRate != null) {
      map['exchange_rate'] = Variable<double>(exchangeRate);
    }
    if (!nullToAbsent || transactionStatus != null) {
      map['transaction_status'] = Variable<String>(transactionStatus);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || upcCode != null) {
      map['upc_code'] = Variable<String>(upcCode);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || itemGroup != null) {
      map['item_group'] = Variable<String>(itemGroup);
    }
    if (!nullToAbsent || category != null) {
      map['category'] = Variable<String>(category);
    }
    if (!nullToAbsent || salesUOM != null) {
      map['sales_u_o_m'] = Variable<String>(salesUOM);
    }
    if (!nullToAbsent || stockUOM != null) {
      map['stock_u_o_m'] = Variable<String>(stockUOM);
    }
    if (!nullToAbsent || taxGroup != null) {
      map['tax_group'] = Variable<String>(taxGroup);
    }
    if (!nullToAbsent || warehouse != null) {
      map['warehouse'] = Variable<String>(warehouse);
    }
    if (!nullToAbsent || discountType != null) {
      map['discount_type'] = Variable<String>(discountType);
    }
    if (!nullToAbsent || discountPercentage != null) {
      map['discount_percentage'] = Variable<double>(discountPercentage);
    }
    if (!nullToAbsent || discountAmount != null) {
      map['discount_amount'] = Variable<double>(discountAmount);
    }
    if (!nullToAbsent || lineDiscountTotal != null) {
      map['line_discount_total'] = Variable<double>(lineDiscountTotal);
    }
    if (!nullToAbsent || taxIndicator != null) {
      map['tax_indicator'] = Variable<String>(taxIndicator);
    }
    if (!nullToAbsent || unitPrice != null) {
      map['unit_price'] = Variable<double>(unitPrice);
    }
    if (!nullToAbsent || costPrice != null) {
      map['cost_price'] = Variable<double>(costPrice);
    }
    if (!nullToAbsent || listPrice != null) {
      map['list_price'] = Variable<double>(listPrice);
    }
    if (!nullToAbsent || quantity != null) {
      map['quantity'] = Variable<double>(quantity);
    }
    if (!nullToAbsent || subTotal != null) {
      map['sub_total'] = Variable<double>(subTotal);
    }
    if (!nullToAbsent || grandTotal != null) {
      map['grand_total'] = Variable<double>(grandTotal);
    }
    if (!nullToAbsent || itemCount != null) {
      map['item_count'] = Variable<int>(itemCount);
    }
    if (!nullToAbsent || depositTotal != null) {
      map['deposit_total'] = Variable<double>(depositTotal);
    }
    if (!nullToAbsent || lineId != null) {
      map['line_id'] = Variable<int>(lineId);
    }
    if (!nullToAbsent || taxTotal != null) {
      map['tax_total'] = Variable<double>(taxTotal);
    }
    if (!nullToAbsent || shippingTotal != null) {
      map['shipping_total'] = Variable<double>(shippingTotal);
    }
    if (!nullToAbsent || conversionFactor != null) {
      map['conversion_factor'] = Variable<double>(conversionFactor);
    }
    return map;
  }

  SalesOrderDetailTempCompanion toCompanion(bool nullToAbsent) {
    return SalesOrderDetailTempCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      userId:
          userId == null && nullToAbsent ? const Value.absent() : Value(userId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      transactionNumber: transactionNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionNumber),
      inventoryCycleNumber: inventoryCycleNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(inventoryCycleNumber),
      daySessionNumber: daySessionNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(daySessionNumber),
      deliveryDate: deliveryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(deliveryDate),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      exchangeRate: exchangeRate == null && nullToAbsent
          ? const Value.absent()
          : Value(exchangeRate),
      transactionStatus: transactionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionStatus),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      upcCode: upcCode == null && nullToAbsent
          ? const Value.absent()
          : Value(upcCode),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      itemGroup: itemGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(itemGroup),
      category: category == null && nullToAbsent
          ? const Value.absent()
          : Value(category),
      salesUOM: salesUOM == null && nullToAbsent
          ? const Value.absent()
          : Value(salesUOM),
      stockUOM: stockUOM == null && nullToAbsent
          ? const Value.absent()
          : Value(stockUOM),
      taxGroup: taxGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(taxGroup),
      warehouse: warehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(warehouse),
      discountType: discountType == null && nullToAbsent
          ? const Value.absent()
          : Value(discountType),
      discountPercentage: discountPercentage == null && nullToAbsent
          ? const Value.absent()
          : Value(discountPercentage),
      discountAmount: discountAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(discountAmount),
      lineDiscountTotal: lineDiscountTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(lineDiscountTotal),
      taxIndicator: taxIndicator == null && nullToAbsent
          ? const Value.absent()
          : Value(taxIndicator),
      unitPrice: unitPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(unitPrice),
      costPrice: costPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(costPrice),
      listPrice: listPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(listPrice),
      quantity: quantity == null && nullToAbsent
          ? const Value.absent()
          : Value(quantity),
      subTotal: subTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(subTotal),
      grandTotal: grandTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(grandTotal),
      itemCount: itemCount == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCount),
      depositTotal: depositTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(depositTotal),
      lineId:
          lineId == null && nullToAbsent ? const Value.absent() : Value(lineId),
      taxTotal: taxTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(taxTotal),
      shippingTotal: shippingTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(shippingTotal),
      conversionFactor: conversionFactor == null && nullToAbsent
          ? const Value.absent()
          : Value(conversionFactor),
    );
  }

  factory SalesOrderDetailTempData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesOrderDetailTempData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      userName: serializer.fromJson<String>(json['userName']),
      userId: serializer.fromJson<int>(json['userId']),
      id: serializer.fromJson<int>(json['id']),
      transactionNumber: serializer.fromJson<String>(json['transactionNumber']),
      inventoryCycleNumber:
          serializer.fromJson<String>(json['inventoryCycleNumber']),
      daySessionNumber: serializer.fromJson<String>(json['daySessionNumber']),
      deliveryDate: serializer.fromJson<DateTime>(json['deliveryDate']),
      currency: serializer.fromJson<String>(json['currency']),
      exchangeRate: serializer.fromJson<double>(json['exchangeRate']),
      transactionStatus: serializer.fromJson<String>(json['transactionStatus']),
      itemId: serializer.fromJson<String>(json['itemId']),
      itemCode: serializer.fromJson<String>(json['itemCode']),
      upcCode: serializer.fromJson<String>(json['upcCode']),
      description: serializer.fromJson<String>(json['description']),
      itemGroup: serializer.fromJson<String>(json['itemGroup']),
      category: serializer.fromJson<String>(json['category']),
      salesUOM: serializer.fromJson<String>(json['salesUOM']),
      stockUOM: serializer.fromJson<String>(json['stockUOM']),
      taxGroup: serializer.fromJson<String>(json['taxGroup']),
      warehouse: serializer.fromJson<String>(json['warehouse']),
      discountType: serializer.fromJson<String>(json['discountType']),
      discountPercentage:
          serializer.fromJson<double>(json['discountPercentage']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      lineDiscountTotal: serializer.fromJson<double>(json['lineDiscountTotal']),
      taxIndicator: serializer.fromJson<String>(json['taxIndicator']),
      unitPrice: serializer.fromJson<double>(json['unitPrice']),
      costPrice: serializer.fromJson<double>(json['costPrice']),
      listPrice: serializer.fromJson<double>(json['listPrice']),
      quantity: serializer.fromJson<double>(json['quantity']),
      subTotal: serializer.fromJson<double>(json['subTotal']),
      grandTotal: serializer.fromJson<double>(json['grandTotal']),
      itemCount: serializer.fromJson<int>(json['itemCount']),
      depositTotal: serializer.fromJson<double>(json['depositTotal']),
      lineId: serializer.fromJson<int>(json['lineId']),
      taxTotal: serializer.fromJson<double>(json['taxTotal']),
      shippingTotal: serializer.fromJson<double>(json['shippingTotal']),
      conversionFactor: serializer.fromJson<double>(json['conversionFactor']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'userName': serializer.toJson<String>(userName),
      'userId': serializer.toJson<int>(userId),
      'id': serializer.toJson<int>(id),
      'transactionNumber': serializer.toJson<String>(transactionNumber),
      'inventoryCycleNumber': serializer.toJson<String>(inventoryCycleNumber),
      'daySessionNumber': serializer.toJson<String>(daySessionNumber),
      'deliveryDate': serializer.toJson<DateTime>(deliveryDate),
      'currency': serializer.toJson<String>(currency),
      'exchangeRate': serializer.toJson<double>(exchangeRate),
      'transactionStatus': serializer.toJson<String>(transactionStatus),
      'itemId': serializer.toJson<String>(itemId),
      'itemCode': serializer.toJson<String>(itemCode),
      'upcCode': serializer.toJson<String>(upcCode),
      'description': serializer.toJson<String>(description),
      'itemGroup': serializer.toJson<String>(itemGroup),
      'category': serializer.toJson<String>(category),
      'salesUOM': serializer.toJson<String>(salesUOM),
      'stockUOM': serializer.toJson<String>(stockUOM),
      'taxGroup': serializer.toJson<String>(taxGroup),
      'warehouse': serializer.toJson<String>(warehouse),
      'discountType': serializer.toJson<String>(discountType),
      'discountPercentage': serializer.toJson<double>(discountPercentage),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'lineDiscountTotal': serializer.toJson<double>(lineDiscountTotal),
      'taxIndicator': serializer.toJson<String>(taxIndicator),
      'unitPrice': serializer.toJson<double>(unitPrice),
      'costPrice': serializer.toJson<double>(costPrice),
      'listPrice': serializer.toJson<double>(listPrice),
      'quantity': serializer.toJson<double>(quantity),
      'subTotal': serializer.toJson<double>(subTotal),
      'grandTotal': serializer.toJson<double>(grandTotal),
      'itemCount': serializer.toJson<int>(itemCount),
      'depositTotal': serializer.toJson<double>(depositTotal),
      'lineId': serializer.toJson<int>(lineId),
      'taxTotal': serializer.toJson<double>(taxTotal),
      'shippingTotal': serializer.toJson<double>(shippingTotal),
      'conversionFactor': serializer.toJson<double>(conversionFactor),
    };
  }

  SalesOrderDetailTempData copyWith(
          {int tenantId,
          String userName,
          int userId,
          int id,
          String transactionNumber,
          String inventoryCycleNumber,
          String daySessionNumber,
          DateTime deliveryDate,
          String currency,
          double exchangeRate,
          String transactionStatus,
          String itemId,
          String itemCode,
          String upcCode,
          String description,
          String itemGroup,
          String category,
          String salesUOM,
          String stockUOM,
          String taxGroup,
          String warehouse,
          String discountType,
          double discountPercentage,
          double discountAmount,
          double lineDiscountTotal,
          String taxIndicator,
          double unitPrice,
          double costPrice,
          double listPrice,
          double quantity,
          double subTotal,
          double grandTotal,
          int itemCount,
          double depositTotal,
          int lineId,
          double taxTotal,
          double shippingTotal,
          double conversionFactor}) =>
      SalesOrderDetailTempData(
        tenantId: tenantId ?? this.tenantId,
        userName: userName ?? this.userName,
        userId: userId ?? this.userId,
        id: id ?? this.id,
        transactionNumber: transactionNumber ?? this.transactionNumber,
        inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
        daySessionNumber: daySessionNumber ?? this.daySessionNumber,
        deliveryDate: deliveryDate ?? this.deliveryDate,
        currency: currency ?? this.currency,
        exchangeRate: exchangeRate ?? this.exchangeRate,
        transactionStatus: transactionStatus ?? this.transactionStatus,
        itemId: itemId ?? this.itemId,
        itemCode: itemCode ?? this.itemCode,
        upcCode: upcCode ?? this.upcCode,
        description: description ?? this.description,
        itemGroup: itemGroup ?? this.itemGroup,
        category: category ?? this.category,
        salesUOM: salesUOM ?? this.salesUOM,
        stockUOM: stockUOM ?? this.stockUOM,
        taxGroup: taxGroup ?? this.taxGroup,
        warehouse: warehouse ?? this.warehouse,
        discountType: discountType ?? this.discountType,
        discountPercentage: discountPercentage ?? this.discountPercentage,
        discountAmount: discountAmount ?? this.discountAmount,
        lineDiscountTotal: lineDiscountTotal ?? this.lineDiscountTotal,
        taxIndicator: taxIndicator ?? this.taxIndicator,
        unitPrice: unitPrice ?? this.unitPrice,
        costPrice: costPrice ?? this.costPrice,
        listPrice: listPrice ?? this.listPrice,
        quantity: quantity ?? this.quantity,
        subTotal: subTotal ?? this.subTotal,
        grandTotal: grandTotal ?? this.grandTotal,
        itemCount: itemCount ?? this.itemCount,
        depositTotal: depositTotal ?? this.depositTotal,
        lineId: lineId ?? this.lineId,
        taxTotal: taxTotal ?? this.taxTotal,
        shippingTotal: shippingTotal ?? this.shippingTotal,
        conversionFactor: conversionFactor ?? this.conversionFactor,
      );
  @override
  String toString() {
    return (StringBuffer('SalesOrderDetailTempData(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('upcCode: $upcCode, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('salesUOM: $salesUOM, ')
          ..write('stockUOM: $stockUOM, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('warehouse: $warehouse, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('lineDiscountTotal: $lineDiscountTotal, ')
          ..write('taxIndicator: $taxIndicator, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('costPrice: $costPrice, ')
          ..write('listPrice: $listPrice, ')
          ..write('quantity: $quantity, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('lineId: $lineId, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('conversionFactor: $conversionFactor')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        inventoryCycleNumber,
        daySessionNumber,
        deliveryDate,
        currency,
        exchangeRate,
        transactionStatus,
        itemId,
        itemCode,
        upcCode,
        description,
        itemGroup,
        category,
        salesUOM,
        stockUOM,
        taxGroup,
        warehouse,
        discountType,
        discountPercentage,
        discountAmount,
        lineDiscountTotal,
        taxIndicator,
        unitPrice,
        costPrice,
        listPrice,
        quantity,
        subTotal,
        grandTotal,
        itemCount,
        depositTotal,
        lineId,
        taxTotal,
        shippingTotal,
        conversionFactor
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesOrderDetailTempData &&
          other.tenantId == this.tenantId &&
          other.userName == this.userName &&
          other.userId == this.userId &&
          other.id == this.id &&
          other.transactionNumber == this.transactionNumber &&
          other.inventoryCycleNumber == this.inventoryCycleNumber &&
          other.daySessionNumber == this.daySessionNumber &&
          other.deliveryDate == this.deliveryDate &&
          other.currency == this.currency &&
          other.exchangeRate == this.exchangeRate &&
          other.transactionStatus == this.transactionStatus &&
          other.itemId == this.itemId &&
          other.itemCode == this.itemCode &&
          other.upcCode == this.upcCode &&
          other.description == this.description &&
          other.itemGroup == this.itemGroup &&
          other.category == this.category &&
          other.salesUOM == this.salesUOM &&
          other.stockUOM == this.stockUOM &&
          other.taxGroup == this.taxGroup &&
          other.warehouse == this.warehouse &&
          other.discountType == this.discountType &&
          other.discountPercentage == this.discountPercentage &&
          other.discountAmount == this.discountAmount &&
          other.lineDiscountTotal == this.lineDiscountTotal &&
          other.taxIndicator == this.taxIndicator &&
          other.unitPrice == this.unitPrice &&
          other.costPrice == this.costPrice &&
          other.listPrice == this.listPrice &&
          other.quantity == this.quantity &&
          other.subTotal == this.subTotal &&
          other.grandTotal == this.grandTotal &&
          other.itemCount == this.itemCount &&
          other.depositTotal == this.depositTotal &&
          other.lineId == this.lineId &&
          other.taxTotal == this.taxTotal &&
          other.shippingTotal == this.shippingTotal &&
          other.conversionFactor == this.conversionFactor);
}

class SalesOrderDetailTempCompanion
    extends UpdateCompanion<SalesOrderDetailTempData> {
  final Value<int> tenantId;
  final Value<String> userName;
  final Value<int> userId;
  final Value<int> id;
  final Value<String> transactionNumber;
  final Value<String> inventoryCycleNumber;
  final Value<String> daySessionNumber;
  final Value<DateTime> deliveryDate;
  final Value<String> currency;
  final Value<double> exchangeRate;
  final Value<String> transactionStatus;
  final Value<String> itemId;
  final Value<String> itemCode;
  final Value<String> upcCode;
  final Value<String> description;
  final Value<String> itemGroup;
  final Value<String> category;
  final Value<String> salesUOM;
  final Value<String> stockUOM;
  final Value<String> taxGroup;
  final Value<String> warehouse;
  final Value<String> discountType;
  final Value<double> discountPercentage;
  final Value<double> discountAmount;
  final Value<double> lineDiscountTotal;
  final Value<String> taxIndicator;
  final Value<double> unitPrice;
  final Value<double> costPrice;
  final Value<double> listPrice;
  final Value<double> quantity;
  final Value<double> subTotal;
  final Value<double> grandTotal;
  final Value<int> itemCount;
  final Value<double> depositTotal;
  final Value<int> lineId;
  final Value<double> taxTotal;
  final Value<double> shippingTotal;
  final Value<double> conversionFactor;
  const SalesOrderDetailTempCompanion({
    this.tenantId = const Value.absent(),
    this.userName = const Value.absent(),
    this.userId = const Value.absent(),
    this.id = const Value.absent(),
    this.transactionNumber = const Value.absent(),
    this.inventoryCycleNumber = const Value.absent(),
    this.daySessionNumber = const Value.absent(),
    this.deliveryDate = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.itemId = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.upcCode = const Value.absent(),
    this.description = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.category = const Value.absent(),
    this.salesUOM = const Value.absent(),
    this.stockUOM = const Value.absent(),
    this.taxGroup = const Value.absent(),
    this.warehouse = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.lineDiscountTotal = const Value.absent(),
    this.taxIndicator = const Value.absent(),
    this.unitPrice = const Value.absent(),
    this.costPrice = const Value.absent(),
    this.listPrice = const Value.absent(),
    this.quantity = const Value.absent(),
    this.subTotal = const Value.absent(),
    this.grandTotal = const Value.absent(),
    this.itemCount = const Value.absent(),
    this.depositTotal = const Value.absent(),
    this.lineId = const Value.absent(),
    this.taxTotal = const Value.absent(),
    this.shippingTotal = const Value.absent(),
    this.conversionFactor = const Value.absent(),
  });
  SalesOrderDetailTempCompanion.insert({
    this.tenantId = const Value.absent(),
    @required String userName,
    @required int userId,
    this.id = const Value.absent(),
    @required String transactionNumber,
    this.inventoryCycleNumber = const Value.absent(),
    this.daySessionNumber = const Value.absent(),
    this.deliveryDate = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.itemId = const Value.absent(),
    @required String itemCode,
    this.upcCode = const Value.absent(),
    @required String description,
    this.itemGroup = const Value.absent(),
    this.category = const Value.absent(),
    this.salesUOM = const Value.absent(),
    this.stockUOM = const Value.absent(),
    this.taxGroup = const Value.absent(),
    this.warehouse = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.lineDiscountTotal = const Value.absent(),
    this.taxIndicator = const Value.absent(),
    @required double unitPrice,
    this.costPrice = const Value.absent(),
    this.listPrice = const Value.absent(),
    @required double quantity,
    @required double subTotal,
    @required double grandTotal,
    this.itemCount = const Value.absent(),
    this.depositTotal = const Value.absent(),
    this.lineId = const Value.absent(),
    this.taxTotal = const Value.absent(),
    @required double shippingTotal,
    this.conversionFactor = const Value.absent(),
  })  : userName = Value(userName),
        userId = Value(userId),
        transactionNumber = Value(transactionNumber),
        itemCode = Value(itemCode),
        description = Value(description),
        unitPrice = Value(unitPrice),
        quantity = Value(quantity),
        subTotal = Value(subTotal),
        grandTotal = Value(grandTotal),
        shippingTotal = Value(shippingTotal);
  static Insertable<SalesOrderDetailTempData> custom({
    Expression<int> tenantId,
    Expression<String> userName,
    Expression<int> userId,
    Expression<int> id,
    Expression<String> transactionNumber,
    Expression<String> inventoryCycleNumber,
    Expression<String> daySessionNumber,
    Expression<DateTime> deliveryDate,
    Expression<String> currency,
    Expression<double> exchangeRate,
    Expression<String> transactionStatus,
    Expression<String> itemId,
    Expression<String> itemCode,
    Expression<String> upcCode,
    Expression<String> description,
    Expression<String> itemGroup,
    Expression<String> category,
    Expression<String> salesUOM,
    Expression<String> stockUOM,
    Expression<String> taxGroup,
    Expression<String> warehouse,
    Expression<String> discountType,
    Expression<double> discountPercentage,
    Expression<double> discountAmount,
    Expression<double> lineDiscountTotal,
    Expression<String> taxIndicator,
    Expression<double> unitPrice,
    Expression<double> costPrice,
    Expression<double> listPrice,
    Expression<double> quantity,
    Expression<double> subTotal,
    Expression<double> grandTotal,
    Expression<int> itemCount,
    Expression<double> depositTotal,
    Expression<int> lineId,
    Expression<double> taxTotal,
    Expression<double> shippingTotal,
    Expression<double> conversionFactor,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (userName != null) 'user_name': userName,
      if (userId != null) 'user_id': userId,
      if (id != null) 'id': id,
      if (transactionNumber != null) 'transaction_number': transactionNumber,
      if (inventoryCycleNumber != null)
        'inventory_cycle_number': inventoryCycleNumber,
      if (daySessionNumber != null) 'day_session_number': daySessionNumber,
      if (deliveryDate != null) 'delivery_date': deliveryDate,
      if (currency != null) 'currency': currency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (transactionStatus != null) 'transaction_status': transactionStatus,
      if (itemId != null) 'item_id': itemId,
      if (itemCode != null) 'item_code': itemCode,
      if (upcCode != null) 'upc_code': upcCode,
      if (description != null) 'description': description,
      if (itemGroup != null) 'item_group': itemGroup,
      if (category != null) 'category': category,
      if (salesUOM != null) 'sales_u_o_m': salesUOM,
      if (stockUOM != null) 'stock_u_o_m': stockUOM,
      if (taxGroup != null) 'tax_group': taxGroup,
      if (warehouse != null) 'warehouse': warehouse,
      if (discountType != null) 'discount_type': discountType,
      if (discountPercentage != null) 'discount_percentage': discountPercentage,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (lineDiscountTotal != null) 'line_discount_total': lineDiscountTotal,
      if (taxIndicator != null) 'tax_indicator': taxIndicator,
      if (unitPrice != null) 'unit_price': unitPrice,
      if (costPrice != null) 'cost_price': costPrice,
      if (listPrice != null) 'list_price': listPrice,
      if (quantity != null) 'quantity': quantity,
      if (subTotal != null) 'sub_total': subTotal,
      if (grandTotal != null) 'grand_total': grandTotal,
      if (itemCount != null) 'item_count': itemCount,
      if (depositTotal != null) 'deposit_total': depositTotal,
      if (lineId != null) 'line_id': lineId,
      if (taxTotal != null) 'tax_total': taxTotal,
      if (shippingTotal != null) 'shipping_total': shippingTotal,
      if (conversionFactor != null) 'conversion_factor': conversionFactor,
    });
  }

  SalesOrderDetailTempCompanion copyWith(
      {Value<int> tenantId,
      Value<String> userName,
      Value<int> userId,
      Value<int> id,
      Value<String> transactionNumber,
      Value<String> inventoryCycleNumber,
      Value<String> daySessionNumber,
      Value<DateTime> deliveryDate,
      Value<String> currency,
      Value<double> exchangeRate,
      Value<String> transactionStatus,
      Value<String> itemId,
      Value<String> itemCode,
      Value<String> upcCode,
      Value<String> description,
      Value<String> itemGroup,
      Value<String> category,
      Value<String> salesUOM,
      Value<String> stockUOM,
      Value<String> taxGroup,
      Value<String> warehouse,
      Value<String> discountType,
      Value<double> discountPercentage,
      Value<double> discountAmount,
      Value<double> lineDiscountTotal,
      Value<String> taxIndicator,
      Value<double> unitPrice,
      Value<double> costPrice,
      Value<double> listPrice,
      Value<double> quantity,
      Value<double> subTotal,
      Value<double> grandTotal,
      Value<int> itemCount,
      Value<double> depositTotal,
      Value<int> lineId,
      Value<double> taxTotal,
      Value<double> shippingTotal,
      Value<double> conversionFactor}) {
    return SalesOrderDetailTempCompanion(
      tenantId: tenantId ?? this.tenantId,
      userName: userName ?? this.userName,
      userId: userId ?? this.userId,
      id: id ?? this.id,
      transactionNumber: transactionNumber ?? this.transactionNumber,
      inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
      daySessionNumber: daySessionNumber ?? this.daySessionNumber,
      deliveryDate: deliveryDate ?? this.deliveryDate,
      currency: currency ?? this.currency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      transactionStatus: transactionStatus ?? this.transactionStatus,
      itemId: itemId ?? this.itemId,
      itemCode: itemCode ?? this.itemCode,
      upcCode: upcCode ?? this.upcCode,
      description: description ?? this.description,
      itemGroup: itemGroup ?? this.itemGroup,
      category: category ?? this.category,
      salesUOM: salesUOM ?? this.salesUOM,
      stockUOM: stockUOM ?? this.stockUOM,
      taxGroup: taxGroup ?? this.taxGroup,
      warehouse: warehouse ?? this.warehouse,
      discountType: discountType ?? this.discountType,
      discountPercentage: discountPercentage ?? this.discountPercentage,
      discountAmount: discountAmount ?? this.discountAmount,
      lineDiscountTotal: lineDiscountTotal ?? this.lineDiscountTotal,
      taxIndicator: taxIndicator ?? this.taxIndicator,
      unitPrice: unitPrice ?? this.unitPrice,
      costPrice: costPrice ?? this.costPrice,
      listPrice: listPrice ?? this.listPrice,
      quantity: quantity ?? this.quantity,
      subTotal: subTotal ?? this.subTotal,
      grandTotal: grandTotal ?? this.grandTotal,
      itemCount: itemCount ?? this.itemCount,
      depositTotal: depositTotal ?? this.depositTotal,
      lineId: lineId ?? this.lineId,
      taxTotal: taxTotal ?? this.taxTotal,
      shippingTotal: shippingTotal ?? this.shippingTotal,
      conversionFactor: conversionFactor ?? this.conversionFactor,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (transactionNumber.present) {
      map['transaction_number'] = Variable<String>(transactionNumber.value);
    }
    if (inventoryCycleNumber.present) {
      map['inventory_cycle_number'] =
          Variable<String>(inventoryCycleNumber.value);
    }
    if (daySessionNumber.present) {
      map['day_session_number'] = Variable<String>(daySessionNumber.value);
    }
    if (deliveryDate.present) {
      map['delivery_date'] = Variable<DateTime>(deliveryDate.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (transactionStatus.present) {
      map['transaction_status'] = Variable<String>(transactionStatus.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (upcCode.present) {
      map['upc_code'] = Variable<String>(upcCode.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (itemGroup.present) {
      map['item_group'] = Variable<String>(itemGroup.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (salesUOM.present) {
      map['sales_u_o_m'] = Variable<String>(salesUOM.value);
    }
    if (stockUOM.present) {
      map['stock_u_o_m'] = Variable<String>(stockUOM.value);
    }
    if (taxGroup.present) {
      map['tax_group'] = Variable<String>(taxGroup.value);
    }
    if (warehouse.present) {
      map['warehouse'] = Variable<String>(warehouse.value);
    }
    if (discountType.present) {
      map['discount_type'] = Variable<String>(discountType.value);
    }
    if (discountPercentage.present) {
      map['discount_percentage'] = Variable<double>(discountPercentage.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (lineDiscountTotal.present) {
      map['line_discount_total'] = Variable<double>(lineDiscountTotal.value);
    }
    if (taxIndicator.present) {
      map['tax_indicator'] = Variable<String>(taxIndicator.value);
    }
    if (unitPrice.present) {
      map['unit_price'] = Variable<double>(unitPrice.value);
    }
    if (costPrice.present) {
      map['cost_price'] = Variable<double>(costPrice.value);
    }
    if (listPrice.present) {
      map['list_price'] = Variable<double>(listPrice.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (subTotal.present) {
      map['sub_total'] = Variable<double>(subTotal.value);
    }
    if (grandTotal.present) {
      map['grand_total'] = Variable<double>(grandTotal.value);
    }
    if (itemCount.present) {
      map['item_count'] = Variable<int>(itemCount.value);
    }
    if (depositTotal.present) {
      map['deposit_total'] = Variable<double>(depositTotal.value);
    }
    if (lineId.present) {
      map['line_id'] = Variable<int>(lineId.value);
    }
    if (taxTotal.present) {
      map['tax_total'] = Variable<double>(taxTotal.value);
    }
    if (shippingTotal.present) {
      map['shipping_total'] = Variable<double>(shippingTotal.value);
    }
    if (conversionFactor.present) {
      map['conversion_factor'] = Variable<double>(conversionFactor.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesOrderDetailTempCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('userName: $userName, ')
          ..write('userId: $userId, ')
          ..write('id: $id, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber, ')
          ..write('daySessionNumber: $daySessionNumber, ')
          ..write('deliveryDate: $deliveryDate, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('upcCode: $upcCode, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('salesUOM: $salesUOM, ')
          ..write('stockUOM: $stockUOM, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('warehouse: $warehouse, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('lineDiscountTotal: $lineDiscountTotal, ')
          ..write('taxIndicator: $taxIndicator, ')
          ..write('unitPrice: $unitPrice, ')
          ..write('costPrice: $costPrice, ')
          ..write('listPrice: $listPrice, ')
          ..write('quantity: $quantity, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal, ')
          ..write('itemCount: $itemCount, ')
          ..write('depositTotal: $depositTotal, ')
          ..write('lineId: $lineId, ')
          ..write('taxTotal: $taxTotal, ')
          ..write('shippingTotal: $shippingTotal, ')
          ..write('conversionFactor: $conversionFactor')
          ..write(')'))
        .toString();
  }
}

class $SalesOrderDetailTempTable extends SalesOrderDetailTemp
    with TableInfo<$SalesOrderDetailTempTable, SalesOrderDetailTempData> {
  final GeneratedDatabase _db;
  final String _alias;
  $SalesOrderDetailTempTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _userIdMeta = const VerificationMeta('userId');
  GeneratedColumn<int> _userId;
  @override
  GeneratedColumn<int> get userId =>
      _userId ??= GeneratedColumn<int>('user_id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(),
          requiredDuringInsert: false,
          defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
  final VerificationMeta _transactionNumberMeta =
      const VerificationMeta('transactionNumber');
  GeneratedColumn<String> _transactionNumber;
  @override
  GeneratedColumn<String> get transactionNumber => _transactionNumber ??=
      GeneratedColumn<String>('transaction_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _inventoryCycleNumberMeta =
      const VerificationMeta('inventoryCycleNumber');
  GeneratedColumn<String> _inventoryCycleNumber;
  @override
  GeneratedColumn<String> get inventoryCycleNumber => _inventoryCycleNumber ??=
      GeneratedColumn<String>('inventory_cycle_number', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _daySessionNumberMeta =
      const VerificationMeta('daySessionNumber');
  GeneratedColumn<String> _daySessionNumber;
  @override
  GeneratedColumn<String> get daySessionNumber => _daySessionNumber ??=
      GeneratedColumn<String>('day_session_number', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deliveryDateMeta =
      const VerificationMeta('deliveryDate');
  GeneratedColumn<DateTime> _deliveryDate;
  @override
  GeneratedColumn<DateTime> get deliveryDate => _deliveryDate ??=
      GeneratedColumn<DateTime>('delivery_date', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _currencyMeta = const VerificationMeta('currency');
  GeneratedColumn<String> _currency;
  @override
  GeneratedColumn<String> get currency =>
      _currency ??= GeneratedColumn<String>('currency', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  GeneratedColumn<double> _exchangeRate;
  @override
  GeneratedColumn<double> get exchangeRate => _exchangeRate ??=
      GeneratedColumn<double>('exchange_rate', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _transactionStatusMeta =
      const VerificationMeta('transactionStatus');
  GeneratedColumn<String> _transactionStatus;
  @override
  GeneratedColumn<String> get transactionStatus => _transactionStatus ??=
      GeneratedColumn<String>('transaction_status', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  GeneratedColumn<String> _itemId;
  @override
  GeneratedColumn<String> get itemId =>
      _itemId ??= GeneratedColumn<String>('item_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemCodeMeta = const VerificationMeta('itemCode');
  GeneratedColumn<String> _itemCode;
  @override
  GeneratedColumn<String> get itemCode =>
      _itemCode ??= GeneratedColumn<String>('item_code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _upcCodeMeta = const VerificationMeta('upcCode');
  GeneratedColumn<String> _upcCode;
  @override
  GeneratedColumn<String> get upcCode =>
      _upcCode ??= GeneratedColumn<String>('upc_code', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  GeneratedColumn<String> _description;
  @override
  GeneratedColumn<String> get description => _description ??=
      GeneratedColumn<String>('description', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _itemGroupMeta = const VerificationMeta('itemGroup');
  GeneratedColumn<String> _itemGroup;
  @override
  GeneratedColumn<String> get itemGroup =>
      _itemGroup ??= GeneratedColumn<String>('item_group', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _categoryMeta = const VerificationMeta('category');
  GeneratedColumn<String> _category;
  @override
  GeneratedColumn<String> get category =>
      _category ??= GeneratedColumn<String>('category', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _salesUOMMeta = const VerificationMeta('salesUOM');
  GeneratedColumn<String> _salesUOM;
  @override
  GeneratedColumn<String> get salesUOM =>
      _salesUOM ??= GeneratedColumn<String>('sales_u_o_m', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _stockUOMMeta = const VerificationMeta('stockUOM');
  GeneratedColumn<String> _stockUOM;
  @override
  GeneratedColumn<String> get stockUOM =>
      _stockUOM ??= GeneratedColumn<String>('stock_u_o_m', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _taxGroupMeta = const VerificationMeta('taxGroup');
  GeneratedColumn<String> _taxGroup;
  @override
  GeneratedColumn<String> get taxGroup =>
      _taxGroup ??= GeneratedColumn<String>('tax_group', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _warehouseMeta = const VerificationMeta('warehouse');
  GeneratedColumn<String> _warehouse;
  @override
  GeneratedColumn<String> get warehouse =>
      _warehouse ??= GeneratedColumn<String>('warehouse', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _discountTypeMeta =
      const VerificationMeta('discountType');
  GeneratedColumn<String> _discountType;
  @override
  GeneratedColumn<String> get discountType => _discountType ??=
      GeneratedColumn<String>('discount_type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _discountPercentageMeta =
      const VerificationMeta('discountPercentage');
  GeneratedColumn<double> _discountPercentage;
  @override
  GeneratedColumn<double> get discountPercentage => _discountPercentage ??=
      GeneratedColumn<double>('discount_percentage', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _discountAmountMeta =
      const VerificationMeta('discountAmount');
  GeneratedColumn<double> _discountAmount;
  @override
  GeneratedColumn<double> get discountAmount => _discountAmount ??=
      GeneratedColumn<double>('discount_amount', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _lineDiscountTotalMeta =
      const VerificationMeta('lineDiscountTotal');
  GeneratedColumn<double> _lineDiscountTotal;
  @override
  GeneratedColumn<double> get lineDiscountTotal => _lineDiscountTotal ??=
      GeneratedColumn<double>('line_discount_total', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _taxIndicatorMeta =
      const VerificationMeta('taxIndicator');
  GeneratedColumn<String> _taxIndicator;
  @override
  GeneratedColumn<String> get taxIndicator => _taxIndicator ??=
      GeneratedColumn<String>('tax_indicator', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _unitPriceMeta = const VerificationMeta('unitPrice');
  GeneratedColumn<double> _unitPrice;
  @override
  GeneratedColumn<double> get unitPrice =>
      _unitPrice ??= GeneratedColumn<double>('unit_price', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _costPriceMeta = const VerificationMeta('costPrice');
  GeneratedColumn<double> _costPrice;
  @override
  GeneratedColumn<double> get costPrice =>
      _costPrice ??= GeneratedColumn<double>('cost_price', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _listPriceMeta = const VerificationMeta('listPrice');
  GeneratedColumn<double> _listPrice;
  @override
  GeneratedColumn<double> get listPrice =>
      _listPrice ??= GeneratedColumn<double>('list_price', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _quantityMeta = const VerificationMeta('quantity');
  GeneratedColumn<double> _quantity;
  @override
  GeneratedColumn<double> get quantity =>
      _quantity ??= GeneratedColumn<double>('quantity', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _subTotalMeta = const VerificationMeta('subTotal');
  GeneratedColumn<double> _subTotal;
  @override
  GeneratedColumn<double> get subTotal =>
      _subTotal ??= GeneratedColumn<double>('sub_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _grandTotalMeta = const VerificationMeta('grandTotal');
  GeneratedColumn<double> _grandTotal;
  @override
  GeneratedColumn<double> get grandTotal =>
      _grandTotal ??= GeneratedColumn<double>('grand_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _itemCountMeta = const VerificationMeta('itemCount');
  GeneratedColumn<int> _itemCount;
  @override
  GeneratedColumn<int> get itemCount =>
      _itemCount ??= GeneratedColumn<int>('item_count', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _depositTotalMeta =
      const VerificationMeta('depositTotal');
  GeneratedColumn<double> _depositTotal;
  @override
  GeneratedColumn<double> get depositTotal => _depositTotal ??=
      GeneratedColumn<double>('deposit_total', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _lineIdMeta = const VerificationMeta('lineId');
  GeneratedColumn<int> _lineId;
  @override
  GeneratedColumn<int> get lineId =>
      _lineId ??= GeneratedColumn<int>('line_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _taxTotalMeta = const VerificationMeta('taxTotal');
  GeneratedColumn<double> _taxTotal;
  @override
  GeneratedColumn<double> get taxTotal =>
      _taxTotal ??= GeneratedColumn<double>('tax_total', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _shippingTotalMeta =
      const VerificationMeta('shippingTotal');
  GeneratedColumn<double> _shippingTotal;
  @override
  GeneratedColumn<double> get shippingTotal => _shippingTotal ??=
      GeneratedColumn<double>('shipping_total', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _conversionFactorMeta =
      const VerificationMeta('conversionFactor');
  GeneratedColumn<double> _conversionFactor;
  @override
  GeneratedColumn<double> get conversionFactor => _conversionFactor ??=
      GeneratedColumn<double>('conversion_factor', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        userName,
        userId,
        id,
        transactionNumber,
        inventoryCycleNumber,
        daySessionNumber,
        deliveryDate,
        currency,
        exchangeRate,
        transactionStatus,
        itemId,
        itemCode,
        upcCode,
        description,
        itemGroup,
        category,
        salesUOM,
        stockUOM,
        taxGroup,
        warehouse,
        discountType,
        discountPercentage,
        discountAmount,
        lineDiscountTotal,
        taxIndicator,
        unitPrice,
        costPrice,
        listPrice,
        quantity,
        subTotal,
        grandTotal,
        itemCount,
        depositTotal,
        lineId,
        taxTotal,
        shippingTotal,
        conversionFactor
      ];
  @override
  String get aliasedName => _alias ?? 'sales_order_detail_temp';
  @override
  String get actualTableName => 'sales_order_detail_temp';
  @override
  VerificationContext validateIntegrity(
      Insertable<SalesOrderDetailTempData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    } else if (isInserting) {
      context.missing(_userNameMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id'], _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('transaction_number')) {
      context.handle(
          _transactionNumberMeta,
          transactionNumber.isAcceptableOrUnknown(
              data['transaction_number'], _transactionNumberMeta));
    } else if (isInserting) {
      context.missing(_transactionNumberMeta);
    }
    if (data.containsKey('inventory_cycle_number')) {
      context.handle(
          _inventoryCycleNumberMeta,
          inventoryCycleNumber.isAcceptableOrUnknown(
              data['inventory_cycle_number'], _inventoryCycleNumberMeta));
    }
    if (data.containsKey('day_session_number')) {
      context.handle(
          _daySessionNumberMeta,
          daySessionNumber.isAcceptableOrUnknown(
              data['day_session_number'], _daySessionNumberMeta));
    }
    if (data.containsKey('delivery_date')) {
      context.handle(
          _deliveryDateMeta,
          deliveryDate.isAcceptableOrUnknown(
              data['delivery_date'], _deliveryDateMeta));
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency'], _currencyMeta));
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate'], _exchangeRateMeta));
    }
    if (data.containsKey('transaction_status')) {
      context.handle(
          _transactionStatusMeta,
          transactionStatus.isAcceptableOrUnknown(
              data['transaction_status'], _transactionStatusMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id'], _itemIdMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code'], _itemCodeMeta));
    } else if (isInserting) {
      context.missing(_itemCodeMeta);
    }
    if (data.containsKey('upc_code')) {
      context.handle(_upcCodeMeta,
          upcCode.isAcceptableOrUnknown(data['upc_code'], _upcCodeMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description'], _descriptionMeta));
    } else if (isInserting) {
      context.missing(_descriptionMeta);
    }
    if (data.containsKey('item_group')) {
      context.handle(_itemGroupMeta,
          itemGroup.isAcceptableOrUnknown(data['item_group'], _itemGroupMeta));
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category'], _categoryMeta));
    }
    if (data.containsKey('sales_u_o_m')) {
      context.handle(_salesUOMMeta,
          salesUOM.isAcceptableOrUnknown(data['sales_u_o_m'], _salesUOMMeta));
    }
    if (data.containsKey('stock_u_o_m')) {
      context.handle(_stockUOMMeta,
          stockUOM.isAcceptableOrUnknown(data['stock_u_o_m'], _stockUOMMeta));
    }
    if (data.containsKey('tax_group')) {
      context.handle(_taxGroupMeta,
          taxGroup.isAcceptableOrUnknown(data['tax_group'], _taxGroupMeta));
    }
    if (data.containsKey('warehouse')) {
      context.handle(_warehouseMeta,
          warehouse.isAcceptableOrUnknown(data['warehouse'], _warehouseMeta));
    }
    if (data.containsKey('discount_type')) {
      context.handle(
          _discountTypeMeta,
          discountType.isAcceptableOrUnknown(
              data['discount_type'], _discountTypeMeta));
    }
    if (data.containsKey('discount_percentage')) {
      context.handle(
          _discountPercentageMeta,
          discountPercentage.isAcceptableOrUnknown(
              data['discount_percentage'], _discountPercentageMeta));
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
          _discountAmountMeta,
          discountAmount.isAcceptableOrUnknown(
              data['discount_amount'], _discountAmountMeta));
    }
    if (data.containsKey('line_discount_total')) {
      context.handle(
          _lineDiscountTotalMeta,
          lineDiscountTotal.isAcceptableOrUnknown(
              data['line_discount_total'], _lineDiscountTotalMeta));
    }
    if (data.containsKey('tax_indicator')) {
      context.handle(
          _taxIndicatorMeta,
          taxIndicator.isAcceptableOrUnknown(
              data['tax_indicator'], _taxIndicatorMeta));
    }
    if (data.containsKey('unit_price')) {
      context.handle(_unitPriceMeta,
          unitPrice.isAcceptableOrUnknown(data['unit_price'], _unitPriceMeta));
    } else if (isInserting) {
      context.missing(_unitPriceMeta);
    }
    if (data.containsKey('cost_price')) {
      context.handle(_costPriceMeta,
          costPrice.isAcceptableOrUnknown(data['cost_price'], _costPriceMeta));
    }
    if (data.containsKey('list_price')) {
      context.handle(_listPriceMeta,
          listPrice.isAcceptableOrUnknown(data['list_price'], _listPriceMeta));
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity'], _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('sub_total')) {
      context.handle(_subTotalMeta,
          subTotal.isAcceptableOrUnknown(data['sub_total'], _subTotalMeta));
    } else if (isInserting) {
      context.missing(_subTotalMeta);
    }
    if (data.containsKey('grand_total')) {
      context.handle(
          _grandTotalMeta,
          grandTotal.isAcceptableOrUnknown(
              data['grand_total'], _grandTotalMeta));
    } else if (isInserting) {
      context.missing(_grandTotalMeta);
    }
    if (data.containsKey('item_count')) {
      context.handle(_itemCountMeta,
          itemCount.isAcceptableOrUnknown(data['item_count'], _itemCountMeta));
    }
    if (data.containsKey('deposit_total')) {
      context.handle(
          _depositTotalMeta,
          depositTotal.isAcceptableOrUnknown(
              data['deposit_total'], _depositTotalMeta));
    }
    if (data.containsKey('line_id')) {
      context.handle(_lineIdMeta,
          lineId.isAcceptableOrUnknown(data['line_id'], _lineIdMeta));
    }
    if (data.containsKey('tax_total')) {
      context.handle(_taxTotalMeta,
          taxTotal.isAcceptableOrUnknown(data['tax_total'], _taxTotalMeta));
    }
    if (data.containsKey('shipping_total')) {
      context.handle(
          _shippingTotalMeta,
          shippingTotal.isAcceptableOrUnknown(
              data['shipping_total'], _shippingTotalMeta));
    } else if (isInserting) {
      context.missing(_shippingTotalMeta);
    }
    if (data.containsKey('conversion_factor')) {
      context.handle(
          _conversionFactorMeta,
          conversionFactor.isAcceptableOrUnknown(
              data['conversion_factor'], _conversionFactorMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SalesOrderDetailTempData map(Map<String, dynamic> data,
      {String tablePrefix}) {
    return SalesOrderDetailTempData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $SalesOrderDetailTempTable createAlias(String alias) {
    return $SalesOrderDetailTempTable(_db, alias);
  }
}

class SeriesNumberGeneratorData extends DataClass
    implements Insertable<SeriesNumberGeneratorData> {
  final int tenantId;
  final int id;
  final String numberPrefix;
  final bool includePrefix;
  final bool includeJulianDate;
  final bool includeUserID;
  final bool includeTenantId;
  final bool usedAutoNumber;
  final int endingLength;
  final String typeOfNumber;
  SeriesNumberGeneratorData(
      {this.tenantId,
      @required this.id,
      this.numberPrefix,
      @required this.includePrefix,
      @required this.includeJulianDate,
      @required this.includeUserID,
      @required this.includeTenantId,
      @required this.usedAutoNumber,
      this.endingLength,
      this.typeOfNumber});
  factory SeriesNumberGeneratorData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return SeriesNumberGeneratorData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      numberPrefix: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}number_prefix']),
      includePrefix: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}include_prefix']),
      includeJulianDate: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}include_julian_date']),
      includeUserID: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}include_user_i_d']),
      includeTenantId: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}include_tenant_id']),
      usedAutoNumber: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}used_auto_number']),
      endingLength: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}ending_length']),
      typeOfNumber: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}type_of_number']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || numberPrefix != null) {
      map['number_prefix'] = Variable<String>(numberPrefix);
    }
    if (!nullToAbsent || includePrefix != null) {
      map['include_prefix'] = Variable<bool>(includePrefix);
    }
    if (!nullToAbsent || includeJulianDate != null) {
      map['include_julian_date'] = Variable<bool>(includeJulianDate);
    }
    if (!nullToAbsent || includeUserID != null) {
      map['include_user_i_d'] = Variable<bool>(includeUserID);
    }
    if (!nullToAbsent || includeTenantId != null) {
      map['include_tenant_id'] = Variable<bool>(includeTenantId);
    }
    if (!nullToAbsent || usedAutoNumber != null) {
      map['used_auto_number'] = Variable<bool>(usedAutoNumber);
    }
    if (!nullToAbsent || endingLength != null) {
      map['ending_length'] = Variable<int>(endingLength);
    }
    if (!nullToAbsent || typeOfNumber != null) {
      map['type_of_number'] = Variable<String>(typeOfNumber);
    }
    return map;
  }

  SeriesNumberGeneratorCompanion toCompanion(bool nullToAbsent) {
    return SeriesNumberGeneratorCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      numberPrefix: numberPrefix == null && nullToAbsent
          ? const Value.absent()
          : Value(numberPrefix),
      includePrefix: includePrefix == null && nullToAbsent
          ? const Value.absent()
          : Value(includePrefix),
      includeJulianDate: includeJulianDate == null && nullToAbsent
          ? const Value.absent()
          : Value(includeJulianDate),
      includeUserID: includeUserID == null && nullToAbsent
          ? const Value.absent()
          : Value(includeUserID),
      includeTenantId: includeTenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(includeTenantId),
      usedAutoNumber: usedAutoNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(usedAutoNumber),
      endingLength: endingLength == null && nullToAbsent
          ? const Value.absent()
          : Value(endingLength),
      typeOfNumber: typeOfNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(typeOfNumber),
    );
  }

  factory SeriesNumberGeneratorData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SeriesNumberGeneratorData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      numberPrefix: serializer.fromJson<String>(json['numberPrefix']),
      includePrefix: serializer.fromJson<bool>(json['includePrefix']),
      includeJulianDate: serializer.fromJson<bool>(json['includeJulianDate']),
      includeUserID: serializer.fromJson<bool>(json['includeUserID']),
      includeTenantId: serializer.fromJson<bool>(json['includeTenantId']),
      usedAutoNumber: serializer.fromJson<bool>(json['usedAutoNumber']),
      endingLength: serializer.fromJson<int>(json['endingLength']),
      typeOfNumber: serializer.fromJson<String>(json['typeOfNumber']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'numberPrefix': serializer.toJson<String>(numberPrefix),
      'includePrefix': serializer.toJson<bool>(includePrefix),
      'includeJulianDate': serializer.toJson<bool>(includeJulianDate),
      'includeUserID': serializer.toJson<bool>(includeUserID),
      'includeTenantId': serializer.toJson<bool>(includeTenantId),
      'usedAutoNumber': serializer.toJson<bool>(usedAutoNumber),
      'endingLength': serializer.toJson<int>(endingLength),
      'typeOfNumber': serializer.toJson<String>(typeOfNumber),
    };
  }

  SeriesNumberGeneratorData copyWith(
          {int tenantId,
          int id,
          String numberPrefix,
          bool includePrefix,
          bool includeJulianDate,
          bool includeUserID,
          bool includeTenantId,
          bool usedAutoNumber,
          int endingLength,
          String typeOfNumber}) =>
      SeriesNumberGeneratorData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        numberPrefix: numberPrefix ?? this.numberPrefix,
        includePrefix: includePrefix ?? this.includePrefix,
        includeJulianDate: includeJulianDate ?? this.includeJulianDate,
        includeUserID: includeUserID ?? this.includeUserID,
        includeTenantId: includeTenantId ?? this.includeTenantId,
        usedAutoNumber: usedAutoNumber ?? this.usedAutoNumber,
        endingLength: endingLength ?? this.endingLength,
        typeOfNumber: typeOfNumber ?? this.typeOfNumber,
      );
  @override
  String toString() {
    return (StringBuffer('SeriesNumberGeneratorData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('numberPrefix: $numberPrefix, ')
          ..write('includePrefix: $includePrefix, ')
          ..write('includeJulianDate: $includeJulianDate, ')
          ..write('includeUserID: $includeUserID, ')
          ..write('includeTenantId: $includeTenantId, ')
          ..write('usedAutoNumber: $usedAutoNumber, ')
          ..write('endingLength: $endingLength, ')
          ..write('typeOfNumber: $typeOfNumber')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      numberPrefix,
      includePrefix,
      includeJulianDate,
      includeUserID,
      includeTenantId,
      usedAutoNumber,
      endingLength,
      typeOfNumber);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SeriesNumberGeneratorData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.numberPrefix == this.numberPrefix &&
          other.includePrefix == this.includePrefix &&
          other.includeJulianDate == this.includeJulianDate &&
          other.includeUserID == this.includeUserID &&
          other.includeTenantId == this.includeTenantId &&
          other.usedAutoNumber == this.usedAutoNumber &&
          other.endingLength == this.endingLength &&
          other.typeOfNumber == this.typeOfNumber);
}

class SeriesNumberGeneratorCompanion
    extends UpdateCompanion<SeriesNumberGeneratorData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> numberPrefix;
  final Value<bool> includePrefix;
  final Value<bool> includeJulianDate;
  final Value<bool> includeUserID;
  final Value<bool> includeTenantId;
  final Value<bool> usedAutoNumber;
  final Value<int> endingLength;
  final Value<String> typeOfNumber;
  const SeriesNumberGeneratorCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.numberPrefix = const Value.absent(),
    this.includePrefix = const Value.absent(),
    this.includeJulianDate = const Value.absent(),
    this.includeUserID = const Value.absent(),
    this.includeTenantId = const Value.absent(),
    this.usedAutoNumber = const Value.absent(),
    this.endingLength = const Value.absent(),
    this.typeOfNumber = const Value.absent(),
  });
  SeriesNumberGeneratorCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.numberPrefix = const Value.absent(),
    this.includePrefix = const Value.absent(),
    this.includeJulianDate = const Value.absent(),
    this.includeUserID = const Value.absent(),
    this.includeTenantId = const Value.absent(),
    this.usedAutoNumber = const Value.absent(),
    this.endingLength = const Value.absent(),
    this.typeOfNumber = const Value.absent(),
  });
  static Insertable<SeriesNumberGeneratorData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> numberPrefix,
    Expression<bool> includePrefix,
    Expression<bool> includeJulianDate,
    Expression<bool> includeUserID,
    Expression<bool> includeTenantId,
    Expression<bool> usedAutoNumber,
    Expression<int> endingLength,
    Expression<String> typeOfNumber,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (numberPrefix != null) 'number_prefix': numberPrefix,
      if (includePrefix != null) 'include_prefix': includePrefix,
      if (includeJulianDate != null) 'include_julian_date': includeJulianDate,
      if (includeUserID != null) 'include_user_i_d': includeUserID,
      if (includeTenantId != null) 'include_tenant_id': includeTenantId,
      if (usedAutoNumber != null) 'used_auto_number': usedAutoNumber,
      if (endingLength != null) 'ending_length': endingLength,
      if (typeOfNumber != null) 'type_of_number': typeOfNumber,
    });
  }

  SeriesNumberGeneratorCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> numberPrefix,
      Value<bool> includePrefix,
      Value<bool> includeJulianDate,
      Value<bool> includeUserID,
      Value<bool> includeTenantId,
      Value<bool> usedAutoNumber,
      Value<int> endingLength,
      Value<String> typeOfNumber}) {
    return SeriesNumberGeneratorCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      numberPrefix: numberPrefix ?? this.numberPrefix,
      includePrefix: includePrefix ?? this.includePrefix,
      includeJulianDate: includeJulianDate ?? this.includeJulianDate,
      includeUserID: includeUserID ?? this.includeUserID,
      includeTenantId: includeTenantId ?? this.includeTenantId,
      usedAutoNumber: usedAutoNumber ?? this.usedAutoNumber,
      endingLength: endingLength ?? this.endingLength,
      typeOfNumber: typeOfNumber ?? this.typeOfNumber,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (numberPrefix.present) {
      map['number_prefix'] = Variable<String>(numberPrefix.value);
    }
    if (includePrefix.present) {
      map['include_prefix'] = Variable<bool>(includePrefix.value);
    }
    if (includeJulianDate.present) {
      map['include_julian_date'] = Variable<bool>(includeJulianDate.value);
    }
    if (includeUserID.present) {
      map['include_user_i_d'] = Variable<bool>(includeUserID.value);
    }
    if (includeTenantId.present) {
      map['include_tenant_id'] = Variable<bool>(includeTenantId.value);
    }
    if (usedAutoNumber.present) {
      map['used_auto_number'] = Variable<bool>(usedAutoNumber.value);
    }
    if (endingLength.present) {
      map['ending_length'] = Variable<int>(endingLength.value);
    }
    if (typeOfNumber.present) {
      map['type_of_number'] = Variable<String>(typeOfNumber.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SeriesNumberGeneratorCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('numberPrefix: $numberPrefix, ')
          ..write('includePrefix: $includePrefix, ')
          ..write('includeJulianDate: $includeJulianDate, ')
          ..write('includeUserID: $includeUserID, ')
          ..write('includeTenantId: $includeTenantId, ')
          ..write('usedAutoNumber: $usedAutoNumber, ')
          ..write('endingLength: $endingLength, ')
          ..write('typeOfNumber: $typeOfNumber')
          ..write(')'))
        .toString();
  }
}

class $SeriesNumberGeneratorTable extends SeriesNumberGenerator
    with TableInfo<$SeriesNumberGeneratorTable, SeriesNumberGeneratorData> {
  final GeneratedDatabase _db;
  final String _alias;
  $SeriesNumberGeneratorTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _numberPrefixMeta =
      const VerificationMeta('numberPrefix');
  GeneratedColumn<String> _numberPrefix;
  @override
  GeneratedColumn<String> get numberPrefix => _numberPrefix ??=
      GeneratedColumn<String>('number_prefix', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _includePrefixMeta =
      const VerificationMeta('includePrefix');
  GeneratedColumn<bool> _includePrefix;
  @override
  GeneratedColumn<bool> get includePrefix => _includePrefix ??=
      GeneratedColumn<bool>('include_prefix', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (include_prefix IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _includeJulianDateMeta =
      const VerificationMeta('includeJulianDate');
  GeneratedColumn<bool> _includeJulianDate;
  @override
  GeneratedColumn<bool> get includeJulianDate => _includeJulianDate ??=
      GeneratedColumn<bool>('include_julian_date', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (include_julian_date IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _includeUserIDMeta =
      const VerificationMeta('includeUserID');
  GeneratedColumn<bool> _includeUserID;
  @override
  GeneratedColumn<bool> get includeUserID => _includeUserID ??=
      GeneratedColumn<bool>('include_user_i_d', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (include_user_i_d IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _includeTenantIdMeta =
      const VerificationMeta('includeTenantId');
  GeneratedColumn<bool> _includeTenantId;
  @override
  GeneratedColumn<bool> get includeTenantId => _includeTenantId ??=
      GeneratedColumn<bool>('include_tenant_id', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (include_tenant_id IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _usedAutoNumberMeta =
      const VerificationMeta('usedAutoNumber');
  GeneratedColumn<bool> _usedAutoNumber;
  @override
  GeneratedColumn<bool> get usedAutoNumber => _usedAutoNumber ??=
      GeneratedColumn<bool>('used_auto_number', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (used_auto_number IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _endingLengthMeta =
      const VerificationMeta('endingLength');
  GeneratedColumn<int> _endingLength;
  @override
  GeneratedColumn<int> get endingLength =>
      _endingLength ??= GeneratedColumn<int>('ending_length', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _typeOfNumberMeta =
      const VerificationMeta('typeOfNumber');
  GeneratedColumn<String> _typeOfNumber;
  @override
  GeneratedColumn<String> get typeOfNumber => _typeOfNumber ??=
      GeneratedColumn<String>('type_of_number', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        numberPrefix,
        includePrefix,
        includeJulianDate,
        includeUserID,
        includeTenantId,
        usedAutoNumber,
        endingLength,
        typeOfNumber
      ];
  @override
  String get aliasedName => _alias ?? 'series_number_generator';
  @override
  String get actualTableName => 'series_number_generator';
  @override
  VerificationContext validateIntegrity(
      Insertable<SeriesNumberGeneratorData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('number_prefix')) {
      context.handle(
          _numberPrefixMeta,
          numberPrefix.isAcceptableOrUnknown(
              data['number_prefix'], _numberPrefixMeta));
    }
    if (data.containsKey('include_prefix')) {
      context.handle(
          _includePrefixMeta,
          includePrefix.isAcceptableOrUnknown(
              data['include_prefix'], _includePrefixMeta));
    }
    if (data.containsKey('include_julian_date')) {
      context.handle(
          _includeJulianDateMeta,
          includeJulianDate.isAcceptableOrUnknown(
              data['include_julian_date'], _includeJulianDateMeta));
    }
    if (data.containsKey('include_user_i_d')) {
      context.handle(
          _includeUserIDMeta,
          includeUserID.isAcceptableOrUnknown(
              data['include_user_i_d'], _includeUserIDMeta));
    }
    if (data.containsKey('include_tenant_id')) {
      context.handle(
          _includeTenantIdMeta,
          includeTenantId.isAcceptableOrUnknown(
              data['include_tenant_id'], _includeTenantIdMeta));
    }
    if (data.containsKey('used_auto_number')) {
      context.handle(
          _usedAutoNumberMeta,
          usedAutoNumber.isAcceptableOrUnknown(
              data['used_auto_number'], _usedAutoNumberMeta));
    }
    if (data.containsKey('ending_length')) {
      context.handle(
          _endingLengthMeta,
          endingLength.isAcceptableOrUnknown(
              data['ending_length'], _endingLengthMeta));
    }
    if (data.containsKey('type_of_number')) {
      context.handle(
          _typeOfNumberMeta,
          typeOfNumber.isAcceptableOrUnknown(
              data['type_of_number'], _typeOfNumberMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SeriesNumberGeneratorData map(Map<String, dynamic> data,
      {String tablePrefix}) {
    return SeriesNumberGeneratorData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $SeriesNumberGeneratorTable createAlias(String alias) {
    return $SeriesNumberGeneratorTable(_db, alias);
  }
}

class SalesTaxData extends DataClass implements Insertable<SalesTaxData> {
  final int tenantId;
  final int id;
  final String type;
  final String taxAccount;
  final double accountRate;
  final DateTime effectiveDate;
  final double amount;
  final String taxIndicator;
  SalesTaxData(
      {this.tenantId,
      @required this.id,
      this.type,
      this.taxAccount,
      this.accountRate,
      @required this.effectiveDate,
      this.amount,
      this.taxIndicator});
  factory SalesTaxData.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return SalesTaxData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      type: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}type']),
      taxAccount: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_account']),
      accountRate: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}account_rate']),
      effectiveDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}effective_date']),
      amount: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}amount']),
      taxIndicator: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_indicator']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || taxAccount != null) {
      map['tax_account'] = Variable<String>(taxAccount);
    }
    if (!nullToAbsent || accountRate != null) {
      map['account_rate'] = Variable<double>(accountRate);
    }
    if (!nullToAbsent || effectiveDate != null) {
      map['effective_date'] = Variable<DateTime>(effectiveDate);
    }
    if (!nullToAbsent || amount != null) {
      map['amount'] = Variable<double>(amount);
    }
    if (!nullToAbsent || taxIndicator != null) {
      map['tax_indicator'] = Variable<String>(taxIndicator);
    }
    return map;
  }

  SalesTaxCompanion toCompanion(bool nullToAbsent) {
    return SalesTaxCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      taxAccount: taxAccount == null && nullToAbsent
          ? const Value.absent()
          : Value(taxAccount),
      accountRate: accountRate == null && nullToAbsent
          ? const Value.absent()
          : Value(accountRate),
      effectiveDate: effectiveDate == null && nullToAbsent
          ? const Value.absent()
          : Value(effectiveDate),
      amount:
          amount == null && nullToAbsent ? const Value.absent() : Value(amount),
      taxIndicator: taxIndicator == null && nullToAbsent
          ? const Value.absent()
          : Value(taxIndicator),
    );
  }

  factory SalesTaxData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SalesTaxData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      type: serializer.fromJson<String>(json['type']),
      taxAccount: serializer.fromJson<String>(json['taxAccount']),
      accountRate: serializer.fromJson<double>(json['accountRate']),
      effectiveDate: serializer.fromJson<DateTime>(json['effectiveDate']),
      amount: serializer.fromJson<double>(json['amount']),
      taxIndicator: serializer.fromJson<String>(json['taxIndicator']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'type': serializer.toJson<String>(type),
      'taxAccount': serializer.toJson<String>(taxAccount),
      'accountRate': serializer.toJson<double>(accountRate),
      'effectiveDate': serializer.toJson<DateTime>(effectiveDate),
      'amount': serializer.toJson<double>(amount),
      'taxIndicator': serializer.toJson<String>(taxIndicator),
    };
  }

  SalesTaxData copyWith(
          {int tenantId,
          int id,
          String type,
          String taxAccount,
          double accountRate,
          DateTime effectiveDate,
          double amount,
          String taxIndicator}) =>
      SalesTaxData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        type: type ?? this.type,
        taxAccount: taxAccount ?? this.taxAccount,
        accountRate: accountRate ?? this.accountRate,
        effectiveDate: effectiveDate ?? this.effectiveDate,
        amount: amount ?? this.amount,
        taxIndicator: taxIndicator ?? this.taxIndicator,
      );
  @override
  String toString() {
    return (StringBuffer('SalesTaxData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('taxAccount: $taxAccount, ')
          ..write('accountRate: $accountRate, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('amount: $amount, ')
          ..write('taxIndicator: $taxIndicator')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, type, taxAccount, accountRate,
      effectiveDate, amount, taxIndicator);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SalesTaxData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.type == this.type &&
          other.taxAccount == this.taxAccount &&
          other.accountRate == this.accountRate &&
          other.effectiveDate == this.effectiveDate &&
          other.amount == this.amount &&
          other.taxIndicator == this.taxIndicator);
}

class SalesTaxCompanion extends UpdateCompanion<SalesTaxData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> type;
  final Value<String> taxAccount;
  final Value<double> accountRate;
  final Value<DateTime> effectiveDate;
  final Value<double> amount;
  final Value<String> taxIndicator;
  const SalesTaxCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.taxAccount = const Value.absent(),
    this.accountRate = const Value.absent(),
    this.effectiveDate = const Value.absent(),
    this.amount = const Value.absent(),
    this.taxIndicator = const Value.absent(),
  });
  SalesTaxCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.taxAccount = const Value.absent(),
    this.accountRate = const Value.absent(),
    @required DateTime effectiveDate,
    this.amount = const Value.absent(),
    this.taxIndicator = const Value.absent(),
  }) : effectiveDate = Value(effectiveDate);
  static Insertable<SalesTaxData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> type,
    Expression<String> taxAccount,
    Expression<double> accountRate,
    Expression<DateTime> effectiveDate,
    Expression<double> amount,
    Expression<String> taxIndicator,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (type != null) 'type': type,
      if (taxAccount != null) 'tax_account': taxAccount,
      if (accountRate != null) 'account_rate': accountRate,
      if (effectiveDate != null) 'effective_date': effectiveDate,
      if (amount != null) 'amount': amount,
      if (taxIndicator != null) 'tax_indicator': taxIndicator,
    });
  }

  SalesTaxCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> type,
      Value<String> taxAccount,
      Value<double> accountRate,
      Value<DateTime> effectiveDate,
      Value<double> amount,
      Value<String> taxIndicator}) {
    return SalesTaxCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      type: type ?? this.type,
      taxAccount: taxAccount ?? this.taxAccount,
      accountRate: accountRate ?? this.accountRate,
      effectiveDate: effectiveDate ?? this.effectiveDate,
      amount: amount ?? this.amount,
      taxIndicator: taxIndicator ?? this.taxIndicator,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (taxAccount.present) {
      map['tax_account'] = Variable<String>(taxAccount.value);
    }
    if (accountRate.present) {
      map['account_rate'] = Variable<double>(accountRate.value);
    }
    if (effectiveDate.present) {
      map['effective_date'] = Variable<DateTime>(effectiveDate.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (taxIndicator.present) {
      map['tax_indicator'] = Variable<String>(taxIndicator.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SalesTaxCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('taxAccount: $taxAccount, ')
          ..write('accountRate: $accountRate, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('amount: $amount, ')
          ..write('taxIndicator: $taxIndicator')
          ..write(')'))
        .toString();
  }
}

class $SalesTaxTable extends SalesTax
    with TableInfo<$SalesTaxTable, SalesTaxData> {
  final GeneratedDatabase _db;
  final String _alias;
  $SalesTaxTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(),
          requiredDuringInsert: false,
          defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
  final VerificationMeta _typeMeta = const VerificationMeta('type');
  GeneratedColumn<String> _type;
  @override
  GeneratedColumn<String> get type =>
      _type ??= GeneratedColumn<String>('type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _taxAccountMeta = const VerificationMeta('taxAccount');
  GeneratedColumn<String> _taxAccount;
  @override
  GeneratedColumn<String> get taxAccount =>
      _taxAccount ??= GeneratedColumn<String>('tax_account', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _accountRateMeta =
      const VerificationMeta('accountRate');
  GeneratedColumn<double> _accountRate;
  @override
  GeneratedColumn<double> get accountRate => _accountRate ??=
      GeneratedColumn<double>('account_rate', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _effectiveDateMeta =
      const VerificationMeta('effectiveDate');
  GeneratedColumn<DateTime> _effectiveDate;
  @override
  GeneratedColumn<DateTime> get effectiveDate => _effectiveDate ??=
      GeneratedColumn<DateTime>('effective_date', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _amountMeta = const VerificationMeta('amount');
  GeneratedColumn<double> _amount;
  @override
  GeneratedColumn<double> get amount =>
      _amount ??= GeneratedColumn<double>('amount', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _taxIndicatorMeta =
      const VerificationMeta('taxIndicator');
  GeneratedColumn<String> _taxIndicator;
  @override
  GeneratedColumn<String> get taxIndicator => _taxIndicator ??=
      GeneratedColumn<String>('tax_indicator', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        type,
        taxAccount,
        accountRate,
        effectiveDate,
        amount,
        taxIndicator
      ];
  @override
  String get aliasedName => _alias ?? 'sales_tax';
  @override
  String get actualTableName => 'sales_tax';
  @override
  VerificationContext validateIntegrity(Insertable<SalesTaxData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type'], _typeMeta));
    }
    if (data.containsKey('tax_account')) {
      context.handle(
          _taxAccountMeta,
          taxAccount.isAcceptableOrUnknown(
              data['tax_account'], _taxAccountMeta));
    }
    if (data.containsKey('account_rate')) {
      context.handle(
          _accountRateMeta,
          accountRate.isAcceptableOrUnknown(
              data['account_rate'], _accountRateMeta));
    }
    if (data.containsKey('effective_date')) {
      context.handle(
          _effectiveDateMeta,
          effectiveDate.isAcceptableOrUnknown(
              data['effective_date'], _effectiveDateMeta));
    } else if (isInserting) {
      context.missing(_effectiveDateMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(_amountMeta,
          amount.isAcceptableOrUnknown(data['amount'], _amountMeta));
    }
    if (data.containsKey('tax_indicator')) {
      context.handle(
          _taxIndicatorMeta,
          taxIndicator.isAcceptableOrUnknown(
              data['tax_indicator'], _taxIndicatorMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SalesTaxData map(Map<String, dynamic> data, {String tablePrefix}) {
    return SalesTaxData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $SalesTaxTable createAlias(String alias) {
    return $SalesTaxTable(_db, alias);
  }
}

class TempNumberLog extends DataClass implements Insertable<TempNumberLog> {
  final int tenantId;
  final int id;
  final String nextSeriesNumber;
  final String lastSeriesNumber;
  final DateTime lastUsageDate;
  final String userName;
  final String typeOfNumber;
  TempNumberLog(
      {this.tenantId,
      @required this.id,
      this.nextSeriesNumber,
      this.lastSeriesNumber,
      @required this.lastUsageDate,
      this.userName,
      this.typeOfNumber});
  factory TempNumberLog.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return TempNumberLog(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      nextSeriesNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}next_series_number']),
      lastSeriesNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}last_series_number']),
      lastUsageDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}last_usage_date']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      typeOfNumber: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}type_of_number']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || nextSeriesNumber != null) {
      map['next_series_number'] = Variable<String>(nextSeriesNumber);
    }
    if (!nullToAbsent || lastSeriesNumber != null) {
      map['last_series_number'] = Variable<String>(lastSeriesNumber);
    }
    if (!nullToAbsent || lastUsageDate != null) {
      map['last_usage_date'] = Variable<DateTime>(lastUsageDate);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || typeOfNumber != null) {
      map['type_of_number'] = Variable<String>(typeOfNumber);
    }
    return map;
  }

  TempNumberLogsCompanion toCompanion(bool nullToAbsent) {
    return TempNumberLogsCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      nextSeriesNumber: nextSeriesNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(nextSeriesNumber),
      lastSeriesNumber: lastSeriesNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSeriesNumber),
      lastUsageDate: lastUsageDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastUsageDate),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      typeOfNumber: typeOfNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(typeOfNumber),
    );
  }

  factory TempNumberLog.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TempNumberLog(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      nextSeriesNumber: serializer.fromJson<String>(json['nextSeriesNumber']),
      lastSeriesNumber: serializer.fromJson<String>(json['lastSeriesNumber']),
      lastUsageDate: serializer.fromJson<DateTime>(json['lastUsageDate']),
      userName: serializer.fromJson<String>(json['userName']),
      typeOfNumber: serializer.fromJson<String>(json['typeOfNumber']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'nextSeriesNumber': serializer.toJson<String>(nextSeriesNumber),
      'lastSeriesNumber': serializer.toJson<String>(lastSeriesNumber),
      'lastUsageDate': serializer.toJson<DateTime>(lastUsageDate),
      'userName': serializer.toJson<String>(userName),
      'typeOfNumber': serializer.toJson<String>(typeOfNumber),
    };
  }

  TempNumberLog copyWith(
          {int tenantId,
          int id,
          String nextSeriesNumber,
          String lastSeriesNumber,
          DateTime lastUsageDate,
          String userName,
          String typeOfNumber}) =>
      TempNumberLog(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        nextSeriesNumber: nextSeriesNumber ?? this.nextSeriesNumber,
        lastSeriesNumber: lastSeriesNumber ?? this.lastSeriesNumber,
        lastUsageDate: lastUsageDate ?? this.lastUsageDate,
        userName: userName ?? this.userName,
        typeOfNumber: typeOfNumber ?? this.typeOfNumber,
      );
  @override
  String toString() {
    return (StringBuffer('TempNumberLog(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('nextSeriesNumber: $nextSeriesNumber, ')
          ..write('lastSeriesNumber: $lastSeriesNumber, ')
          ..write('lastUsageDate: $lastUsageDate, ')
          ..write('userName: $userName, ')
          ..write('typeOfNumber: $typeOfNumber')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, nextSeriesNumber,
      lastSeriesNumber, lastUsageDate, userName, typeOfNumber);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TempNumberLog &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.nextSeriesNumber == this.nextSeriesNumber &&
          other.lastSeriesNumber == this.lastSeriesNumber &&
          other.lastUsageDate == this.lastUsageDate &&
          other.userName == this.userName &&
          other.typeOfNumber == this.typeOfNumber);
}

class TempNumberLogsCompanion extends UpdateCompanion<TempNumberLog> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> nextSeriesNumber;
  final Value<String> lastSeriesNumber;
  final Value<DateTime> lastUsageDate;
  final Value<String> userName;
  final Value<String> typeOfNumber;
  const TempNumberLogsCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.nextSeriesNumber = const Value.absent(),
    this.lastSeriesNumber = const Value.absent(),
    this.lastUsageDate = const Value.absent(),
    this.userName = const Value.absent(),
    this.typeOfNumber = const Value.absent(),
  });
  TempNumberLogsCompanion.insert({
    this.tenantId = const Value.absent(),
    @required int id,
    this.nextSeriesNumber = const Value.absent(),
    this.lastSeriesNumber = const Value.absent(),
    @required DateTime lastUsageDate,
    this.userName = const Value.absent(),
    this.typeOfNumber = const Value.absent(),
  })  : id = Value(id),
        lastUsageDate = Value(lastUsageDate);
  static Insertable<TempNumberLog> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> nextSeriesNumber,
    Expression<String> lastSeriesNumber,
    Expression<DateTime> lastUsageDate,
    Expression<String> userName,
    Expression<String> typeOfNumber,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (nextSeriesNumber != null) 'next_series_number': nextSeriesNumber,
      if (lastSeriesNumber != null) 'last_series_number': lastSeriesNumber,
      if (lastUsageDate != null) 'last_usage_date': lastUsageDate,
      if (userName != null) 'user_name': userName,
      if (typeOfNumber != null) 'type_of_number': typeOfNumber,
    });
  }

  TempNumberLogsCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> nextSeriesNumber,
      Value<String> lastSeriesNumber,
      Value<DateTime> lastUsageDate,
      Value<String> userName,
      Value<String> typeOfNumber}) {
    return TempNumberLogsCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      nextSeriesNumber: nextSeriesNumber ?? this.nextSeriesNumber,
      lastSeriesNumber: lastSeriesNumber ?? this.lastSeriesNumber,
      lastUsageDate: lastUsageDate ?? this.lastUsageDate,
      userName: userName ?? this.userName,
      typeOfNumber: typeOfNumber ?? this.typeOfNumber,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (nextSeriesNumber.present) {
      map['next_series_number'] = Variable<String>(nextSeriesNumber.value);
    }
    if (lastSeriesNumber.present) {
      map['last_series_number'] = Variable<String>(lastSeriesNumber.value);
    }
    if (lastUsageDate.present) {
      map['last_usage_date'] = Variable<DateTime>(lastUsageDate.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (typeOfNumber.present) {
      map['type_of_number'] = Variable<String>(typeOfNumber.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TempNumberLogsCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('nextSeriesNumber: $nextSeriesNumber, ')
          ..write('lastSeriesNumber: $lastSeriesNumber, ')
          ..write('lastUsageDate: $lastUsageDate, ')
          ..write('userName: $userName, ')
          ..write('typeOfNumber: $typeOfNumber')
          ..write(')'))
        .toString();
  }
}

class $TempNumberLogsTable extends TempNumberLogs
    with TableInfo<$TempNumberLogsTable, TempNumberLog> {
  final GeneratedDatabase _db;
  final String _alias;
  $TempNumberLogsTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(),
          requiredDuringInsert: true,
          defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
  final VerificationMeta _nextSeriesNumberMeta =
      const VerificationMeta('nextSeriesNumber');
  GeneratedColumn<String> _nextSeriesNumber;
  @override
  GeneratedColumn<String> get nextSeriesNumber => _nextSeriesNumber ??=
      GeneratedColumn<String>('next_series_number', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _lastSeriesNumberMeta =
      const VerificationMeta('lastSeriesNumber');
  GeneratedColumn<String> _lastSeriesNumber;
  @override
  GeneratedColumn<String> get lastSeriesNumber => _lastSeriesNumber ??=
      GeneratedColumn<String>('last_series_number', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _lastUsageDateMeta =
      const VerificationMeta('lastUsageDate');
  GeneratedColumn<DateTime> _lastUsageDate;
  @override
  GeneratedColumn<DateTime> get lastUsageDate => _lastUsageDate ??=
      GeneratedColumn<DateTime>('last_usage_date', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _typeOfNumberMeta =
      const VerificationMeta('typeOfNumber');
  GeneratedColumn<String> _typeOfNumber;
  @override
  GeneratedColumn<String> get typeOfNumber => _typeOfNumber ??=
      GeneratedColumn<String>('type_of_number', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        nextSeriesNumber,
        lastSeriesNumber,
        lastUsageDate,
        userName,
        typeOfNumber
      ];
  @override
  String get aliasedName => _alias ?? 'temp_number_logs';
  @override
  String get actualTableName => 'temp_number_logs';
  @override
  VerificationContext validateIntegrity(Insertable<TempNumberLog> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('next_series_number')) {
      context.handle(
          _nextSeriesNumberMeta,
          nextSeriesNumber.isAcceptableOrUnknown(
              data['next_series_number'], _nextSeriesNumberMeta));
    }
    if (data.containsKey('last_series_number')) {
      context.handle(
          _lastSeriesNumberMeta,
          lastSeriesNumber.isAcceptableOrUnknown(
              data['last_series_number'], _lastSeriesNumberMeta));
    }
    if (data.containsKey('last_usage_date')) {
      context.handle(
          _lastUsageDateMeta,
          lastUsageDate.isAcceptableOrUnknown(
              data['last_usage_date'], _lastUsageDateMeta));
    } else if (isInserting) {
      context.missing(_lastUsageDateMeta);
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    }
    if (data.containsKey('type_of_number')) {
      context.handle(
          _typeOfNumberMeta,
          typeOfNumber.isAcceptableOrUnknown(
              data['type_of_number'], _typeOfNumberMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {typeOfNumber};
  @override
  TempNumberLog map(Map<String, dynamic> data, {String tablePrefix}) {
    return TempNumberLog.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $TempNumberLogsTable createAlias(String alias) {
    return $TempNumberLogsTable(_db, alias);
  }
}

class CustomerData extends DataClass implements Insertable<CustomerData> {
  final int tenantId;
  final int id;
  final String customerId;
  final String customerName;
  final String companyName;
  final String customerType;
  final String customerGroup;
  final String customerTerritory;
  final String defaultCurrency;
  final String paymentTerms;
  final String language;
  final double creditLimit;
  final String billingAddressName;
  final String shippingAddressName;
  final String contactName;
  final String priceList;
  final double minQuantity;
  final double maxQuantity;
  final String discountType;
  final double discountPercentage;
  final double discountAmount;
  final bool enableHeaderDiscount;
  final double accumulatedPurchase;
  final DateTime validFrom;
  final DateTime validTo;
  final String taxId;
  final String taxGroup;
  CustomerData(
      {this.tenantId,
      @required this.id,
      @required this.customerId,
      @required this.customerName,
      @required this.companyName,
      @required this.customerType,
      @required this.customerGroup,
      @required this.customerTerritory,
      @required this.defaultCurrency,
      @required this.paymentTerms,
      @required this.language,
      @required this.creditLimit,
      this.billingAddressName,
      this.shippingAddressName,
      this.contactName,
      this.priceList,
      @required this.minQuantity,
      @required this.maxQuantity,
      @required this.discountType,
      @required this.discountPercentage,
      @required this.discountAmount,
      @required this.enableHeaderDiscount,
      @required this.accumulatedPurchase,
      @required this.validFrom,
      @required this.validTo,
      @required this.taxId,
      @required this.taxGroup});
  factory CustomerData.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return CustomerData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      customerId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_id']),
      customerName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_name']),
      companyName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}company_name']),
      customerType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_type']),
      customerGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_group']),
      customerTerritory: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}customer_territory']),
      defaultCurrency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}default_currency']),
      paymentTerms: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}payment_terms']),
      language: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}language']),
      creditLimit: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}credit_limit']),
      billingAddressName: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}billing_address_name']),
      shippingAddressName: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}shipping_address_name']),
      contactName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}contact_name']),
      priceList: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}price_list']),
      minQuantity: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}min_quantity']),
      maxQuantity: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}max_quantity']),
      discountType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}discount_type']),
      discountPercentage: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}discount_percentage']),
      discountAmount: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}discount_amount']),
      enableHeaderDiscount: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}enable_header_discount']),
      accumulatedPurchase: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}accumulated_purchase']),
      validFrom: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}valid_from']),
      validTo: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}valid_to']),
      taxId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_id']),
      taxGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_group']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || customerName != null) {
      map['customer_name'] = Variable<String>(customerName);
    }
    if (!nullToAbsent || companyName != null) {
      map['company_name'] = Variable<String>(companyName);
    }
    if (!nullToAbsent || customerType != null) {
      map['customer_type'] = Variable<String>(customerType);
    }
    if (!nullToAbsent || customerGroup != null) {
      map['customer_group'] = Variable<String>(customerGroup);
    }
    if (!nullToAbsent || customerTerritory != null) {
      map['customer_territory'] = Variable<String>(customerTerritory);
    }
    if (!nullToAbsent || defaultCurrency != null) {
      map['default_currency'] = Variable<String>(defaultCurrency);
    }
    if (!nullToAbsent || paymentTerms != null) {
      map['payment_terms'] = Variable<String>(paymentTerms);
    }
    if (!nullToAbsent || language != null) {
      map['language'] = Variable<String>(language);
    }
    if (!nullToAbsent || creditLimit != null) {
      map['credit_limit'] = Variable<double>(creditLimit);
    }
    if (!nullToAbsent || billingAddressName != null) {
      map['billing_address_name'] = Variable<String>(billingAddressName);
    }
    if (!nullToAbsent || shippingAddressName != null) {
      map['shipping_address_name'] = Variable<String>(shippingAddressName);
    }
    if (!nullToAbsent || contactName != null) {
      map['contact_name'] = Variable<String>(contactName);
    }
    if (!nullToAbsent || priceList != null) {
      map['price_list'] = Variable<String>(priceList);
    }
    if (!nullToAbsent || minQuantity != null) {
      map['min_quantity'] = Variable<double>(minQuantity);
    }
    if (!nullToAbsent || maxQuantity != null) {
      map['max_quantity'] = Variable<double>(maxQuantity);
    }
    if (!nullToAbsent || discountType != null) {
      map['discount_type'] = Variable<String>(discountType);
    }
    if (!nullToAbsent || discountPercentage != null) {
      map['discount_percentage'] = Variable<double>(discountPercentage);
    }
    if (!nullToAbsent || discountAmount != null) {
      map['discount_amount'] = Variable<double>(discountAmount);
    }
    if (!nullToAbsent || enableHeaderDiscount != null) {
      map['enable_header_discount'] = Variable<bool>(enableHeaderDiscount);
    }
    if (!nullToAbsent || accumulatedPurchase != null) {
      map['accumulated_purchase'] = Variable<double>(accumulatedPurchase);
    }
    if (!nullToAbsent || validFrom != null) {
      map['valid_from'] = Variable<DateTime>(validFrom);
    }
    if (!nullToAbsent || validTo != null) {
      map['valid_to'] = Variable<DateTime>(validTo);
    }
    if (!nullToAbsent || taxId != null) {
      map['tax_id'] = Variable<String>(taxId);
    }
    if (!nullToAbsent || taxGroup != null) {
      map['tax_group'] = Variable<String>(taxGroup);
    }
    return map;
  }

  CustomerCompanion toCompanion(bool nullToAbsent) {
    return CustomerCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      customerName: customerName == null && nullToAbsent
          ? const Value.absent()
          : Value(customerName),
      companyName: companyName == null && nullToAbsent
          ? const Value.absent()
          : Value(companyName),
      customerType: customerType == null && nullToAbsent
          ? const Value.absent()
          : Value(customerType),
      customerGroup: customerGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(customerGroup),
      customerTerritory: customerTerritory == null && nullToAbsent
          ? const Value.absent()
          : Value(customerTerritory),
      defaultCurrency: defaultCurrency == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultCurrency),
      paymentTerms: paymentTerms == null && nullToAbsent
          ? const Value.absent()
          : Value(paymentTerms),
      language: language == null && nullToAbsent
          ? const Value.absent()
          : Value(language),
      creditLimit: creditLimit == null && nullToAbsent
          ? const Value.absent()
          : Value(creditLimit),
      billingAddressName: billingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(billingAddressName),
      shippingAddressName: shippingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(shippingAddressName),
      contactName: contactName == null && nullToAbsent
          ? const Value.absent()
          : Value(contactName),
      priceList: priceList == null && nullToAbsent
          ? const Value.absent()
          : Value(priceList),
      minQuantity: minQuantity == null && nullToAbsent
          ? const Value.absent()
          : Value(minQuantity),
      maxQuantity: maxQuantity == null && nullToAbsent
          ? const Value.absent()
          : Value(maxQuantity),
      discountType: discountType == null && nullToAbsent
          ? const Value.absent()
          : Value(discountType),
      discountPercentage: discountPercentage == null && nullToAbsent
          ? const Value.absent()
          : Value(discountPercentage),
      discountAmount: discountAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(discountAmount),
      enableHeaderDiscount: enableHeaderDiscount == null && nullToAbsent
          ? const Value.absent()
          : Value(enableHeaderDiscount),
      accumulatedPurchase: accumulatedPurchase == null && nullToAbsent
          ? const Value.absent()
          : Value(accumulatedPurchase),
      validFrom: validFrom == null && nullToAbsent
          ? const Value.absent()
          : Value(validFrom),
      validTo: validTo == null && nullToAbsent
          ? const Value.absent()
          : Value(validTo),
      taxId:
          taxId == null && nullToAbsent ? const Value.absent() : Value(taxId),
      taxGroup: taxGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(taxGroup),
    );
  }

  factory CustomerData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CustomerData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      customerId: serializer.fromJson<String>(json['customerId']),
      customerName: serializer.fromJson<String>(json['customerName']),
      companyName: serializer.fromJson<String>(json['companyName']),
      customerType: serializer.fromJson<String>(json['customerType']),
      customerGroup: serializer.fromJson<String>(json['customerGroup']),
      customerTerritory: serializer.fromJson<String>(json['customerTerritory']),
      defaultCurrency: serializer.fromJson<String>(json['defaultCurrency']),
      paymentTerms: serializer.fromJson<String>(json['paymentTerms']),
      language: serializer.fromJson<String>(json['language']),
      creditLimit: serializer.fromJson<double>(json['creditLimit']),
      billingAddressName:
          serializer.fromJson<String>(json['billingAddressName']),
      shippingAddressName:
          serializer.fromJson<String>(json['shippingAddressName']),
      contactName: serializer.fromJson<String>(json['contactName']),
      priceList: serializer.fromJson<String>(json['priceList']),
      minQuantity: serializer.fromJson<double>(json['minQuantity']),
      maxQuantity: serializer.fromJson<double>(json['maxQuantity']),
      discountType: serializer.fromJson<String>(json['discountType']),
      discountPercentage:
          serializer.fromJson<double>(json['discountPercentage']),
      discountAmount: serializer.fromJson<double>(json['discountAmount']),
      enableHeaderDiscount:
          serializer.fromJson<bool>(json['enableHeaderDiscount']),
      accumulatedPurchase:
          serializer.fromJson<double>(json['accumulatedPurchase']),
      validFrom: serializer.fromJson<DateTime>(json['validFrom']),
      validTo: serializer.fromJson<DateTime>(json['validTo']),
      taxId: serializer.fromJson<String>(json['taxId']),
      taxGroup: serializer.fromJson<String>(json['taxGroup']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'customerId': serializer.toJson<String>(customerId),
      'customerName': serializer.toJson<String>(customerName),
      'companyName': serializer.toJson<String>(companyName),
      'customerType': serializer.toJson<String>(customerType),
      'customerGroup': serializer.toJson<String>(customerGroup),
      'customerTerritory': serializer.toJson<String>(customerTerritory),
      'defaultCurrency': serializer.toJson<String>(defaultCurrency),
      'paymentTerms': serializer.toJson<String>(paymentTerms),
      'language': serializer.toJson<String>(language),
      'creditLimit': serializer.toJson<double>(creditLimit),
      'billingAddressName': serializer.toJson<String>(billingAddressName),
      'shippingAddressName': serializer.toJson<String>(shippingAddressName),
      'contactName': serializer.toJson<String>(contactName),
      'priceList': serializer.toJson<String>(priceList),
      'minQuantity': serializer.toJson<double>(minQuantity),
      'maxQuantity': serializer.toJson<double>(maxQuantity),
      'discountType': serializer.toJson<String>(discountType),
      'discountPercentage': serializer.toJson<double>(discountPercentage),
      'discountAmount': serializer.toJson<double>(discountAmount),
      'enableHeaderDiscount': serializer.toJson<bool>(enableHeaderDiscount),
      'accumulatedPurchase': serializer.toJson<double>(accumulatedPurchase),
      'validFrom': serializer.toJson<DateTime>(validFrom),
      'validTo': serializer.toJson<DateTime>(validTo),
      'taxId': serializer.toJson<String>(taxId),
      'taxGroup': serializer.toJson<String>(taxGroup),
    };
  }

  CustomerData copyWith(
          {int tenantId,
          int id,
          String customerId,
          String customerName,
          String companyName,
          String customerType,
          String customerGroup,
          String customerTerritory,
          String defaultCurrency,
          String paymentTerms,
          String language,
          double creditLimit,
          String billingAddressName,
          String shippingAddressName,
          String contactName,
          String priceList,
          double minQuantity,
          double maxQuantity,
          String discountType,
          double discountPercentage,
          double discountAmount,
          bool enableHeaderDiscount,
          double accumulatedPurchase,
          DateTime validFrom,
          DateTime validTo,
          String taxId,
          String taxGroup}) =>
      CustomerData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        customerId: customerId ?? this.customerId,
        customerName: customerName ?? this.customerName,
        companyName: companyName ?? this.companyName,
        customerType: customerType ?? this.customerType,
        customerGroup: customerGroup ?? this.customerGroup,
        customerTerritory: customerTerritory ?? this.customerTerritory,
        defaultCurrency: defaultCurrency ?? this.defaultCurrency,
        paymentTerms: paymentTerms ?? this.paymentTerms,
        language: language ?? this.language,
        creditLimit: creditLimit ?? this.creditLimit,
        billingAddressName: billingAddressName ?? this.billingAddressName,
        shippingAddressName: shippingAddressName ?? this.shippingAddressName,
        contactName: contactName ?? this.contactName,
        priceList: priceList ?? this.priceList,
        minQuantity: minQuantity ?? this.minQuantity,
        maxQuantity: maxQuantity ?? this.maxQuantity,
        discountType: discountType ?? this.discountType,
        discountPercentage: discountPercentage ?? this.discountPercentage,
        discountAmount: discountAmount ?? this.discountAmount,
        enableHeaderDiscount: enableHeaderDiscount ?? this.enableHeaderDiscount,
        accumulatedPurchase: accumulatedPurchase ?? this.accumulatedPurchase,
        validFrom: validFrom ?? this.validFrom,
        validTo: validTo ?? this.validTo,
        taxId: taxId ?? this.taxId,
        taxGroup: taxGroup ?? this.taxGroup,
      );
  @override
  String toString() {
    return (StringBuffer('CustomerData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('companyName: $companyName, ')
          ..write('customerType: $customerType, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('customerTerritory: $customerTerritory, ')
          ..write('defaultCurrency: $defaultCurrency, ')
          ..write('paymentTerms: $paymentTerms, ')
          ..write('language: $language, ')
          ..write('creditLimit: $creditLimit, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('contactName: $contactName, ')
          ..write('priceList: $priceList, ')
          ..write('minQuantity: $minQuantity, ')
          ..write('maxQuantity: $maxQuantity, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('enableHeaderDiscount: $enableHeaderDiscount, ')
          ..write('accumulatedPurchase: $accumulatedPurchase, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo, ')
          ..write('taxId: $taxId, ')
          ..write('taxGroup: $taxGroup')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        id,
        customerId,
        customerName,
        companyName,
        customerType,
        customerGroup,
        customerTerritory,
        defaultCurrency,
        paymentTerms,
        language,
        creditLimit,
        billingAddressName,
        shippingAddressName,
        contactName,
        priceList,
        minQuantity,
        maxQuantity,
        discountType,
        discountPercentage,
        discountAmount,
        enableHeaderDiscount,
        accumulatedPurchase,
        validFrom,
        validTo,
        taxId,
        taxGroup
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CustomerData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.customerId == this.customerId &&
          other.customerName == this.customerName &&
          other.companyName == this.companyName &&
          other.customerType == this.customerType &&
          other.customerGroup == this.customerGroup &&
          other.customerTerritory == this.customerTerritory &&
          other.defaultCurrency == this.defaultCurrency &&
          other.paymentTerms == this.paymentTerms &&
          other.language == this.language &&
          other.creditLimit == this.creditLimit &&
          other.billingAddressName == this.billingAddressName &&
          other.shippingAddressName == this.shippingAddressName &&
          other.contactName == this.contactName &&
          other.priceList == this.priceList &&
          other.minQuantity == this.minQuantity &&
          other.maxQuantity == this.maxQuantity &&
          other.discountType == this.discountType &&
          other.discountPercentage == this.discountPercentage &&
          other.discountAmount == this.discountAmount &&
          other.enableHeaderDiscount == this.enableHeaderDiscount &&
          other.accumulatedPurchase == this.accumulatedPurchase &&
          other.validFrom == this.validFrom &&
          other.validTo == this.validTo &&
          other.taxId == this.taxId &&
          other.taxGroup == this.taxGroup);
}

class CustomerCompanion extends UpdateCompanion<CustomerData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> customerId;
  final Value<String> customerName;
  final Value<String> companyName;
  final Value<String> customerType;
  final Value<String> customerGroup;
  final Value<String> customerTerritory;
  final Value<String> defaultCurrency;
  final Value<String> paymentTerms;
  final Value<String> language;
  final Value<double> creditLimit;
  final Value<String> billingAddressName;
  final Value<String> shippingAddressName;
  final Value<String> contactName;
  final Value<String> priceList;
  final Value<double> minQuantity;
  final Value<double> maxQuantity;
  final Value<String> discountType;
  final Value<double> discountPercentage;
  final Value<double> discountAmount;
  final Value<bool> enableHeaderDiscount;
  final Value<double> accumulatedPurchase;
  final Value<DateTime> validFrom;
  final Value<DateTime> validTo;
  final Value<String> taxId;
  final Value<String> taxGroup;
  const CustomerCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.customerId = const Value.absent(),
    this.customerName = const Value.absent(),
    this.companyName = const Value.absent(),
    this.customerType = const Value.absent(),
    this.customerGroup = const Value.absent(),
    this.customerTerritory = const Value.absent(),
    this.defaultCurrency = const Value.absent(),
    this.paymentTerms = const Value.absent(),
    this.language = const Value.absent(),
    this.creditLimit = const Value.absent(),
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.contactName = const Value.absent(),
    this.priceList = const Value.absent(),
    this.minQuantity = const Value.absent(),
    this.maxQuantity = const Value.absent(),
    this.discountType = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.discountAmount = const Value.absent(),
    this.enableHeaderDiscount = const Value.absent(),
    this.accumulatedPurchase = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
    this.taxId = const Value.absent(),
    this.taxGroup = const Value.absent(),
  });
  CustomerCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    @required String customerId,
    @required String customerName,
    @required String companyName,
    @required String customerType,
    @required String customerGroup,
    @required String customerTerritory,
    @required String defaultCurrency,
    @required String paymentTerms,
    @required String language,
    @required double creditLimit,
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.contactName = const Value.absent(),
    this.priceList = const Value.absent(),
    @required double minQuantity,
    @required double maxQuantity,
    @required String discountType,
    @required double discountPercentage,
    @required double discountAmount,
    this.enableHeaderDiscount = const Value.absent(),
    @required double accumulatedPurchase,
    @required DateTime validFrom,
    @required DateTime validTo,
    @required String taxId,
    @required String taxGroup,
  })  : customerId = Value(customerId),
        customerName = Value(customerName),
        companyName = Value(companyName),
        customerType = Value(customerType),
        customerGroup = Value(customerGroup),
        customerTerritory = Value(customerTerritory),
        defaultCurrency = Value(defaultCurrency),
        paymentTerms = Value(paymentTerms),
        language = Value(language),
        creditLimit = Value(creditLimit),
        minQuantity = Value(minQuantity),
        maxQuantity = Value(maxQuantity),
        discountType = Value(discountType),
        discountPercentage = Value(discountPercentage),
        discountAmount = Value(discountAmount),
        accumulatedPurchase = Value(accumulatedPurchase),
        validFrom = Value(validFrom),
        validTo = Value(validTo),
        taxId = Value(taxId),
        taxGroup = Value(taxGroup);
  static Insertable<CustomerData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> customerId,
    Expression<String> customerName,
    Expression<String> companyName,
    Expression<String> customerType,
    Expression<String> customerGroup,
    Expression<String> customerTerritory,
    Expression<String> defaultCurrency,
    Expression<String> paymentTerms,
    Expression<String> language,
    Expression<double> creditLimit,
    Expression<String> billingAddressName,
    Expression<String> shippingAddressName,
    Expression<String> contactName,
    Expression<String> priceList,
    Expression<double> minQuantity,
    Expression<double> maxQuantity,
    Expression<String> discountType,
    Expression<double> discountPercentage,
    Expression<double> discountAmount,
    Expression<bool> enableHeaderDiscount,
    Expression<double> accumulatedPurchase,
    Expression<DateTime> validFrom,
    Expression<DateTime> validTo,
    Expression<String> taxId,
    Expression<String> taxGroup,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (customerId != null) 'customer_id': customerId,
      if (customerName != null) 'customer_name': customerName,
      if (companyName != null) 'company_name': companyName,
      if (customerType != null) 'customer_type': customerType,
      if (customerGroup != null) 'customer_group': customerGroup,
      if (customerTerritory != null) 'customer_territory': customerTerritory,
      if (defaultCurrency != null) 'default_currency': defaultCurrency,
      if (paymentTerms != null) 'payment_terms': paymentTerms,
      if (language != null) 'language': language,
      if (creditLimit != null) 'credit_limit': creditLimit,
      if (billingAddressName != null)
        'billing_address_name': billingAddressName,
      if (shippingAddressName != null)
        'shipping_address_name': shippingAddressName,
      if (contactName != null) 'contact_name': contactName,
      if (priceList != null) 'price_list': priceList,
      if (minQuantity != null) 'min_quantity': minQuantity,
      if (maxQuantity != null) 'max_quantity': maxQuantity,
      if (discountType != null) 'discount_type': discountType,
      if (discountPercentage != null) 'discount_percentage': discountPercentage,
      if (discountAmount != null) 'discount_amount': discountAmount,
      if (enableHeaderDiscount != null)
        'enable_header_discount': enableHeaderDiscount,
      if (accumulatedPurchase != null)
        'accumulated_purchase': accumulatedPurchase,
      if (validFrom != null) 'valid_from': validFrom,
      if (validTo != null) 'valid_to': validTo,
      if (taxId != null) 'tax_id': taxId,
      if (taxGroup != null) 'tax_group': taxGroup,
    });
  }

  CustomerCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> customerId,
      Value<String> customerName,
      Value<String> companyName,
      Value<String> customerType,
      Value<String> customerGroup,
      Value<String> customerTerritory,
      Value<String> defaultCurrency,
      Value<String> paymentTerms,
      Value<String> language,
      Value<double> creditLimit,
      Value<String> billingAddressName,
      Value<String> shippingAddressName,
      Value<String> contactName,
      Value<String> priceList,
      Value<double> minQuantity,
      Value<double> maxQuantity,
      Value<String> discountType,
      Value<double> discountPercentage,
      Value<double> discountAmount,
      Value<bool> enableHeaderDiscount,
      Value<double> accumulatedPurchase,
      Value<DateTime> validFrom,
      Value<DateTime> validTo,
      Value<String> taxId,
      Value<String> taxGroup}) {
    return CustomerCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      customerId: customerId ?? this.customerId,
      customerName: customerName ?? this.customerName,
      companyName: companyName ?? this.companyName,
      customerType: customerType ?? this.customerType,
      customerGroup: customerGroup ?? this.customerGroup,
      customerTerritory: customerTerritory ?? this.customerTerritory,
      defaultCurrency: defaultCurrency ?? this.defaultCurrency,
      paymentTerms: paymentTerms ?? this.paymentTerms,
      language: language ?? this.language,
      creditLimit: creditLimit ?? this.creditLimit,
      billingAddressName: billingAddressName ?? this.billingAddressName,
      shippingAddressName: shippingAddressName ?? this.shippingAddressName,
      contactName: contactName ?? this.contactName,
      priceList: priceList ?? this.priceList,
      minQuantity: minQuantity ?? this.minQuantity,
      maxQuantity: maxQuantity ?? this.maxQuantity,
      discountType: discountType ?? this.discountType,
      discountPercentage: discountPercentage ?? this.discountPercentage,
      discountAmount: discountAmount ?? this.discountAmount,
      enableHeaderDiscount: enableHeaderDiscount ?? this.enableHeaderDiscount,
      accumulatedPurchase: accumulatedPurchase ?? this.accumulatedPurchase,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo ?? this.validTo,
      taxId: taxId ?? this.taxId,
      taxGroup: taxGroup ?? this.taxGroup,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (customerName.present) {
      map['customer_name'] = Variable<String>(customerName.value);
    }
    if (companyName.present) {
      map['company_name'] = Variable<String>(companyName.value);
    }
    if (customerType.present) {
      map['customer_type'] = Variable<String>(customerType.value);
    }
    if (customerGroup.present) {
      map['customer_group'] = Variable<String>(customerGroup.value);
    }
    if (customerTerritory.present) {
      map['customer_territory'] = Variable<String>(customerTerritory.value);
    }
    if (defaultCurrency.present) {
      map['default_currency'] = Variable<String>(defaultCurrency.value);
    }
    if (paymentTerms.present) {
      map['payment_terms'] = Variable<String>(paymentTerms.value);
    }
    if (language.present) {
      map['language'] = Variable<String>(language.value);
    }
    if (creditLimit.present) {
      map['credit_limit'] = Variable<double>(creditLimit.value);
    }
    if (billingAddressName.present) {
      map['billing_address_name'] = Variable<String>(billingAddressName.value);
    }
    if (shippingAddressName.present) {
      map['shipping_address_name'] =
          Variable<String>(shippingAddressName.value);
    }
    if (contactName.present) {
      map['contact_name'] = Variable<String>(contactName.value);
    }
    if (priceList.present) {
      map['price_list'] = Variable<String>(priceList.value);
    }
    if (minQuantity.present) {
      map['min_quantity'] = Variable<double>(minQuantity.value);
    }
    if (maxQuantity.present) {
      map['max_quantity'] = Variable<double>(maxQuantity.value);
    }
    if (discountType.present) {
      map['discount_type'] = Variable<String>(discountType.value);
    }
    if (discountPercentage.present) {
      map['discount_percentage'] = Variable<double>(discountPercentage.value);
    }
    if (discountAmount.present) {
      map['discount_amount'] = Variable<double>(discountAmount.value);
    }
    if (enableHeaderDiscount.present) {
      map['enable_header_discount'] =
          Variable<bool>(enableHeaderDiscount.value);
    }
    if (accumulatedPurchase.present) {
      map['accumulated_purchase'] = Variable<double>(accumulatedPurchase.value);
    }
    if (validFrom.present) {
      map['valid_from'] = Variable<DateTime>(validFrom.value);
    }
    if (validTo.present) {
      map['valid_to'] = Variable<DateTime>(validTo.value);
    }
    if (taxId.present) {
      map['tax_id'] = Variable<String>(taxId.value);
    }
    if (taxGroup.present) {
      map['tax_group'] = Variable<String>(taxGroup.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CustomerCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('companyName: $companyName, ')
          ..write('customerType: $customerType, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('customerTerritory: $customerTerritory, ')
          ..write('defaultCurrency: $defaultCurrency, ')
          ..write('paymentTerms: $paymentTerms, ')
          ..write('language: $language, ')
          ..write('creditLimit: $creditLimit, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('contactName: $contactName, ')
          ..write('priceList: $priceList, ')
          ..write('minQuantity: $minQuantity, ')
          ..write('maxQuantity: $maxQuantity, ')
          ..write('discountType: $discountType, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('discountAmount: $discountAmount, ')
          ..write('enableHeaderDiscount: $enableHeaderDiscount, ')
          ..write('accumulatedPurchase: $accumulatedPurchase, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo, ')
          ..write('taxId: $taxId, ')
          ..write('taxGroup: $taxGroup')
          ..write(')'))
        .toString();
  }
}

class $CustomerTable extends Customer
    with TableInfo<$CustomerTable, CustomerData> {
  final GeneratedDatabase _db;
  final String _alias;
  $CustomerTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _customerIdMeta = const VerificationMeta('customerId');
  GeneratedColumn<String> _customerId;
  @override
  GeneratedColumn<String> get customerId =>
      _customerId ??= GeneratedColumn<String>('customer_id', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _customerNameMeta =
      const VerificationMeta('customerName');
  GeneratedColumn<String> _customerName;
  @override
  GeneratedColumn<String> get customerName => _customerName ??=
      GeneratedColumn<String>('customer_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _companyNameMeta =
      const VerificationMeta('companyName');
  GeneratedColumn<String> _companyName;
  @override
  GeneratedColumn<String> get companyName => _companyName ??=
      GeneratedColumn<String>('company_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _customerTypeMeta =
      const VerificationMeta('customerType');
  GeneratedColumn<String> _customerType;
  @override
  GeneratedColumn<String> get customerType => _customerType ??=
      GeneratedColumn<String>('customer_type', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _customerGroupMeta =
      const VerificationMeta('customerGroup');
  GeneratedColumn<String> _customerGroup;
  @override
  GeneratedColumn<String> get customerGroup => _customerGroup ??=
      GeneratedColumn<String>('customer_group', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _customerTerritoryMeta =
      const VerificationMeta('customerTerritory');
  GeneratedColumn<String> _customerTerritory;
  @override
  GeneratedColumn<String> get customerTerritory => _customerTerritory ??=
      GeneratedColumn<String>('customer_territory', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _defaultCurrencyMeta =
      const VerificationMeta('defaultCurrency');
  GeneratedColumn<String> _defaultCurrency;
  @override
  GeneratedColumn<String> get defaultCurrency => _defaultCurrency ??=
      GeneratedColumn<String>('default_currency', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _paymentTermsMeta =
      const VerificationMeta('paymentTerms');
  GeneratedColumn<String> _paymentTerms;
  @override
  GeneratedColumn<String> get paymentTerms => _paymentTerms ??=
      GeneratedColumn<String>('payment_terms', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _languageMeta = const VerificationMeta('language');
  GeneratedColumn<String> _language;
  @override
  GeneratedColumn<String> get language =>
      _language ??= GeneratedColumn<String>('language', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _creditLimitMeta =
      const VerificationMeta('creditLimit');
  GeneratedColumn<double> _creditLimit;
  @override
  GeneratedColumn<double> get creditLimit => _creditLimit ??=
      GeneratedColumn<double>('credit_limit', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _billingAddressNameMeta =
      const VerificationMeta('billingAddressName');
  GeneratedColumn<String> _billingAddressName;
  @override
  GeneratedColumn<String> get billingAddressName => _billingAddressName ??=
      GeneratedColumn<String>('billing_address_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _shippingAddressNameMeta =
      const VerificationMeta('shippingAddressName');
  GeneratedColumn<String> _shippingAddressName;
  @override
  GeneratedColumn<String> get shippingAddressName => _shippingAddressName ??=
      GeneratedColumn<String>('shipping_address_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _contactNameMeta =
      const VerificationMeta('contactName');
  GeneratedColumn<String> _contactName;
  @override
  GeneratedColumn<String> get contactName => _contactName ??=
      GeneratedColumn<String>('contact_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _priceListMeta = const VerificationMeta('priceList');
  GeneratedColumn<String> _priceList;
  @override
  GeneratedColumn<String> get priceList =>
      _priceList ??= GeneratedColumn<String>('price_list', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _minQuantityMeta =
      const VerificationMeta('minQuantity');
  GeneratedColumn<double> _minQuantity;
  @override
  GeneratedColumn<double> get minQuantity => _minQuantity ??=
      GeneratedColumn<double>('min_quantity', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _maxQuantityMeta =
      const VerificationMeta('maxQuantity');
  GeneratedColumn<double> _maxQuantity;
  @override
  GeneratedColumn<double> get maxQuantity => _maxQuantity ??=
      GeneratedColumn<double>('max_quantity', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _discountTypeMeta =
      const VerificationMeta('discountType');
  GeneratedColumn<String> _discountType;
  @override
  GeneratedColumn<String> get discountType => _discountType ??=
      GeneratedColumn<String>('discount_type', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _discountPercentageMeta =
      const VerificationMeta('discountPercentage');
  GeneratedColumn<double> _discountPercentage;
  @override
  GeneratedColumn<double> get discountPercentage => _discountPercentage ??=
      GeneratedColumn<double>('discount_percentage', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _discountAmountMeta =
      const VerificationMeta('discountAmount');
  GeneratedColumn<double> _discountAmount;
  @override
  GeneratedColumn<double> get discountAmount => _discountAmount ??=
      GeneratedColumn<double>('discount_amount', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _enableHeaderDiscountMeta =
      const VerificationMeta('enableHeaderDiscount');
  GeneratedColumn<bool> _enableHeaderDiscount;
  @override
  GeneratedColumn<bool> get enableHeaderDiscount => _enableHeaderDiscount ??=
      GeneratedColumn<bool>('enable_header_discount', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (enable_header_discount IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _accumulatedPurchaseMeta =
      const VerificationMeta('accumulatedPurchase');
  GeneratedColumn<double> _accumulatedPurchase;
  @override
  GeneratedColumn<double> get accumulatedPurchase => _accumulatedPurchase ??=
      GeneratedColumn<double>('accumulated_purchase', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _validFromMeta = const VerificationMeta('validFrom');
  GeneratedColumn<DateTime> _validFrom;
  @override
  GeneratedColumn<DateTime> get validFrom =>
      _validFrom ??= GeneratedColumn<DateTime>('valid_from', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _validToMeta = const VerificationMeta('validTo');
  GeneratedColumn<DateTime> _validTo;
  @override
  GeneratedColumn<DateTime> get validTo =>
      _validTo ??= GeneratedColumn<DateTime>('valid_to', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _taxIdMeta = const VerificationMeta('taxId');
  GeneratedColumn<String> _taxId;
  @override
  GeneratedColumn<String> get taxId =>
      _taxId ??= GeneratedColumn<String>('tax_id', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _taxGroupMeta = const VerificationMeta('taxGroup');
  GeneratedColumn<String> _taxGroup;
  @override
  GeneratedColumn<String> get taxGroup =>
      _taxGroup ??= GeneratedColumn<String>('tax_group', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        customerId,
        customerName,
        companyName,
        customerType,
        customerGroup,
        customerTerritory,
        defaultCurrency,
        paymentTerms,
        language,
        creditLimit,
        billingAddressName,
        shippingAddressName,
        contactName,
        priceList,
        minQuantity,
        maxQuantity,
        discountType,
        discountPercentage,
        discountAmount,
        enableHeaderDiscount,
        accumulatedPurchase,
        validFrom,
        validTo,
        taxId,
        taxGroup
      ];
  @override
  String get aliasedName => _alias ?? 'customer';
  @override
  String get actualTableName => 'customer';
  @override
  VerificationContext validateIntegrity(Insertable<CustomerData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id'], _customerIdMeta));
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('customer_name')) {
      context.handle(
          _customerNameMeta,
          customerName.isAcceptableOrUnknown(
              data['customer_name'], _customerNameMeta));
    } else if (isInserting) {
      context.missing(_customerNameMeta);
    }
    if (data.containsKey('company_name')) {
      context.handle(
          _companyNameMeta,
          companyName.isAcceptableOrUnknown(
              data['company_name'], _companyNameMeta));
    } else if (isInserting) {
      context.missing(_companyNameMeta);
    }
    if (data.containsKey('customer_type')) {
      context.handle(
          _customerTypeMeta,
          customerType.isAcceptableOrUnknown(
              data['customer_type'], _customerTypeMeta));
    } else if (isInserting) {
      context.missing(_customerTypeMeta);
    }
    if (data.containsKey('customer_group')) {
      context.handle(
          _customerGroupMeta,
          customerGroup.isAcceptableOrUnknown(
              data['customer_group'], _customerGroupMeta));
    } else if (isInserting) {
      context.missing(_customerGroupMeta);
    }
    if (data.containsKey('customer_territory')) {
      context.handle(
          _customerTerritoryMeta,
          customerTerritory.isAcceptableOrUnknown(
              data['customer_territory'], _customerTerritoryMeta));
    } else if (isInserting) {
      context.missing(_customerTerritoryMeta);
    }
    if (data.containsKey('default_currency')) {
      context.handle(
          _defaultCurrencyMeta,
          defaultCurrency.isAcceptableOrUnknown(
              data['default_currency'], _defaultCurrencyMeta));
    } else if (isInserting) {
      context.missing(_defaultCurrencyMeta);
    }
    if (data.containsKey('payment_terms')) {
      context.handle(
          _paymentTermsMeta,
          paymentTerms.isAcceptableOrUnknown(
              data['payment_terms'], _paymentTermsMeta));
    } else if (isInserting) {
      context.missing(_paymentTermsMeta);
    }
    if (data.containsKey('language')) {
      context.handle(_languageMeta,
          language.isAcceptableOrUnknown(data['language'], _languageMeta));
    } else if (isInserting) {
      context.missing(_languageMeta);
    }
    if (data.containsKey('credit_limit')) {
      context.handle(
          _creditLimitMeta,
          creditLimit.isAcceptableOrUnknown(
              data['credit_limit'], _creditLimitMeta));
    } else if (isInserting) {
      context.missing(_creditLimitMeta);
    }
    if (data.containsKey('billing_address_name')) {
      context.handle(
          _billingAddressNameMeta,
          billingAddressName.isAcceptableOrUnknown(
              data['billing_address_name'], _billingAddressNameMeta));
    }
    if (data.containsKey('shipping_address_name')) {
      context.handle(
          _shippingAddressNameMeta,
          shippingAddressName.isAcceptableOrUnknown(
              data['shipping_address_name'], _shippingAddressNameMeta));
    }
    if (data.containsKey('contact_name')) {
      context.handle(
          _contactNameMeta,
          contactName.isAcceptableOrUnknown(
              data['contact_name'], _contactNameMeta));
    }
    if (data.containsKey('price_list')) {
      context.handle(_priceListMeta,
          priceList.isAcceptableOrUnknown(data['price_list'], _priceListMeta));
    }
    if (data.containsKey('min_quantity')) {
      context.handle(
          _minQuantityMeta,
          minQuantity.isAcceptableOrUnknown(
              data['min_quantity'], _minQuantityMeta));
    } else if (isInserting) {
      context.missing(_minQuantityMeta);
    }
    if (data.containsKey('max_quantity')) {
      context.handle(
          _maxQuantityMeta,
          maxQuantity.isAcceptableOrUnknown(
              data['max_quantity'], _maxQuantityMeta));
    } else if (isInserting) {
      context.missing(_maxQuantityMeta);
    }
    if (data.containsKey('discount_type')) {
      context.handle(
          _discountTypeMeta,
          discountType.isAcceptableOrUnknown(
              data['discount_type'], _discountTypeMeta));
    } else if (isInserting) {
      context.missing(_discountTypeMeta);
    }
    if (data.containsKey('discount_percentage')) {
      context.handle(
          _discountPercentageMeta,
          discountPercentage.isAcceptableOrUnknown(
              data['discount_percentage'], _discountPercentageMeta));
    } else if (isInserting) {
      context.missing(_discountPercentageMeta);
    }
    if (data.containsKey('discount_amount')) {
      context.handle(
          _discountAmountMeta,
          discountAmount.isAcceptableOrUnknown(
              data['discount_amount'], _discountAmountMeta));
    } else if (isInserting) {
      context.missing(_discountAmountMeta);
    }
    if (data.containsKey('enable_header_discount')) {
      context.handle(
          _enableHeaderDiscountMeta,
          enableHeaderDiscount.isAcceptableOrUnknown(
              data['enable_header_discount'], _enableHeaderDiscountMeta));
    }
    if (data.containsKey('accumulated_purchase')) {
      context.handle(
          _accumulatedPurchaseMeta,
          accumulatedPurchase.isAcceptableOrUnknown(
              data['accumulated_purchase'], _accumulatedPurchaseMeta));
    } else if (isInserting) {
      context.missing(_accumulatedPurchaseMeta);
    }
    if (data.containsKey('valid_from')) {
      context.handle(_validFromMeta,
          validFrom.isAcceptableOrUnknown(data['valid_from'], _validFromMeta));
    } else if (isInserting) {
      context.missing(_validFromMeta);
    }
    if (data.containsKey('valid_to')) {
      context.handle(_validToMeta,
          validTo.isAcceptableOrUnknown(data['valid_to'], _validToMeta));
    } else if (isInserting) {
      context.missing(_validToMeta);
    }
    if (data.containsKey('tax_id')) {
      context.handle(
          _taxIdMeta, taxId.isAcceptableOrUnknown(data['tax_id'], _taxIdMeta));
    } else if (isInserting) {
      context.missing(_taxIdMeta);
    }
    if (data.containsKey('tax_group')) {
      context.handle(_taxGroupMeta,
          taxGroup.isAcceptableOrUnknown(data['tax_group'], _taxGroupMeta));
    } else if (isInserting) {
      context.missing(_taxGroupMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CustomerData map(Map<String, dynamic> data, {String tablePrefix}) {
    return CustomerData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $CustomerTable createAlias(String alias) {
    return $CustomerTable(_db, alias);
  }
}

class Addres extends DataClass implements Insertable<Addres> {
  final int tenantId;
  final int id;
  final String customerId;
  final String addressTitle;
  final String addressType;
  final String addressLine1;
  final String addressLine2;
  final String city;
  final String state;
  final String apartment;
  final String country;
  final String zipCode;
  final String contactPerson;
  final String phoneNumber;
  final bool isYourCompanyAddress;
  final bool isPrimaryAddress;
  final bool isShippingAddress;
  final double latitude;
  final double longitude;
  final bool isDeleted;
  Addres(
      {this.tenantId,
      @required this.id,
      @required this.customerId,
      @required this.addressTitle,
      @required this.addressType,
      @required this.addressLine1,
      @required this.addressLine2,
      @required this.city,
      @required this.state,
      @required this.apartment,
      @required this.country,
      @required this.zipCode,
      @required this.contactPerson,
      @required this.phoneNumber,
      @required this.isYourCompanyAddress,
      @required this.isPrimaryAddress,
      @required this.isShippingAddress,
      @required this.latitude,
      @required this.longitude,
      @required this.isDeleted});
  factory Addres.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return Addres(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      customerId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_id']),
      addressTitle: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}address_title']),
      addressType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}address_type']),
      addressLine1: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}address_line1']),
      addressLine2: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}address_line2']),
      city: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}city']),
      state: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}state']),
      apartment: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}apartment']),
      country: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}country']),
      zipCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}zip_code']),
      contactPerson: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}contact_person']),
      phoneNumber: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}phone_number']),
      isYourCompanyAddress: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}is_your_company_address']),
      isPrimaryAddress: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}is_primary_address']),
      isShippingAddress: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}is_shipping_address']),
      latitude: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}latitude']),
      longitude: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}longitude']),
      isDeleted: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_deleted']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || addressTitle != null) {
      map['address_title'] = Variable<String>(addressTitle);
    }
    if (!nullToAbsent || addressType != null) {
      map['address_type'] = Variable<String>(addressType);
    }
    if (!nullToAbsent || addressLine1 != null) {
      map['address_line1'] = Variable<String>(addressLine1);
    }
    if (!nullToAbsent || addressLine2 != null) {
      map['address_line2'] = Variable<String>(addressLine2);
    }
    if (!nullToAbsent || city != null) {
      map['city'] = Variable<String>(city);
    }
    if (!nullToAbsent || state != null) {
      map['state'] = Variable<String>(state);
    }
    if (!nullToAbsent || apartment != null) {
      map['apartment'] = Variable<String>(apartment);
    }
    if (!nullToAbsent || country != null) {
      map['country'] = Variable<String>(country);
    }
    if (!nullToAbsent || zipCode != null) {
      map['zip_code'] = Variable<String>(zipCode);
    }
    if (!nullToAbsent || contactPerson != null) {
      map['contact_person'] = Variable<String>(contactPerson);
    }
    if (!nullToAbsent || phoneNumber != null) {
      map['phone_number'] = Variable<String>(phoneNumber);
    }
    if (!nullToAbsent || isYourCompanyAddress != null) {
      map['is_your_company_address'] = Variable<bool>(isYourCompanyAddress);
    }
    if (!nullToAbsent || isPrimaryAddress != null) {
      map['is_primary_address'] = Variable<bool>(isPrimaryAddress);
    }
    if (!nullToAbsent || isShippingAddress != null) {
      map['is_shipping_address'] = Variable<bool>(isShippingAddress);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    return map;
  }

  AddressCompanion toCompanion(bool nullToAbsent) {
    return AddressCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      addressTitle: addressTitle == null && nullToAbsent
          ? const Value.absent()
          : Value(addressTitle),
      addressType: addressType == null && nullToAbsent
          ? const Value.absent()
          : Value(addressType),
      addressLine1: addressLine1 == null && nullToAbsent
          ? const Value.absent()
          : Value(addressLine1),
      addressLine2: addressLine2 == null && nullToAbsent
          ? const Value.absent()
          : Value(addressLine2),
      city: city == null && nullToAbsent ? const Value.absent() : Value(city),
      state:
          state == null && nullToAbsent ? const Value.absent() : Value(state),
      apartment: apartment == null && nullToAbsent
          ? const Value.absent()
          : Value(apartment),
      country: country == null && nullToAbsent
          ? const Value.absent()
          : Value(country),
      zipCode: zipCode == null && nullToAbsent
          ? const Value.absent()
          : Value(zipCode),
      contactPerson: contactPerson == null && nullToAbsent
          ? const Value.absent()
          : Value(contactPerson),
      phoneNumber: phoneNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(phoneNumber),
      isYourCompanyAddress: isYourCompanyAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(isYourCompanyAddress),
      isPrimaryAddress: isPrimaryAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(isPrimaryAddress),
      isShippingAddress: isShippingAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(isShippingAddress),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
    );
  }

  factory Addres.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Addres(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      customerId: serializer.fromJson<String>(json['customerId']),
      addressTitle: serializer.fromJson<String>(json['addressTitle']),
      addressType: serializer.fromJson<String>(json['addressType']),
      addressLine1: serializer.fromJson<String>(json['addressLine1']),
      addressLine2: serializer.fromJson<String>(json['addressLine2']),
      city: serializer.fromJson<String>(json['city']),
      state: serializer.fromJson<String>(json['state']),
      apartment: serializer.fromJson<String>(json['apartment']),
      country: serializer.fromJson<String>(json['country']),
      zipCode: serializer.fromJson<String>(json['zipCode']),
      contactPerson: serializer.fromJson<String>(json['contactPerson']),
      phoneNumber: serializer.fromJson<String>(json['phoneNumber']),
      isYourCompanyAddress:
          serializer.fromJson<bool>(json['isYourCompanyAddress']),
      isPrimaryAddress: serializer.fromJson<bool>(json['isPrimaryAddress']),
      isShippingAddress: serializer.fromJson<bool>(json['isShippingAddress']),
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'customerId': serializer.toJson<String>(customerId),
      'addressTitle': serializer.toJson<String>(addressTitle),
      'addressType': serializer.toJson<String>(addressType),
      'addressLine1': serializer.toJson<String>(addressLine1),
      'addressLine2': serializer.toJson<String>(addressLine2),
      'city': serializer.toJson<String>(city),
      'state': serializer.toJson<String>(state),
      'apartment': serializer.toJson<String>(apartment),
      'country': serializer.toJson<String>(country),
      'zipCode': serializer.toJson<String>(zipCode),
      'contactPerson': serializer.toJson<String>(contactPerson),
      'phoneNumber': serializer.toJson<String>(phoneNumber),
      'isYourCompanyAddress': serializer.toJson<bool>(isYourCompanyAddress),
      'isPrimaryAddress': serializer.toJson<bool>(isPrimaryAddress),
      'isShippingAddress': serializer.toJson<bool>(isShippingAddress),
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  Addres copyWith(
          {int tenantId,
          int id,
          String customerId,
          String addressTitle,
          String addressType,
          String addressLine1,
          String addressLine2,
          String city,
          String state,
          String apartment,
          String country,
          String zipCode,
          String contactPerson,
          String phoneNumber,
          bool isYourCompanyAddress,
          bool isPrimaryAddress,
          bool isShippingAddress,
          double latitude,
          double longitude,
          bool isDeleted}) =>
      Addres(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        customerId: customerId ?? this.customerId,
        addressTitle: addressTitle ?? this.addressTitle,
        addressType: addressType ?? this.addressType,
        addressLine1: addressLine1 ?? this.addressLine1,
        addressLine2: addressLine2 ?? this.addressLine2,
        city: city ?? this.city,
        state: state ?? this.state,
        apartment: apartment ?? this.apartment,
        country: country ?? this.country,
        zipCode: zipCode ?? this.zipCode,
        contactPerson: contactPerson ?? this.contactPerson,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        isYourCompanyAddress: isYourCompanyAddress ?? this.isYourCompanyAddress,
        isPrimaryAddress: isPrimaryAddress ?? this.isPrimaryAddress,
        isShippingAddress: isShippingAddress ?? this.isShippingAddress,
        latitude: latitude ?? this.latitude,
        longitude: longitude ?? this.longitude,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  @override
  String toString() {
    return (StringBuffer('Addres(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('addressTitle: $addressTitle, ')
          ..write('addressType: $addressType, ')
          ..write('addressLine1: $addressLine1, ')
          ..write('addressLine2: $addressLine2, ')
          ..write('city: $city, ')
          ..write('state: $state, ')
          ..write('apartment: $apartment, ')
          ..write('country: $country, ')
          ..write('zipCode: $zipCode, ')
          ..write('contactPerson: $contactPerson, ')
          ..write('phoneNumber: $phoneNumber, ')
          ..write('isYourCompanyAddress: $isYourCompanyAddress, ')
          ..write('isPrimaryAddress: $isPrimaryAddress, ')
          ..write('isShippingAddress: $isShippingAddress, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      customerId,
      addressTitle,
      addressType,
      addressLine1,
      addressLine2,
      city,
      state,
      apartment,
      country,
      zipCode,
      contactPerson,
      phoneNumber,
      isYourCompanyAddress,
      isPrimaryAddress,
      isShippingAddress,
      latitude,
      longitude,
      isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Addres &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.customerId == this.customerId &&
          other.addressTitle == this.addressTitle &&
          other.addressType == this.addressType &&
          other.addressLine1 == this.addressLine1 &&
          other.addressLine2 == this.addressLine2 &&
          other.city == this.city &&
          other.state == this.state &&
          other.apartment == this.apartment &&
          other.country == this.country &&
          other.zipCode == this.zipCode &&
          other.contactPerson == this.contactPerson &&
          other.phoneNumber == this.phoneNumber &&
          other.isYourCompanyAddress == this.isYourCompanyAddress &&
          other.isPrimaryAddress == this.isPrimaryAddress &&
          other.isShippingAddress == this.isShippingAddress &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.isDeleted == this.isDeleted);
}

class AddressCompanion extends UpdateCompanion<Addres> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> customerId;
  final Value<String> addressTitle;
  final Value<String> addressType;
  final Value<String> addressLine1;
  final Value<String> addressLine2;
  final Value<String> city;
  final Value<String> state;
  final Value<String> apartment;
  final Value<String> country;
  final Value<String> zipCode;
  final Value<String> contactPerson;
  final Value<String> phoneNumber;
  final Value<bool> isYourCompanyAddress;
  final Value<bool> isPrimaryAddress;
  final Value<bool> isShippingAddress;
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<bool> isDeleted;
  const AddressCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.customerId = const Value.absent(),
    this.addressTitle = const Value.absent(),
    this.addressType = const Value.absent(),
    this.addressLine1 = const Value.absent(),
    this.addressLine2 = const Value.absent(),
    this.city = const Value.absent(),
    this.state = const Value.absent(),
    this.apartment = const Value.absent(),
    this.country = const Value.absent(),
    this.zipCode = const Value.absent(),
    this.contactPerson = const Value.absent(),
    this.phoneNumber = const Value.absent(),
    this.isYourCompanyAddress = const Value.absent(),
    this.isPrimaryAddress = const Value.absent(),
    this.isShippingAddress = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  AddressCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    @required String customerId,
    @required String addressTitle,
    @required String addressType,
    @required String addressLine1,
    @required String addressLine2,
    @required String city,
    @required String state,
    @required String apartment,
    @required String country,
    @required String zipCode,
    @required String contactPerson,
    @required String phoneNumber,
    this.isYourCompanyAddress = const Value.absent(),
    this.isPrimaryAddress = const Value.absent(),
    this.isShippingAddress = const Value.absent(),
    @required double latitude,
    @required double longitude,
    this.isDeleted = const Value.absent(),
  })  : customerId = Value(customerId),
        addressTitle = Value(addressTitle),
        addressType = Value(addressType),
        addressLine1 = Value(addressLine1),
        addressLine2 = Value(addressLine2),
        city = Value(city),
        state = Value(state),
        apartment = Value(apartment),
        country = Value(country),
        zipCode = Value(zipCode),
        contactPerson = Value(contactPerson),
        phoneNumber = Value(phoneNumber),
        latitude = Value(latitude),
        longitude = Value(longitude);
  static Insertable<Addres> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> customerId,
    Expression<String> addressTitle,
    Expression<String> addressType,
    Expression<String> addressLine1,
    Expression<String> addressLine2,
    Expression<String> city,
    Expression<String> state,
    Expression<String> apartment,
    Expression<String> country,
    Expression<String> zipCode,
    Expression<String> contactPerson,
    Expression<String> phoneNumber,
    Expression<bool> isYourCompanyAddress,
    Expression<bool> isPrimaryAddress,
    Expression<bool> isShippingAddress,
    Expression<double> latitude,
    Expression<double> longitude,
    Expression<bool> isDeleted,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (customerId != null) 'customer_id': customerId,
      if (addressTitle != null) 'address_title': addressTitle,
      if (addressType != null) 'address_type': addressType,
      if (addressLine1 != null) 'address_line1': addressLine1,
      if (addressLine2 != null) 'address_line2': addressLine2,
      if (city != null) 'city': city,
      if (state != null) 'state': state,
      if (apartment != null) 'apartment': apartment,
      if (country != null) 'country': country,
      if (zipCode != null) 'zip_code': zipCode,
      if (contactPerson != null) 'contact_person': contactPerson,
      if (phoneNumber != null) 'phone_number': phoneNumber,
      if (isYourCompanyAddress != null)
        'is_your_company_address': isYourCompanyAddress,
      if (isPrimaryAddress != null) 'is_primary_address': isPrimaryAddress,
      if (isShippingAddress != null) 'is_shipping_address': isShippingAddress,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  AddressCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> customerId,
      Value<String> addressTitle,
      Value<String> addressType,
      Value<String> addressLine1,
      Value<String> addressLine2,
      Value<String> city,
      Value<String> state,
      Value<String> apartment,
      Value<String> country,
      Value<String> zipCode,
      Value<String> contactPerson,
      Value<String> phoneNumber,
      Value<bool> isYourCompanyAddress,
      Value<bool> isPrimaryAddress,
      Value<bool> isShippingAddress,
      Value<double> latitude,
      Value<double> longitude,
      Value<bool> isDeleted}) {
    return AddressCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      customerId: customerId ?? this.customerId,
      addressTitle: addressTitle ?? this.addressTitle,
      addressType: addressType ?? this.addressType,
      addressLine1: addressLine1 ?? this.addressLine1,
      addressLine2: addressLine2 ?? this.addressLine2,
      city: city ?? this.city,
      state: state ?? this.state,
      apartment: apartment ?? this.apartment,
      country: country ?? this.country,
      zipCode: zipCode ?? this.zipCode,
      contactPerson: contactPerson ?? this.contactPerson,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      isYourCompanyAddress: isYourCompanyAddress ?? this.isYourCompanyAddress,
      isPrimaryAddress: isPrimaryAddress ?? this.isPrimaryAddress,
      isShippingAddress: isShippingAddress ?? this.isShippingAddress,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (addressTitle.present) {
      map['address_title'] = Variable<String>(addressTitle.value);
    }
    if (addressType.present) {
      map['address_type'] = Variable<String>(addressType.value);
    }
    if (addressLine1.present) {
      map['address_line1'] = Variable<String>(addressLine1.value);
    }
    if (addressLine2.present) {
      map['address_line2'] = Variable<String>(addressLine2.value);
    }
    if (city.present) {
      map['city'] = Variable<String>(city.value);
    }
    if (state.present) {
      map['state'] = Variable<String>(state.value);
    }
    if (apartment.present) {
      map['apartment'] = Variable<String>(apartment.value);
    }
    if (country.present) {
      map['country'] = Variable<String>(country.value);
    }
    if (zipCode.present) {
      map['zip_code'] = Variable<String>(zipCode.value);
    }
    if (contactPerson.present) {
      map['contact_person'] = Variable<String>(contactPerson.value);
    }
    if (phoneNumber.present) {
      map['phone_number'] = Variable<String>(phoneNumber.value);
    }
    if (isYourCompanyAddress.present) {
      map['is_your_company_address'] =
          Variable<bool>(isYourCompanyAddress.value);
    }
    if (isPrimaryAddress.present) {
      map['is_primary_address'] = Variable<bool>(isPrimaryAddress.value);
    }
    if (isShippingAddress.present) {
      map['is_shipping_address'] = Variable<bool>(isShippingAddress.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AddressCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('addressTitle: $addressTitle, ')
          ..write('addressType: $addressType, ')
          ..write('addressLine1: $addressLine1, ')
          ..write('addressLine2: $addressLine2, ')
          ..write('city: $city, ')
          ..write('state: $state, ')
          ..write('apartment: $apartment, ')
          ..write('country: $country, ')
          ..write('zipCode: $zipCode, ')
          ..write('contactPerson: $contactPerson, ')
          ..write('phoneNumber: $phoneNumber, ')
          ..write('isYourCompanyAddress: $isYourCompanyAddress, ')
          ..write('isPrimaryAddress: $isPrimaryAddress, ')
          ..write('isShippingAddress: $isShippingAddress, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $AddressTable extends Address with TableInfo<$AddressTable, Addres> {
  final GeneratedDatabase _db;
  final String _alias;
  $AddressTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _customerIdMeta = const VerificationMeta('customerId');
  GeneratedColumn<String> _customerId;
  @override
  GeneratedColumn<String> get customerId =>
      _customerId ??= GeneratedColumn<String>('customer_id', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _addressTitleMeta =
      const VerificationMeta('addressTitle');
  GeneratedColumn<String> _addressTitle;
  @override
  GeneratedColumn<String> get addressTitle => _addressTitle ??=
      GeneratedColumn<String>('address_title', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _addressTypeMeta =
      const VerificationMeta('addressType');
  GeneratedColumn<String> _addressType;
  @override
  GeneratedColumn<String> get addressType => _addressType ??=
      GeneratedColumn<String>('address_type', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _addressLine1Meta =
      const VerificationMeta('addressLine1');
  GeneratedColumn<String> _addressLine1;
  @override
  GeneratedColumn<String> get addressLine1 => _addressLine1 ??=
      GeneratedColumn<String>('address_line1', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _addressLine2Meta =
      const VerificationMeta('addressLine2');
  GeneratedColumn<String> _addressLine2;
  @override
  GeneratedColumn<String> get addressLine2 => _addressLine2 ??=
      GeneratedColumn<String>('address_line2', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _cityMeta = const VerificationMeta('city');
  GeneratedColumn<String> _city;
  @override
  GeneratedColumn<String> get city =>
      _city ??= GeneratedColumn<String>('city', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _stateMeta = const VerificationMeta('state');
  GeneratedColumn<String> _state;
  @override
  GeneratedColumn<String> get state =>
      _state ??= GeneratedColumn<String>('state', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _apartmentMeta = const VerificationMeta('apartment');
  GeneratedColumn<String> _apartment;
  @override
  GeneratedColumn<String> get apartment =>
      _apartment ??= GeneratedColumn<String>('apartment', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _countryMeta = const VerificationMeta('country');
  GeneratedColumn<String> _country;
  @override
  GeneratedColumn<String> get country =>
      _country ??= GeneratedColumn<String>('country', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _zipCodeMeta = const VerificationMeta('zipCode');
  GeneratedColumn<String> _zipCode;
  @override
  GeneratedColumn<String> get zipCode =>
      _zipCode ??= GeneratedColumn<String>('zip_code', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _contactPersonMeta =
      const VerificationMeta('contactPerson');
  GeneratedColumn<String> _contactPerson;
  @override
  GeneratedColumn<String> get contactPerson => _contactPerson ??=
      GeneratedColumn<String>('contact_person', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _phoneNumberMeta =
      const VerificationMeta('phoneNumber');
  GeneratedColumn<String> _phoneNumber;
  @override
  GeneratedColumn<String> get phoneNumber => _phoneNumber ??=
      GeneratedColumn<String>('phone_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _isYourCompanyAddressMeta =
      const VerificationMeta('isYourCompanyAddress');
  GeneratedColumn<bool> _isYourCompanyAddress;
  @override
  GeneratedColumn<bool> get isYourCompanyAddress => _isYourCompanyAddress ??=
      GeneratedColumn<bool>('is_your_company_address', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_your_company_address IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isPrimaryAddressMeta =
      const VerificationMeta('isPrimaryAddress');
  GeneratedColumn<bool> _isPrimaryAddress;
  @override
  GeneratedColumn<bool> get isPrimaryAddress => _isPrimaryAddress ??=
      GeneratedColumn<bool>('is_primary_address', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_primary_address IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isShippingAddressMeta =
      const VerificationMeta('isShippingAddress');
  GeneratedColumn<bool> _isShippingAddress;
  @override
  GeneratedColumn<bool> get isShippingAddress => _isShippingAddress ??=
      GeneratedColumn<bool>('is_shipping_address', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_shipping_address IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _latitudeMeta = const VerificationMeta('latitude');
  GeneratedColumn<double> _latitude;
  @override
  GeneratedColumn<double> get latitude =>
      _latitude ??= GeneratedColumn<double>('latitude', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _longitudeMeta = const VerificationMeta('longitude');
  GeneratedColumn<double> _longitude;
  @override
  GeneratedColumn<double> get longitude =>
      _longitude ??= GeneratedColumn<double>('longitude', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _isDeletedMeta = const VerificationMeta('isDeleted');
  GeneratedColumn<bool> _isDeleted;
  @override
  GeneratedColumn<bool> get isDeleted =>
      _isDeleted ??= GeneratedColumn<bool>('is_deleted', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_deleted IN (0, 1))',
          defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        customerId,
        addressTitle,
        addressType,
        addressLine1,
        addressLine2,
        city,
        state,
        apartment,
        country,
        zipCode,
        contactPerson,
        phoneNumber,
        isYourCompanyAddress,
        isPrimaryAddress,
        isShippingAddress,
        latitude,
        longitude,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? 'address';
  @override
  String get actualTableName => 'address';
  @override
  VerificationContext validateIntegrity(Insertable<Addres> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id'], _customerIdMeta));
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('address_title')) {
      context.handle(
          _addressTitleMeta,
          addressTitle.isAcceptableOrUnknown(
              data['address_title'], _addressTitleMeta));
    } else if (isInserting) {
      context.missing(_addressTitleMeta);
    }
    if (data.containsKey('address_type')) {
      context.handle(
          _addressTypeMeta,
          addressType.isAcceptableOrUnknown(
              data['address_type'], _addressTypeMeta));
    } else if (isInserting) {
      context.missing(_addressTypeMeta);
    }
    if (data.containsKey('address_line1')) {
      context.handle(
          _addressLine1Meta,
          addressLine1.isAcceptableOrUnknown(
              data['address_line1'], _addressLine1Meta));
    } else if (isInserting) {
      context.missing(_addressLine1Meta);
    }
    if (data.containsKey('address_line2')) {
      context.handle(
          _addressLine2Meta,
          addressLine2.isAcceptableOrUnknown(
              data['address_line2'], _addressLine2Meta));
    } else if (isInserting) {
      context.missing(_addressLine2Meta);
    }
    if (data.containsKey('city')) {
      context.handle(
          _cityMeta, city.isAcceptableOrUnknown(data['city'], _cityMeta));
    } else if (isInserting) {
      context.missing(_cityMeta);
    }
    if (data.containsKey('state')) {
      context.handle(
          _stateMeta, state.isAcceptableOrUnknown(data['state'], _stateMeta));
    } else if (isInserting) {
      context.missing(_stateMeta);
    }
    if (data.containsKey('apartment')) {
      context.handle(_apartmentMeta,
          apartment.isAcceptableOrUnknown(data['apartment'], _apartmentMeta));
    } else if (isInserting) {
      context.missing(_apartmentMeta);
    }
    if (data.containsKey('country')) {
      context.handle(_countryMeta,
          country.isAcceptableOrUnknown(data['country'], _countryMeta));
    } else if (isInserting) {
      context.missing(_countryMeta);
    }
    if (data.containsKey('zip_code')) {
      context.handle(_zipCodeMeta,
          zipCode.isAcceptableOrUnknown(data['zip_code'], _zipCodeMeta));
    } else if (isInserting) {
      context.missing(_zipCodeMeta);
    }
    if (data.containsKey('contact_person')) {
      context.handle(
          _contactPersonMeta,
          contactPerson.isAcceptableOrUnknown(
              data['contact_person'], _contactPersonMeta));
    } else if (isInserting) {
      context.missing(_contactPersonMeta);
    }
    if (data.containsKey('phone_number')) {
      context.handle(
          _phoneNumberMeta,
          phoneNumber.isAcceptableOrUnknown(
              data['phone_number'], _phoneNumberMeta));
    } else if (isInserting) {
      context.missing(_phoneNumberMeta);
    }
    if (data.containsKey('is_your_company_address')) {
      context.handle(
          _isYourCompanyAddressMeta,
          isYourCompanyAddress.isAcceptableOrUnknown(
              data['is_your_company_address'], _isYourCompanyAddressMeta));
    }
    if (data.containsKey('is_primary_address')) {
      context.handle(
          _isPrimaryAddressMeta,
          isPrimaryAddress.isAcceptableOrUnknown(
              data['is_primary_address'], _isPrimaryAddressMeta));
    }
    if (data.containsKey('is_shipping_address')) {
      context.handle(
          _isShippingAddressMeta,
          isShippingAddress.isAcceptableOrUnknown(
              data['is_shipping_address'], _isShippingAddressMeta));
    }
    if (data.containsKey('latitude')) {
      context.handle(_latitudeMeta,
          latitude.isAcceptableOrUnknown(data['latitude'], _latitudeMeta));
    } else if (isInserting) {
      context.missing(_latitudeMeta);
    }
    if (data.containsKey('longitude')) {
      context.handle(_longitudeMeta,
          longitude.isAcceptableOrUnknown(data['longitude'], _longitudeMeta));
    } else if (isInserting) {
      context.missing(_longitudeMeta);
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted'], _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Addres map(Map<String, dynamic> data, {String tablePrefix}) {
    return Addres.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $AddressTable createAlias(String alias) {
    return $AddressTable(_db, alias);
  }
}

class ContactData extends DataClass implements Insertable<ContactData> {
  final int tenantId;
  final int id;
  final String contactTitle;
  final String customerId;
  final String contactPerson;
  final String workNumber;
  final String cellNumber;
  final String whatappNumber;
  final bool isYourCompanyContact;
  final bool isPrimaryContact;
  final bool isUserContact;
  final String userName;
  ContactData(
      {this.tenantId,
      @required this.id,
      @required this.contactTitle,
      @required this.customerId,
      @required this.contactPerson,
      @required this.workNumber,
      @required this.cellNumber,
      @required this.whatappNumber,
      @required this.isYourCompanyContact,
      @required this.isPrimaryContact,
      @required this.isUserContact,
      @required this.userName});
  factory ContactData.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return ContactData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      contactTitle: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}contact_title']),
      customerId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_id']),
      contactPerson: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}contact_person']),
      workNumber: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}work_number']),
      cellNumber: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}cell_number']),
      whatappNumber: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}whatapp_number']),
      isYourCompanyContact: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}is_your_company_contact']),
      isPrimaryContact: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}is_primary_contact']),
      isUserContact: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_user_contact']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || contactTitle != null) {
      map['contact_title'] = Variable<String>(contactTitle);
    }
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || contactPerson != null) {
      map['contact_person'] = Variable<String>(contactPerson);
    }
    if (!nullToAbsent || workNumber != null) {
      map['work_number'] = Variable<String>(workNumber);
    }
    if (!nullToAbsent || cellNumber != null) {
      map['cell_number'] = Variable<String>(cellNumber);
    }
    if (!nullToAbsent || whatappNumber != null) {
      map['whatapp_number'] = Variable<String>(whatappNumber);
    }
    if (!nullToAbsent || isYourCompanyContact != null) {
      map['is_your_company_contact'] = Variable<bool>(isYourCompanyContact);
    }
    if (!nullToAbsent || isPrimaryContact != null) {
      map['is_primary_contact'] = Variable<bool>(isPrimaryContact);
    }
    if (!nullToAbsent || isUserContact != null) {
      map['is_user_contact'] = Variable<bool>(isUserContact);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    return map;
  }

  ContactCompanion toCompanion(bool nullToAbsent) {
    return ContactCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      contactTitle: contactTitle == null && nullToAbsent
          ? const Value.absent()
          : Value(contactTitle),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      contactPerson: contactPerson == null && nullToAbsent
          ? const Value.absent()
          : Value(contactPerson),
      workNumber: workNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(workNumber),
      cellNumber: cellNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(cellNumber),
      whatappNumber: whatappNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(whatappNumber),
      isYourCompanyContact: isYourCompanyContact == null && nullToAbsent
          ? const Value.absent()
          : Value(isYourCompanyContact),
      isPrimaryContact: isPrimaryContact == null && nullToAbsent
          ? const Value.absent()
          : Value(isPrimaryContact),
      isUserContact: isUserContact == null && nullToAbsent
          ? const Value.absent()
          : Value(isUserContact),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
    );
  }

  factory ContactData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ContactData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      contactTitle: serializer.fromJson<String>(json['contactTitle']),
      customerId: serializer.fromJson<String>(json['customerId']),
      contactPerson: serializer.fromJson<String>(json['contactPerson']),
      workNumber: serializer.fromJson<String>(json['workNumber']),
      cellNumber: serializer.fromJson<String>(json['cellNumber']),
      whatappNumber: serializer.fromJson<String>(json['whatappNumber']),
      isYourCompanyContact:
          serializer.fromJson<bool>(json['isYourCompanyContact']),
      isPrimaryContact: serializer.fromJson<bool>(json['isPrimaryContact']),
      isUserContact: serializer.fromJson<bool>(json['isUserContact']),
      userName: serializer.fromJson<String>(json['userName']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'contactTitle': serializer.toJson<String>(contactTitle),
      'customerId': serializer.toJson<String>(customerId),
      'contactPerson': serializer.toJson<String>(contactPerson),
      'workNumber': serializer.toJson<String>(workNumber),
      'cellNumber': serializer.toJson<String>(cellNumber),
      'whatappNumber': serializer.toJson<String>(whatappNumber),
      'isYourCompanyContact': serializer.toJson<bool>(isYourCompanyContact),
      'isPrimaryContact': serializer.toJson<bool>(isPrimaryContact),
      'isUserContact': serializer.toJson<bool>(isUserContact),
      'userName': serializer.toJson<String>(userName),
    };
  }

  ContactData copyWith(
          {int tenantId,
          int id,
          String contactTitle,
          String customerId,
          String contactPerson,
          String workNumber,
          String cellNumber,
          String whatappNumber,
          bool isYourCompanyContact,
          bool isPrimaryContact,
          bool isUserContact,
          String userName}) =>
      ContactData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        contactTitle: contactTitle ?? this.contactTitle,
        customerId: customerId ?? this.customerId,
        contactPerson: contactPerson ?? this.contactPerson,
        workNumber: workNumber ?? this.workNumber,
        cellNumber: cellNumber ?? this.cellNumber,
        whatappNumber: whatappNumber ?? this.whatappNumber,
        isYourCompanyContact: isYourCompanyContact ?? this.isYourCompanyContact,
        isPrimaryContact: isPrimaryContact ?? this.isPrimaryContact,
        isUserContact: isUserContact ?? this.isUserContact,
        userName: userName ?? this.userName,
      );
  @override
  String toString() {
    return (StringBuffer('ContactData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('contactTitle: $contactTitle, ')
          ..write('customerId: $customerId, ')
          ..write('contactPerson: $contactPerson, ')
          ..write('workNumber: $workNumber, ')
          ..write('cellNumber: $cellNumber, ')
          ..write('whatappNumber: $whatappNumber, ')
          ..write('isYourCompanyContact: $isYourCompanyContact, ')
          ..write('isPrimaryContact: $isPrimaryContact, ')
          ..write('isUserContact: $isUserContact, ')
          ..write('userName: $userName')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      contactTitle,
      customerId,
      contactPerson,
      workNumber,
      cellNumber,
      whatappNumber,
      isYourCompanyContact,
      isPrimaryContact,
      isUserContact,
      userName);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ContactData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.contactTitle == this.contactTitle &&
          other.customerId == this.customerId &&
          other.contactPerson == this.contactPerson &&
          other.workNumber == this.workNumber &&
          other.cellNumber == this.cellNumber &&
          other.whatappNumber == this.whatappNumber &&
          other.isYourCompanyContact == this.isYourCompanyContact &&
          other.isPrimaryContact == this.isPrimaryContact &&
          other.isUserContact == this.isUserContact &&
          other.userName == this.userName);
}

class ContactCompanion extends UpdateCompanion<ContactData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> contactTitle;
  final Value<String> customerId;
  final Value<String> contactPerson;
  final Value<String> workNumber;
  final Value<String> cellNumber;
  final Value<String> whatappNumber;
  final Value<bool> isYourCompanyContact;
  final Value<bool> isPrimaryContact;
  final Value<bool> isUserContact;
  final Value<String> userName;
  const ContactCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.contactTitle = const Value.absent(),
    this.customerId = const Value.absent(),
    this.contactPerson = const Value.absent(),
    this.workNumber = const Value.absent(),
    this.cellNumber = const Value.absent(),
    this.whatappNumber = const Value.absent(),
    this.isYourCompanyContact = const Value.absent(),
    this.isPrimaryContact = const Value.absent(),
    this.isUserContact = const Value.absent(),
    this.userName = const Value.absent(),
  });
  ContactCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    @required String contactTitle,
    @required String customerId,
    @required String contactPerson,
    @required String workNumber,
    @required String cellNumber,
    @required String whatappNumber,
    this.isYourCompanyContact = const Value.absent(),
    this.isPrimaryContact = const Value.absent(),
    this.isUserContact = const Value.absent(),
    @required String userName,
  })  : contactTitle = Value(contactTitle),
        customerId = Value(customerId),
        contactPerson = Value(contactPerson),
        workNumber = Value(workNumber),
        cellNumber = Value(cellNumber),
        whatappNumber = Value(whatappNumber),
        userName = Value(userName);
  static Insertable<ContactData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> contactTitle,
    Expression<String> customerId,
    Expression<String> contactPerson,
    Expression<String> workNumber,
    Expression<String> cellNumber,
    Expression<String> whatappNumber,
    Expression<bool> isYourCompanyContact,
    Expression<bool> isPrimaryContact,
    Expression<bool> isUserContact,
    Expression<String> userName,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (contactTitle != null) 'contact_title': contactTitle,
      if (customerId != null) 'customer_id': customerId,
      if (contactPerson != null) 'contact_person': contactPerson,
      if (workNumber != null) 'work_number': workNumber,
      if (cellNumber != null) 'cell_number': cellNumber,
      if (whatappNumber != null) 'whatapp_number': whatappNumber,
      if (isYourCompanyContact != null)
        'is_your_company_contact': isYourCompanyContact,
      if (isPrimaryContact != null) 'is_primary_contact': isPrimaryContact,
      if (isUserContact != null) 'is_user_contact': isUserContact,
      if (userName != null) 'user_name': userName,
    });
  }

  ContactCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> contactTitle,
      Value<String> customerId,
      Value<String> contactPerson,
      Value<String> workNumber,
      Value<String> cellNumber,
      Value<String> whatappNumber,
      Value<bool> isYourCompanyContact,
      Value<bool> isPrimaryContact,
      Value<bool> isUserContact,
      Value<String> userName}) {
    return ContactCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      contactTitle: contactTitle ?? this.contactTitle,
      customerId: customerId ?? this.customerId,
      contactPerson: contactPerson ?? this.contactPerson,
      workNumber: workNumber ?? this.workNumber,
      cellNumber: cellNumber ?? this.cellNumber,
      whatappNumber: whatappNumber ?? this.whatappNumber,
      isYourCompanyContact: isYourCompanyContact ?? this.isYourCompanyContact,
      isPrimaryContact: isPrimaryContact ?? this.isPrimaryContact,
      isUserContact: isUserContact ?? this.isUserContact,
      userName: userName ?? this.userName,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (contactTitle.present) {
      map['contact_title'] = Variable<String>(contactTitle.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (contactPerson.present) {
      map['contact_person'] = Variable<String>(contactPerson.value);
    }
    if (workNumber.present) {
      map['work_number'] = Variable<String>(workNumber.value);
    }
    if (cellNumber.present) {
      map['cell_number'] = Variable<String>(cellNumber.value);
    }
    if (whatappNumber.present) {
      map['whatapp_number'] = Variable<String>(whatappNumber.value);
    }
    if (isYourCompanyContact.present) {
      map['is_your_company_contact'] =
          Variable<bool>(isYourCompanyContact.value);
    }
    if (isPrimaryContact.present) {
      map['is_primary_contact'] = Variable<bool>(isPrimaryContact.value);
    }
    if (isUserContact.present) {
      map['is_user_contact'] = Variable<bool>(isUserContact.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ContactCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('contactTitle: $contactTitle, ')
          ..write('customerId: $customerId, ')
          ..write('contactPerson: $contactPerson, ')
          ..write('workNumber: $workNumber, ')
          ..write('cellNumber: $cellNumber, ')
          ..write('whatappNumber: $whatappNumber, ')
          ..write('isYourCompanyContact: $isYourCompanyContact, ')
          ..write('isPrimaryContact: $isPrimaryContact, ')
          ..write('isUserContact: $isUserContact, ')
          ..write('userName: $userName')
          ..write(')'))
        .toString();
  }
}

class $ContactTable extends Contact with TableInfo<$ContactTable, ContactData> {
  final GeneratedDatabase _db;
  final String _alias;
  $ContactTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _contactTitleMeta =
      const VerificationMeta('contactTitle');
  GeneratedColumn<String> _contactTitle;
  @override
  GeneratedColumn<String> get contactTitle => _contactTitle ??=
      GeneratedColumn<String>('contact_title', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _customerIdMeta = const VerificationMeta('customerId');
  GeneratedColumn<String> _customerId;
  @override
  GeneratedColumn<String> get customerId =>
      _customerId ??= GeneratedColumn<String>('customer_id', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _contactPersonMeta =
      const VerificationMeta('contactPerson');
  GeneratedColumn<String> _contactPerson;
  @override
  GeneratedColumn<String> get contactPerson => _contactPerson ??=
      GeneratedColumn<String>('contact_person', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _workNumberMeta = const VerificationMeta('workNumber');
  GeneratedColumn<String> _workNumber;
  @override
  GeneratedColumn<String> get workNumber =>
      _workNumber ??= GeneratedColumn<String>('work_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _cellNumberMeta = const VerificationMeta('cellNumber');
  GeneratedColumn<String> _cellNumber;
  @override
  GeneratedColumn<String> get cellNumber =>
      _cellNumber ??= GeneratedColumn<String>('cell_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _whatappNumberMeta =
      const VerificationMeta('whatappNumber');
  GeneratedColumn<String> _whatappNumber;
  @override
  GeneratedColumn<String> get whatappNumber => _whatappNumber ??=
      GeneratedColumn<String>('whatapp_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _isYourCompanyContactMeta =
      const VerificationMeta('isYourCompanyContact');
  GeneratedColumn<bool> _isYourCompanyContact;
  @override
  GeneratedColumn<bool> get isYourCompanyContact => _isYourCompanyContact ??=
      GeneratedColumn<bool>('is_your_company_contact', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_your_company_contact IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isPrimaryContactMeta =
      const VerificationMeta('isPrimaryContact');
  GeneratedColumn<bool> _isPrimaryContact;
  @override
  GeneratedColumn<bool> get isPrimaryContact => _isPrimaryContact ??=
      GeneratedColumn<bool>('is_primary_contact', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_primary_contact IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isUserContactMeta =
      const VerificationMeta('isUserContact');
  GeneratedColumn<bool> _isUserContact;
  @override
  GeneratedColumn<bool> get isUserContact => _isUserContact ??=
      GeneratedColumn<bool>('is_user_contact', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_user_contact IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        contactTitle,
        customerId,
        contactPerson,
        workNumber,
        cellNumber,
        whatappNumber,
        isYourCompanyContact,
        isPrimaryContact,
        isUserContact,
        userName
      ];
  @override
  String get aliasedName => _alias ?? 'contact';
  @override
  String get actualTableName => 'contact';
  @override
  VerificationContext validateIntegrity(Insertable<ContactData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('contact_title')) {
      context.handle(
          _contactTitleMeta,
          contactTitle.isAcceptableOrUnknown(
              data['contact_title'], _contactTitleMeta));
    } else if (isInserting) {
      context.missing(_contactTitleMeta);
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id'], _customerIdMeta));
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('contact_person')) {
      context.handle(
          _contactPersonMeta,
          contactPerson.isAcceptableOrUnknown(
              data['contact_person'], _contactPersonMeta));
    } else if (isInserting) {
      context.missing(_contactPersonMeta);
    }
    if (data.containsKey('work_number')) {
      context.handle(
          _workNumberMeta,
          workNumber.isAcceptableOrUnknown(
              data['work_number'], _workNumberMeta));
    } else if (isInserting) {
      context.missing(_workNumberMeta);
    }
    if (data.containsKey('cell_number')) {
      context.handle(
          _cellNumberMeta,
          cellNumber.isAcceptableOrUnknown(
              data['cell_number'], _cellNumberMeta));
    } else if (isInserting) {
      context.missing(_cellNumberMeta);
    }
    if (data.containsKey('whatapp_number')) {
      context.handle(
          _whatappNumberMeta,
          whatappNumber.isAcceptableOrUnknown(
              data['whatapp_number'], _whatappNumberMeta));
    } else if (isInserting) {
      context.missing(_whatappNumberMeta);
    }
    if (data.containsKey('is_your_company_contact')) {
      context.handle(
          _isYourCompanyContactMeta,
          isYourCompanyContact.isAcceptableOrUnknown(
              data['is_your_company_contact'], _isYourCompanyContactMeta));
    }
    if (data.containsKey('is_primary_contact')) {
      context.handle(
          _isPrimaryContactMeta,
          isPrimaryContact.isAcceptableOrUnknown(
              data['is_primary_contact'], _isPrimaryContactMeta));
    }
    if (data.containsKey('is_user_contact')) {
      context.handle(
          _isUserContactMeta,
          isUserContact.isAcceptableOrUnknown(
              data['is_user_contact'], _isUserContactMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    } else if (isInserting) {
      context.missing(_userNameMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ContactData map(Map<String, dynamic> data, {String tablePrefix}) {
    return ContactData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $ContactTable createAlias(String alias) {
    return $ContactTable(_db, alias);
  }
}

class Item extends DataClass implements Insertable<Item> {
  final int tenantId;
  final int id;
  final String itemId;
  final String description;
  final String itemCode;
  final String itemName;
  final String itemGroup;
  final String taxGroup;
  final String uom;
  final bool trackInventory;
  final String category;
  final bool isProductBundleParent;
  final bool isQuickMenue;
  final bool isRetired;
  final DateTime retiredDate;
  final bool hasVariant;
  final String defaultWarehouse;
  final bool isDeleted;
  Item(
      {this.tenantId,
      @required this.id,
      @required this.itemId,
      this.description,
      this.itemCode,
      this.itemName,
      this.itemGroup,
      this.taxGroup,
      this.uom,
      @required this.trackInventory,
      this.category,
      @required this.isProductBundleParent,
      @required this.isQuickMenue,
      @required this.isRetired,
      this.retiredDate,
      @required this.hasVariant,
      this.defaultWarehouse,
      @required this.isDeleted});
  factory Item.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return Item(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      itemId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_id']),
      description: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}description']),
      itemCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_code']),
      itemName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_name']),
      itemGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_group']),
      taxGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tax_group']),
      uom: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}uom']),
      trackInventory: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}track_inventory']),
      category: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}category']),
      isProductBundleParent: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}is_product_bundle_parent']),
      isQuickMenue: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_quick_menue']),
      isRetired: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_retired']),
      retiredDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}retired_date']),
      hasVariant: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}has_variant']),
      defaultWarehouse: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}default_warehouse']),
      isDeleted: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_deleted']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || itemName != null) {
      map['item_name'] = Variable<String>(itemName);
    }
    if (!nullToAbsent || itemGroup != null) {
      map['item_group'] = Variable<String>(itemGroup);
    }
    if (!nullToAbsent || taxGroup != null) {
      map['tax_group'] = Variable<String>(taxGroup);
    }
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    if (!nullToAbsent || trackInventory != null) {
      map['track_inventory'] = Variable<bool>(trackInventory);
    }
    if (!nullToAbsent || category != null) {
      map['category'] = Variable<String>(category);
    }
    if (!nullToAbsent || isProductBundleParent != null) {
      map['is_product_bundle_parent'] = Variable<bool>(isProductBundleParent);
    }
    if (!nullToAbsent || isQuickMenue != null) {
      map['is_quick_menue'] = Variable<bool>(isQuickMenue);
    }
    if (!nullToAbsent || isRetired != null) {
      map['is_retired'] = Variable<bool>(isRetired);
    }
    if (!nullToAbsent || retiredDate != null) {
      map['retired_date'] = Variable<DateTime>(retiredDate);
    }
    if (!nullToAbsent || hasVariant != null) {
      map['has_variant'] = Variable<bool>(hasVariant);
    }
    if (!nullToAbsent || defaultWarehouse != null) {
      map['default_warehouse'] = Variable<String>(defaultWarehouse);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    return map;
  }

  ItemsCompanion toCompanion(bool nullToAbsent) {
    return ItemsCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      itemName: itemName == null && nullToAbsent
          ? const Value.absent()
          : Value(itemName),
      itemGroup: itemGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(itemGroup),
      taxGroup: taxGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(taxGroup),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
      trackInventory: trackInventory == null && nullToAbsent
          ? const Value.absent()
          : Value(trackInventory),
      category: category == null && nullToAbsent
          ? const Value.absent()
          : Value(category),
      isProductBundleParent: isProductBundleParent == null && nullToAbsent
          ? const Value.absent()
          : Value(isProductBundleParent),
      isQuickMenue: isQuickMenue == null && nullToAbsent
          ? const Value.absent()
          : Value(isQuickMenue),
      isRetired: isRetired == null && nullToAbsent
          ? const Value.absent()
          : Value(isRetired),
      retiredDate: retiredDate == null && nullToAbsent
          ? const Value.absent()
          : Value(retiredDate),
      hasVariant: hasVariant == null && nullToAbsent
          ? const Value.absent()
          : Value(hasVariant),
      defaultWarehouse: defaultWarehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultWarehouse),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
    );
  }

  factory Item.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Item(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<String>(json['itemId']),
      description: serializer.fromJson<String>(json['description']),
      itemCode: serializer.fromJson<String>(json['itemCode']),
      itemName: serializer.fromJson<String>(json['itemName']),
      itemGroup: serializer.fromJson<String>(json['itemGroup']),
      taxGroup: serializer.fromJson<String>(json['taxGroup']),
      uom: serializer.fromJson<String>(json['uom']),
      trackInventory: serializer.fromJson<bool>(json['trackInventory']),
      category: serializer.fromJson<String>(json['category']),
      isProductBundleParent:
          serializer.fromJson<bool>(json['isProductBundleParent']),
      isQuickMenue: serializer.fromJson<bool>(json['isQuickMenue']),
      isRetired: serializer.fromJson<bool>(json['isRetired']),
      retiredDate: serializer.fromJson<DateTime>(json['retiredDate']),
      hasVariant: serializer.fromJson<bool>(json['hasVariant']),
      defaultWarehouse: serializer.fromJson<String>(json['defaultWarehouse']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemId': serializer.toJson<String>(itemId),
      'description': serializer.toJson<String>(description),
      'itemCode': serializer.toJson<String>(itemCode),
      'itemName': serializer.toJson<String>(itemName),
      'itemGroup': serializer.toJson<String>(itemGroup),
      'taxGroup': serializer.toJson<String>(taxGroup),
      'uom': serializer.toJson<String>(uom),
      'trackInventory': serializer.toJson<bool>(trackInventory),
      'category': serializer.toJson<String>(category),
      'isProductBundleParent': serializer.toJson<bool>(isProductBundleParent),
      'isQuickMenue': serializer.toJson<bool>(isQuickMenue),
      'isRetired': serializer.toJson<bool>(isRetired),
      'retiredDate': serializer.toJson<DateTime>(retiredDate),
      'hasVariant': serializer.toJson<bool>(hasVariant),
      'defaultWarehouse': serializer.toJson<String>(defaultWarehouse),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  Item copyWith(
          {int tenantId,
          int id,
          String itemId,
          String description,
          String itemCode,
          String itemName,
          String itemGroup,
          String taxGroup,
          String uom,
          bool trackInventory,
          String category,
          bool isProductBundleParent,
          bool isQuickMenue,
          bool isRetired,
          DateTime retiredDate,
          bool hasVariant,
          String defaultWarehouse,
          bool isDeleted}) =>
      Item(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        description: description ?? this.description,
        itemCode: itemCode ?? this.itemCode,
        itemName: itemName ?? this.itemName,
        itemGroup: itemGroup ?? this.itemGroup,
        taxGroup: taxGroup ?? this.taxGroup,
        uom: uom ?? this.uom,
        trackInventory: trackInventory ?? this.trackInventory,
        category: category ?? this.category,
        isProductBundleParent:
            isProductBundleParent ?? this.isProductBundleParent,
        isQuickMenue: isQuickMenue ?? this.isQuickMenue,
        isRetired: isRetired ?? this.isRetired,
        retiredDate: retiredDate ?? this.retiredDate,
        hasVariant: hasVariant ?? this.hasVariant,
        defaultWarehouse: defaultWarehouse ?? this.defaultWarehouse,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  @override
  String toString() {
    return (StringBuffer('Item(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('description: $description, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('uom: $uom, ')
          ..write('trackInventory: $trackInventory, ')
          ..write('category: $category, ')
          ..write('isProductBundleParent: $isProductBundleParent, ')
          ..write('isQuickMenue: $isQuickMenue, ')
          ..write('isRetired: $isRetired, ')
          ..write('retiredDate: $retiredDate, ')
          ..write('hasVariant: $hasVariant, ')
          ..write('defaultWarehouse: $defaultWarehouse, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      itemId,
      description,
      itemCode,
      itemName,
      itemGroup,
      taxGroup,
      uom,
      trackInventory,
      category,
      isProductBundleParent,
      isQuickMenue,
      isRetired,
      retiredDate,
      hasVariant,
      defaultWarehouse,
      isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Item &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.description == this.description &&
          other.itemCode == this.itemCode &&
          other.itemName == this.itemName &&
          other.itemGroup == this.itemGroup &&
          other.taxGroup == this.taxGroup &&
          other.uom == this.uom &&
          other.trackInventory == this.trackInventory &&
          other.category == this.category &&
          other.isProductBundleParent == this.isProductBundleParent &&
          other.isQuickMenue == this.isQuickMenue &&
          other.isRetired == this.isRetired &&
          other.retiredDate == this.retiredDate &&
          other.hasVariant == this.hasVariant &&
          other.defaultWarehouse == this.defaultWarehouse &&
          other.isDeleted == this.isDeleted);
}

class ItemsCompanion extends UpdateCompanion<Item> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> itemId;
  final Value<String> description;
  final Value<String> itemCode;
  final Value<String> itemName;
  final Value<String> itemGroup;
  final Value<String> taxGroup;
  final Value<String> uom;
  final Value<bool> trackInventory;
  final Value<String> category;
  final Value<bool> isProductBundleParent;
  final Value<bool> isQuickMenue;
  final Value<bool> isRetired;
  final Value<DateTime> retiredDate;
  final Value<bool> hasVariant;
  final Value<String> defaultWarehouse;
  final Value<bool> isDeleted;
  const ItemsCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.description = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.taxGroup = const Value.absent(),
    this.uom = const Value.absent(),
    this.trackInventory = const Value.absent(),
    this.category = const Value.absent(),
    this.isProductBundleParent = const Value.absent(),
    this.isQuickMenue = const Value.absent(),
    this.isRetired = const Value.absent(),
    this.retiredDate = const Value.absent(),
    this.hasVariant = const Value.absent(),
    this.defaultWarehouse = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  ItemsCompanion.insert({
    this.tenantId = const Value.absent(),
    @required int id,
    @required String itemId,
    this.description = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.taxGroup = const Value.absent(),
    this.uom = const Value.absent(),
    this.trackInventory = const Value.absent(),
    this.category = const Value.absent(),
    this.isProductBundleParent = const Value.absent(),
    this.isQuickMenue = const Value.absent(),
    this.isRetired = const Value.absent(),
    this.retiredDate = const Value.absent(),
    this.hasVariant = const Value.absent(),
    this.defaultWarehouse = const Value.absent(),
    this.isDeleted = const Value.absent(),
  })  : id = Value(id),
        itemId = Value(itemId);
  static Insertable<Item> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> itemId,
    Expression<String> description,
    Expression<String> itemCode,
    Expression<String> itemName,
    Expression<String> itemGroup,
    Expression<String> taxGroup,
    Expression<String> uom,
    Expression<bool> trackInventory,
    Expression<String> category,
    Expression<bool> isProductBundleParent,
    Expression<bool> isQuickMenue,
    Expression<bool> isRetired,
    Expression<DateTime> retiredDate,
    Expression<bool> hasVariant,
    Expression<String> defaultWarehouse,
    Expression<bool> isDeleted,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (description != null) 'description': description,
      if (itemCode != null) 'item_code': itemCode,
      if (itemName != null) 'item_name': itemName,
      if (itemGroup != null) 'item_group': itemGroup,
      if (taxGroup != null) 'tax_group': taxGroup,
      if (uom != null) 'uom': uom,
      if (trackInventory != null) 'track_inventory': trackInventory,
      if (category != null) 'category': category,
      if (isProductBundleParent != null)
        'is_product_bundle_parent': isProductBundleParent,
      if (isQuickMenue != null) 'is_quick_menue': isQuickMenue,
      if (isRetired != null) 'is_retired': isRetired,
      if (retiredDate != null) 'retired_date': retiredDate,
      if (hasVariant != null) 'has_variant': hasVariant,
      if (defaultWarehouse != null) 'default_warehouse': defaultWarehouse,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  ItemsCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> itemId,
      Value<String> description,
      Value<String> itemCode,
      Value<String> itemName,
      Value<String> itemGroup,
      Value<String> taxGroup,
      Value<String> uom,
      Value<bool> trackInventory,
      Value<String> category,
      Value<bool> isProductBundleParent,
      Value<bool> isQuickMenue,
      Value<bool> isRetired,
      Value<DateTime> retiredDate,
      Value<bool> hasVariant,
      Value<String> defaultWarehouse,
      Value<bool> isDeleted}) {
    return ItemsCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      description: description ?? this.description,
      itemCode: itemCode ?? this.itemCode,
      itemName: itemName ?? this.itemName,
      itemGroup: itemGroup ?? this.itemGroup,
      taxGroup: taxGroup ?? this.taxGroup,
      uom: uom ?? this.uom,
      trackInventory: trackInventory ?? this.trackInventory,
      category: category ?? this.category,
      isProductBundleParent:
          isProductBundleParent ?? this.isProductBundleParent,
      isQuickMenue: isQuickMenue ?? this.isQuickMenue,
      isRetired: isRetired ?? this.isRetired,
      retiredDate: retiredDate ?? this.retiredDate,
      hasVariant: hasVariant ?? this.hasVariant,
      defaultWarehouse: defaultWarehouse ?? this.defaultWarehouse,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (itemName.present) {
      map['item_name'] = Variable<String>(itemName.value);
    }
    if (itemGroup.present) {
      map['item_group'] = Variable<String>(itemGroup.value);
    }
    if (taxGroup.present) {
      map['tax_group'] = Variable<String>(taxGroup.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    if (trackInventory.present) {
      map['track_inventory'] = Variable<bool>(trackInventory.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (isProductBundleParent.present) {
      map['is_product_bundle_parent'] =
          Variable<bool>(isProductBundleParent.value);
    }
    if (isQuickMenue.present) {
      map['is_quick_menue'] = Variable<bool>(isQuickMenue.value);
    }
    if (isRetired.present) {
      map['is_retired'] = Variable<bool>(isRetired.value);
    }
    if (retiredDate.present) {
      map['retired_date'] = Variable<DateTime>(retiredDate.value);
    }
    if (hasVariant.present) {
      map['has_variant'] = Variable<bool>(hasVariant.value);
    }
    if (defaultWarehouse.present) {
      map['default_warehouse'] = Variable<String>(defaultWarehouse.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemsCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('description: $description, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('taxGroup: $taxGroup, ')
          ..write('uom: $uom, ')
          ..write('trackInventory: $trackInventory, ')
          ..write('category: $category, ')
          ..write('isProductBundleParent: $isProductBundleParent, ')
          ..write('isQuickMenue: $isQuickMenue, ')
          ..write('isRetired: $isRetired, ')
          ..write('retiredDate: $retiredDate, ')
          ..write('hasVariant: $hasVariant, ')
          ..write('defaultWarehouse: $defaultWarehouse, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $ItemsTable extends Items with TableInfo<$ItemsTable, Item> {
  final GeneratedDatabase _db;
  final String _alias;
  $ItemsTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  GeneratedColumn<String> _itemId;
  @override
  GeneratedColumn<String> get itemId =>
      _itemId ??= GeneratedColumn<String>('item_id', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  GeneratedColumn<String> _description;
  @override
  GeneratedColumn<String> get description =>
      _description ??= GeneratedColumn<String>('description', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemCodeMeta = const VerificationMeta('itemCode');
  GeneratedColumn<String> _itemCode;
  @override
  GeneratedColumn<String> get itemCode =>
      _itemCode ??= GeneratedColumn<String>('item_code', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemNameMeta = const VerificationMeta('itemName');
  GeneratedColumn<String> _itemName;
  @override
  GeneratedColumn<String> get itemName =>
      _itemName ??= GeneratedColumn<String>('item_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemGroupMeta = const VerificationMeta('itemGroup');
  GeneratedColumn<String> _itemGroup;
  @override
  GeneratedColumn<String> get itemGroup =>
      _itemGroup ??= GeneratedColumn<String>('item_group', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _taxGroupMeta = const VerificationMeta('taxGroup');
  GeneratedColumn<String> _taxGroup;
  @override
  GeneratedColumn<String> get taxGroup =>
      _taxGroup ??= GeneratedColumn<String>('tax_group', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _uomMeta = const VerificationMeta('uom');
  GeneratedColumn<String> _uom;
  @override
  GeneratedColumn<String> get uom =>
      _uom ??= GeneratedColumn<String>('uom', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _trackInventoryMeta =
      const VerificationMeta('trackInventory');
  GeneratedColumn<bool> _trackInventory;
  @override
  GeneratedColumn<bool> get trackInventory => _trackInventory ??=
      GeneratedColumn<bool>('track_inventory', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (track_inventory IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _categoryMeta = const VerificationMeta('category');
  GeneratedColumn<String> _category;
  @override
  GeneratedColumn<String> get category =>
      _category ??= GeneratedColumn<String>('category', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isProductBundleParentMeta =
      const VerificationMeta('isProductBundleParent');
  GeneratedColumn<bool> _isProductBundleParent;
  @override
  GeneratedColumn<bool> get isProductBundleParent => _isProductBundleParent ??=
      GeneratedColumn<bool>('is_product_bundle_parent', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_product_bundle_parent IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isQuickMenueMeta =
      const VerificationMeta('isQuickMenue');
  GeneratedColumn<bool> _isQuickMenue;
  @override
  GeneratedColumn<bool> get isQuickMenue => _isQuickMenue ??=
      GeneratedColumn<bool>('is_quick_menue', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_quick_menue IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isRetiredMeta = const VerificationMeta('isRetired');
  GeneratedColumn<bool> _isRetired;
  @override
  GeneratedColumn<bool> get isRetired =>
      _isRetired ??= GeneratedColumn<bool>('is_retired', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_retired IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _retiredDateMeta =
      const VerificationMeta('retiredDate');
  GeneratedColumn<DateTime> _retiredDate;
  @override
  GeneratedColumn<DateTime> get retiredDate => _retiredDate ??=
      GeneratedColumn<DateTime>('retired_date', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _hasVariantMeta = const VerificationMeta('hasVariant');
  GeneratedColumn<bool> _hasVariant;
  @override
  GeneratedColumn<bool> get hasVariant =>
      _hasVariant ??= GeneratedColumn<bool>('has_variant', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (has_variant IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _defaultWarehouseMeta =
      const VerificationMeta('defaultWarehouse');
  GeneratedColumn<String> _defaultWarehouse;
  @override
  GeneratedColumn<String> get defaultWarehouse => _defaultWarehouse ??=
      GeneratedColumn<String>('default_warehouse', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isDeletedMeta = const VerificationMeta('isDeleted');
  GeneratedColumn<bool> _isDeleted;
  @override
  GeneratedColumn<bool> get isDeleted =>
      _isDeleted ??= GeneratedColumn<bool>('is_deleted', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_deleted IN (0, 1))',
          defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        itemId,
        description,
        itemCode,
        itemName,
        itemGroup,
        taxGroup,
        uom,
        trackInventory,
        category,
        isProductBundleParent,
        isQuickMenue,
        isRetired,
        retiredDate,
        hasVariant,
        defaultWarehouse,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? 'items';
  @override
  String get actualTableName => 'items';
  @override
  VerificationContext validateIntegrity(Insertable<Item> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id'], _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description'], _descriptionMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code'], _itemCodeMeta));
    }
    if (data.containsKey('item_name')) {
      context.handle(_itemNameMeta,
          itemName.isAcceptableOrUnknown(data['item_name'], _itemNameMeta));
    }
    if (data.containsKey('item_group')) {
      context.handle(_itemGroupMeta,
          itemGroup.isAcceptableOrUnknown(data['item_group'], _itemGroupMeta));
    }
    if (data.containsKey('tax_group')) {
      context.handle(_taxGroupMeta,
          taxGroup.isAcceptableOrUnknown(data['tax_group'], _taxGroupMeta));
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom'], _uomMeta));
    }
    if (data.containsKey('track_inventory')) {
      context.handle(
          _trackInventoryMeta,
          trackInventory.isAcceptableOrUnknown(
              data['track_inventory'], _trackInventoryMeta));
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category'], _categoryMeta));
    }
    if (data.containsKey('is_product_bundle_parent')) {
      context.handle(
          _isProductBundleParentMeta,
          isProductBundleParent.isAcceptableOrUnknown(
              data['is_product_bundle_parent'], _isProductBundleParentMeta));
    }
    if (data.containsKey('is_quick_menue')) {
      context.handle(
          _isQuickMenueMeta,
          isQuickMenue.isAcceptableOrUnknown(
              data['is_quick_menue'], _isQuickMenueMeta));
    }
    if (data.containsKey('is_retired')) {
      context.handle(_isRetiredMeta,
          isRetired.isAcceptableOrUnknown(data['is_retired'], _isRetiredMeta));
    }
    if (data.containsKey('retired_date')) {
      context.handle(
          _retiredDateMeta,
          retiredDate.isAcceptableOrUnknown(
              data['retired_date'], _retiredDateMeta));
    }
    if (data.containsKey('has_variant')) {
      context.handle(
          _hasVariantMeta,
          hasVariant.isAcceptableOrUnknown(
              data['has_variant'], _hasVariantMeta));
    }
    if (data.containsKey('default_warehouse')) {
      context.handle(
          _defaultWarehouseMeta,
          defaultWarehouse.isAcceptableOrUnknown(
              data['default_warehouse'], _defaultWarehouseMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted'], _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {itemId};
  @override
  Item map(Map<String, dynamic> data, {String tablePrefix}) {
    return Item.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $ItemsTable createAlias(String alias) {
    return $ItemsTable(_db, alias);
  }
}

class ItemsPrice extends DataClass implements Insertable<ItemsPrice> {
  final int tenantId;
  final int id;
  final String itemId;
  final String itemCode;
  final String priceList;
  final String itemName;
  final double itemPrice;
  final double returnPrice;
  final double deposit;
  final double shippingCost;
  final double sellingDeposit;
  final double returnDeposit;
  final double conversionFactor;
  final double actualPoints;
  final String uom;
  final String currency;
  final int pricingScheduleNo;
  final bool isActive;
  final bool isDiscountEnable;
  final DateTime validFrom;
  final DateTime validTo;
  ItemsPrice(
      {this.tenantId,
      @required this.id,
      @required this.itemId,
      this.itemCode,
      this.priceList,
      this.itemName,
      @required this.itemPrice,
      @required this.returnPrice,
      @required this.deposit,
      @required this.shippingCost,
      @required this.sellingDeposit,
      @required this.returnDeposit,
      @required this.conversionFactor,
      @required this.actualPoints,
      this.uom,
      this.currency,
      @required this.pricingScheduleNo,
      @required this.isActive,
      @required this.isDiscountEnable,
      this.validFrom,
      this.validTo});
  factory ItemsPrice.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return ItemsPrice(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      itemId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_id']),
      itemCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_code']),
      priceList: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}price_list']),
      itemName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_name']),
      itemPrice: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_price']),
      returnPrice: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}return_price']),
      deposit: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}deposit']),
      shippingCost: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}shipping_cost']),
      sellingDeposit: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}selling_deposit']),
      returnDeposit: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}return_deposit']),
      conversionFactor: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}conversion_factor']),
      actualPoints: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}actual_points']),
      uom: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}uom']),
      currency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}currency']),
      pricingScheduleNo: const IntType().mapFromDatabaseResponse(
          data['${effectivePrefix}pricing_schedule_no']),
      isActive: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_active']),
      isDiscountEnable: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}is_discount_enable']),
      validFrom: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}valid_from']),
      validTo: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}valid_to']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || priceList != null) {
      map['price_list'] = Variable<String>(priceList);
    }
    if (!nullToAbsent || itemName != null) {
      map['item_name'] = Variable<String>(itemName);
    }
    if (!nullToAbsent || itemPrice != null) {
      map['item_price'] = Variable<double>(itemPrice);
    }
    if (!nullToAbsent || returnPrice != null) {
      map['return_price'] = Variable<double>(returnPrice);
    }
    if (!nullToAbsent || deposit != null) {
      map['deposit'] = Variable<double>(deposit);
    }
    if (!nullToAbsent || shippingCost != null) {
      map['shipping_cost'] = Variable<double>(shippingCost);
    }
    if (!nullToAbsent || sellingDeposit != null) {
      map['selling_deposit'] = Variable<double>(sellingDeposit);
    }
    if (!nullToAbsent || returnDeposit != null) {
      map['return_deposit'] = Variable<double>(returnDeposit);
    }
    if (!nullToAbsent || conversionFactor != null) {
      map['conversion_factor'] = Variable<double>(conversionFactor);
    }
    if (!nullToAbsent || actualPoints != null) {
      map['actual_points'] = Variable<double>(actualPoints);
    }
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    if (!nullToAbsent || pricingScheduleNo != null) {
      map['pricing_schedule_no'] = Variable<int>(pricingScheduleNo);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || isDiscountEnable != null) {
      map['is_discount_enable'] = Variable<bool>(isDiscountEnable);
    }
    if (!nullToAbsent || validFrom != null) {
      map['valid_from'] = Variable<DateTime>(validFrom);
    }
    if (!nullToAbsent || validTo != null) {
      map['valid_to'] = Variable<DateTime>(validTo);
    }
    return map;
  }

  ItemsPricesCompanion toCompanion(bool nullToAbsent) {
    return ItemsPricesCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      priceList: priceList == null && nullToAbsent
          ? const Value.absent()
          : Value(priceList),
      itemName: itemName == null && nullToAbsent
          ? const Value.absent()
          : Value(itemName),
      itemPrice: itemPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(itemPrice),
      returnPrice: returnPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(returnPrice),
      deposit: deposit == null && nullToAbsent
          ? const Value.absent()
          : Value(deposit),
      shippingCost: shippingCost == null && nullToAbsent
          ? const Value.absent()
          : Value(shippingCost),
      sellingDeposit: sellingDeposit == null && nullToAbsent
          ? const Value.absent()
          : Value(sellingDeposit),
      returnDeposit: returnDeposit == null && nullToAbsent
          ? const Value.absent()
          : Value(returnDeposit),
      conversionFactor: conversionFactor == null && nullToAbsent
          ? const Value.absent()
          : Value(conversionFactor),
      actualPoints: actualPoints == null && nullToAbsent
          ? const Value.absent()
          : Value(actualPoints),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      pricingScheduleNo: pricingScheduleNo == null && nullToAbsent
          ? const Value.absent()
          : Value(pricingScheduleNo),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      isDiscountEnable: isDiscountEnable == null && nullToAbsent
          ? const Value.absent()
          : Value(isDiscountEnable),
      validFrom: validFrom == null && nullToAbsent
          ? const Value.absent()
          : Value(validFrom),
      validTo: validTo == null && nullToAbsent
          ? const Value.absent()
          : Value(validTo),
    );
  }

  factory ItemsPrice.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemsPrice(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<String>(json['itemId']),
      itemCode: serializer.fromJson<String>(json['itemCode']),
      priceList: serializer.fromJson<String>(json['priceList']),
      itemName: serializer.fromJson<String>(json['itemName']),
      itemPrice: serializer.fromJson<double>(json['itemPrice']),
      returnPrice: serializer.fromJson<double>(json['returnPrice']),
      deposit: serializer.fromJson<double>(json['deposit']),
      shippingCost: serializer.fromJson<double>(json['shippingCost']),
      sellingDeposit: serializer.fromJson<double>(json['sellingDeposit']),
      returnDeposit: serializer.fromJson<double>(json['returnDeposit']),
      conversionFactor: serializer.fromJson<double>(json['conversionFactor']),
      actualPoints: serializer.fromJson<double>(json['actualPoints']),
      uom: serializer.fromJson<String>(json['uom']),
      currency: serializer.fromJson<String>(json['currency']),
      pricingScheduleNo: serializer.fromJson<int>(json['pricingScheduleNo']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isDiscountEnable: serializer.fromJson<bool>(json['isDiscountEnable']),
      validFrom: serializer.fromJson<DateTime>(json['validFrom']),
      validTo: serializer.fromJson<DateTime>(json['validTo']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemId': serializer.toJson<String>(itemId),
      'itemCode': serializer.toJson<String>(itemCode),
      'priceList': serializer.toJson<String>(priceList),
      'itemName': serializer.toJson<String>(itemName),
      'itemPrice': serializer.toJson<double>(itemPrice),
      'returnPrice': serializer.toJson<double>(returnPrice),
      'deposit': serializer.toJson<double>(deposit),
      'shippingCost': serializer.toJson<double>(shippingCost),
      'sellingDeposit': serializer.toJson<double>(sellingDeposit),
      'returnDeposit': serializer.toJson<double>(returnDeposit),
      'conversionFactor': serializer.toJson<double>(conversionFactor),
      'actualPoints': serializer.toJson<double>(actualPoints),
      'uom': serializer.toJson<String>(uom),
      'currency': serializer.toJson<String>(currency),
      'pricingScheduleNo': serializer.toJson<int>(pricingScheduleNo),
      'isActive': serializer.toJson<bool>(isActive),
      'isDiscountEnable': serializer.toJson<bool>(isDiscountEnable),
      'validFrom': serializer.toJson<DateTime>(validFrom),
      'validTo': serializer.toJson<DateTime>(validTo),
    };
  }

  ItemsPrice copyWith(
          {int tenantId,
          int id,
          String itemId,
          String itemCode,
          String priceList,
          String itemName,
          double itemPrice,
          double returnPrice,
          double deposit,
          double shippingCost,
          double sellingDeposit,
          double returnDeposit,
          double conversionFactor,
          double actualPoints,
          String uom,
          String currency,
          int pricingScheduleNo,
          bool isActive,
          bool isDiscountEnable,
          DateTime validFrom,
          DateTime validTo}) =>
      ItemsPrice(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        itemCode: itemCode ?? this.itemCode,
        priceList: priceList ?? this.priceList,
        itemName: itemName ?? this.itemName,
        itemPrice: itemPrice ?? this.itemPrice,
        returnPrice: returnPrice ?? this.returnPrice,
        deposit: deposit ?? this.deposit,
        shippingCost: shippingCost ?? this.shippingCost,
        sellingDeposit: sellingDeposit ?? this.sellingDeposit,
        returnDeposit: returnDeposit ?? this.returnDeposit,
        conversionFactor: conversionFactor ?? this.conversionFactor,
        actualPoints: actualPoints ?? this.actualPoints,
        uom: uom ?? this.uom,
        currency: currency ?? this.currency,
        pricingScheduleNo: pricingScheduleNo ?? this.pricingScheduleNo,
        isActive: isActive ?? this.isActive,
        isDiscountEnable: isDiscountEnable ?? this.isDiscountEnable,
        validFrom: validFrom ?? this.validFrom,
        validTo: validTo ?? this.validTo,
      );
  @override
  String toString() {
    return (StringBuffer('ItemsPrice(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('priceList: $priceList, ')
          ..write('itemName: $itemName, ')
          ..write('itemPrice: $itemPrice, ')
          ..write('returnPrice: $returnPrice, ')
          ..write('deposit: $deposit, ')
          ..write('shippingCost: $shippingCost, ')
          ..write('sellingDeposit: $sellingDeposit, ')
          ..write('returnDeposit: $returnDeposit, ')
          ..write('conversionFactor: $conversionFactor, ')
          ..write('actualPoints: $actualPoints, ')
          ..write('uom: $uom, ')
          ..write('currency: $currency, ')
          ..write('pricingScheduleNo: $pricingScheduleNo, ')
          ..write('isActive: $isActive, ')
          ..write('isDiscountEnable: $isDiscountEnable, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        id,
        itemId,
        itemCode,
        priceList,
        itemName,
        itemPrice,
        returnPrice,
        deposit,
        shippingCost,
        sellingDeposit,
        returnDeposit,
        conversionFactor,
        actualPoints,
        uom,
        currency,
        pricingScheduleNo,
        isActive,
        isDiscountEnable,
        validFrom,
        validTo
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemsPrice &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.itemCode == this.itemCode &&
          other.priceList == this.priceList &&
          other.itemName == this.itemName &&
          other.itemPrice == this.itemPrice &&
          other.returnPrice == this.returnPrice &&
          other.deposit == this.deposit &&
          other.shippingCost == this.shippingCost &&
          other.sellingDeposit == this.sellingDeposit &&
          other.returnDeposit == this.returnDeposit &&
          other.conversionFactor == this.conversionFactor &&
          other.actualPoints == this.actualPoints &&
          other.uom == this.uom &&
          other.currency == this.currency &&
          other.pricingScheduleNo == this.pricingScheduleNo &&
          other.isActive == this.isActive &&
          other.isDiscountEnable == this.isDiscountEnable &&
          other.validFrom == this.validFrom &&
          other.validTo == this.validTo);
}

class ItemsPricesCompanion extends UpdateCompanion<ItemsPrice> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> itemId;
  final Value<String> itemCode;
  final Value<String> priceList;
  final Value<String> itemName;
  final Value<double> itemPrice;
  final Value<double> returnPrice;
  final Value<double> deposit;
  final Value<double> shippingCost;
  final Value<double> sellingDeposit;
  final Value<double> returnDeposit;
  final Value<double> conversionFactor;
  final Value<double> actualPoints;
  final Value<String> uom;
  final Value<String> currency;
  final Value<int> pricingScheduleNo;
  final Value<bool> isActive;
  final Value<bool> isDiscountEnable;
  final Value<DateTime> validFrom;
  final Value<DateTime> validTo;
  const ItemsPricesCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.priceList = const Value.absent(),
    this.itemName = const Value.absent(),
    this.itemPrice = const Value.absent(),
    this.returnPrice = const Value.absent(),
    this.deposit = const Value.absent(),
    this.shippingCost = const Value.absent(),
    this.sellingDeposit = const Value.absent(),
    this.returnDeposit = const Value.absent(),
    this.conversionFactor = const Value.absent(),
    this.actualPoints = const Value.absent(),
    this.uom = const Value.absent(),
    this.currency = const Value.absent(),
    this.pricingScheduleNo = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isDiscountEnable = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  });
  ItemsPricesCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    @required String itemId,
    this.itemCode = const Value.absent(),
    this.priceList = const Value.absent(),
    this.itemName = const Value.absent(),
    @required double itemPrice,
    @required double returnPrice,
    @required double deposit,
    @required double shippingCost,
    @required double sellingDeposit,
    @required double returnDeposit,
    @required double conversionFactor,
    @required double actualPoints,
    this.uom = const Value.absent(),
    this.currency = const Value.absent(),
    @required int pricingScheduleNo,
    this.isActive = const Value.absent(),
    this.isDiscountEnable = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  })  : itemId = Value(itemId),
        itemPrice = Value(itemPrice),
        returnPrice = Value(returnPrice),
        deposit = Value(deposit),
        shippingCost = Value(shippingCost),
        sellingDeposit = Value(sellingDeposit),
        returnDeposit = Value(returnDeposit),
        conversionFactor = Value(conversionFactor),
        actualPoints = Value(actualPoints),
        pricingScheduleNo = Value(pricingScheduleNo);
  static Insertable<ItemsPrice> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> itemId,
    Expression<String> itemCode,
    Expression<String> priceList,
    Expression<String> itemName,
    Expression<double> itemPrice,
    Expression<double> returnPrice,
    Expression<double> deposit,
    Expression<double> shippingCost,
    Expression<double> sellingDeposit,
    Expression<double> returnDeposit,
    Expression<double> conversionFactor,
    Expression<double> actualPoints,
    Expression<String> uom,
    Expression<String> currency,
    Expression<int> pricingScheduleNo,
    Expression<bool> isActive,
    Expression<bool> isDiscountEnable,
    Expression<DateTime> validFrom,
    Expression<DateTime> validTo,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (itemCode != null) 'item_code': itemCode,
      if (priceList != null) 'price_list': priceList,
      if (itemName != null) 'item_name': itemName,
      if (itemPrice != null) 'item_price': itemPrice,
      if (returnPrice != null) 'return_price': returnPrice,
      if (deposit != null) 'deposit': deposit,
      if (shippingCost != null) 'shipping_cost': shippingCost,
      if (sellingDeposit != null) 'selling_deposit': sellingDeposit,
      if (returnDeposit != null) 'return_deposit': returnDeposit,
      if (conversionFactor != null) 'conversion_factor': conversionFactor,
      if (actualPoints != null) 'actual_points': actualPoints,
      if (uom != null) 'uom': uom,
      if (currency != null) 'currency': currency,
      if (pricingScheduleNo != null) 'pricing_schedule_no': pricingScheduleNo,
      if (isActive != null) 'is_active': isActive,
      if (isDiscountEnable != null) 'is_discount_enable': isDiscountEnable,
      if (validFrom != null) 'valid_from': validFrom,
      if (validTo != null) 'valid_to': validTo,
    });
  }

  ItemsPricesCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> itemId,
      Value<String> itemCode,
      Value<String> priceList,
      Value<String> itemName,
      Value<double> itemPrice,
      Value<double> returnPrice,
      Value<double> deposit,
      Value<double> shippingCost,
      Value<double> sellingDeposit,
      Value<double> returnDeposit,
      Value<double> conversionFactor,
      Value<double> actualPoints,
      Value<String> uom,
      Value<String> currency,
      Value<int> pricingScheduleNo,
      Value<bool> isActive,
      Value<bool> isDiscountEnable,
      Value<DateTime> validFrom,
      Value<DateTime> validTo}) {
    return ItemsPricesCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      itemCode: itemCode ?? this.itemCode,
      priceList: priceList ?? this.priceList,
      itemName: itemName ?? this.itemName,
      itemPrice: itemPrice ?? this.itemPrice,
      returnPrice: returnPrice ?? this.returnPrice,
      deposit: deposit ?? this.deposit,
      shippingCost: shippingCost ?? this.shippingCost,
      sellingDeposit: sellingDeposit ?? this.sellingDeposit,
      returnDeposit: returnDeposit ?? this.returnDeposit,
      conversionFactor: conversionFactor ?? this.conversionFactor,
      actualPoints: actualPoints ?? this.actualPoints,
      uom: uom ?? this.uom,
      currency: currency ?? this.currency,
      pricingScheduleNo: pricingScheduleNo ?? this.pricingScheduleNo,
      isActive: isActive ?? this.isActive,
      isDiscountEnable: isDiscountEnable ?? this.isDiscountEnable,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo ?? this.validTo,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (priceList.present) {
      map['price_list'] = Variable<String>(priceList.value);
    }
    if (itemName.present) {
      map['item_name'] = Variable<String>(itemName.value);
    }
    if (itemPrice.present) {
      map['item_price'] = Variable<double>(itemPrice.value);
    }
    if (returnPrice.present) {
      map['return_price'] = Variable<double>(returnPrice.value);
    }
    if (deposit.present) {
      map['deposit'] = Variable<double>(deposit.value);
    }
    if (shippingCost.present) {
      map['shipping_cost'] = Variable<double>(shippingCost.value);
    }
    if (sellingDeposit.present) {
      map['selling_deposit'] = Variable<double>(sellingDeposit.value);
    }
    if (returnDeposit.present) {
      map['return_deposit'] = Variable<double>(returnDeposit.value);
    }
    if (conversionFactor.present) {
      map['conversion_factor'] = Variable<double>(conversionFactor.value);
    }
    if (actualPoints.present) {
      map['actual_points'] = Variable<double>(actualPoints.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (pricingScheduleNo.present) {
      map['pricing_schedule_no'] = Variable<int>(pricingScheduleNo.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isDiscountEnable.present) {
      map['is_discount_enable'] = Variable<bool>(isDiscountEnable.value);
    }
    if (validFrom.present) {
      map['valid_from'] = Variable<DateTime>(validFrom.value);
    }
    if (validTo.present) {
      map['valid_to'] = Variable<DateTime>(validTo.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemsPricesCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('priceList: $priceList, ')
          ..write('itemName: $itemName, ')
          ..write('itemPrice: $itemPrice, ')
          ..write('returnPrice: $returnPrice, ')
          ..write('deposit: $deposit, ')
          ..write('shippingCost: $shippingCost, ')
          ..write('sellingDeposit: $sellingDeposit, ')
          ..write('returnDeposit: $returnDeposit, ')
          ..write('conversionFactor: $conversionFactor, ')
          ..write('actualPoints: $actualPoints, ')
          ..write('uom: $uom, ')
          ..write('currency: $currency, ')
          ..write('pricingScheduleNo: $pricingScheduleNo, ')
          ..write('isActive: $isActive, ')
          ..write('isDiscountEnable: $isDiscountEnable, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }
}

class $ItemsPricesTable extends ItemsPrices
    with TableInfo<$ItemsPricesTable, ItemsPrice> {
  final GeneratedDatabase _db;
  final String _alias;
  $ItemsPricesTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  GeneratedColumn<String> _itemId;
  @override
  GeneratedColumn<String> get itemId =>
      _itemId ??= GeneratedColumn<String>('item_id', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _itemCodeMeta = const VerificationMeta('itemCode');
  GeneratedColumn<String> _itemCode;
  @override
  GeneratedColumn<String> get itemCode =>
      _itemCode ??= GeneratedColumn<String>('item_code', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _priceListMeta = const VerificationMeta('priceList');
  GeneratedColumn<String> _priceList;
  @override
  GeneratedColumn<String> get priceList =>
      _priceList ??= GeneratedColumn<String>('price_list', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemNameMeta = const VerificationMeta('itemName');
  GeneratedColumn<String> _itemName;
  @override
  GeneratedColumn<String> get itemName =>
      _itemName ??= GeneratedColumn<String>('item_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemPriceMeta = const VerificationMeta('itemPrice');
  GeneratedColumn<double> _itemPrice;
  @override
  GeneratedColumn<double> get itemPrice =>
      _itemPrice ??= GeneratedColumn<double>('item_price', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _returnPriceMeta =
      const VerificationMeta('returnPrice');
  GeneratedColumn<double> _returnPrice;
  @override
  GeneratedColumn<double> get returnPrice => _returnPrice ??=
      GeneratedColumn<double>('return_price', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _depositMeta = const VerificationMeta('deposit');
  GeneratedColumn<double> _deposit;
  @override
  GeneratedColumn<double> get deposit =>
      _deposit ??= GeneratedColumn<double>('deposit', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _shippingCostMeta =
      const VerificationMeta('shippingCost');
  GeneratedColumn<double> _shippingCost;
  @override
  GeneratedColumn<double> get shippingCost => _shippingCost ??=
      GeneratedColumn<double>('shipping_cost', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _sellingDepositMeta =
      const VerificationMeta('sellingDeposit');
  GeneratedColumn<double> _sellingDeposit;
  @override
  GeneratedColumn<double> get sellingDeposit => _sellingDeposit ??=
      GeneratedColumn<double>('selling_deposit', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _returnDepositMeta =
      const VerificationMeta('returnDeposit');
  GeneratedColumn<double> _returnDeposit;
  @override
  GeneratedColumn<double> get returnDeposit => _returnDeposit ??=
      GeneratedColumn<double>('return_deposit', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _conversionFactorMeta =
      const VerificationMeta('conversionFactor');
  GeneratedColumn<double> _conversionFactor;
  @override
  GeneratedColumn<double> get conversionFactor => _conversionFactor ??=
      GeneratedColumn<double>('conversion_factor', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _actualPointsMeta =
      const VerificationMeta('actualPoints');
  GeneratedColumn<double> _actualPoints;
  @override
  GeneratedColumn<double> get actualPoints => _actualPoints ??=
      GeneratedColumn<double>('actual_points', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _uomMeta = const VerificationMeta('uom');
  GeneratedColumn<String> _uom;
  @override
  GeneratedColumn<String> get uom =>
      _uom ??= GeneratedColumn<String>('uom', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _currencyMeta = const VerificationMeta('currency');
  GeneratedColumn<String> _currency;
  @override
  GeneratedColumn<String> get currency =>
      _currency ??= GeneratedColumn<String>('currency', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _pricingScheduleNoMeta =
      const VerificationMeta('pricingScheduleNo');
  GeneratedColumn<int> _pricingScheduleNo;
  @override
  GeneratedColumn<int> get pricingScheduleNo => _pricingScheduleNo ??=
      GeneratedColumn<int>('pricing_schedule_no', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _isActiveMeta = const VerificationMeta('isActive');
  GeneratedColumn<bool> _isActive;
  @override
  GeneratedColumn<bool> get isActive =>
      _isActive ??= GeneratedColumn<bool>('is_active', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_active IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isDiscountEnableMeta =
      const VerificationMeta('isDiscountEnable');
  GeneratedColumn<bool> _isDiscountEnable;
  @override
  GeneratedColumn<bool> get isDiscountEnable => _isDiscountEnable ??=
      GeneratedColumn<bool>('is_discount_enable', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_discount_enable IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _validFromMeta = const VerificationMeta('validFrom');
  GeneratedColumn<DateTime> _validFrom;
  @override
  GeneratedColumn<DateTime> get validFrom =>
      _validFrom ??= GeneratedColumn<DateTime>('valid_from', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _validToMeta = const VerificationMeta('validTo');
  GeneratedColumn<DateTime> _validTo;
  @override
  GeneratedColumn<DateTime> get validTo =>
      _validTo ??= GeneratedColumn<DateTime>('valid_to', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        itemId,
        itemCode,
        priceList,
        itemName,
        itemPrice,
        returnPrice,
        deposit,
        shippingCost,
        sellingDeposit,
        returnDeposit,
        conversionFactor,
        actualPoints,
        uom,
        currency,
        pricingScheduleNo,
        isActive,
        isDiscountEnable,
        validFrom,
        validTo
      ];
  @override
  String get aliasedName => _alias ?? 'items_prices';
  @override
  String get actualTableName => 'items_prices';
  @override
  VerificationContext validateIntegrity(Insertable<ItemsPrice> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id'], _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code'], _itemCodeMeta));
    }
    if (data.containsKey('price_list')) {
      context.handle(_priceListMeta,
          priceList.isAcceptableOrUnknown(data['price_list'], _priceListMeta));
    }
    if (data.containsKey('item_name')) {
      context.handle(_itemNameMeta,
          itemName.isAcceptableOrUnknown(data['item_name'], _itemNameMeta));
    }
    if (data.containsKey('item_price')) {
      context.handle(_itemPriceMeta,
          itemPrice.isAcceptableOrUnknown(data['item_price'], _itemPriceMeta));
    } else if (isInserting) {
      context.missing(_itemPriceMeta);
    }
    if (data.containsKey('return_price')) {
      context.handle(
          _returnPriceMeta,
          returnPrice.isAcceptableOrUnknown(
              data['return_price'], _returnPriceMeta));
    } else if (isInserting) {
      context.missing(_returnPriceMeta);
    }
    if (data.containsKey('deposit')) {
      context.handle(_depositMeta,
          deposit.isAcceptableOrUnknown(data['deposit'], _depositMeta));
    } else if (isInserting) {
      context.missing(_depositMeta);
    }
    if (data.containsKey('shipping_cost')) {
      context.handle(
          _shippingCostMeta,
          shippingCost.isAcceptableOrUnknown(
              data['shipping_cost'], _shippingCostMeta));
    } else if (isInserting) {
      context.missing(_shippingCostMeta);
    }
    if (data.containsKey('selling_deposit')) {
      context.handle(
          _sellingDepositMeta,
          sellingDeposit.isAcceptableOrUnknown(
              data['selling_deposit'], _sellingDepositMeta));
    } else if (isInserting) {
      context.missing(_sellingDepositMeta);
    }
    if (data.containsKey('return_deposit')) {
      context.handle(
          _returnDepositMeta,
          returnDeposit.isAcceptableOrUnknown(
              data['return_deposit'], _returnDepositMeta));
    } else if (isInserting) {
      context.missing(_returnDepositMeta);
    }
    if (data.containsKey('conversion_factor')) {
      context.handle(
          _conversionFactorMeta,
          conversionFactor.isAcceptableOrUnknown(
              data['conversion_factor'], _conversionFactorMeta));
    } else if (isInserting) {
      context.missing(_conversionFactorMeta);
    }
    if (data.containsKey('actual_points')) {
      context.handle(
          _actualPointsMeta,
          actualPoints.isAcceptableOrUnknown(
              data['actual_points'], _actualPointsMeta));
    } else if (isInserting) {
      context.missing(_actualPointsMeta);
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom'], _uomMeta));
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency'], _currencyMeta));
    }
    if (data.containsKey('pricing_schedule_no')) {
      context.handle(
          _pricingScheduleNoMeta,
          pricingScheduleNo.isAcceptableOrUnknown(
              data['pricing_schedule_no'], _pricingScheduleNoMeta));
    } else if (isInserting) {
      context.missing(_pricingScheduleNoMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active'], _isActiveMeta));
    }
    if (data.containsKey('is_discount_enable')) {
      context.handle(
          _isDiscountEnableMeta,
          isDiscountEnable.isAcceptableOrUnknown(
              data['is_discount_enable'], _isDiscountEnableMeta));
    }
    if (data.containsKey('valid_from')) {
      context.handle(_validFromMeta,
          validFrom.isAcceptableOrUnknown(data['valid_from'], _validFromMeta));
    }
    if (data.containsKey('valid_to')) {
      context.handle(_validToMeta,
          validTo.isAcceptableOrUnknown(data['valid_to'], _validToMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemsPrice map(Map<String, dynamic> data, {String tablePrefix}) {
    return ItemsPrice.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $ItemsPricesTable createAlias(String alias) {
    return $ItemsPricesTable(_db, alias);
  }
}

class ItemPricingRuleData extends DataClass
    implements Insertable<ItemPricingRuleData> {
  final int tenantId;
  final int id;
  final int priority;
  final String itemId;
  final String itemCode;
  final String priceList;
  final String customerId;
  final double minQuantity;
  final double maxQuantity;
  final double price;
  final double discountPercentage;
  final String uom;
  final String priceOrDiscount;
  final String customerGroup;
  final String itemGroup;
  final String category;
  final String applicableFor;
  final String applyOn;
  final String title;
  final String ruleName;
  final bool isActive;
  final bool isDeleted;
  final bool isDiscountEnable;
  final DateTime validFrom;
  final DateTime validTo;
  ItemPricingRuleData(
      {this.tenantId,
      @required this.id,
      @required this.priority,
      this.itemId,
      this.itemCode,
      this.priceList,
      this.customerId,
      @required this.minQuantity,
      @required this.maxQuantity,
      @required this.price,
      @required this.discountPercentage,
      this.uom,
      this.priceOrDiscount,
      this.customerGroup,
      this.itemGroup,
      this.category,
      this.applicableFor,
      this.applyOn,
      this.title,
      this.ruleName,
      @required this.isActive,
      @required this.isDeleted,
      @required this.isDiscountEnable,
      this.validFrom,
      this.validTo});
  factory ItemPricingRuleData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return ItemPricingRuleData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      priority: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}priority']),
      itemId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_id']),
      itemCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_code']),
      priceList: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}price_list']),
      customerId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_id']),
      minQuantity: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}min_quantity']),
      maxQuantity: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}max_quantity']),
      price: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}price']),
      discountPercentage: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}discount_percentage']),
      uom: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}uom']),
      priceOrDiscount: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}price_or_discount']),
      customerGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_group']),
      itemGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_group']),
      category: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}category']),
      applicableFor: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}applicable_for']),
      applyOn: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}apply_on']),
      title: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}title']),
      ruleName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}rule_name']),
      isActive: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_active']),
      isDeleted: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_deleted']),
      isDiscountEnable: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}is_discount_enable']),
      validFrom: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}valid_from']),
      validTo: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}valid_to']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || priority != null) {
      map['priority'] = Variable<int>(priority);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || priceList != null) {
      map['price_list'] = Variable<String>(priceList);
    }
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || minQuantity != null) {
      map['min_quantity'] = Variable<double>(minQuantity);
    }
    if (!nullToAbsent || maxQuantity != null) {
      map['max_quantity'] = Variable<double>(maxQuantity);
    }
    if (!nullToAbsent || price != null) {
      map['price'] = Variable<double>(price);
    }
    if (!nullToAbsent || discountPercentage != null) {
      map['discount_percentage'] = Variable<double>(discountPercentage);
    }
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    if (!nullToAbsent || priceOrDiscount != null) {
      map['price_or_discount'] = Variable<String>(priceOrDiscount);
    }
    if (!nullToAbsent || customerGroup != null) {
      map['customer_group'] = Variable<String>(customerGroup);
    }
    if (!nullToAbsent || itemGroup != null) {
      map['item_group'] = Variable<String>(itemGroup);
    }
    if (!nullToAbsent || category != null) {
      map['category'] = Variable<String>(category);
    }
    if (!nullToAbsent || applicableFor != null) {
      map['applicable_for'] = Variable<String>(applicableFor);
    }
    if (!nullToAbsent || applyOn != null) {
      map['apply_on'] = Variable<String>(applyOn);
    }
    if (!nullToAbsent || title != null) {
      map['title'] = Variable<String>(title);
    }
    if (!nullToAbsent || ruleName != null) {
      map['rule_name'] = Variable<String>(ruleName);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || isDiscountEnable != null) {
      map['is_discount_enable'] = Variable<bool>(isDiscountEnable);
    }
    if (!nullToAbsent || validFrom != null) {
      map['valid_from'] = Variable<DateTime>(validFrom);
    }
    if (!nullToAbsent || validTo != null) {
      map['valid_to'] = Variable<DateTime>(validTo);
    }
    return map;
  }

  ItemPricingRuleCompanion toCompanion(bool nullToAbsent) {
    return ItemPricingRuleCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      priority: priority == null && nullToAbsent
          ? const Value.absent()
          : Value(priority),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      priceList: priceList == null && nullToAbsent
          ? const Value.absent()
          : Value(priceList),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      minQuantity: minQuantity == null && nullToAbsent
          ? const Value.absent()
          : Value(minQuantity),
      maxQuantity: maxQuantity == null && nullToAbsent
          ? const Value.absent()
          : Value(maxQuantity),
      price:
          price == null && nullToAbsent ? const Value.absent() : Value(price),
      discountPercentage: discountPercentage == null && nullToAbsent
          ? const Value.absent()
          : Value(discountPercentage),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
      priceOrDiscount: priceOrDiscount == null && nullToAbsent
          ? const Value.absent()
          : Value(priceOrDiscount),
      customerGroup: customerGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(customerGroup),
      itemGroup: itemGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(itemGroup),
      category: category == null && nullToAbsent
          ? const Value.absent()
          : Value(category),
      applicableFor: applicableFor == null && nullToAbsent
          ? const Value.absent()
          : Value(applicableFor),
      applyOn: applyOn == null && nullToAbsent
          ? const Value.absent()
          : Value(applyOn),
      title:
          title == null && nullToAbsent ? const Value.absent() : Value(title),
      ruleName: ruleName == null && nullToAbsent
          ? const Value.absent()
          : Value(ruleName),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      isDiscountEnable: isDiscountEnable == null && nullToAbsent
          ? const Value.absent()
          : Value(isDiscountEnable),
      validFrom: validFrom == null && nullToAbsent
          ? const Value.absent()
          : Value(validFrom),
      validTo: validTo == null && nullToAbsent
          ? const Value.absent()
          : Value(validTo),
    );
  }

  factory ItemPricingRuleData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemPricingRuleData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      priority: serializer.fromJson<int>(json['priority']),
      itemId: serializer.fromJson<String>(json['itemId']),
      itemCode: serializer.fromJson<String>(json['itemCode']),
      priceList: serializer.fromJson<String>(json['priceList']),
      customerId: serializer.fromJson<String>(json['customerId']),
      minQuantity: serializer.fromJson<double>(json['minQuantity']),
      maxQuantity: serializer.fromJson<double>(json['maxQuantity']),
      price: serializer.fromJson<double>(json['price']),
      discountPercentage:
          serializer.fromJson<double>(json['discountPercentage']),
      uom: serializer.fromJson<String>(json['uom']),
      priceOrDiscount: serializer.fromJson<String>(json['priceOrDiscount']),
      customerGroup: serializer.fromJson<String>(json['customerGroup']),
      itemGroup: serializer.fromJson<String>(json['itemGroup']),
      category: serializer.fromJson<String>(json['category']),
      applicableFor: serializer.fromJson<String>(json['applicableFor']),
      applyOn: serializer.fromJson<String>(json['applyOn']),
      title: serializer.fromJson<String>(json['title']),
      ruleName: serializer.fromJson<String>(json['ruleName']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      isDiscountEnable: serializer.fromJson<bool>(json['isDiscountEnable']),
      validFrom: serializer.fromJson<DateTime>(json['validFrom']),
      validTo: serializer.fromJson<DateTime>(json['validTo']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'priority': serializer.toJson<int>(priority),
      'itemId': serializer.toJson<String>(itemId),
      'itemCode': serializer.toJson<String>(itemCode),
      'priceList': serializer.toJson<String>(priceList),
      'customerId': serializer.toJson<String>(customerId),
      'minQuantity': serializer.toJson<double>(minQuantity),
      'maxQuantity': serializer.toJson<double>(maxQuantity),
      'price': serializer.toJson<double>(price),
      'discountPercentage': serializer.toJson<double>(discountPercentage),
      'uom': serializer.toJson<String>(uom),
      'priceOrDiscount': serializer.toJson<String>(priceOrDiscount),
      'customerGroup': serializer.toJson<String>(customerGroup),
      'itemGroup': serializer.toJson<String>(itemGroup),
      'category': serializer.toJson<String>(category),
      'applicableFor': serializer.toJson<String>(applicableFor),
      'applyOn': serializer.toJson<String>(applyOn),
      'title': serializer.toJson<String>(title),
      'ruleName': serializer.toJson<String>(ruleName),
      'isActive': serializer.toJson<bool>(isActive),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'isDiscountEnable': serializer.toJson<bool>(isDiscountEnable),
      'validFrom': serializer.toJson<DateTime>(validFrom),
      'validTo': serializer.toJson<DateTime>(validTo),
    };
  }

  ItemPricingRuleData copyWith(
          {int tenantId,
          int id,
          int priority,
          String itemId,
          String itemCode,
          String priceList,
          String customerId,
          double minQuantity,
          double maxQuantity,
          double price,
          double discountPercentage,
          String uom,
          String priceOrDiscount,
          String customerGroup,
          String itemGroup,
          String category,
          String applicableFor,
          String applyOn,
          String title,
          String ruleName,
          bool isActive,
          bool isDeleted,
          bool isDiscountEnable,
          DateTime validFrom,
          DateTime validTo}) =>
      ItemPricingRuleData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        priority: priority ?? this.priority,
        itemId: itemId ?? this.itemId,
        itemCode: itemCode ?? this.itemCode,
        priceList: priceList ?? this.priceList,
        customerId: customerId ?? this.customerId,
        minQuantity: minQuantity ?? this.minQuantity,
        maxQuantity: maxQuantity ?? this.maxQuantity,
        price: price ?? this.price,
        discountPercentage: discountPercentage ?? this.discountPercentage,
        uom: uom ?? this.uom,
        priceOrDiscount: priceOrDiscount ?? this.priceOrDiscount,
        customerGroup: customerGroup ?? this.customerGroup,
        itemGroup: itemGroup ?? this.itemGroup,
        category: category ?? this.category,
        applicableFor: applicableFor ?? this.applicableFor,
        applyOn: applyOn ?? this.applyOn,
        title: title ?? this.title,
        ruleName: ruleName ?? this.ruleName,
        isActive: isActive ?? this.isActive,
        isDeleted: isDeleted ?? this.isDeleted,
        isDiscountEnable: isDiscountEnable ?? this.isDiscountEnable,
        validFrom: validFrom ?? this.validFrom,
        validTo: validTo ?? this.validTo,
      );
  @override
  String toString() {
    return (StringBuffer('ItemPricingRuleData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('priority: $priority, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('priceList: $priceList, ')
          ..write('customerId: $customerId, ')
          ..write('minQuantity: $minQuantity, ')
          ..write('maxQuantity: $maxQuantity, ')
          ..write('price: $price, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('uom: $uom, ')
          ..write('priceOrDiscount: $priceOrDiscount, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('applicableFor: $applicableFor, ')
          ..write('applyOn: $applyOn, ')
          ..write('title: $title, ')
          ..write('ruleName: $ruleName, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('isDiscountEnable: $isDiscountEnable, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        id,
        priority,
        itemId,
        itemCode,
        priceList,
        customerId,
        minQuantity,
        maxQuantity,
        price,
        discountPercentage,
        uom,
        priceOrDiscount,
        customerGroup,
        itemGroup,
        category,
        applicableFor,
        applyOn,
        title,
        ruleName,
        isActive,
        isDeleted,
        isDiscountEnable,
        validFrom,
        validTo
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemPricingRuleData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.priority == this.priority &&
          other.itemId == this.itemId &&
          other.itemCode == this.itemCode &&
          other.priceList == this.priceList &&
          other.customerId == this.customerId &&
          other.minQuantity == this.minQuantity &&
          other.maxQuantity == this.maxQuantity &&
          other.price == this.price &&
          other.discountPercentage == this.discountPercentage &&
          other.uom == this.uom &&
          other.priceOrDiscount == this.priceOrDiscount &&
          other.customerGroup == this.customerGroup &&
          other.itemGroup == this.itemGroup &&
          other.category == this.category &&
          other.applicableFor == this.applicableFor &&
          other.applyOn == this.applyOn &&
          other.title == this.title &&
          other.ruleName == this.ruleName &&
          other.isActive == this.isActive &&
          other.isDeleted == this.isDeleted &&
          other.isDiscountEnable == this.isDiscountEnable &&
          other.validFrom == this.validFrom &&
          other.validTo == this.validTo);
}

class ItemPricingRuleCompanion extends UpdateCompanion<ItemPricingRuleData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<int> priority;
  final Value<String> itemId;
  final Value<String> itemCode;
  final Value<String> priceList;
  final Value<String> customerId;
  final Value<double> minQuantity;
  final Value<double> maxQuantity;
  final Value<double> price;
  final Value<double> discountPercentage;
  final Value<String> uom;
  final Value<String> priceOrDiscount;
  final Value<String> customerGroup;
  final Value<String> itemGroup;
  final Value<String> category;
  final Value<String> applicableFor;
  final Value<String> applyOn;
  final Value<String> title;
  final Value<String> ruleName;
  final Value<bool> isActive;
  final Value<bool> isDeleted;
  final Value<bool> isDiscountEnable;
  final Value<DateTime> validFrom;
  final Value<DateTime> validTo;
  const ItemPricingRuleCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.priority = const Value.absent(),
    this.itemId = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.priceList = const Value.absent(),
    this.customerId = const Value.absent(),
    this.minQuantity = const Value.absent(),
    this.maxQuantity = const Value.absent(),
    this.price = const Value.absent(),
    this.discountPercentage = const Value.absent(),
    this.uom = const Value.absent(),
    this.priceOrDiscount = const Value.absent(),
    this.customerGroup = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.category = const Value.absent(),
    this.applicableFor = const Value.absent(),
    this.applyOn = const Value.absent(),
    this.title = const Value.absent(),
    this.ruleName = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.isDiscountEnable = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  });
  ItemPricingRuleCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    @required int priority,
    this.itemId = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.priceList = const Value.absent(),
    this.customerId = const Value.absent(),
    @required double minQuantity,
    @required double maxQuantity,
    @required double price,
    @required double discountPercentage,
    this.uom = const Value.absent(),
    this.priceOrDiscount = const Value.absent(),
    this.customerGroup = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.category = const Value.absent(),
    this.applicableFor = const Value.absent(),
    this.applyOn = const Value.absent(),
    this.title = const Value.absent(),
    this.ruleName = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.isDiscountEnable = const Value.absent(),
    this.validFrom = const Value.absent(),
    this.validTo = const Value.absent(),
  })  : priority = Value(priority),
        minQuantity = Value(minQuantity),
        maxQuantity = Value(maxQuantity),
        price = Value(price),
        discountPercentage = Value(discountPercentage);
  static Insertable<ItemPricingRuleData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<int> priority,
    Expression<String> itemId,
    Expression<String> itemCode,
    Expression<String> priceList,
    Expression<String> customerId,
    Expression<double> minQuantity,
    Expression<double> maxQuantity,
    Expression<double> price,
    Expression<double> discountPercentage,
    Expression<String> uom,
    Expression<String> priceOrDiscount,
    Expression<String> customerGroup,
    Expression<String> itemGroup,
    Expression<String> category,
    Expression<String> applicableFor,
    Expression<String> applyOn,
    Expression<String> title,
    Expression<String> ruleName,
    Expression<bool> isActive,
    Expression<bool> isDeleted,
    Expression<bool> isDiscountEnable,
    Expression<DateTime> validFrom,
    Expression<DateTime> validTo,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (priority != null) 'priority': priority,
      if (itemId != null) 'item_id': itemId,
      if (itemCode != null) 'item_code': itemCode,
      if (priceList != null) 'price_list': priceList,
      if (customerId != null) 'customer_id': customerId,
      if (minQuantity != null) 'min_quantity': minQuantity,
      if (maxQuantity != null) 'max_quantity': maxQuantity,
      if (price != null) 'price': price,
      if (discountPercentage != null) 'discount_percentage': discountPercentage,
      if (uom != null) 'uom': uom,
      if (priceOrDiscount != null) 'price_or_discount': priceOrDiscount,
      if (customerGroup != null) 'customer_group': customerGroup,
      if (itemGroup != null) 'item_group': itemGroup,
      if (category != null) 'category': category,
      if (applicableFor != null) 'applicable_for': applicableFor,
      if (applyOn != null) 'apply_on': applyOn,
      if (title != null) 'title': title,
      if (ruleName != null) 'rule_name': ruleName,
      if (isActive != null) 'is_active': isActive,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (isDiscountEnable != null) 'is_discount_enable': isDiscountEnable,
      if (validFrom != null) 'valid_from': validFrom,
      if (validTo != null) 'valid_to': validTo,
    });
  }

  ItemPricingRuleCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<int> priority,
      Value<String> itemId,
      Value<String> itemCode,
      Value<String> priceList,
      Value<String> customerId,
      Value<double> minQuantity,
      Value<double> maxQuantity,
      Value<double> price,
      Value<double> discountPercentage,
      Value<String> uom,
      Value<String> priceOrDiscount,
      Value<String> customerGroup,
      Value<String> itemGroup,
      Value<String> category,
      Value<String> applicableFor,
      Value<String> applyOn,
      Value<String> title,
      Value<String> ruleName,
      Value<bool> isActive,
      Value<bool> isDeleted,
      Value<bool> isDiscountEnable,
      Value<DateTime> validFrom,
      Value<DateTime> validTo}) {
    return ItemPricingRuleCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      priority: priority ?? this.priority,
      itemId: itemId ?? this.itemId,
      itemCode: itemCode ?? this.itemCode,
      priceList: priceList ?? this.priceList,
      customerId: customerId ?? this.customerId,
      minQuantity: minQuantity ?? this.minQuantity,
      maxQuantity: maxQuantity ?? this.maxQuantity,
      price: price ?? this.price,
      discountPercentage: discountPercentage ?? this.discountPercentage,
      uom: uom ?? this.uom,
      priceOrDiscount: priceOrDiscount ?? this.priceOrDiscount,
      customerGroup: customerGroup ?? this.customerGroup,
      itemGroup: itemGroup ?? this.itemGroup,
      category: category ?? this.category,
      applicableFor: applicableFor ?? this.applicableFor,
      applyOn: applyOn ?? this.applyOn,
      title: title ?? this.title,
      ruleName: ruleName ?? this.ruleName,
      isActive: isActive ?? this.isActive,
      isDeleted: isDeleted ?? this.isDeleted,
      isDiscountEnable: isDiscountEnable ?? this.isDiscountEnable,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo ?? this.validTo,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (priority.present) {
      map['priority'] = Variable<int>(priority.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (priceList.present) {
      map['price_list'] = Variable<String>(priceList.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (minQuantity.present) {
      map['min_quantity'] = Variable<double>(minQuantity.value);
    }
    if (maxQuantity.present) {
      map['max_quantity'] = Variable<double>(maxQuantity.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (discountPercentage.present) {
      map['discount_percentage'] = Variable<double>(discountPercentage.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    if (priceOrDiscount.present) {
      map['price_or_discount'] = Variable<String>(priceOrDiscount.value);
    }
    if (customerGroup.present) {
      map['customer_group'] = Variable<String>(customerGroup.value);
    }
    if (itemGroup.present) {
      map['item_group'] = Variable<String>(itemGroup.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (applicableFor.present) {
      map['applicable_for'] = Variable<String>(applicableFor.value);
    }
    if (applyOn.present) {
      map['apply_on'] = Variable<String>(applyOn.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (ruleName.present) {
      map['rule_name'] = Variable<String>(ruleName.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (isDiscountEnable.present) {
      map['is_discount_enable'] = Variable<bool>(isDiscountEnable.value);
    }
    if (validFrom.present) {
      map['valid_from'] = Variable<DateTime>(validFrom.value);
    }
    if (validTo.present) {
      map['valid_to'] = Variable<DateTime>(validTo.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemPricingRuleCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('priority: $priority, ')
          ..write('itemId: $itemId, ')
          ..write('itemCode: $itemCode, ')
          ..write('priceList: $priceList, ')
          ..write('customerId: $customerId, ')
          ..write('minQuantity: $minQuantity, ')
          ..write('maxQuantity: $maxQuantity, ')
          ..write('price: $price, ')
          ..write('discountPercentage: $discountPercentage, ')
          ..write('uom: $uom, ')
          ..write('priceOrDiscount: $priceOrDiscount, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('category: $category, ')
          ..write('applicableFor: $applicableFor, ')
          ..write('applyOn: $applyOn, ')
          ..write('title: $title, ')
          ..write('ruleName: $ruleName, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('isDiscountEnable: $isDiscountEnable, ')
          ..write('validFrom: $validFrom, ')
          ..write('validTo: $validTo')
          ..write(')'))
        .toString();
  }
}

class $ItemPricingRuleTable extends ItemPricingRule
    with TableInfo<$ItemPricingRuleTable, ItemPricingRuleData> {
  final GeneratedDatabase _db;
  final String _alias;
  $ItemPricingRuleTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _priorityMeta = const VerificationMeta('priority');
  GeneratedColumn<int> _priority;
  @override
  GeneratedColumn<int> get priority =>
      _priority ??= GeneratedColumn<int>('priority', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  GeneratedColumn<String> _itemId;
  @override
  GeneratedColumn<String> get itemId =>
      _itemId ??= GeneratedColumn<String>('item_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemCodeMeta = const VerificationMeta('itemCode');
  GeneratedColumn<String> _itemCode;
  @override
  GeneratedColumn<String> get itemCode =>
      _itemCode ??= GeneratedColumn<String>('item_code', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _priceListMeta = const VerificationMeta('priceList');
  GeneratedColumn<String> _priceList;
  @override
  GeneratedColumn<String> get priceList =>
      _priceList ??= GeneratedColumn<String>('price_list', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _customerIdMeta = const VerificationMeta('customerId');
  GeneratedColumn<String> _customerId;
  @override
  GeneratedColumn<String> get customerId =>
      _customerId ??= GeneratedColumn<String>('customer_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _minQuantityMeta =
      const VerificationMeta('minQuantity');
  GeneratedColumn<double> _minQuantity;
  @override
  GeneratedColumn<double> get minQuantity => _minQuantity ??=
      GeneratedColumn<double>('min_quantity', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _maxQuantityMeta =
      const VerificationMeta('maxQuantity');
  GeneratedColumn<double> _maxQuantity;
  @override
  GeneratedColumn<double> get maxQuantity => _maxQuantity ??=
      GeneratedColumn<double>('max_quantity', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _priceMeta = const VerificationMeta('price');
  GeneratedColumn<double> _price;
  @override
  GeneratedColumn<double> get price =>
      _price ??= GeneratedColumn<double>('price', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _discountPercentageMeta =
      const VerificationMeta('discountPercentage');
  GeneratedColumn<double> _discountPercentage;
  @override
  GeneratedColumn<double> get discountPercentage => _discountPercentage ??=
      GeneratedColumn<double>('discount_percentage', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _uomMeta = const VerificationMeta('uom');
  GeneratedColumn<String> _uom;
  @override
  GeneratedColumn<String> get uom =>
      _uom ??= GeneratedColumn<String>('uom', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _priceOrDiscountMeta =
      const VerificationMeta('priceOrDiscount');
  GeneratedColumn<String> _priceOrDiscount;
  @override
  GeneratedColumn<String> get priceOrDiscount => _priceOrDiscount ??=
      GeneratedColumn<String>('price_or_discount', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _customerGroupMeta =
      const VerificationMeta('customerGroup');
  GeneratedColumn<String> _customerGroup;
  @override
  GeneratedColumn<String> get customerGroup => _customerGroup ??=
      GeneratedColumn<String>('customer_group', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemGroupMeta = const VerificationMeta('itemGroup');
  GeneratedColumn<String> _itemGroup;
  @override
  GeneratedColumn<String> get itemGroup =>
      _itemGroup ??= GeneratedColumn<String>('item_group', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _categoryMeta = const VerificationMeta('category');
  GeneratedColumn<String> _category;
  @override
  GeneratedColumn<String> get category =>
      _category ??= GeneratedColumn<String>('category', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _applicableForMeta =
      const VerificationMeta('applicableFor');
  GeneratedColumn<String> _applicableFor;
  @override
  GeneratedColumn<String> get applicableFor => _applicableFor ??=
      GeneratedColumn<String>('applicable_for', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _applyOnMeta = const VerificationMeta('applyOn');
  GeneratedColumn<String> _applyOn;
  @override
  GeneratedColumn<String> get applyOn =>
      _applyOn ??= GeneratedColumn<String>('apply_on', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _titleMeta = const VerificationMeta('title');
  GeneratedColumn<String> _title;
  @override
  GeneratedColumn<String> get title =>
      _title ??= GeneratedColumn<String>('title', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _ruleNameMeta = const VerificationMeta('ruleName');
  GeneratedColumn<String> _ruleName;
  @override
  GeneratedColumn<String> get ruleName =>
      _ruleName ??= GeneratedColumn<String>('rule_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isActiveMeta = const VerificationMeta('isActive');
  GeneratedColumn<bool> _isActive;
  @override
  GeneratedColumn<bool> get isActive =>
      _isActive ??= GeneratedColumn<bool>('is_active', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_active IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isDeletedMeta = const VerificationMeta('isDeleted');
  GeneratedColumn<bool> _isDeleted;
  @override
  GeneratedColumn<bool> get isDeleted =>
      _isDeleted ??= GeneratedColumn<bool>('is_deleted', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_deleted IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isDiscountEnableMeta =
      const VerificationMeta('isDiscountEnable');
  GeneratedColumn<bool> _isDiscountEnable;
  @override
  GeneratedColumn<bool> get isDiscountEnable => _isDiscountEnable ??=
      GeneratedColumn<bool>('is_discount_enable', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_discount_enable IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _validFromMeta = const VerificationMeta('validFrom');
  GeneratedColumn<DateTime> _validFrom;
  @override
  GeneratedColumn<DateTime> get validFrom =>
      _validFrom ??= GeneratedColumn<DateTime>('valid_from', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _validToMeta = const VerificationMeta('validTo');
  GeneratedColumn<DateTime> _validTo;
  @override
  GeneratedColumn<DateTime> get validTo =>
      _validTo ??= GeneratedColumn<DateTime>('valid_to', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        priority,
        itemId,
        itemCode,
        priceList,
        customerId,
        minQuantity,
        maxQuantity,
        price,
        discountPercentage,
        uom,
        priceOrDiscount,
        customerGroup,
        itemGroup,
        category,
        applicableFor,
        applyOn,
        title,
        ruleName,
        isActive,
        isDeleted,
        isDiscountEnable,
        validFrom,
        validTo
      ];
  @override
  String get aliasedName => _alias ?? 'item_pricing_rule';
  @override
  String get actualTableName => 'item_pricing_rule';
  @override
  VerificationContext validateIntegrity(
      Insertable<ItemPricingRuleData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('priority')) {
      context.handle(_priorityMeta,
          priority.isAcceptableOrUnknown(data['priority'], _priorityMeta));
    } else if (isInserting) {
      context.missing(_priorityMeta);
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id'], _itemIdMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code'], _itemCodeMeta));
    }
    if (data.containsKey('price_list')) {
      context.handle(_priceListMeta,
          priceList.isAcceptableOrUnknown(data['price_list'], _priceListMeta));
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id'], _customerIdMeta));
    }
    if (data.containsKey('min_quantity')) {
      context.handle(
          _minQuantityMeta,
          minQuantity.isAcceptableOrUnknown(
              data['min_quantity'], _minQuantityMeta));
    } else if (isInserting) {
      context.missing(_minQuantityMeta);
    }
    if (data.containsKey('max_quantity')) {
      context.handle(
          _maxQuantityMeta,
          maxQuantity.isAcceptableOrUnknown(
              data['max_quantity'], _maxQuantityMeta));
    } else if (isInserting) {
      context.missing(_maxQuantityMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price'], _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('discount_percentage')) {
      context.handle(
          _discountPercentageMeta,
          discountPercentage.isAcceptableOrUnknown(
              data['discount_percentage'], _discountPercentageMeta));
    } else if (isInserting) {
      context.missing(_discountPercentageMeta);
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom'], _uomMeta));
    }
    if (data.containsKey('price_or_discount')) {
      context.handle(
          _priceOrDiscountMeta,
          priceOrDiscount.isAcceptableOrUnknown(
              data['price_or_discount'], _priceOrDiscountMeta));
    }
    if (data.containsKey('customer_group')) {
      context.handle(
          _customerGroupMeta,
          customerGroup.isAcceptableOrUnknown(
              data['customer_group'], _customerGroupMeta));
    }
    if (data.containsKey('item_group')) {
      context.handle(_itemGroupMeta,
          itemGroup.isAcceptableOrUnknown(data['item_group'], _itemGroupMeta));
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category'], _categoryMeta));
    }
    if (data.containsKey('applicable_for')) {
      context.handle(
          _applicableForMeta,
          applicableFor.isAcceptableOrUnknown(
              data['applicable_for'], _applicableForMeta));
    }
    if (data.containsKey('apply_on')) {
      context.handle(_applyOnMeta,
          applyOn.isAcceptableOrUnknown(data['apply_on'], _applyOnMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title'], _titleMeta));
    }
    if (data.containsKey('rule_name')) {
      context.handle(_ruleNameMeta,
          ruleName.isAcceptableOrUnknown(data['rule_name'], _ruleNameMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active'], _isActiveMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted'], _isDeletedMeta));
    }
    if (data.containsKey('is_discount_enable')) {
      context.handle(
          _isDiscountEnableMeta,
          isDiscountEnable.isAcceptableOrUnknown(
              data['is_discount_enable'], _isDiscountEnableMeta));
    }
    if (data.containsKey('valid_from')) {
      context.handle(_validFromMeta,
          validFrom.isAcceptableOrUnknown(data['valid_from'], _validFromMeta));
    }
    if (data.containsKey('valid_to')) {
      context.handle(_validToMeta,
          validTo.isAcceptableOrUnknown(data['valid_to'], _validToMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemPricingRuleData map(Map<String, dynamic> data, {String tablePrefix}) {
    return ItemPricingRuleData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $ItemPricingRuleTable createAlias(String alias) {
    return $ItemPricingRuleTable(_db, alias);
  }
}

class Categore extends DataClass implements Insertable<Categore> {
  final int tenantId;
  final int id;
  final String itemId;
  final String parentCategory;
  final String category;
  Categore(
      {this.tenantId,
      @required this.id,
      this.itemId,
      this.parentCategory,
      this.category});
  factory Categore.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return Categore(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      itemId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_id']),
      parentCategory: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}parent_category']),
      category: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}category']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || parentCategory != null) {
      map['parent_category'] = Variable<String>(parentCategory);
    }
    if (!nullToAbsent || category != null) {
      map['category'] = Variable<String>(category);
    }
    return map;
  }

  CategoresCompanion toCompanion(bool nullToAbsent) {
    return CategoresCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      parentCategory: parentCategory == null && nullToAbsent
          ? const Value.absent()
          : Value(parentCategory),
      category: category == null && nullToAbsent
          ? const Value.absent()
          : Value(category),
    );
  }

  factory Categore.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Categore(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<String>(json['itemId']),
      parentCategory: serializer.fromJson<String>(json['parentCategory']),
      category: serializer.fromJson<String>(json['category']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemId': serializer.toJson<String>(itemId),
      'parentCategory': serializer.toJson<String>(parentCategory),
      'category': serializer.toJson<String>(category),
    };
  }

  Categore copyWith(
          {int tenantId,
          int id,
          String itemId,
          String parentCategory,
          String category}) =>
      Categore(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        parentCategory: parentCategory ?? this.parentCategory,
        category: category ?? this.category,
      );
  @override
  String toString() {
    return (StringBuffer('Categore(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('parentCategory: $parentCategory, ')
          ..write('category: $category')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(tenantId, id, itemId, parentCategory, category);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Categore &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.parentCategory == this.parentCategory &&
          other.category == this.category);
}

class CategoresCompanion extends UpdateCompanion<Categore> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> itemId;
  final Value<String> parentCategory;
  final Value<String> category;
  const CategoresCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.parentCategory = const Value.absent(),
    this.category = const Value.absent(),
  });
  CategoresCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.parentCategory = const Value.absent(),
    this.category = const Value.absent(),
  });
  static Insertable<Categore> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> itemId,
    Expression<String> parentCategory,
    Expression<String> category,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (parentCategory != null) 'parent_category': parentCategory,
      if (category != null) 'category': category,
    });
  }

  CategoresCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> itemId,
      Value<String> parentCategory,
      Value<String> category}) {
    return CategoresCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      parentCategory: parentCategory ?? this.parentCategory,
      category: category ?? this.category,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (parentCategory.present) {
      map['parent_category'] = Variable<String>(parentCategory.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CategoresCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('parentCategory: $parentCategory, ')
          ..write('category: $category')
          ..write(')'))
        .toString();
  }
}

class $CategoresTable extends Categores
    with TableInfo<$CategoresTable, Categore> {
  final GeneratedDatabase _db;
  final String _alias;
  $CategoresTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  GeneratedColumn<String> _itemId;
  @override
  GeneratedColumn<String> get itemId =>
      _itemId ??= GeneratedColumn<String>('item_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _parentCategoryMeta =
      const VerificationMeta('parentCategory');
  GeneratedColumn<String> _parentCategory;
  @override
  GeneratedColumn<String> get parentCategory => _parentCategory ??=
      GeneratedColumn<String>('parent_category', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _categoryMeta = const VerificationMeta('category');
  GeneratedColumn<String> _category;
  @override
  GeneratedColumn<String> get category =>
      _category ??= GeneratedColumn<String>('category', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [tenantId, id, itemId, parentCategory, category];
  @override
  String get aliasedName => _alias ?? 'categores';
  @override
  String get actualTableName => 'categores';
  @override
  VerificationContext validateIntegrity(Insertable<Categore> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id'], _itemIdMeta));
    }
    if (data.containsKey('parent_category')) {
      context.handle(
          _parentCategoryMeta,
          parentCategory.isAcceptableOrUnknown(
              data['parent_category'], _parentCategoryMeta));
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category'], _categoryMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Categore map(Map<String, dynamic> data, {String tablePrefix}) {
    return Categore.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $CategoresTable createAlias(String alias) {
    return $CategoresTable(_db, alias);
  }
}

class ItemGroup extends DataClass implements Insertable<ItemGroup> {
  final int tenantId;
  final int id;
  final String itemId;
  final String parentGroup;
  final String group;
  ItemGroup(
      {this.tenantId,
      @required this.id,
      this.itemId,
      this.parentGroup,
      this.group});
  factory ItemGroup.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return ItemGroup(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      itemId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_id']),
      parentGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}parent_group']),
      group: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}group']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || parentGroup != null) {
      map['parent_group'] = Variable<String>(parentGroup);
    }
    if (!nullToAbsent || group != null) {
      map['group'] = Variable<String>(group);
    }
    return map;
  }

  ItemGroupsCompanion toCompanion(bool nullToAbsent) {
    return ItemGroupsCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      parentGroup: parentGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(parentGroup),
      group:
          group == null && nullToAbsent ? const Value.absent() : Value(group),
    );
  }

  factory ItemGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemGroup(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<String>(json['itemId']),
      parentGroup: serializer.fromJson<String>(json['parentGroup']),
      group: serializer.fromJson<String>(json['group']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemId': serializer.toJson<String>(itemId),
      'parentGroup': serializer.toJson<String>(parentGroup),
      'group': serializer.toJson<String>(group),
    };
  }

  ItemGroup copyWith(
          {int tenantId,
          int id,
          String itemId,
          String parentGroup,
          String group}) =>
      ItemGroup(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        parentGroup: parentGroup ?? this.parentGroup,
        group: group ?? this.group,
      );
  @override
  String toString() {
    return (StringBuffer('ItemGroup(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('parentGroup: $parentGroup, ')
          ..write('group: $group')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, itemId, parentGroup, group);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemGroup &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.parentGroup == this.parentGroup &&
          other.group == this.group);
}

class ItemGroupsCompanion extends UpdateCompanion<ItemGroup> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> itemId;
  final Value<String> parentGroup;
  final Value<String> group;
  const ItemGroupsCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.parentGroup = const Value.absent(),
    this.group = const Value.absent(),
  });
  ItemGroupsCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.parentGroup = const Value.absent(),
    this.group = const Value.absent(),
  });
  static Insertable<ItemGroup> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> itemId,
    Expression<String> parentGroup,
    Expression<String> group,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (parentGroup != null) 'parent_group': parentGroup,
      if (group != null) 'group': group,
    });
  }

  ItemGroupsCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> itemId,
      Value<String> parentGroup,
      Value<String> group}) {
    return ItemGroupsCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      parentGroup: parentGroup ?? this.parentGroup,
      group: group ?? this.group,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (parentGroup.present) {
      map['parent_group'] = Variable<String>(parentGroup.value);
    }
    if (group.present) {
      map['group'] = Variable<String>(group.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemGroupsCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('parentGroup: $parentGroup, ')
          ..write('group: $group')
          ..write(')'))
        .toString();
  }
}

class $ItemGroupsTable extends ItemGroups
    with TableInfo<$ItemGroupsTable, ItemGroup> {
  final GeneratedDatabase _db;
  final String _alias;
  $ItemGroupsTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  GeneratedColumn<String> _itemId;
  @override
  GeneratedColumn<String> get itemId =>
      _itemId ??= GeneratedColumn<String>('item_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _parentGroupMeta =
      const VerificationMeta('parentGroup');
  GeneratedColumn<String> _parentGroup;
  @override
  GeneratedColumn<String> get parentGroup => _parentGroup ??=
      GeneratedColumn<String>('parent_group', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _groupMeta = const VerificationMeta('group');
  GeneratedColumn<String> _group;
  @override
  GeneratedColumn<String> get group =>
      _group ??= GeneratedColumn<String>('group', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [tenantId, id, itemId, parentGroup, group];
  @override
  String get aliasedName => _alias ?? 'item_groups';
  @override
  String get actualTableName => 'item_groups';
  @override
  VerificationContext validateIntegrity(Insertable<ItemGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id'], _itemIdMeta));
    }
    if (data.containsKey('parent_group')) {
      context.handle(
          _parentGroupMeta,
          parentGroup.isAcceptableOrUnknown(
              data['parent_group'], _parentGroupMeta));
    }
    if (data.containsKey('group')) {
      context.handle(
          _groupMeta, group.isAcceptableOrUnknown(data['group'], _groupMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemGroup map(Map<String, dynamic> data, {String tablePrefix}) {
    return ItemGroup.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $ItemGroupsTable createAlias(String alias) {
    return $ItemGroupsTable(_db, alias);
  }
}

class PriceListData extends DataClass implements Insertable<PriceListData> {
  final int tenantId;
  final int id;
  final String priceListName;
  final String currency;
  final bool isActive;
  final bool isBuying;
  final bool isSelling;
  final bool isPriceNotUOMDependency;
  PriceListData(
      {this.tenantId,
      @required this.id,
      @required this.priceListName,
      this.currency,
      @required this.isActive,
      @required this.isBuying,
      @required this.isSelling,
      @required this.isPriceNotUOMDependency});
  factory PriceListData.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return PriceListData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      priceListName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}price_list_name']),
      currency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}currency']),
      isActive: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_active']),
      isBuying: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_buying']),
      isSelling: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_selling']),
      isPriceNotUOMDependency: const BoolType().mapFromDatabaseResponse(
          data['${effectivePrefix}is_price_not_u_o_m_dependency']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || priceListName != null) {
      map['price_list_name'] = Variable<String>(priceListName);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || isBuying != null) {
      map['is_buying'] = Variable<bool>(isBuying);
    }
    if (!nullToAbsent || isSelling != null) {
      map['is_selling'] = Variable<bool>(isSelling);
    }
    if (!nullToAbsent || isPriceNotUOMDependency != null) {
      map['is_price_not_u_o_m_dependency'] =
          Variable<bool>(isPriceNotUOMDependency);
    }
    return map;
  }

  PriceListCompanion toCompanion(bool nullToAbsent) {
    return PriceListCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      priceListName: priceListName == null && nullToAbsent
          ? const Value.absent()
          : Value(priceListName),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      isBuying: isBuying == null && nullToAbsent
          ? const Value.absent()
          : Value(isBuying),
      isSelling: isSelling == null && nullToAbsent
          ? const Value.absent()
          : Value(isSelling),
      isPriceNotUOMDependency: isPriceNotUOMDependency == null && nullToAbsent
          ? const Value.absent()
          : Value(isPriceNotUOMDependency),
    );
  }

  factory PriceListData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PriceListData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      priceListName: serializer.fromJson<String>(json['priceListName']),
      currency: serializer.fromJson<String>(json['currency']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isBuying: serializer.fromJson<bool>(json['isBuying']),
      isSelling: serializer.fromJson<bool>(json['isSelling']),
      isPriceNotUOMDependency:
          serializer.fromJson<bool>(json['isPriceNotUOMDependency']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'priceListName': serializer.toJson<String>(priceListName),
      'currency': serializer.toJson<String>(currency),
      'isActive': serializer.toJson<bool>(isActive),
      'isBuying': serializer.toJson<bool>(isBuying),
      'isSelling': serializer.toJson<bool>(isSelling),
      'isPriceNotUOMDependency':
          serializer.toJson<bool>(isPriceNotUOMDependency),
    };
  }

  PriceListData copyWith(
          {int tenantId,
          int id,
          String priceListName,
          String currency,
          bool isActive,
          bool isBuying,
          bool isSelling,
          bool isPriceNotUOMDependency}) =>
      PriceListData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        priceListName: priceListName ?? this.priceListName,
        currency: currency ?? this.currency,
        isActive: isActive ?? this.isActive,
        isBuying: isBuying ?? this.isBuying,
        isSelling: isSelling ?? this.isSelling,
        isPriceNotUOMDependency:
            isPriceNotUOMDependency ?? this.isPriceNotUOMDependency,
      );
  @override
  String toString() {
    return (StringBuffer('PriceListData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('priceListName: $priceListName, ')
          ..write('currency: $currency, ')
          ..write('isActive: $isActive, ')
          ..write('isBuying: $isBuying, ')
          ..write('isSelling: $isSelling, ')
          ..write('isPriceNotUOMDependency: $isPriceNotUOMDependency')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, priceListName, currency,
      isActive, isBuying, isSelling, isPriceNotUOMDependency);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PriceListData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.priceListName == this.priceListName &&
          other.currency == this.currency &&
          other.isActive == this.isActive &&
          other.isBuying == this.isBuying &&
          other.isSelling == this.isSelling &&
          other.isPriceNotUOMDependency == this.isPriceNotUOMDependency);
}

class PriceListCompanion extends UpdateCompanion<PriceListData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> priceListName;
  final Value<String> currency;
  final Value<bool> isActive;
  final Value<bool> isBuying;
  final Value<bool> isSelling;
  final Value<bool> isPriceNotUOMDependency;
  const PriceListCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.priceListName = const Value.absent(),
    this.currency = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isBuying = const Value.absent(),
    this.isSelling = const Value.absent(),
    this.isPriceNotUOMDependency = const Value.absent(),
  });
  PriceListCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    @required String priceListName,
    this.currency = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isBuying = const Value.absent(),
    this.isSelling = const Value.absent(),
    this.isPriceNotUOMDependency = const Value.absent(),
  }) : priceListName = Value(priceListName);
  static Insertable<PriceListData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> priceListName,
    Expression<String> currency,
    Expression<bool> isActive,
    Expression<bool> isBuying,
    Expression<bool> isSelling,
    Expression<bool> isPriceNotUOMDependency,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (priceListName != null) 'price_list_name': priceListName,
      if (currency != null) 'currency': currency,
      if (isActive != null) 'is_active': isActive,
      if (isBuying != null) 'is_buying': isBuying,
      if (isSelling != null) 'is_selling': isSelling,
      if (isPriceNotUOMDependency != null)
        'is_price_not_u_o_m_dependency': isPriceNotUOMDependency,
    });
  }

  PriceListCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> priceListName,
      Value<String> currency,
      Value<bool> isActive,
      Value<bool> isBuying,
      Value<bool> isSelling,
      Value<bool> isPriceNotUOMDependency}) {
    return PriceListCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      priceListName: priceListName ?? this.priceListName,
      currency: currency ?? this.currency,
      isActive: isActive ?? this.isActive,
      isBuying: isBuying ?? this.isBuying,
      isSelling: isSelling ?? this.isSelling,
      isPriceNotUOMDependency:
          isPriceNotUOMDependency ?? this.isPriceNotUOMDependency,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (priceListName.present) {
      map['price_list_name'] = Variable<String>(priceListName.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isBuying.present) {
      map['is_buying'] = Variable<bool>(isBuying.value);
    }
    if (isSelling.present) {
      map['is_selling'] = Variable<bool>(isSelling.value);
    }
    if (isPriceNotUOMDependency.present) {
      map['is_price_not_u_o_m_dependency'] =
          Variable<bool>(isPriceNotUOMDependency.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PriceListCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('priceListName: $priceListName, ')
          ..write('currency: $currency, ')
          ..write('isActive: $isActive, ')
          ..write('isBuying: $isBuying, ')
          ..write('isSelling: $isSelling, ')
          ..write('isPriceNotUOMDependency: $isPriceNotUOMDependency')
          ..write(')'))
        .toString();
  }
}

class $PriceListTable extends PriceList
    with TableInfo<$PriceListTable, PriceListData> {
  final GeneratedDatabase _db;
  final String _alias;
  $PriceListTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _priceListNameMeta =
      const VerificationMeta('priceListName');
  GeneratedColumn<String> _priceListName;
  @override
  GeneratedColumn<String> get priceListName => _priceListName ??=
      GeneratedColumn<String>('price_list_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _currencyMeta = const VerificationMeta('currency');
  GeneratedColumn<String> _currency;
  @override
  GeneratedColumn<String> get currency =>
      _currency ??= GeneratedColumn<String>('currency', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isActiveMeta = const VerificationMeta('isActive');
  GeneratedColumn<bool> _isActive;
  @override
  GeneratedColumn<bool> get isActive =>
      _isActive ??= GeneratedColumn<bool>('is_active', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_active IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isBuyingMeta = const VerificationMeta('isBuying');
  GeneratedColumn<bool> _isBuying;
  @override
  GeneratedColumn<bool> get isBuying =>
      _isBuying ??= GeneratedColumn<bool>('is_buying', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_buying IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isSellingMeta = const VerificationMeta('isSelling');
  GeneratedColumn<bool> _isSelling;
  @override
  GeneratedColumn<bool> get isSelling =>
      _isSelling ??= GeneratedColumn<bool>('is_selling', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_selling IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isPriceNotUOMDependencyMeta =
      const VerificationMeta('isPriceNotUOMDependency');
  GeneratedColumn<bool> _isPriceNotUOMDependency;
  @override
  GeneratedColumn<bool> get isPriceNotUOMDependency =>
      _isPriceNotUOMDependency ??= GeneratedColumn<bool>(
          'is_price_not_u_o_m_dependency', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_price_not_u_o_m_dependency IN (0, 1))',
          defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        priceListName,
        currency,
        isActive,
        isBuying,
        isSelling,
        isPriceNotUOMDependency
      ];
  @override
  String get aliasedName => _alias ?? 'price_list';
  @override
  String get actualTableName => 'price_list';
  @override
  VerificationContext validateIntegrity(Insertable<PriceListData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('price_list_name')) {
      context.handle(
          _priceListNameMeta,
          priceListName.isAcceptableOrUnknown(
              data['price_list_name'], _priceListNameMeta));
    } else if (isInserting) {
      context.missing(_priceListNameMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency'], _currencyMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active'], _isActiveMeta));
    }
    if (data.containsKey('is_buying')) {
      context.handle(_isBuyingMeta,
          isBuying.isAcceptableOrUnknown(data['is_buying'], _isBuyingMeta));
    }
    if (data.containsKey('is_selling')) {
      context.handle(_isSellingMeta,
          isSelling.isAcceptableOrUnknown(data['is_selling'], _isSellingMeta));
    }
    if (data.containsKey('is_price_not_u_o_m_dependency')) {
      context.handle(
          _isPriceNotUOMDependencyMeta,
          isPriceNotUOMDependency.isAcceptableOrUnknown(
              data['is_price_not_u_o_m_dependency'],
              _isPriceNotUOMDependencyMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PriceListData map(Map<String, dynamic> data, {String tablePrefix}) {
    return PriceListData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $PriceListTable createAlias(String alias) {
    return $PriceListTable(_db, alias);
  }
}

class UnitOfMeasureData extends DataClass
    implements Insertable<UnitOfMeasureData> {
  final int tenantId;
  final int id;
  final String uom;
  UnitOfMeasureData({this.tenantId, @required this.id, this.uom});
  factory UnitOfMeasureData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return UnitOfMeasureData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      uom: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}uom']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    return map;
  }

  UnitOfMeasureCompanion toCompanion(bool nullToAbsent) {
    return UnitOfMeasureCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
    );
  }

  factory UnitOfMeasureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UnitOfMeasureData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      uom: serializer.fromJson<String>(json['uom']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'uom': serializer.toJson<String>(uom),
    };
  }

  UnitOfMeasureData copyWith({int tenantId, int id, String uom}) =>
      UnitOfMeasureData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        uom: uom ?? this.uom,
      );
  @override
  String toString() {
    return (StringBuffer('UnitOfMeasureData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('uom: $uom')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, uom);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UnitOfMeasureData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.uom == this.uom);
}

class UnitOfMeasureCompanion extends UpdateCompanion<UnitOfMeasureData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> uom;
  const UnitOfMeasureCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.uom = const Value.absent(),
  });
  UnitOfMeasureCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.uom = const Value.absent(),
  });
  static Insertable<UnitOfMeasureData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> uom,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (uom != null) 'uom': uom,
    });
  }

  UnitOfMeasureCompanion copyWith(
      {Value<int> tenantId, Value<int> id, Value<String> uom}) {
    return UnitOfMeasureCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      uom: uom ?? this.uom,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UnitOfMeasureCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('uom: $uom')
          ..write(')'))
        .toString();
  }
}

class $UnitOfMeasureTable extends UnitOfMeasure
    with TableInfo<$UnitOfMeasureTable, UnitOfMeasureData> {
  final GeneratedDatabase _db;
  final String _alias;
  $UnitOfMeasureTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _uomMeta = const VerificationMeta('uom');
  GeneratedColumn<String> _uom;
  @override
  GeneratedColumn<String> get uom =>
      _uom ??= GeneratedColumn<String>('uom', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [tenantId, id, uom];
  @override
  String get aliasedName => _alias ?? 'unit_of_measure';
  @override
  String get actualTableName => 'unit_of_measure';
  @override
  VerificationContext validateIntegrity(Insertable<UnitOfMeasureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom'], _uomMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UnitOfMeasureData map(Map<String, dynamic> data, {String tablePrefix}) {
    return UnitOfMeasureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $UnitOfMeasureTable createAlias(String alias) {
    return $UnitOfMeasureTable(_db, alias);
  }
}

class StockUnitOfMeasureData extends DataClass
    implements Insertable<StockUnitOfMeasureData> {
  final int tenantId;
  final int id;
  final String itemId;
  final String uom;
  final int createUserId;
  final DateTime creationTime;
  final DateTime deleteTime;
  final int deleteUserId;
  final String creatorUser;
  final String deleterUserId;
  final bool isDeleted;
  final String lastModifierUser;
  final int lastModifierUserId;
  StockUnitOfMeasureData(
      {this.tenantId,
      @required this.id,
      this.itemId,
      this.uom,
      this.createUserId,
      this.creationTime,
      this.deleteTime,
      this.deleteUserId,
      this.creatorUser,
      this.deleterUserId,
      @required this.isDeleted,
      this.lastModifierUser,
      this.lastModifierUserId});
  factory StockUnitOfMeasureData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return StockUnitOfMeasureData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      itemId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_id']),
      uom: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}uom']),
      createUserId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}create_user_id']),
      creationTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}creation_time']),
      deleteTime: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}delete_time']),
      deleteUserId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}delete_user_id']),
      creatorUser: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}creator_user']),
      deleterUserId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}deleter_user_id']),
      isDeleted: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_deleted']),
      lastModifierUser: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}last_modifier_user']),
      lastModifierUserId: const IntType().mapFromDatabaseResponse(
          data['${effectivePrefix}last_modifier_user_id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    if (!nullToAbsent || createUserId != null) {
      map['create_user_id'] = Variable<int>(createUserId);
    }
    if (!nullToAbsent || creationTime != null) {
      map['creation_time'] = Variable<DateTime>(creationTime);
    }
    if (!nullToAbsent || deleteTime != null) {
      map['delete_time'] = Variable<DateTime>(deleteTime);
    }
    if (!nullToAbsent || deleteUserId != null) {
      map['delete_user_id'] = Variable<int>(deleteUserId);
    }
    if (!nullToAbsent || creatorUser != null) {
      map['creator_user'] = Variable<String>(creatorUser);
    }
    if (!nullToAbsent || deleterUserId != null) {
      map['deleter_user_id'] = Variable<String>(deleterUserId);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    if (!nullToAbsent || lastModifierUser != null) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser);
    }
    if (!nullToAbsent || lastModifierUserId != null) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId);
    }
    return map;
  }

  StockUnitOfMeasureCompanion toCompanion(bool nullToAbsent) {
    return StockUnitOfMeasureCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
      createUserId: createUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(createUserId),
      creationTime: creationTime == null && nullToAbsent
          ? const Value.absent()
          : Value(creationTime),
      deleteTime: deleteTime == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteTime),
      deleteUserId: deleteUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleteUserId),
      creatorUser: creatorUser == null && nullToAbsent
          ? const Value.absent()
          : Value(creatorUser),
      deleterUserId: deleterUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(deleterUserId),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
      lastModifierUser: lastModifierUser == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUser),
      lastModifierUserId: lastModifierUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifierUserId),
    );
  }

  factory StockUnitOfMeasureData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockUnitOfMeasureData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<String>(json['itemId']),
      uom: serializer.fromJson<String>(json['uom']),
      createUserId: serializer.fromJson<int>(json['createUserId']),
      creationTime: serializer.fromJson<DateTime>(json['creationTime']),
      deleteTime: serializer.fromJson<DateTime>(json['deleteTime']),
      deleteUserId: serializer.fromJson<int>(json['deleteUserId']),
      creatorUser: serializer.fromJson<String>(json['creatorUser']),
      deleterUserId: serializer.fromJson<String>(json['deleterUserId']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      lastModifierUser: serializer.fromJson<String>(json['lastModifierUser']),
      lastModifierUserId: serializer.fromJson<int>(json['lastModifierUserId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemId': serializer.toJson<String>(itemId),
      'uom': serializer.toJson<String>(uom),
      'createUserId': serializer.toJson<int>(createUserId),
      'creationTime': serializer.toJson<DateTime>(creationTime),
      'deleteTime': serializer.toJson<DateTime>(deleteTime),
      'deleteUserId': serializer.toJson<int>(deleteUserId),
      'creatorUser': serializer.toJson<String>(creatorUser),
      'deleterUserId': serializer.toJson<String>(deleterUserId),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'lastModifierUser': serializer.toJson<String>(lastModifierUser),
      'lastModifierUserId': serializer.toJson<int>(lastModifierUserId),
    };
  }

  StockUnitOfMeasureData copyWith(
          {int tenantId,
          int id,
          String itemId,
          String uom,
          int createUserId,
          DateTime creationTime,
          DateTime deleteTime,
          int deleteUserId,
          String creatorUser,
          String deleterUserId,
          bool isDeleted,
          String lastModifierUser,
          int lastModifierUserId}) =>
      StockUnitOfMeasureData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        uom: uom ?? this.uom,
        createUserId: createUserId ?? this.createUserId,
        creationTime: creationTime ?? this.creationTime,
        deleteTime: deleteTime ?? this.deleteTime,
        deleteUserId: deleteUserId ?? this.deleteUserId,
        creatorUser: creatorUser ?? this.creatorUser,
        deleterUserId: deleterUserId ?? this.deleterUserId,
        isDeleted: isDeleted ?? this.isDeleted,
        lastModifierUser: lastModifierUser ?? this.lastModifierUser,
        lastModifierUserId: lastModifierUserId ?? this.lastModifierUserId,
      );
  @override
  String toString() {
    return (StringBuffer('StockUnitOfMeasureData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('uom: $uom, ')
          ..write('createUserId: $createUserId, ')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      itemId,
      uom,
      createUserId,
      creationTime,
      deleteTime,
      deleteUserId,
      creatorUser,
      deleterUserId,
      isDeleted,
      lastModifierUser,
      lastModifierUserId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockUnitOfMeasureData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.uom == this.uom &&
          other.createUserId == this.createUserId &&
          other.creationTime == this.creationTime &&
          other.deleteTime == this.deleteTime &&
          other.deleteUserId == this.deleteUserId &&
          other.creatorUser == this.creatorUser &&
          other.deleterUserId == this.deleterUserId &&
          other.isDeleted == this.isDeleted &&
          other.lastModifierUser == this.lastModifierUser &&
          other.lastModifierUserId == this.lastModifierUserId);
}

class StockUnitOfMeasureCompanion
    extends UpdateCompanion<StockUnitOfMeasureData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> itemId;
  final Value<String> uom;
  final Value<int> createUserId;
  final Value<DateTime> creationTime;
  final Value<DateTime> deleteTime;
  final Value<int> deleteUserId;
  final Value<String> creatorUser;
  final Value<String> deleterUserId;
  final Value<bool> isDeleted;
  final Value<String> lastModifierUser;
  final Value<int> lastModifierUserId;
  const StockUnitOfMeasureCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.uom = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
  });
  StockUnitOfMeasureCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.uom = const Value.absent(),
    this.createUserId = const Value.absent(),
    this.creationTime = const Value.absent(),
    this.deleteTime = const Value.absent(),
    this.deleteUserId = const Value.absent(),
    this.creatorUser = const Value.absent(),
    this.deleterUserId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lastModifierUser = const Value.absent(),
    this.lastModifierUserId = const Value.absent(),
  });
  static Insertable<StockUnitOfMeasureData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> itemId,
    Expression<String> uom,
    Expression<int> createUserId,
    Expression<DateTime> creationTime,
    Expression<DateTime> deleteTime,
    Expression<int> deleteUserId,
    Expression<String> creatorUser,
    Expression<String> deleterUserId,
    Expression<bool> isDeleted,
    Expression<String> lastModifierUser,
    Expression<int> lastModifierUserId,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (uom != null) 'uom': uom,
      if (createUserId != null) 'create_user_id': createUserId,
      if (creationTime != null) 'creation_time': creationTime,
      if (deleteTime != null) 'delete_time': deleteTime,
      if (deleteUserId != null) 'delete_user_id': deleteUserId,
      if (creatorUser != null) 'creator_user': creatorUser,
      if (deleterUserId != null) 'deleter_user_id': deleterUserId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (lastModifierUser != null) 'last_modifier_user': lastModifierUser,
      if (lastModifierUserId != null)
        'last_modifier_user_id': lastModifierUserId,
    });
  }

  StockUnitOfMeasureCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> itemId,
      Value<String> uom,
      Value<int> createUserId,
      Value<DateTime> creationTime,
      Value<DateTime> deleteTime,
      Value<int> deleteUserId,
      Value<String> creatorUser,
      Value<String> deleterUserId,
      Value<bool> isDeleted,
      Value<String> lastModifierUser,
      Value<int> lastModifierUserId}) {
    return StockUnitOfMeasureCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      uom: uom ?? this.uom,
      createUserId: createUserId ?? this.createUserId,
      creationTime: creationTime ?? this.creationTime,
      deleteTime: deleteTime ?? this.deleteTime,
      deleteUserId: deleteUserId ?? this.deleteUserId,
      creatorUser: creatorUser ?? this.creatorUser,
      deleterUserId: deleterUserId ?? this.deleterUserId,
      isDeleted: isDeleted ?? this.isDeleted,
      lastModifierUser: lastModifierUser ?? this.lastModifierUser,
      lastModifierUserId: lastModifierUserId ?? this.lastModifierUserId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    if (createUserId.present) {
      map['create_user_id'] = Variable<int>(createUserId.value);
    }
    if (creationTime.present) {
      map['creation_time'] = Variable<DateTime>(creationTime.value);
    }
    if (deleteTime.present) {
      map['delete_time'] = Variable<DateTime>(deleteTime.value);
    }
    if (deleteUserId.present) {
      map['delete_user_id'] = Variable<int>(deleteUserId.value);
    }
    if (creatorUser.present) {
      map['creator_user'] = Variable<String>(creatorUser.value);
    }
    if (deleterUserId.present) {
      map['deleter_user_id'] = Variable<String>(deleterUserId.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (lastModifierUser.present) {
      map['last_modifier_user'] = Variable<String>(lastModifierUser.value);
    }
    if (lastModifierUserId.present) {
      map['last_modifier_user_id'] = Variable<int>(lastModifierUserId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockUnitOfMeasureCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('uom: $uom, ')
          ..write('createUserId: $createUserId, ')
          ..write('creationTime: $creationTime, ')
          ..write('deleteTime: $deleteTime, ')
          ..write('deleteUserId: $deleteUserId, ')
          ..write('creatorUser: $creatorUser, ')
          ..write('deleterUserId: $deleterUserId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lastModifierUser: $lastModifierUser, ')
          ..write('lastModifierUserId: $lastModifierUserId')
          ..write(')'))
        .toString();
  }
}

class $StockUnitOfMeasureTable extends StockUnitOfMeasure
    with TableInfo<$StockUnitOfMeasureTable, StockUnitOfMeasureData> {
  final GeneratedDatabase _db;
  final String _alias;
  $StockUnitOfMeasureTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  GeneratedColumn<String> _itemId;
  @override
  GeneratedColumn<String> get itemId =>
      _itemId ??= GeneratedColumn<String>('item_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _uomMeta = const VerificationMeta('uom');
  GeneratedColumn<String> _uom;
  @override
  GeneratedColumn<String> get uom =>
      _uom ??= GeneratedColumn<String>('uom', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _createUserIdMeta =
      const VerificationMeta('createUserId');
  GeneratedColumn<int> _createUserId;
  @override
  GeneratedColumn<int> get createUserId => _createUserId ??=
      GeneratedColumn<int>('create_user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _creationTimeMeta =
      const VerificationMeta('creationTime');
  GeneratedColumn<DateTime> _creationTime;
  @override
  GeneratedColumn<DateTime> get creationTime => _creationTime ??=
      GeneratedColumn<DateTime>('creation_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _deleteTimeMeta = const VerificationMeta('deleteTime');
  GeneratedColumn<DateTime> _deleteTime;
  @override
  GeneratedColumn<DateTime> get deleteTime => _deleteTime ??=
      GeneratedColumn<DateTime>('delete_time', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _deleteUserIdMeta =
      const VerificationMeta('deleteUserId');
  GeneratedColumn<int> _deleteUserId;
  @override
  GeneratedColumn<int> get deleteUserId => _deleteUserId ??=
      GeneratedColumn<int>('delete_user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _creatorUserMeta =
      const VerificationMeta('creatorUser');
  GeneratedColumn<String> _creatorUser;
  @override
  GeneratedColumn<String> get creatorUser => _creatorUser ??=
      GeneratedColumn<String>('creator_user', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deleterUserIdMeta =
      const VerificationMeta('deleterUserId');
  GeneratedColumn<String> _deleterUserId;
  @override
  GeneratedColumn<String> get deleterUserId => _deleterUserId ??=
      GeneratedColumn<String>('deleter_user_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isDeletedMeta = const VerificationMeta('isDeleted');
  GeneratedColumn<bool> _isDeleted;
  @override
  GeneratedColumn<bool> get isDeleted =>
      _isDeleted ??= GeneratedColumn<bool>('is_deleted', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_deleted IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _lastModifierUserMeta =
      const VerificationMeta('lastModifierUser');
  GeneratedColumn<String> _lastModifierUser;
  @override
  GeneratedColumn<String> get lastModifierUser => _lastModifierUser ??=
      GeneratedColumn<String>('last_modifier_user', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _lastModifierUserIdMeta =
      const VerificationMeta('lastModifierUserId');
  GeneratedColumn<int> _lastModifierUserId;
  @override
  GeneratedColumn<int> get lastModifierUserId => _lastModifierUserId ??=
      GeneratedColumn<int>('last_modifier_user_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        itemId,
        uom,
        createUserId,
        creationTime,
        deleteTime,
        deleteUserId,
        creatorUser,
        deleterUserId,
        isDeleted,
        lastModifierUser,
        lastModifierUserId
      ];
  @override
  String get aliasedName => _alias ?? 'stock_unit_of_measure';
  @override
  String get actualTableName => 'stock_unit_of_measure';
  @override
  VerificationContext validateIntegrity(
      Insertable<StockUnitOfMeasureData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id'], _itemIdMeta));
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom'], _uomMeta));
    }
    if (data.containsKey('create_user_id')) {
      context.handle(
          _createUserIdMeta,
          createUserId.isAcceptableOrUnknown(
              data['create_user_id'], _createUserIdMeta));
    }
    if (data.containsKey('creation_time')) {
      context.handle(
          _creationTimeMeta,
          creationTime.isAcceptableOrUnknown(
              data['creation_time'], _creationTimeMeta));
    }
    if (data.containsKey('delete_time')) {
      context.handle(
          _deleteTimeMeta,
          deleteTime.isAcceptableOrUnknown(
              data['delete_time'], _deleteTimeMeta));
    }
    if (data.containsKey('delete_user_id')) {
      context.handle(
          _deleteUserIdMeta,
          deleteUserId.isAcceptableOrUnknown(
              data['delete_user_id'], _deleteUserIdMeta));
    }
    if (data.containsKey('creator_user')) {
      context.handle(
          _creatorUserMeta,
          creatorUser.isAcceptableOrUnknown(
              data['creator_user'], _creatorUserMeta));
    }
    if (data.containsKey('deleter_user_id')) {
      context.handle(
          _deleterUserIdMeta,
          deleterUserId.isAcceptableOrUnknown(
              data['deleter_user_id'], _deleterUserIdMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted'], _isDeletedMeta));
    }
    if (data.containsKey('last_modifier_user')) {
      context.handle(
          _lastModifierUserMeta,
          lastModifierUser.isAcceptableOrUnknown(
              data['last_modifier_user'], _lastModifierUserMeta));
    }
    if (data.containsKey('last_modifier_user_id')) {
      context.handle(
          _lastModifierUserIdMeta,
          lastModifierUserId.isAcceptableOrUnknown(
              data['last_modifier_user_id'], _lastModifierUserIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StockUnitOfMeasureData map(Map<String, dynamic> data, {String tablePrefix}) {
    return StockUnitOfMeasureData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $StockUnitOfMeasureTable createAlias(String alias) {
    return $StockUnitOfMeasureTable(_db, alias);
  }
}

class JourneyPlanData extends DataClass implements Insertable<JourneyPlanData> {
  final int tenantId;
  final int id;
  final String customerId;
  final String customerName;
  final String companyName;
  final String customerType;
  final String customerGroup;
  final String customerTerritory;
  final String billingAddressName;
  final String shippingAddressName;
  final String assignTo;
  final DateTime expiryDate;
  final int weekNumber;
  final String weekDay;
  final double inMiles;
  final double inKilometer;
  final double inMeter;
  final String distanceLabel;
  final double distanceUsed;
  final String transactionStatus;
  final bool isDeleted;
  JourneyPlanData(
      {this.tenantId,
      @required this.id,
      @required this.customerId,
      @required this.customerName,
      @required this.companyName,
      @required this.customerType,
      @required this.customerGroup,
      @required this.customerTerritory,
      this.billingAddressName,
      this.shippingAddressName,
      this.assignTo,
      this.expiryDate,
      this.weekNumber,
      this.weekDay,
      this.inMiles,
      this.inKilometer,
      this.inMeter,
      this.distanceLabel,
      this.distanceUsed,
      this.transactionStatus,
      @required this.isDeleted});
  factory JourneyPlanData.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return JourneyPlanData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      customerId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_id']),
      customerName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_name']),
      companyName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}company_name']),
      customerType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_type']),
      customerGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}customer_group']),
      customerTerritory: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}customer_territory']),
      billingAddressName: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}billing_address_name']),
      shippingAddressName: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}shipping_address_name']),
      assignTo: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}assign_to']),
      expiryDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}expiry_date']),
      weekNumber: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}week_number']),
      weekDay: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}week_day']),
      inMiles: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}in_miles']),
      inKilometer: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}in_kilometer']),
      inMeter: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}in_meter']),
      distanceLabel: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}distance_label']),
      distanceUsed: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}distance_used']),
      transactionStatus: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}transaction_status']),
      isDeleted: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_deleted']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || customerId != null) {
      map['customer_id'] = Variable<String>(customerId);
    }
    if (!nullToAbsent || customerName != null) {
      map['customer_name'] = Variable<String>(customerName);
    }
    if (!nullToAbsent || companyName != null) {
      map['company_name'] = Variable<String>(companyName);
    }
    if (!nullToAbsent || customerType != null) {
      map['customer_type'] = Variable<String>(customerType);
    }
    if (!nullToAbsent || customerGroup != null) {
      map['customer_group'] = Variable<String>(customerGroup);
    }
    if (!nullToAbsent || customerTerritory != null) {
      map['customer_territory'] = Variable<String>(customerTerritory);
    }
    if (!nullToAbsent || billingAddressName != null) {
      map['billing_address_name'] = Variable<String>(billingAddressName);
    }
    if (!nullToAbsent || shippingAddressName != null) {
      map['shipping_address_name'] = Variable<String>(shippingAddressName);
    }
    if (!nullToAbsent || assignTo != null) {
      map['assign_to'] = Variable<String>(assignTo);
    }
    if (!nullToAbsent || expiryDate != null) {
      map['expiry_date'] = Variable<DateTime>(expiryDate);
    }
    if (!nullToAbsent || weekNumber != null) {
      map['week_number'] = Variable<int>(weekNumber);
    }
    if (!nullToAbsent || weekDay != null) {
      map['week_day'] = Variable<String>(weekDay);
    }
    if (!nullToAbsent || inMiles != null) {
      map['in_miles'] = Variable<double>(inMiles);
    }
    if (!nullToAbsent || inKilometer != null) {
      map['in_kilometer'] = Variable<double>(inKilometer);
    }
    if (!nullToAbsent || inMeter != null) {
      map['in_meter'] = Variable<double>(inMeter);
    }
    if (!nullToAbsent || distanceLabel != null) {
      map['distance_label'] = Variable<String>(distanceLabel);
    }
    if (!nullToAbsent || distanceUsed != null) {
      map['distance_used'] = Variable<double>(distanceUsed);
    }
    if (!nullToAbsent || transactionStatus != null) {
      map['transaction_status'] = Variable<String>(transactionStatus);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    return map;
  }

  JourneyPlanCompanion toCompanion(bool nullToAbsent) {
    return JourneyPlanCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      customerId: customerId == null && nullToAbsent
          ? const Value.absent()
          : Value(customerId),
      customerName: customerName == null && nullToAbsent
          ? const Value.absent()
          : Value(customerName),
      companyName: companyName == null && nullToAbsent
          ? const Value.absent()
          : Value(companyName),
      customerType: customerType == null && nullToAbsent
          ? const Value.absent()
          : Value(customerType),
      customerGroup: customerGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(customerGroup),
      customerTerritory: customerTerritory == null && nullToAbsent
          ? const Value.absent()
          : Value(customerTerritory),
      billingAddressName: billingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(billingAddressName),
      shippingAddressName: shippingAddressName == null && nullToAbsent
          ? const Value.absent()
          : Value(shippingAddressName),
      assignTo: assignTo == null && nullToAbsent
          ? const Value.absent()
          : Value(assignTo),
      expiryDate: expiryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(expiryDate),
      weekNumber: weekNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(weekNumber),
      weekDay: weekDay == null && nullToAbsent
          ? const Value.absent()
          : Value(weekDay),
      inMiles: inMiles == null && nullToAbsent
          ? const Value.absent()
          : Value(inMiles),
      inKilometer: inKilometer == null && nullToAbsent
          ? const Value.absent()
          : Value(inKilometer),
      inMeter: inMeter == null && nullToAbsent
          ? const Value.absent()
          : Value(inMeter),
      distanceLabel: distanceLabel == null && nullToAbsent
          ? const Value.absent()
          : Value(distanceLabel),
      distanceUsed: distanceUsed == null && nullToAbsent
          ? const Value.absent()
          : Value(distanceUsed),
      transactionStatus: transactionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionStatus),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
    );
  }

  factory JourneyPlanData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return JourneyPlanData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      customerId: serializer.fromJson<String>(json['customerId']),
      customerName: serializer.fromJson<String>(json['customerName']),
      companyName: serializer.fromJson<String>(json['companyName']),
      customerType: serializer.fromJson<String>(json['customerType']),
      customerGroup: serializer.fromJson<String>(json['customerGroup']),
      customerTerritory: serializer.fromJson<String>(json['customerTerritory']),
      billingAddressName:
          serializer.fromJson<String>(json['billingAddressName']),
      shippingAddressName:
          serializer.fromJson<String>(json['shippingAddressName']),
      assignTo: serializer.fromJson<String>(json['assignTo']),
      expiryDate: serializer.fromJson<DateTime>(json['expiryDate']),
      weekNumber: serializer.fromJson<int>(json['weekNumber']),
      weekDay: serializer.fromJson<String>(json['weekDay']),
      inMiles: serializer.fromJson<double>(json['inMiles']),
      inKilometer: serializer.fromJson<double>(json['inKilometer']),
      inMeter: serializer.fromJson<double>(json['inMeter']),
      distanceLabel: serializer.fromJson<String>(json['distanceLabel']),
      distanceUsed: serializer.fromJson<double>(json['distanceUsed']),
      transactionStatus: serializer.fromJson<String>(json['transactionStatus']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'customerId': serializer.toJson<String>(customerId),
      'customerName': serializer.toJson<String>(customerName),
      'companyName': serializer.toJson<String>(companyName),
      'customerType': serializer.toJson<String>(customerType),
      'customerGroup': serializer.toJson<String>(customerGroup),
      'customerTerritory': serializer.toJson<String>(customerTerritory),
      'billingAddressName': serializer.toJson<String>(billingAddressName),
      'shippingAddressName': serializer.toJson<String>(shippingAddressName),
      'assignTo': serializer.toJson<String>(assignTo),
      'expiryDate': serializer.toJson<DateTime>(expiryDate),
      'weekNumber': serializer.toJson<int>(weekNumber),
      'weekDay': serializer.toJson<String>(weekDay),
      'inMiles': serializer.toJson<double>(inMiles),
      'inKilometer': serializer.toJson<double>(inKilometer),
      'inMeter': serializer.toJson<double>(inMeter),
      'distanceLabel': serializer.toJson<String>(distanceLabel),
      'distanceUsed': serializer.toJson<double>(distanceUsed),
      'transactionStatus': serializer.toJson<String>(transactionStatus),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  JourneyPlanData copyWith(
          {int tenantId,
          int id,
          String customerId,
          String customerName,
          String companyName,
          String customerType,
          String customerGroup,
          String customerTerritory,
          String billingAddressName,
          String shippingAddressName,
          String assignTo,
          DateTime expiryDate,
          int weekNumber,
          String weekDay,
          double inMiles,
          double inKilometer,
          double inMeter,
          String distanceLabel,
          double distanceUsed,
          String transactionStatus,
          bool isDeleted}) =>
      JourneyPlanData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        customerId: customerId ?? this.customerId,
        customerName: customerName ?? this.customerName,
        companyName: companyName ?? this.companyName,
        customerType: customerType ?? this.customerType,
        customerGroup: customerGroup ?? this.customerGroup,
        customerTerritory: customerTerritory ?? this.customerTerritory,
        billingAddressName: billingAddressName ?? this.billingAddressName,
        shippingAddressName: shippingAddressName ?? this.shippingAddressName,
        assignTo: assignTo ?? this.assignTo,
        expiryDate: expiryDate ?? this.expiryDate,
        weekNumber: weekNumber ?? this.weekNumber,
        weekDay: weekDay ?? this.weekDay,
        inMiles: inMiles ?? this.inMiles,
        inKilometer: inKilometer ?? this.inKilometer,
        inMeter: inMeter ?? this.inMeter,
        distanceLabel: distanceLabel ?? this.distanceLabel,
        distanceUsed: distanceUsed ?? this.distanceUsed,
        transactionStatus: transactionStatus ?? this.transactionStatus,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  @override
  String toString() {
    return (StringBuffer('JourneyPlanData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('companyName: $companyName, ')
          ..write('customerType: $customerType, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('customerTerritory: $customerTerritory, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('assignTo: $assignTo, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('weekNumber: $weekNumber, ')
          ..write('weekDay: $weekDay, ')
          ..write('inMiles: $inMiles, ')
          ..write('inKilometer: $inKilometer, ')
          ..write('inMeter: $inMeter, ')
          ..write('distanceLabel: $distanceLabel, ')
          ..write('distanceUsed: $distanceUsed, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        id,
        customerId,
        customerName,
        companyName,
        customerType,
        customerGroup,
        customerTerritory,
        billingAddressName,
        shippingAddressName,
        assignTo,
        expiryDate,
        weekNumber,
        weekDay,
        inMiles,
        inKilometer,
        inMeter,
        distanceLabel,
        distanceUsed,
        transactionStatus,
        isDeleted
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is JourneyPlanData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.customerId == this.customerId &&
          other.customerName == this.customerName &&
          other.companyName == this.companyName &&
          other.customerType == this.customerType &&
          other.customerGroup == this.customerGroup &&
          other.customerTerritory == this.customerTerritory &&
          other.billingAddressName == this.billingAddressName &&
          other.shippingAddressName == this.shippingAddressName &&
          other.assignTo == this.assignTo &&
          other.expiryDate == this.expiryDate &&
          other.weekNumber == this.weekNumber &&
          other.weekDay == this.weekDay &&
          other.inMiles == this.inMiles &&
          other.inKilometer == this.inKilometer &&
          other.inMeter == this.inMeter &&
          other.distanceLabel == this.distanceLabel &&
          other.distanceUsed == this.distanceUsed &&
          other.transactionStatus == this.transactionStatus &&
          other.isDeleted == this.isDeleted);
}

class JourneyPlanCompanion extends UpdateCompanion<JourneyPlanData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> customerId;
  final Value<String> customerName;
  final Value<String> companyName;
  final Value<String> customerType;
  final Value<String> customerGroup;
  final Value<String> customerTerritory;
  final Value<String> billingAddressName;
  final Value<String> shippingAddressName;
  final Value<String> assignTo;
  final Value<DateTime> expiryDate;
  final Value<int> weekNumber;
  final Value<String> weekDay;
  final Value<double> inMiles;
  final Value<double> inKilometer;
  final Value<double> inMeter;
  final Value<String> distanceLabel;
  final Value<double> distanceUsed;
  final Value<String> transactionStatus;
  final Value<bool> isDeleted;
  const JourneyPlanCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.customerId = const Value.absent(),
    this.customerName = const Value.absent(),
    this.companyName = const Value.absent(),
    this.customerType = const Value.absent(),
    this.customerGroup = const Value.absent(),
    this.customerTerritory = const Value.absent(),
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.assignTo = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.weekNumber = const Value.absent(),
    this.weekDay = const Value.absent(),
    this.inMiles = const Value.absent(),
    this.inKilometer = const Value.absent(),
    this.inMeter = const Value.absent(),
    this.distanceLabel = const Value.absent(),
    this.distanceUsed = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  JourneyPlanCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    @required String customerId,
    @required String customerName,
    @required String companyName,
    @required String customerType,
    @required String customerGroup,
    @required String customerTerritory,
    this.billingAddressName = const Value.absent(),
    this.shippingAddressName = const Value.absent(),
    this.assignTo = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.weekNumber = const Value.absent(),
    this.weekDay = const Value.absent(),
    this.inMiles = const Value.absent(),
    this.inKilometer = const Value.absent(),
    this.inMeter = const Value.absent(),
    this.distanceLabel = const Value.absent(),
    this.distanceUsed = const Value.absent(),
    this.transactionStatus = const Value.absent(),
    this.isDeleted = const Value.absent(),
  })  : customerId = Value(customerId),
        customerName = Value(customerName),
        companyName = Value(companyName),
        customerType = Value(customerType),
        customerGroup = Value(customerGroup),
        customerTerritory = Value(customerTerritory);
  static Insertable<JourneyPlanData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> customerId,
    Expression<String> customerName,
    Expression<String> companyName,
    Expression<String> customerType,
    Expression<String> customerGroup,
    Expression<String> customerTerritory,
    Expression<String> billingAddressName,
    Expression<String> shippingAddressName,
    Expression<String> assignTo,
    Expression<DateTime> expiryDate,
    Expression<int> weekNumber,
    Expression<String> weekDay,
    Expression<double> inMiles,
    Expression<double> inKilometer,
    Expression<double> inMeter,
    Expression<String> distanceLabel,
    Expression<double> distanceUsed,
    Expression<String> transactionStatus,
    Expression<bool> isDeleted,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (customerId != null) 'customer_id': customerId,
      if (customerName != null) 'customer_name': customerName,
      if (companyName != null) 'company_name': companyName,
      if (customerType != null) 'customer_type': customerType,
      if (customerGroup != null) 'customer_group': customerGroup,
      if (customerTerritory != null) 'customer_territory': customerTerritory,
      if (billingAddressName != null)
        'billing_address_name': billingAddressName,
      if (shippingAddressName != null)
        'shipping_address_name': shippingAddressName,
      if (assignTo != null) 'assign_to': assignTo,
      if (expiryDate != null) 'expiry_date': expiryDate,
      if (weekNumber != null) 'week_number': weekNumber,
      if (weekDay != null) 'week_day': weekDay,
      if (inMiles != null) 'in_miles': inMiles,
      if (inKilometer != null) 'in_kilometer': inKilometer,
      if (inMeter != null) 'in_meter': inMeter,
      if (distanceLabel != null) 'distance_label': distanceLabel,
      if (distanceUsed != null) 'distance_used': distanceUsed,
      if (transactionStatus != null) 'transaction_status': transactionStatus,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  JourneyPlanCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> customerId,
      Value<String> customerName,
      Value<String> companyName,
      Value<String> customerType,
      Value<String> customerGroup,
      Value<String> customerTerritory,
      Value<String> billingAddressName,
      Value<String> shippingAddressName,
      Value<String> assignTo,
      Value<DateTime> expiryDate,
      Value<int> weekNumber,
      Value<String> weekDay,
      Value<double> inMiles,
      Value<double> inKilometer,
      Value<double> inMeter,
      Value<String> distanceLabel,
      Value<double> distanceUsed,
      Value<String> transactionStatus,
      Value<bool> isDeleted}) {
    return JourneyPlanCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      customerId: customerId ?? this.customerId,
      customerName: customerName ?? this.customerName,
      companyName: companyName ?? this.companyName,
      customerType: customerType ?? this.customerType,
      customerGroup: customerGroup ?? this.customerGroup,
      customerTerritory: customerTerritory ?? this.customerTerritory,
      billingAddressName: billingAddressName ?? this.billingAddressName,
      shippingAddressName: shippingAddressName ?? this.shippingAddressName,
      assignTo: assignTo ?? this.assignTo,
      expiryDate: expiryDate ?? this.expiryDate,
      weekNumber: weekNumber ?? this.weekNumber,
      weekDay: weekDay ?? this.weekDay,
      inMiles: inMiles ?? this.inMiles,
      inKilometer: inKilometer ?? this.inKilometer,
      inMeter: inMeter ?? this.inMeter,
      distanceLabel: distanceLabel ?? this.distanceLabel,
      distanceUsed: distanceUsed ?? this.distanceUsed,
      transactionStatus: transactionStatus ?? this.transactionStatus,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (customerId.present) {
      map['customer_id'] = Variable<String>(customerId.value);
    }
    if (customerName.present) {
      map['customer_name'] = Variable<String>(customerName.value);
    }
    if (companyName.present) {
      map['company_name'] = Variable<String>(companyName.value);
    }
    if (customerType.present) {
      map['customer_type'] = Variable<String>(customerType.value);
    }
    if (customerGroup.present) {
      map['customer_group'] = Variable<String>(customerGroup.value);
    }
    if (customerTerritory.present) {
      map['customer_territory'] = Variable<String>(customerTerritory.value);
    }
    if (billingAddressName.present) {
      map['billing_address_name'] = Variable<String>(billingAddressName.value);
    }
    if (shippingAddressName.present) {
      map['shipping_address_name'] =
          Variable<String>(shippingAddressName.value);
    }
    if (assignTo.present) {
      map['assign_to'] = Variable<String>(assignTo.value);
    }
    if (expiryDate.present) {
      map['expiry_date'] = Variable<DateTime>(expiryDate.value);
    }
    if (weekNumber.present) {
      map['week_number'] = Variable<int>(weekNumber.value);
    }
    if (weekDay.present) {
      map['week_day'] = Variable<String>(weekDay.value);
    }
    if (inMiles.present) {
      map['in_miles'] = Variable<double>(inMiles.value);
    }
    if (inKilometer.present) {
      map['in_kilometer'] = Variable<double>(inKilometer.value);
    }
    if (inMeter.present) {
      map['in_meter'] = Variable<double>(inMeter.value);
    }
    if (distanceLabel.present) {
      map['distance_label'] = Variable<String>(distanceLabel.value);
    }
    if (distanceUsed.present) {
      map['distance_used'] = Variable<double>(distanceUsed.value);
    }
    if (transactionStatus.present) {
      map['transaction_status'] = Variable<String>(transactionStatus.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('JourneyPlanCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('customerId: $customerId, ')
          ..write('customerName: $customerName, ')
          ..write('companyName: $companyName, ')
          ..write('customerType: $customerType, ')
          ..write('customerGroup: $customerGroup, ')
          ..write('customerTerritory: $customerTerritory, ')
          ..write('billingAddressName: $billingAddressName, ')
          ..write('shippingAddressName: $shippingAddressName, ')
          ..write('assignTo: $assignTo, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('weekNumber: $weekNumber, ')
          ..write('weekDay: $weekDay, ')
          ..write('inMiles: $inMiles, ')
          ..write('inKilometer: $inKilometer, ')
          ..write('inMeter: $inMeter, ')
          ..write('distanceLabel: $distanceLabel, ')
          ..write('distanceUsed: $distanceUsed, ')
          ..write('transactionStatus: $transactionStatus, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $JourneyPlanTable extends JourneyPlan
    with TableInfo<$JourneyPlanTable, JourneyPlanData> {
  final GeneratedDatabase _db;
  final String _alias;
  $JourneyPlanTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _customerIdMeta = const VerificationMeta('customerId');
  GeneratedColumn<String> _customerId;
  @override
  GeneratedColumn<String> get customerId =>
      _customerId ??= GeneratedColumn<String>('customer_id', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _customerNameMeta =
      const VerificationMeta('customerName');
  GeneratedColumn<String> _customerName;
  @override
  GeneratedColumn<String> get customerName => _customerName ??=
      GeneratedColumn<String>('customer_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _companyNameMeta =
      const VerificationMeta('companyName');
  GeneratedColumn<String> _companyName;
  @override
  GeneratedColumn<String> get companyName => _companyName ??=
      GeneratedColumn<String>('company_name', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _customerTypeMeta =
      const VerificationMeta('customerType');
  GeneratedColumn<String> _customerType;
  @override
  GeneratedColumn<String> get customerType => _customerType ??=
      GeneratedColumn<String>('customer_type', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _customerGroupMeta =
      const VerificationMeta('customerGroup');
  GeneratedColumn<String> _customerGroup;
  @override
  GeneratedColumn<String> get customerGroup => _customerGroup ??=
      GeneratedColumn<String>('customer_group', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _customerTerritoryMeta =
      const VerificationMeta('customerTerritory');
  GeneratedColumn<String> _customerTerritory;
  @override
  GeneratedColumn<String> get customerTerritory => _customerTerritory ??=
      GeneratedColumn<String>('customer_territory', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  final VerificationMeta _billingAddressNameMeta =
      const VerificationMeta('billingAddressName');
  GeneratedColumn<String> _billingAddressName;
  @override
  GeneratedColumn<String> get billingAddressName => _billingAddressName ??=
      GeneratedColumn<String>('billing_address_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _shippingAddressNameMeta =
      const VerificationMeta('shippingAddressName');
  GeneratedColumn<String> _shippingAddressName;
  @override
  GeneratedColumn<String> get shippingAddressName => _shippingAddressName ??=
      GeneratedColumn<String>('shipping_address_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _assignToMeta = const VerificationMeta('assignTo');
  GeneratedColumn<String> _assignTo;
  @override
  GeneratedColumn<String> get assignTo =>
      _assignTo ??= GeneratedColumn<String>('assign_to', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _expiryDateMeta = const VerificationMeta('expiryDate');
  GeneratedColumn<DateTime> _expiryDate;
  @override
  GeneratedColumn<DateTime> get expiryDate => _expiryDate ??=
      GeneratedColumn<DateTime>('expiry_date', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _weekNumberMeta = const VerificationMeta('weekNumber');
  GeneratedColumn<int> _weekNumber;
  @override
  GeneratedColumn<int> get weekNumber =>
      _weekNumber ??= GeneratedColumn<int>('week_number', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _weekDayMeta = const VerificationMeta('weekDay');
  GeneratedColumn<String> _weekDay;
  @override
  GeneratedColumn<String> get weekDay =>
      _weekDay ??= GeneratedColumn<String>('week_day', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _inMilesMeta = const VerificationMeta('inMiles');
  GeneratedColumn<double> _inMiles;
  @override
  GeneratedColumn<double> get inMiles =>
      _inMiles ??= GeneratedColumn<double>('in_miles', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _inKilometerMeta =
      const VerificationMeta('inKilometer');
  GeneratedColumn<double> _inKilometer;
  @override
  GeneratedColumn<double> get inKilometer => _inKilometer ??=
      GeneratedColumn<double>('in_kilometer', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _inMeterMeta = const VerificationMeta('inMeter');
  GeneratedColumn<double> _inMeter;
  @override
  GeneratedColumn<double> get inMeter =>
      _inMeter ??= GeneratedColumn<double>('in_meter', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _distanceLabelMeta =
      const VerificationMeta('distanceLabel');
  GeneratedColumn<String> _distanceLabel;
  @override
  GeneratedColumn<String> get distanceLabel => _distanceLabel ??=
      GeneratedColumn<String>('distance_label', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _distanceUsedMeta =
      const VerificationMeta('distanceUsed');
  GeneratedColumn<double> _distanceUsed;
  @override
  GeneratedColumn<double> get distanceUsed => _distanceUsed ??=
      GeneratedColumn<double>('distance_used', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _transactionStatusMeta =
      const VerificationMeta('transactionStatus');
  GeneratedColumn<String> _transactionStatus;
  @override
  GeneratedColumn<String> get transactionStatus => _transactionStatus ??=
      GeneratedColumn<String>('transaction_status', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _isDeletedMeta = const VerificationMeta('isDeleted');
  GeneratedColumn<bool> _isDeleted;
  @override
  GeneratedColumn<bool> get isDeleted =>
      _isDeleted ??= GeneratedColumn<bool>('is_deleted', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_deleted IN (0, 1))',
          defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        customerId,
        customerName,
        companyName,
        customerType,
        customerGroup,
        customerTerritory,
        billingAddressName,
        shippingAddressName,
        assignTo,
        expiryDate,
        weekNumber,
        weekDay,
        inMiles,
        inKilometer,
        inMeter,
        distanceLabel,
        distanceUsed,
        transactionStatus,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? 'journey_plan';
  @override
  String get actualTableName => 'journey_plan';
  @override
  VerificationContext validateIntegrity(Insertable<JourneyPlanData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('customer_id')) {
      context.handle(
          _customerIdMeta,
          customerId.isAcceptableOrUnknown(
              data['customer_id'], _customerIdMeta));
    } else if (isInserting) {
      context.missing(_customerIdMeta);
    }
    if (data.containsKey('customer_name')) {
      context.handle(
          _customerNameMeta,
          customerName.isAcceptableOrUnknown(
              data['customer_name'], _customerNameMeta));
    } else if (isInserting) {
      context.missing(_customerNameMeta);
    }
    if (data.containsKey('company_name')) {
      context.handle(
          _companyNameMeta,
          companyName.isAcceptableOrUnknown(
              data['company_name'], _companyNameMeta));
    } else if (isInserting) {
      context.missing(_companyNameMeta);
    }
    if (data.containsKey('customer_type')) {
      context.handle(
          _customerTypeMeta,
          customerType.isAcceptableOrUnknown(
              data['customer_type'], _customerTypeMeta));
    } else if (isInserting) {
      context.missing(_customerTypeMeta);
    }
    if (data.containsKey('customer_group')) {
      context.handle(
          _customerGroupMeta,
          customerGroup.isAcceptableOrUnknown(
              data['customer_group'], _customerGroupMeta));
    } else if (isInserting) {
      context.missing(_customerGroupMeta);
    }
    if (data.containsKey('customer_territory')) {
      context.handle(
          _customerTerritoryMeta,
          customerTerritory.isAcceptableOrUnknown(
              data['customer_territory'], _customerTerritoryMeta));
    } else if (isInserting) {
      context.missing(_customerTerritoryMeta);
    }
    if (data.containsKey('billing_address_name')) {
      context.handle(
          _billingAddressNameMeta,
          billingAddressName.isAcceptableOrUnknown(
              data['billing_address_name'], _billingAddressNameMeta));
    }
    if (data.containsKey('shipping_address_name')) {
      context.handle(
          _shippingAddressNameMeta,
          shippingAddressName.isAcceptableOrUnknown(
              data['shipping_address_name'], _shippingAddressNameMeta));
    }
    if (data.containsKey('assign_to')) {
      context.handle(_assignToMeta,
          assignTo.isAcceptableOrUnknown(data['assign_to'], _assignToMeta));
    }
    if (data.containsKey('expiry_date')) {
      context.handle(
          _expiryDateMeta,
          expiryDate.isAcceptableOrUnknown(
              data['expiry_date'], _expiryDateMeta));
    }
    if (data.containsKey('week_number')) {
      context.handle(
          _weekNumberMeta,
          weekNumber.isAcceptableOrUnknown(
              data['week_number'], _weekNumberMeta));
    }
    if (data.containsKey('week_day')) {
      context.handle(_weekDayMeta,
          weekDay.isAcceptableOrUnknown(data['week_day'], _weekDayMeta));
    }
    if (data.containsKey('in_miles')) {
      context.handle(_inMilesMeta,
          inMiles.isAcceptableOrUnknown(data['in_miles'], _inMilesMeta));
    }
    if (data.containsKey('in_kilometer')) {
      context.handle(
          _inKilometerMeta,
          inKilometer.isAcceptableOrUnknown(
              data['in_kilometer'], _inKilometerMeta));
    }
    if (data.containsKey('in_meter')) {
      context.handle(_inMeterMeta,
          inMeter.isAcceptableOrUnknown(data['in_meter'], _inMeterMeta));
    }
    if (data.containsKey('distance_label')) {
      context.handle(
          _distanceLabelMeta,
          distanceLabel.isAcceptableOrUnknown(
              data['distance_label'], _distanceLabelMeta));
    }
    if (data.containsKey('distance_used')) {
      context.handle(
          _distanceUsedMeta,
          distanceUsed.isAcceptableOrUnknown(
              data['distance_used'], _distanceUsedMeta));
    }
    if (data.containsKey('transaction_status')) {
      context.handle(
          _transactionStatusMeta,
          transactionStatus.isAcceptableOrUnknown(
              data['transaction_status'], _transactionStatusMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted'], _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  JourneyPlanData map(Map<String, dynamic> data, {String tablePrefix}) {
    return JourneyPlanData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $JourneyPlanTable createAlias(String alias) {
    return $JourneyPlanTable(_db, alias);
  }
}

class UPCCodeData extends DataClass implements Insertable<UPCCodeData> {
  final int tenantId;
  final int id;
  final String upcCode;
  final String codeType;
  final String itemId;
  UPCCodeData(
      {this.tenantId,
      @required this.id,
      this.upcCode,
      this.codeType,
      this.itemId});
  factory UPCCodeData.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return UPCCodeData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      upcCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}upc_code']),
      codeType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}code_type']),
      itemId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_id']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || upcCode != null) {
      map['upc_code'] = Variable<String>(upcCode);
    }
    if (!nullToAbsent || codeType != null) {
      map['code_type'] = Variable<String>(codeType);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    return map;
  }

  UPCCodeCompanion toCompanion(bool nullToAbsent) {
    return UPCCodeCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      upcCode: upcCode == null && nullToAbsent
          ? const Value.absent()
          : Value(upcCode),
      codeType: codeType == null && nullToAbsent
          ? const Value.absent()
          : Value(codeType),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
    );
  }

  factory UPCCodeData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UPCCodeData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      upcCode: serializer.fromJson<String>(json['upcCode']),
      codeType: serializer.fromJson<String>(json['codeType']),
      itemId: serializer.fromJson<String>(json['itemId']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'upcCode': serializer.toJson<String>(upcCode),
      'codeType': serializer.toJson<String>(codeType),
      'itemId': serializer.toJson<String>(itemId),
    };
  }

  UPCCodeData copyWith(
          {int tenantId,
          int id,
          String upcCode,
          String codeType,
          String itemId}) =>
      UPCCodeData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        upcCode: upcCode ?? this.upcCode,
        codeType: codeType ?? this.codeType,
        itemId: itemId ?? this.itemId,
      );
  @override
  String toString() {
    return (StringBuffer('UPCCodeData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('upcCode: $upcCode, ')
          ..write('codeType: $codeType, ')
          ..write('itemId: $itemId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, upcCode, codeType, itemId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UPCCodeData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.upcCode == this.upcCode &&
          other.codeType == this.codeType &&
          other.itemId == this.itemId);
}

class UPCCodeCompanion extends UpdateCompanion<UPCCodeData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> upcCode;
  final Value<String> codeType;
  final Value<String> itemId;
  const UPCCodeCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.upcCode = const Value.absent(),
    this.codeType = const Value.absent(),
    this.itemId = const Value.absent(),
  });
  UPCCodeCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.upcCode = const Value.absent(),
    this.codeType = const Value.absent(),
    this.itemId = const Value.absent(),
  });
  static Insertable<UPCCodeData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> upcCode,
    Expression<String> codeType,
    Expression<String> itemId,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (upcCode != null) 'upc_code': upcCode,
      if (codeType != null) 'code_type': codeType,
      if (itemId != null) 'item_id': itemId,
    });
  }

  UPCCodeCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> upcCode,
      Value<String> codeType,
      Value<String> itemId}) {
    return UPCCodeCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      upcCode: upcCode ?? this.upcCode,
      codeType: codeType ?? this.codeType,
      itemId: itemId ?? this.itemId,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (upcCode.present) {
      map['upc_code'] = Variable<String>(upcCode.value);
    }
    if (codeType.present) {
      map['code_type'] = Variable<String>(codeType.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UPCCodeCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('upcCode: $upcCode, ')
          ..write('codeType: $codeType, ')
          ..write('itemId: $itemId')
          ..write(')'))
        .toString();
  }
}

class $UPCCodeTable extends UPCCode with TableInfo<$UPCCodeTable, UPCCodeData> {
  final GeneratedDatabase _db;
  final String _alias;
  $UPCCodeTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _upcCodeMeta = const VerificationMeta('upcCode');
  GeneratedColumn<String> _upcCode;
  @override
  GeneratedColumn<String> get upcCode =>
      _upcCode ??= GeneratedColumn<String>('upc_code', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _codeTypeMeta = const VerificationMeta('codeType');
  GeneratedColumn<String> _codeType;
  @override
  GeneratedColumn<String> get codeType =>
      _codeType ??= GeneratedColumn<String>('code_type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  GeneratedColumn<String> _itemId;
  @override
  GeneratedColumn<String> get itemId =>
      _itemId ??= GeneratedColumn<String>('item_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns =>
      [tenantId, id, upcCode, codeType, itemId];
  @override
  String get aliasedName => _alias ?? 'u_p_c_code';
  @override
  String get actualTableName => 'u_p_c_code';
  @override
  VerificationContext validateIntegrity(Insertable<UPCCodeData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('upc_code')) {
      context.handle(_upcCodeMeta,
          upcCode.isAcceptableOrUnknown(data['upc_code'], _upcCodeMeta));
    }
    if (data.containsKey('code_type')) {
      context.handle(_codeTypeMeta,
          codeType.isAcceptableOrUnknown(data['code_type'], _codeTypeMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id'], _itemIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UPCCodeData map(Map<String, dynamic> data, {String tablePrefix}) {
    return UPCCodeData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $UPCCodeTable createAlias(String alias) {
    return $UPCCodeTable(_db, alias);
  }
}

class InventoryItem extends DataClass implements Insertable<InventoryItem> {
  final int tenantId;
  final int id;
  final String itemCode;
  final String itemName;
  final String uom;
  final String defaultWarehouse;
  final double quantityOnHand;
  final double quantityAvailable;
  final double quantityAdjust;
  final double quantitySoldOnInvoice;
  final double quantitySoldOnOrder;
  final double quantityCount;
  final String inventoryCycleNumber;
  InventoryItem(
      {this.tenantId,
      @required this.id,
      this.itemCode,
      this.itemName,
      this.uom,
      this.defaultWarehouse,
      @required this.quantityOnHand,
      @required this.quantityAvailable,
      @required this.quantityAdjust,
      @required this.quantitySoldOnInvoice,
      @required this.quantitySoldOnOrder,
      @required this.quantityCount,
      @required this.inventoryCycleNumber});
  factory InventoryItem.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return InventoryItem(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      itemCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_code']),
      itemName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_name']),
      uom: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}uom']),
      defaultWarehouse: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}default_warehouse']),
      quantityOnHand: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}quantity_on_hand']),
      quantityAvailable: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}quantity_available']),
      quantityAdjust: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}quantity_adjust']),
      quantitySoldOnInvoice: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}quantity_sold_on_invoice']),
      quantitySoldOnOrder: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}quantity_sold_on_order']),
      quantityCount: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}quantity_count']),
      inventoryCycleNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}inventory_cycle_number']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || itemName != null) {
      map['item_name'] = Variable<String>(itemName);
    }
    if (!nullToAbsent || uom != null) {
      map['uom'] = Variable<String>(uom);
    }
    if (!nullToAbsent || defaultWarehouse != null) {
      map['default_warehouse'] = Variable<String>(defaultWarehouse);
    }
    if (!nullToAbsent || quantityOnHand != null) {
      map['quantity_on_hand'] = Variable<double>(quantityOnHand);
    }
    if (!nullToAbsent || quantityAvailable != null) {
      map['quantity_available'] = Variable<double>(quantityAvailable);
    }
    if (!nullToAbsent || quantityAdjust != null) {
      map['quantity_adjust'] = Variable<double>(quantityAdjust);
    }
    if (!nullToAbsent || quantitySoldOnInvoice != null) {
      map['quantity_sold_on_invoice'] = Variable<double>(quantitySoldOnInvoice);
    }
    if (!nullToAbsent || quantitySoldOnOrder != null) {
      map['quantity_sold_on_order'] = Variable<double>(quantitySoldOnOrder);
    }
    if (!nullToAbsent || quantityCount != null) {
      map['quantity_count'] = Variable<double>(quantityCount);
    }
    if (!nullToAbsent || inventoryCycleNumber != null) {
      map['inventory_cycle_number'] = Variable<String>(inventoryCycleNumber);
    }
    return map;
  }

  InventoryItemsCompanion toCompanion(bool nullToAbsent) {
    return InventoryItemsCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      itemName: itemName == null && nullToAbsent
          ? const Value.absent()
          : Value(itemName),
      uom: uom == null && nullToAbsent ? const Value.absent() : Value(uom),
      defaultWarehouse: defaultWarehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultWarehouse),
      quantityOnHand: quantityOnHand == null && nullToAbsent
          ? const Value.absent()
          : Value(quantityOnHand),
      quantityAvailable: quantityAvailable == null && nullToAbsent
          ? const Value.absent()
          : Value(quantityAvailable),
      quantityAdjust: quantityAdjust == null && nullToAbsent
          ? const Value.absent()
          : Value(quantityAdjust),
      quantitySoldOnInvoice: quantitySoldOnInvoice == null && nullToAbsent
          ? const Value.absent()
          : Value(quantitySoldOnInvoice),
      quantitySoldOnOrder: quantitySoldOnOrder == null && nullToAbsent
          ? const Value.absent()
          : Value(quantitySoldOnOrder),
      quantityCount: quantityCount == null && nullToAbsent
          ? const Value.absent()
          : Value(quantityCount),
      inventoryCycleNumber: inventoryCycleNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(inventoryCycleNumber),
    );
  }

  factory InventoryItem.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InventoryItem(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemCode: serializer.fromJson<String>(json['itemCode']),
      itemName: serializer.fromJson<String>(json['itemName']),
      uom: serializer.fromJson<String>(json['uom']),
      defaultWarehouse: serializer.fromJson<String>(json['defaultWarehouse']),
      quantityOnHand: serializer.fromJson<double>(json['quantityOnHand']),
      quantityAvailable: serializer.fromJson<double>(json['quantityAvailable']),
      quantityAdjust: serializer.fromJson<double>(json['quantityAdjust']),
      quantitySoldOnInvoice:
          serializer.fromJson<double>(json['quantitySoldOnInvoice']),
      quantitySoldOnOrder:
          serializer.fromJson<double>(json['quantitySoldOnOrder']),
      quantityCount: serializer.fromJson<double>(json['quantityCount']),
      inventoryCycleNumber:
          serializer.fromJson<String>(json['inventoryCycleNumber']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemCode': serializer.toJson<String>(itemCode),
      'itemName': serializer.toJson<String>(itemName),
      'uom': serializer.toJson<String>(uom),
      'defaultWarehouse': serializer.toJson<String>(defaultWarehouse),
      'quantityOnHand': serializer.toJson<double>(quantityOnHand),
      'quantityAvailable': serializer.toJson<double>(quantityAvailable),
      'quantityAdjust': serializer.toJson<double>(quantityAdjust),
      'quantitySoldOnInvoice': serializer.toJson<double>(quantitySoldOnInvoice),
      'quantitySoldOnOrder': serializer.toJson<double>(quantitySoldOnOrder),
      'quantityCount': serializer.toJson<double>(quantityCount),
      'inventoryCycleNumber': serializer.toJson<String>(inventoryCycleNumber),
    };
  }

  InventoryItem copyWith(
          {int tenantId,
          int id,
          String itemCode,
          String itemName,
          String uom,
          String defaultWarehouse,
          double quantityOnHand,
          double quantityAvailable,
          double quantityAdjust,
          double quantitySoldOnInvoice,
          double quantitySoldOnOrder,
          double quantityCount,
          String inventoryCycleNumber}) =>
      InventoryItem(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        itemCode: itemCode ?? this.itemCode,
        itemName: itemName ?? this.itemName,
        uom: uom ?? this.uom,
        defaultWarehouse: defaultWarehouse ?? this.defaultWarehouse,
        quantityOnHand: quantityOnHand ?? this.quantityOnHand,
        quantityAvailable: quantityAvailable ?? this.quantityAvailable,
        quantityAdjust: quantityAdjust ?? this.quantityAdjust,
        quantitySoldOnInvoice:
            quantitySoldOnInvoice ?? this.quantitySoldOnInvoice,
        quantitySoldOnOrder: quantitySoldOnOrder ?? this.quantitySoldOnOrder,
        quantityCount: quantityCount ?? this.quantityCount,
        inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
      );
  @override
  String toString() {
    return (StringBuffer('InventoryItem(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('uom: $uom, ')
          ..write('defaultWarehouse: $defaultWarehouse, ')
          ..write('quantityOnHand: $quantityOnHand, ')
          ..write('quantityAvailable: $quantityAvailable, ')
          ..write('quantityAdjust: $quantityAdjust, ')
          ..write('quantitySoldOnInvoice: $quantitySoldOnInvoice, ')
          ..write('quantitySoldOnOrder: $quantitySoldOnOrder, ')
          ..write('quantityCount: $quantityCount, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      itemCode,
      itemName,
      uom,
      defaultWarehouse,
      quantityOnHand,
      quantityAvailable,
      quantityAdjust,
      quantitySoldOnInvoice,
      quantitySoldOnOrder,
      quantityCount,
      inventoryCycleNumber);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InventoryItem &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemCode == this.itemCode &&
          other.itemName == this.itemName &&
          other.uom == this.uom &&
          other.defaultWarehouse == this.defaultWarehouse &&
          other.quantityOnHand == this.quantityOnHand &&
          other.quantityAvailable == this.quantityAvailable &&
          other.quantityAdjust == this.quantityAdjust &&
          other.quantitySoldOnInvoice == this.quantitySoldOnInvoice &&
          other.quantitySoldOnOrder == this.quantitySoldOnOrder &&
          other.quantityCount == this.quantityCount &&
          other.inventoryCycleNumber == this.inventoryCycleNumber);
}

class InventoryItemsCompanion extends UpdateCompanion<InventoryItem> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> itemCode;
  final Value<String> itemName;
  final Value<String> uom;
  final Value<String> defaultWarehouse;
  final Value<double> quantityOnHand;
  final Value<double> quantityAvailable;
  final Value<double> quantityAdjust;
  final Value<double> quantitySoldOnInvoice;
  final Value<double> quantitySoldOnOrder;
  final Value<double> quantityCount;
  final Value<String> inventoryCycleNumber;
  const InventoryItemsCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.uom = const Value.absent(),
    this.defaultWarehouse = const Value.absent(),
    this.quantityOnHand = const Value.absent(),
    this.quantityAvailable = const Value.absent(),
    this.quantityAdjust = const Value.absent(),
    this.quantitySoldOnInvoice = const Value.absent(),
    this.quantitySoldOnOrder = const Value.absent(),
    this.quantityCount = const Value.absent(),
    this.inventoryCycleNumber = const Value.absent(),
  });
  InventoryItemsCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.uom = const Value.absent(),
    this.defaultWarehouse = const Value.absent(),
    @required double quantityOnHand,
    @required double quantityAvailable,
    @required double quantityAdjust,
    @required double quantitySoldOnInvoice,
    @required double quantitySoldOnOrder,
    @required double quantityCount,
    @required String inventoryCycleNumber,
  })  : quantityOnHand = Value(quantityOnHand),
        quantityAvailable = Value(quantityAvailable),
        quantityAdjust = Value(quantityAdjust),
        quantitySoldOnInvoice = Value(quantitySoldOnInvoice),
        quantitySoldOnOrder = Value(quantitySoldOnOrder),
        quantityCount = Value(quantityCount),
        inventoryCycleNumber = Value(inventoryCycleNumber);
  static Insertable<InventoryItem> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> itemCode,
    Expression<String> itemName,
    Expression<String> uom,
    Expression<String> defaultWarehouse,
    Expression<double> quantityOnHand,
    Expression<double> quantityAvailable,
    Expression<double> quantityAdjust,
    Expression<double> quantitySoldOnInvoice,
    Expression<double> quantitySoldOnOrder,
    Expression<double> quantityCount,
    Expression<String> inventoryCycleNumber,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemCode != null) 'item_code': itemCode,
      if (itemName != null) 'item_name': itemName,
      if (uom != null) 'uom': uom,
      if (defaultWarehouse != null) 'default_warehouse': defaultWarehouse,
      if (quantityOnHand != null) 'quantity_on_hand': quantityOnHand,
      if (quantityAvailable != null) 'quantity_available': quantityAvailable,
      if (quantityAdjust != null) 'quantity_adjust': quantityAdjust,
      if (quantitySoldOnInvoice != null)
        'quantity_sold_on_invoice': quantitySoldOnInvoice,
      if (quantitySoldOnOrder != null)
        'quantity_sold_on_order': quantitySoldOnOrder,
      if (quantityCount != null) 'quantity_count': quantityCount,
      if (inventoryCycleNumber != null)
        'inventory_cycle_number': inventoryCycleNumber,
    });
  }

  InventoryItemsCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> itemCode,
      Value<String> itemName,
      Value<String> uom,
      Value<String> defaultWarehouse,
      Value<double> quantityOnHand,
      Value<double> quantityAvailable,
      Value<double> quantityAdjust,
      Value<double> quantitySoldOnInvoice,
      Value<double> quantitySoldOnOrder,
      Value<double> quantityCount,
      Value<String> inventoryCycleNumber}) {
    return InventoryItemsCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemCode: itemCode ?? this.itemCode,
      itemName: itemName ?? this.itemName,
      uom: uom ?? this.uom,
      defaultWarehouse: defaultWarehouse ?? this.defaultWarehouse,
      quantityOnHand: quantityOnHand ?? this.quantityOnHand,
      quantityAvailable: quantityAvailable ?? this.quantityAvailable,
      quantityAdjust: quantityAdjust ?? this.quantityAdjust,
      quantitySoldOnInvoice:
          quantitySoldOnInvoice ?? this.quantitySoldOnInvoice,
      quantitySoldOnOrder: quantitySoldOnOrder ?? this.quantitySoldOnOrder,
      quantityCount: quantityCount ?? this.quantityCount,
      inventoryCycleNumber: inventoryCycleNumber ?? this.inventoryCycleNumber,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (itemName.present) {
      map['item_name'] = Variable<String>(itemName.value);
    }
    if (uom.present) {
      map['uom'] = Variable<String>(uom.value);
    }
    if (defaultWarehouse.present) {
      map['default_warehouse'] = Variable<String>(defaultWarehouse.value);
    }
    if (quantityOnHand.present) {
      map['quantity_on_hand'] = Variable<double>(quantityOnHand.value);
    }
    if (quantityAvailable.present) {
      map['quantity_available'] = Variable<double>(quantityAvailable.value);
    }
    if (quantityAdjust.present) {
      map['quantity_adjust'] = Variable<double>(quantityAdjust.value);
    }
    if (quantitySoldOnInvoice.present) {
      map['quantity_sold_on_invoice'] =
          Variable<double>(quantitySoldOnInvoice.value);
    }
    if (quantitySoldOnOrder.present) {
      map['quantity_sold_on_order'] =
          Variable<double>(quantitySoldOnOrder.value);
    }
    if (quantityCount.present) {
      map['quantity_count'] = Variable<double>(quantityCount.value);
    }
    if (inventoryCycleNumber.present) {
      map['inventory_cycle_number'] =
          Variable<String>(inventoryCycleNumber.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InventoryItemsCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('uom: $uom, ')
          ..write('defaultWarehouse: $defaultWarehouse, ')
          ..write('quantityOnHand: $quantityOnHand, ')
          ..write('quantityAvailable: $quantityAvailable, ')
          ..write('quantityAdjust: $quantityAdjust, ')
          ..write('quantitySoldOnInvoice: $quantitySoldOnInvoice, ')
          ..write('quantitySoldOnOrder: $quantitySoldOnOrder, ')
          ..write('quantityCount: $quantityCount, ')
          ..write('inventoryCycleNumber: $inventoryCycleNumber')
          ..write(')'))
        .toString();
  }
}

class $InventoryItemsTable extends InventoryItems
    with TableInfo<$InventoryItemsTable, InventoryItem> {
  final GeneratedDatabase _db;
  final String _alias;
  $InventoryItemsTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _itemCodeMeta = const VerificationMeta('itemCode');
  GeneratedColumn<String> _itemCode;
  @override
  GeneratedColumn<String> get itemCode =>
      _itemCode ??= GeneratedColumn<String>('item_code', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemNameMeta = const VerificationMeta('itemName');
  GeneratedColumn<String> _itemName;
  @override
  GeneratedColumn<String> get itemName =>
      _itemName ??= GeneratedColumn<String>('item_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _uomMeta = const VerificationMeta('uom');
  GeneratedColumn<String> _uom;
  @override
  GeneratedColumn<String> get uom =>
      _uom ??= GeneratedColumn<String>('uom', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _defaultWarehouseMeta =
      const VerificationMeta('defaultWarehouse');
  GeneratedColumn<String> _defaultWarehouse;
  @override
  GeneratedColumn<String> get defaultWarehouse => _defaultWarehouse ??=
      GeneratedColumn<String>('default_warehouse', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _quantityOnHandMeta =
      const VerificationMeta('quantityOnHand');
  GeneratedColumn<double> _quantityOnHand;
  @override
  GeneratedColumn<double> get quantityOnHand => _quantityOnHand ??=
      GeneratedColumn<double>('quantity_on_hand', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _quantityAvailableMeta =
      const VerificationMeta('quantityAvailable');
  GeneratedColumn<double> _quantityAvailable;
  @override
  GeneratedColumn<double> get quantityAvailable => _quantityAvailable ??=
      GeneratedColumn<double>('quantity_available', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _quantityAdjustMeta =
      const VerificationMeta('quantityAdjust');
  GeneratedColumn<double> _quantityAdjust;
  @override
  GeneratedColumn<double> get quantityAdjust => _quantityAdjust ??=
      GeneratedColumn<double>('quantity_adjust', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _quantitySoldOnInvoiceMeta =
      const VerificationMeta('quantitySoldOnInvoice');
  GeneratedColumn<double> _quantitySoldOnInvoice;
  @override
  GeneratedColumn<double> get quantitySoldOnInvoice =>
      _quantitySoldOnInvoice ??= GeneratedColumn<double>(
          'quantity_sold_on_invoice', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _quantitySoldOnOrderMeta =
      const VerificationMeta('quantitySoldOnOrder');
  GeneratedColumn<double> _quantitySoldOnOrder;
  @override
  GeneratedColumn<double> get quantitySoldOnOrder => _quantitySoldOnOrder ??=
      GeneratedColumn<double>('quantity_sold_on_order', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _quantityCountMeta =
      const VerificationMeta('quantityCount');
  GeneratedColumn<double> _quantityCount;
  @override
  GeneratedColumn<double> get quantityCount => _quantityCount ??=
      GeneratedColumn<double>('quantity_count', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _inventoryCycleNumberMeta =
      const VerificationMeta('inventoryCycleNumber');
  GeneratedColumn<String> _inventoryCycleNumber;
  @override
  GeneratedColumn<String> get inventoryCycleNumber => _inventoryCycleNumber ??=
      GeneratedColumn<String>('inventory_cycle_number', aliasedName, false,
          type: const StringType(), requiredDuringInsert: true);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        itemCode,
        itemName,
        uom,
        defaultWarehouse,
        quantityOnHand,
        quantityAvailable,
        quantityAdjust,
        quantitySoldOnInvoice,
        quantitySoldOnOrder,
        quantityCount,
        inventoryCycleNumber
      ];
  @override
  String get aliasedName => _alias ?? 'inventory_items';
  @override
  String get actualTableName => 'inventory_items';
  @override
  VerificationContext validateIntegrity(Insertable<InventoryItem> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code'], _itemCodeMeta));
    }
    if (data.containsKey('item_name')) {
      context.handle(_itemNameMeta,
          itemName.isAcceptableOrUnknown(data['item_name'], _itemNameMeta));
    }
    if (data.containsKey('uom')) {
      context.handle(
          _uomMeta, uom.isAcceptableOrUnknown(data['uom'], _uomMeta));
    }
    if (data.containsKey('default_warehouse')) {
      context.handle(
          _defaultWarehouseMeta,
          defaultWarehouse.isAcceptableOrUnknown(
              data['default_warehouse'], _defaultWarehouseMeta));
    }
    if (data.containsKey('quantity_on_hand')) {
      context.handle(
          _quantityOnHandMeta,
          quantityOnHand.isAcceptableOrUnknown(
              data['quantity_on_hand'], _quantityOnHandMeta));
    } else if (isInserting) {
      context.missing(_quantityOnHandMeta);
    }
    if (data.containsKey('quantity_available')) {
      context.handle(
          _quantityAvailableMeta,
          quantityAvailable.isAcceptableOrUnknown(
              data['quantity_available'], _quantityAvailableMeta));
    } else if (isInserting) {
      context.missing(_quantityAvailableMeta);
    }
    if (data.containsKey('quantity_adjust')) {
      context.handle(
          _quantityAdjustMeta,
          quantityAdjust.isAcceptableOrUnknown(
              data['quantity_adjust'], _quantityAdjustMeta));
    } else if (isInserting) {
      context.missing(_quantityAdjustMeta);
    }
    if (data.containsKey('quantity_sold_on_invoice')) {
      context.handle(
          _quantitySoldOnInvoiceMeta,
          quantitySoldOnInvoice.isAcceptableOrUnknown(
              data['quantity_sold_on_invoice'], _quantitySoldOnInvoiceMeta));
    } else if (isInserting) {
      context.missing(_quantitySoldOnInvoiceMeta);
    }
    if (data.containsKey('quantity_sold_on_order')) {
      context.handle(
          _quantitySoldOnOrderMeta,
          quantitySoldOnOrder.isAcceptableOrUnknown(
              data['quantity_sold_on_order'], _quantitySoldOnOrderMeta));
    } else if (isInserting) {
      context.missing(_quantitySoldOnOrderMeta);
    }
    if (data.containsKey('quantity_count')) {
      context.handle(
          _quantityCountMeta,
          quantityCount.isAcceptableOrUnknown(
              data['quantity_count'], _quantityCountMeta));
    } else if (isInserting) {
      context.missing(_quantityCountMeta);
    }
    if (data.containsKey('inventory_cycle_number')) {
      context.handle(
          _inventoryCycleNumberMeta,
          inventoryCycleNumber.isAcceptableOrUnknown(
              data['inventory_cycle_number'], _inventoryCycleNumberMeta));
    } else if (isInserting) {
      context.missing(_inventoryCycleNumberMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InventoryItem map(Map<String, dynamic> data, {String tablePrefix}) {
    return InventoryItem.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $InventoryItemsTable createAlias(String alias) {
    return $InventoryItemsTable(_db, alias);
  }
}

class InventoryTransactionData extends DataClass
    implements Insertable<InventoryTransactionData> {
  final int tenantId;
  final int id;
  final String itemCode;
  final String itemName;
  final String itemId;
  final String description;
  final String itemGroup;
  final String stockUom;
  final String salesUom;
  final String transactionNumber;
  final double quantityMove;
  final double quantityMoveConvert;
  final double conversionFactor;
  final double costPrice;
  final double itemPrice;
  final String transactionType;
  final String reasonCode;
  final String inventoryCycle;
  final String toWarehouse;
  final String fromWarehouse;
  InventoryTransactionData(
      {this.tenantId,
      @required this.id,
      this.itemCode,
      this.itemName,
      this.itemId,
      this.description,
      this.itemGroup,
      this.stockUom,
      this.salesUom,
      this.transactionNumber,
      @required this.quantityMove,
      @required this.quantityMoveConvert,
      @required this.conversionFactor,
      @required this.costPrice,
      @required this.itemPrice,
      this.transactionType,
      this.reasonCode,
      this.inventoryCycle,
      this.toWarehouse,
      this.fromWarehouse});
  factory InventoryTransactionData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return InventoryTransactionData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      itemCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_code']),
      itemName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_name']),
      itemId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_id']),
      description: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}description']),
      itemGroup: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_group']),
      stockUom: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}stock_uom']),
      salesUom: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sales_uom']),
      transactionNumber: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}transaction_number']),
      quantityMove: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}quantity_move']),
      quantityMoveConvert: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}quantity_move_convert']),
      conversionFactor: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}conversion_factor']),
      costPrice: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}cost_price']),
      itemPrice: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}item_price']),
      transactionType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}transaction_type']),
      reasonCode: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}reason_code']),
      inventoryCycle: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}inventory_cycle']),
      toWarehouse: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}to_warehouse']),
      fromWarehouse: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}from_warehouse']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || itemCode != null) {
      map['item_code'] = Variable<String>(itemCode);
    }
    if (!nullToAbsent || itemName != null) {
      map['item_name'] = Variable<String>(itemName);
    }
    if (!nullToAbsent || itemId != null) {
      map['item_id'] = Variable<String>(itemId);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || itemGroup != null) {
      map['item_group'] = Variable<String>(itemGroup);
    }
    if (!nullToAbsent || stockUom != null) {
      map['stock_uom'] = Variable<String>(stockUom);
    }
    if (!nullToAbsent || salesUom != null) {
      map['sales_uom'] = Variable<String>(salesUom);
    }
    if (!nullToAbsent || transactionNumber != null) {
      map['transaction_number'] = Variable<String>(transactionNumber);
    }
    if (!nullToAbsent || quantityMove != null) {
      map['quantity_move'] = Variable<double>(quantityMove);
    }
    if (!nullToAbsent || quantityMoveConvert != null) {
      map['quantity_move_convert'] = Variable<double>(quantityMoveConvert);
    }
    if (!nullToAbsent || conversionFactor != null) {
      map['conversion_factor'] = Variable<double>(conversionFactor);
    }
    if (!nullToAbsent || costPrice != null) {
      map['cost_price'] = Variable<double>(costPrice);
    }
    if (!nullToAbsent || itemPrice != null) {
      map['item_price'] = Variable<double>(itemPrice);
    }
    if (!nullToAbsent || transactionType != null) {
      map['transaction_type'] = Variable<String>(transactionType);
    }
    if (!nullToAbsent || reasonCode != null) {
      map['reason_code'] = Variable<String>(reasonCode);
    }
    if (!nullToAbsent || inventoryCycle != null) {
      map['inventory_cycle'] = Variable<String>(inventoryCycle);
    }
    if (!nullToAbsent || toWarehouse != null) {
      map['to_warehouse'] = Variable<String>(toWarehouse);
    }
    if (!nullToAbsent || fromWarehouse != null) {
      map['from_warehouse'] = Variable<String>(fromWarehouse);
    }
    return map;
  }

  InventoryTransactionCompanion toCompanion(bool nullToAbsent) {
    return InventoryTransactionCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      itemCode: itemCode == null && nullToAbsent
          ? const Value.absent()
          : Value(itemCode),
      itemName: itemName == null && nullToAbsent
          ? const Value.absent()
          : Value(itemName),
      itemId:
          itemId == null && nullToAbsent ? const Value.absent() : Value(itemId),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      itemGroup: itemGroup == null && nullToAbsent
          ? const Value.absent()
          : Value(itemGroup),
      stockUom: stockUom == null && nullToAbsent
          ? const Value.absent()
          : Value(stockUom),
      salesUom: salesUom == null && nullToAbsent
          ? const Value.absent()
          : Value(salesUom),
      transactionNumber: transactionNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionNumber),
      quantityMove: quantityMove == null && nullToAbsent
          ? const Value.absent()
          : Value(quantityMove),
      quantityMoveConvert: quantityMoveConvert == null && nullToAbsent
          ? const Value.absent()
          : Value(quantityMoveConvert),
      conversionFactor: conversionFactor == null && nullToAbsent
          ? const Value.absent()
          : Value(conversionFactor),
      costPrice: costPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(costPrice),
      itemPrice: itemPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(itemPrice),
      transactionType: transactionType == null && nullToAbsent
          ? const Value.absent()
          : Value(transactionType),
      reasonCode: reasonCode == null && nullToAbsent
          ? const Value.absent()
          : Value(reasonCode),
      inventoryCycle: inventoryCycle == null && nullToAbsent
          ? const Value.absent()
          : Value(inventoryCycle),
      toWarehouse: toWarehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(toWarehouse),
      fromWarehouse: fromWarehouse == null && nullToAbsent
          ? const Value.absent()
          : Value(fromWarehouse),
    );
  }

  factory InventoryTransactionData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InventoryTransactionData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      itemCode: serializer.fromJson<String>(json['itemCode']),
      itemName: serializer.fromJson<String>(json['itemName']),
      itemId: serializer.fromJson<String>(json['itemId']),
      description: serializer.fromJson<String>(json['description']),
      itemGroup: serializer.fromJson<String>(json['itemGroup']),
      stockUom: serializer.fromJson<String>(json['stockUom']),
      salesUom: serializer.fromJson<String>(json['salesUom']),
      transactionNumber: serializer.fromJson<String>(json['transactionNumber']),
      quantityMove: serializer.fromJson<double>(json['quantityMove']),
      quantityMoveConvert:
          serializer.fromJson<double>(json['quantityMoveConvert']),
      conversionFactor: serializer.fromJson<double>(json['conversionFactor']),
      costPrice: serializer.fromJson<double>(json['costPrice']),
      itemPrice: serializer.fromJson<double>(json['itemPrice']),
      transactionType: serializer.fromJson<String>(json['transactionType']),
      reasonCode: serializer.fromJson<String>(json['reasonCode']),
      inventoryCycle: serializer.fromJson<String>(json['inventoryCycle']),
      toWarehouse: serializer.fromJson<String>(json['toWarehouse']),
      fromWarehouse: serializer.fromJson<String>(json['fromWarehouse']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'itemCode': serializer.toJson<String>(itemCode),
      'itemName': serializer.toJson<String>(itemName),
      'itemId': serializer.toJson<String>(itemId),
      'description': serializer.toJson<String>(description),
      'itemGroup': serializer.toJson<String>(itemGroup),
      'stockUom': serializer.toJson<String>(stockUom),
      'salesUom': serializer.toJson<String>(salesUom),
      'transactionNumber': serializer.toJson<String>(transactionNumber),
      'quantityMove': serializer.toJson<double>(quantityMove),
      'quantityMoveConvert': serializer.toJson<double>(quantityMoveConvert),
      'conversionFactor': serializer.toJson<double>(conversionFactor),
      'costPrice': serializer.toJson<double>(costPrice),
      'itemPrice': serializer.toJson<double>(itemPrice),
      'transactionType': serializer.toJson<String>(transactionType),
      'reasonCode': serializer.toJson<String>(reasonCode),
      'inventoryCycle': serializer.toJson<String>(inventoryCycle),
      'toWarehouse': serializer.toJson<String>(toWarehouse),
      'fromWarehouse': serializer.toJson<String>(fromWarehouse),
    };
  }

  InventoryTransactionData copyWith(
          {int tenantId,
          int id,
          String itemCode,
          String itemName,
          String itemId,
          String description,
          String itemGroup,
          String stockUom,
          String salesUom,
          String transactionNumber,
          double quantityMove,
          double quantityMoveConvert,
          double conversionFactor,
          double costPrice,
          double itemPrice,
          String transactionType,
          String reasonCode,
          String inventoryCycle,
          String toWarehouse,
          String fromWarehouse}) =>
      InventoryTransactionData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        itemCode: itemCode ?? this.itemCode,
        itemName: itemName ?? this.itemName,
        itemId: itemId ?? this.itemId,
        description: description ?? this.description,
        itemGroup: itemGroup ?? this.itemGroup,
        stockUom: stockUom ?? this.stockUom,
        salesUom: salesUom ?? this.salesUom,
        transactionNumber: transactionNumber ?? this.transactionNumber,
        quantityMove: quantityMove ?? this.quantityMove,
        quantityMoveConvert: quantityMoveConvert ?? this.quantityMoveConvert,
        conversionFactor: conversionFactor ?? this.conversionFactor,
        costPrice: costPrice ?? this.costPrice,
        itemPrice: itemPrice ?? this.itemPrice,
        transactionType: transactionType ?? this.transactionType,
        reasonCode: reasonCode ?? this.reasonCode,
        inventoryCycle: inventoryCycle ?? this.inventoryCycle,
        toWarehouse: toWarehouse ?? this.toWarehouse,
        fromWarehouse: fromWarehouse ?? this.fromWarehouse,
      );
  @override
  String toString() {
    return (StringBuffer('InventoryTransactionData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('itemId: $itemId, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('stockUom: $stockUom, ')
          ..write('salesUom: $salesUom, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('quantityMove: $quantityMove, ')
          ..write('quantityMoveConvert: $quantityMoveConvert, ')
          ..write('conversionFactor: $conversionFactor, ')
          ..write('costPrice: $costPrice, ')
          ..write('itemPrice: $itemPrice, ')
          ..write('transactionType: $transactionType, ')
          ..write('reasonCode: $reasonCode, ')
          ..write('inventoryCycle: $inventoryCycle, ')
          ..write('toWarehouse: $toWarehouse, ')
          ..write('fromWarehouse: $fromWarehouse')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      itemCode,
      itemName,
      itemId,
      description,
      itemGroup,
      stockUom,
      salesUom,
      transactionNumber,
      quantityMove,
      quantityMoveConvert,
      conversionFactor,
      costPrice,
      itemPrice,
      transactionType,
      reasonCode,
      inventoryCycle,
      toWarehouse,
      fromWarehouse);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InventoryTransactionData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.itemCode == this.itemCode &&
          other.itemName == this.itemName &&
          other.itemId == this.itemId &&
          other.description == this.description &&
          other.itemGroup == this.itemGroup &&
          other.stockUom == this.stockUom &&
          other.salesUom == this.salesUom &&
          other.transactionNumber == this.transactionNumber &&
          other.quantityMove == this.quantityMove &&
          other.quantityMoveConvert == this.quantityMoveConvert &&
          other.conversionFactor == this.conversionFactor &&
          other.costPrice == this.costPrice &&
          other.itemPrice == this.itemPrice &&
          other.transactionType == this.transactionType &&
          other.reasonCode == this.reasonCode &&
          other.inventoryCycle == this.inventoryCycle &&
          other.toWarehouse == this.toWarehouse &&
          other.fromWarehouse == this.fromWarehouse);
}

class InventoryTransactionCompanion
    extends UpdateCompanion<InventoryTransactionData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> itemCode;
  final Value<String> itemName;
  final Value<String> itemId;
  final Value<String> description;
  final Value<String> itemGroup;
  final Value<String> stockUom;
  final Value<String> salesUom;
  final Value<String> transactionNumber;
  final Value<double> quantityMove;
  final Value<double> quantityMoveConvert;
  final Value<double> conversionFactor;
  final Value<double> costPrice;
  final Value<double> itemPrice;
  final Value<String> transactionType;
  final Value<String> reasonCode;
  final Value<String> inventoryCycle;
  final Value<String> toWarehouse;
  final Value<String> fromWarehouse;
  const InventoryTransactionCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.itemId = const Value.absent(),
    this.description = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.stockUom = const Value.absent(),
    this.salesUom = const Value.absent(),
    this.transactionNumber = const Value.absent(),
    this.quantityMove = const Value.absent(),
    this.quantityMoveConvert = const Value.absent(),
    this.conversionFactor = const Value.absent(),
    this.costPrice = const Value.absent(),
    this.itemPrice = const Value.absent(),
    this.transactionType = const Value.absent(),
    this.reasonCode = const Value.absent(),
    this.inventoryCycle = const Value.absent(),
    this.toWarehouse = const Value.absent(),
    this.fromWarehouse = const Value.absent(),
  });
  InventoryTransactionCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.itemName = const Value.absent(),
    this.itemId = const Value.absent(),
    this.description = const Value.absent(),
    this.itemGroup = const Value.absent(),
    this.stockUom = const Value.absent(),
    this.salesUom = const Value.absent(),
    this.transactionNumber = const Value.absent(),
    @required double quantityMove,
    @required double quantityMoveConvert,
    @required double conversionFactor,
    @required double costPrice,
    @required double itemPrice,
    this.transactionType = const Value.absent(),
    this.reasonCode = const Value.absent(),
    this.inventoryCycle = const Value.absent(),
    this.toWarehouse = const Value.absent(),
    this.fromWarehouse = const Value.absent(),
  })  : quantityMove = Value(quantityMove),
        quantityMoveConvert = Value(quantityMoveConvert),
        conversionFactor = Value(conversionFactor),
        costPrice = Value(costPrice),
        itemPrice = Value(itemPrice);
  static Insertable<InventoryTransactionData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> itemCode,
    Expression<String> itemName,
    Expression<String> itemId,
    Expression<String> description,
    Expression<String> itemGroup,
    Expression<String> stockUom,
    Expression<String> salesUom,
    Expression<String> transactionNumber,
    Expression<double> quantityMove,
    Expression<double> quantityMoveConvert,
    Expression<double> conversionFactor,
    Expression<double> costPrice,
    Expression<double> itemPrice,
    Expression<String> transactionType,
    Expression<String> reasonCode,
    Expression<String> inventoryCycle,
    Expression<String> toWarehouse,
    Expression<String> fromWarehouse,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (itemCode != null) 'item_code': itemCode,
      if (itemName != null) 'item_name': itemName,
      if (itemId != null) 'item_id': itemId,
      if (description != null) 'description': description,
      if (itemGroup != null) 'item_group': itemGroup,
      if (stockUom != null) 'stock_uom': stockUom,
      if (salesUom != null) 'sales_uom': salesUom,
      if (transactionNumber != null) 'transaction_number': transactionNumber,
      if (quantityMove != null) 'quantity_move': quantityMove,
      if (quantityMoveConvert != null)
        'quantity_move_convert': quantityMoveConvert,
      if (conversionFactor != null) 'conversion_factor': conversionFactor,
      if (costPrice != null) 'cost_price': costPrice,
      if (itemPrice != null) 'item_price': itemPrice,
      if (transactionType != null) 'transaction_type': transactionType,
      if (reasonCode != null) 'reason_code': reasonCode,
      if (inventoryCycle != null) 'inventory_cycle': inventoryCycle,
      if (toWarehouse != null) 'to_warehouse': toWarehouse,
      if (fromWarehouse != null) 'from_warehouse': fromWarehouse,
    });
  }

  InventoryTransactionCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> itemCode,
      Value<String> itemName,
      Value<String> itemId,
      Value<String> description,
      Value<String> itemGroup,
      Value<String> stockUom,
      Value<String> salesUom,
      Value<String> transactionNumber,
      Value<double> quantityMove,
      Value<double> quantityMoveConvert,
      Value<double> conversionFactor,
      Value<double> costPrice,
      Value<double> itemPrice,
      Value<String> transactionType,
      Value<String> reasonCode,
      Value<String> inventoryCycle,
      Value<String> toWarehouse,
      Value<String> fromWarehouse}) {
    return InventoryTransactionCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      itemCode: itemCode ?? this.itemCode,
      itemName: itemName ?? this.itemName,
      itemId: itemId ?? this.itemId,
      description: description ?? this.description,
      itemGroup: itemGroup ?? this.itemGroup,
      stockUom: stockUom ?? this.stockUom,
      salesUom: salesUom ?? this.salesUom,
      transactionNumber: transactionNumber ?? this.transactionNumber,
      quantityMove: quantityMove ?? this.quantityMove,
      quantityMoveConvert: quantityMoveConvert ?? this.quantityMoveConvert,
      conversionFactor: conversionFactor ?? this.conversionFactor,
      costPrice: costPrice ?? this.costPrice,
      itemPrice: itemPrice ?? this.itemPrice,
      transactionType: transactionType ?? this.transactionType,
      reasonCode: reasonCode ?? this.reasonCode,
      inventoryCycle: inventoryCycle ?? this.inventoryCycle,
      toWarehouse: toWarehouse ?? this.toWarehouse,
      fromWarehouse: fromWarehouse ?? this.fromWarehouse,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (itemName.present) {
      map['item_name'] = Variable<String>(itemName.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<String>(itemId.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (itemGroup.present) {
      map['item_group'] = Variable<String>(itemGroup.value);
    }
    if (stockUom.present) {
      map['stock_uom'] = Variable<String>(stockUom.value);
    }
    if (salesUom.present) {
      map['sales_uom'] = Variable<String>(salesUom.value);
    }
    if (transactionNumber.present) {
      map['transaction_number'] = Variable<String>(transactionNumber.value);
    }
    if (quantityMove.present) {
      map['quantity_move'] = Variable<double>(quantityMove.value);
    }
    if (quantityMoveConvert.present) {
      map['quantity_move_convert'] =
          Variable<double>(quantityMoveConvert.value);
    }
    if (conversionFactor.present) {
      map['conversion_factor'] = Variable<double>(conversionFactor.value);
    }
    if (costPrice.present) {
      map['cost_price'] = Variable<double>(costPrice.value);
    }
    if (itemPrice.present) {
      map['item_price'] = Variable<double>(itemPrice.value);
    }
    if (transactionType.present) {
      map['transaction_type'] = Variable<String>(transactionType.value);
    }
    if (reasonCode.present) {
      map['reason_code'] = Variable<String>(reasonCode.value);
    }
    if (inventoryCycle.present) {
      map['inventory_cycle'] = Variable<String>(inventoryCycle.value);
    }
    if (toWarehouse.present) {
      map['to_warehouse'] = Variable<String>(toWarehouse.value);
    }
    if (fromWarehouse.present) {
      map['from_warehouse'] = Variable<String>(fromWarehouse.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InventoryTransactionCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('itemCode: $itemCode, ')
          ..write('itemName: $itemName, ')
          ..write('itemId: $itemId, ')
          ..write('description: $description, ')
          ..write('itemGroup: $itemGroup, ')
          ..write('stockUom: $stockUom, ')
          ..write('salesUom: $salesUom, ')
          ..write('transactionNumber: $transactionNumber, ')
          ..write('quantityMove: $quantityMove, ')
          ..write('quantityMoveConvert: $quantityMoveConvert, ')
          ..write('conversionFactor: $conversionFactor, ')
          ..write('costPrice: $costPrice, ')
          ..write('itemPrice: $itemPrice, ')
          ..write('transactionType: $transactionType, ')
          ..write('reasonCode: $reasonCode, ')
          ..write('inventoryCycle: $inventoryCycle, ')
          ..write('toWarehouse: $toWarehouse, ')
          ..write('fromWarehouse: $fromWarehouse')
          ..write(')'))
        .toString();
  }
}

class $InventoryTransactionTable extends InventoryTransaction
    with TableInfo<$InventoryTransactionTable, InventoryTransactionData> {
  final GeneratedDatabase _db;
  final String _alias;
  $InventoryTransactionTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _itemCodeMeta = const VerificationMeta('itemCode');
  GeneratedColumn<String> _itemCode;
  @override
  GeneratedColumn<String> get itemCode =>
      _itemCode ??= GeneratedColumn<String>('item_code', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemNameMeta = const VerificationMeta('itemName');
  GeneratedColumn<String> _itemName;
  @override
  GeneratedColumn<String> get itemName =>
      _itemName ??= GeneratedColumn<String>('item_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  GeneratedColumn<String> _itemId;
  @override
  GeneratedColumn<String> get itemId =>
      _itemId ??= GeneratedColumn<String>('item_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  GeneratedColumn<String> _description;
  @override
  GeneratedColumn<String> get description =>
      _description ??= GeneratedColumn<String>('description', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _itemGroupMeta = const VerificationMeta('itemGroup');
  GeneratedColumn<String> _itemGroup;
  @override
  GeneratedColumn<String> get itemGroup =>
      _itemGroup ??= GeneratedColumn<String>('item_group', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _stockUomMeta = const VerificationMeta('stockUom');
  GeneratedColumn<String> _stockUom;
  @override
  GeneratedColumn<String> get stockUom =>
      _stockUom ??= GeneratedColumn<String>('stock_uom', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _salesUomMeta = const VerificationMeta('salesUom');
  GeneratedColumn<String> _salesUom;
  @override
  GeneratedColumn<String> get salesUom =>
      _salesUom ??= GeneratedColumn<String>('sales_uom', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _transactionNumberMeta =
      const VerificationMeta('transactionNumber');
  GeneratedColumn<String> _transactionNumber;
  @override
  GeneratedColumn<String> get transactionNumber => _transactionNumber ??=
      GeneratedColumn<String>('transaction_number', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _quantityMoveMeta =
      const VerificationMeta('quantityMove');
  GeneratedColumn<double> _quantityMove;
  @override
  GeneratedColumn<double> get quantityMove => _quantityMove ??=
      GeneratedColumn<double>('quantity_move', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _quantityMoveConvertMeta =
      const VerificationMeta('quantityMoveConvert');
  GeneratedColumn<double> _quantityMoveConvert;
  @override
  GeneratedColumn<double> get quantityMoveConvert => _quantityMoveConvert ??=
      GeneratedColumn<double>('quantity_move_convert', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _conversionFactorMeta =
      const VerificationMeta('conversionFactor');
  GeneratedColumn<double> _conversionFactor;
  @override
  GeneratedColumn<double> get conversionFactor => _conversionFactor ??=
      GeneratedColumn<double>('conversion_factor', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _costPriceMeta = const VerificationMeta('costPrice');
  GeneratedColumn<double> _costPrice;
  @override
  GeneratedColumn<double> get costPrice =>
      _costPrice ??= GeneratedColumn<double>('cost_price', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _itemPriceMeta = const VerificationMeta('itemPrice');
  GeneratedColumn<double> _itemPrice;
  @override
  GeneratedColumn<double> get itemPrice =>
      _itemPrice ??= GeneratedColumn<double>('item_price', aliasedName, false,
          type: const RealType(), requiredDuringInsert: true);
  final VerificationMeta _transactionTypeMeta =
      const VerificationMeta('transactionType');
  GeneratedColumn<String> _transactionType;
  @override
  GeneratedColumn<String> get transactionType => _transactionType ??=
      GeneratedColumn<String>('transaction_type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _reasonCodeMeta = const VerificationMeta('reasonCode');
  GeneratedColumn<String> _reasonCode;
  @override
  GeneratedColumn<String> get reasonCode =>
      _reasonCode ??= GeneratedColumn<String>('reason_code', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _inventoryCycleMeta =
      const VerificationMeta('inventoryCycle');
  GeneratedColumn<String> _inventoryCycle;
  @override
  GeneratedColumn<String> get inventoryCycle => _inventoryCycle ??=
      GeneratedColumn<String>('inventory_cycle', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _toWarehouseMeta =
      const VerificationMeta('toWarehouse');
  GeneratedColumn<String> _toWarehouse;
  @override
  GeneratedColumn<String> get toWarehouse => _toWarehouse ??=
      GeneratedColumn<String>('to_warehouse', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _fromWarehouseMeta =
      const VerificationMeta('fromWarehouse');
  GeneratedColumn<String> _fromWarehouse;
  @override
  GeneratedColumn<String> get fromWarehouse => _fromWarehouse ??=
      GeneratedColumn<String>('from_warehouse', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        itemCode,
        itemName,
        itemId,
        description,
        itemGroup,
        stockUom,
        salesUom,
        transactionNumber,
        quantityMove,
        quantityMoveConvert,
        conversionFactor,
        costPrice,
        itemPrice,
        transactionType,
        reasonCode,
        inventoryCycle,
        toWarehouse,
        fromWarehouse
      ];
  @override
  String get aliasedName => _alias ?? 'inventory_transaction';
  @override
  String get actualTableName => 'inventory_transaction';
  @override
  VerificationContext validateIntegrity(
      Insertable<InventoryTransactionData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code'], _itemCodeMeta));
    }
    if (data.containsKey('item_name')) {
      context.handle(_itemNameMeta,
          itemName.isAcceptableOrUnknown(data['item_name'], _itemNameMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id'], _itemIdMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description'], _descriptionMeta));
    }
    if (data.containsKey('item_group')) {
      context.handle(_itemGroupMeta,
          itemGroup.isAcceptableOrUnknown(data['item_group'], _itemGroupMeta));
    }
    if (data.containsKey('stock_uom')) {
      context.handle(_stockUomMeta,
          stockUom.isAcceptableOrUnknown(data['stock_uom'], _stockUomMeta));
    }
    if (data.containsKey('sales_uom')) {
      context.handle(_salesUomMeta,
          salesUom.isAcceptableOrUnknown(data['sales_uom'], _salesUomMeta));
    }
    if (data.containsKey('transaction_number')) {
      context.handle(
          _transactionNumberMeta,
          transactionNumber.isAcceptableOrUnknown(
              data['transaction_number'], _transactionNumberMeta));
    }
    if (data.containsKey('quantity_move')) {
      context.handle(
          _quantityMoveMeta,
          quantityMove.isAcceptableOrUnknown(
              data['quantity_move'], _quantityMoveMeta));
    } else if (isInserting) {
      context.missing(_quantityMoveMeta);
    }
    if (data.containsKey('quantity_move_convert')) {
      context.handle(
          _quantityMoveConvertMeta,
          quantityMoveConvert.isAcceptableOrUnknown(
              data['quantity_move_convert'], _quantityMoveConvertMeta));
    } else if (isInserting) {
      context.missing(_quantityMoveConvertMeta);
    }
    if (data.containsKey('conversion_factor')) {
      context.handle(
          _conversionFactorMeta,
          conversionFactor.isAcceptableOrUnknown(
              data['conversion_factor'], _conversionFactorMeta));
    } else if (isInserting) {
      context.missing(_conversionFactorMeta);
    }
    if (data.containsKey('cost_price')) {
      context.handle(_costPriceMeta,
          costPrice.isAcceptableOrUnknown(data['cost_price'], _costPriceMeta));
    } else if (isInserting) {
      context.missing(_costPriceMeta);
    }
    if (data.containsKey('item_price')) {
      context.handle(_itemPriceMeta,
          itemPrice.isAcceptableOrUnknown(data['item_price'], _itemPriceMeta));
    } else if (isInserting) {
      context.missing(_itemPriceMeta);
    }
    if (data.containsKey('transaction_type')) {
      context.handle(
          _transactionTypeMeta,
          transactionType.isAcceptableOrUnknown(
              data['transaction_type'], _transactionTypeMeta));
    }
    if (data.containsKey('reason_code')) {
      context.handle(
          _reasonCodeMeta,
          reasonCode.isAcceptableOrUnknown(
              data['reason_code'], _reasonCodeMeta));
    }
    if (data.containsKey('inventory_cycle')) {
      context.handle(
          _inventoryCycleMeta,
          inventoryCycle.isAcceptableOrUnknown(
              data['inventory_cycle'], _inventoryCycleMeta));
    }
    if (data.containsKey('to_warehouse')) {
      context.handle(
          _toWarehouseMeta,
          toWarehouse.isAcceptableOrUnknown(
              data['to_warehouse'], _toWarehouseMeta));
    }
    if (data.containsKey('from_warehouse')) {
      context.handle(
          _fromWarehouseMeta,
          fromWarehouse.isAcceptableOrUnknown(
              data['from_warehouse'], _fromWarehouseMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InventoryTransactionData map(Map<String, dynamic> data,
      {String tablePrefix}) {
    return InventoryTransactionData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $InventoryTransactionTable createAlias(String alias) {
    return $InventoryTransactionTable(_db, alias);
  }
}

class MoneyDepositData extends DataClass
    implements Insertable<MoneyDepositData> {
  final int tenantId;
  final int id;
  final String clockInDaySessionId;
  final String clockOutDaySessionId;
  final String depositId;
  final String type;
  final DateTime startDate;
  final DateTime endDate;
  final String depositStatus;
  final String userName;
  final double denominator;
  final String denominatorType;
  final String depositDescription;
  final double amount;
  final String currency;
  final double exchangeRate;
  final double subTotal;
  final double grandTotal;
  MoneyDepositData(
      {this.tenantId,
      @required this.id,
      this.clockInDaySessionId,
      this.clockOutDaySessionId,
      this.depositId,
      this.type,
      this.startDate,
      this.endDate,
      this.depositStatus,
      this.userName,
      this.denominator,
      this.denominatorType,
      this.depositDescription,
      this.amount,
      this.currency,
      this.exchangeRate,
      this.subTotal,
      this.grandTotal});
  factory MoneyDepositData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return MoneyDepositData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      clockInDaySessionId: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}clock_in_day_session_id']),
      clockOutDaySessionId: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}clock_out_day_session_id']),
      depositId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}deposit_id']),
      type: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}type']),
      startDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}start_date']),
      endDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}end_date']),
      depositStatus: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}deposit_status']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      denominator: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}denominator']),
      denominatorType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}denominator_type']),
      depositDescription: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}deposit_description']),
      amount: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}amount']),
      currency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}currency']),
      exchangeRate: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}exchange_rate']),
      subTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sub_total']),
      grandTotal: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}grand_total']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || clockInDaySessionId != null) {
      map['clock_in_day_session_id'] = Variable<String>(clockInDaySessionId);
    }
    if (!nullToAbsent || clockOutDaySessionId != null) {
      map['clock_out_day_session_id'] = Variable<String>(clockOutDaySessionId);
    }
    if (!nullToAbsent || depositId != null) {
      map['deposit_id'] = Variable<String>(depositId);
    }
    if (!nullToAbsent || type != null) {
      map['type'] = Variable<String>(type);
    }
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<DateTime>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<DateTime>(endDate);
    }
    if (!nullToAbsent || depositStatus != null) {
      map['deposit_status'] = Variable<String>(depositStatus);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || denominator != null) {
      map['denominator'] = Variable<double>(denominator);
    }
    if (!nullToAbsent || denominatorType != null) {
      map['denominator_type'] = Variable<String>(denominatorType);
    }
    if (!nullToAbsent || depositDescription != null) {
      map['deposit_description'] = Variable<String>(depositDescription);
    }
    if (!nullToAbsent || amount != null) {
      map['amount'] = Variable<double>(amount);
    }
    if (!nullToAbsent || currency != null) {
      map['currency'] = Variable<String>(currency);
    }
    if (!nullToAbsent || exchangeRate != null) {
      map['exchange_rate'] = Variable<double>(exchangeRate);
    }
    if (!nullToAbsent || subTotal != null) {
      map['sub_total'] = Variable<double>(subTotal);
    }
    if (!nullToAbsent || grandTotal != null) {
      map['grand_total'] = Variable<double>(grandTotal);
    }
    return map;
  }

  MoneyDepositCompanion toCompanion(bool nullToAbsent) {
    return MoneyDepositCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      clockInDaySessionId: clockInDaySessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(clockInDaySessionId),
      clockOutDaySessionId: clockOutDaySessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(clockOutDaySessionId),
      depositId: depositId == null && nullToAbsent
          ? const Value.absent()
          : Value(depositId),
      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      depositStatus: depositStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(depositStatus),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      denominator: denominator == null && nullToAbsent
          ? const Value.absent()
          : Value(denominator),
      denominatorType: denominatorType == null && nullToAbsent
          ? const Value.absent()
          : Value(denominatorType),
      depositDescription: depositDescription == null && nullToAbsent
          ? const Value.absent()
          : Value(depositDescription),
      amount:
          amount == null && nullToAbsent ? const Value.absent() : Value(amount),
      currency: currency == null && nullToAbsent
          ? const Value.absent()
          : Value(currency),
      exchangeRate: exchangeRate == null && nullToAbsent
          ? const Value.absent()
          : Value(exchangeRate),
      subTotal: subTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(subTotal),
      grandTotal: grandTotal == null && nullToAbsent
          ? const Value.absent()
          : Value(grandTotal),
    );
  }

  factory MoneyDepositData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MoneyDepositData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      clockInDaySessionId:
          serializer.fromJson<String>(json['clockInDaySessionId']),
      clockOutDaySessionId:
          serializer.fromJson<String>(json['clockOutDaySessionId']),
      depositId: serializer.fromJson<String>(json['depositId']),
      type: serializer.fromJson<String>(json['type']),
      startDate: serializer.fromJson<DateTime>(json['startDate']),
      endDate: serializer.fromJson<DateTime>(json['endDate']),
      depositStatus: serializer.fromJson<String>(json['depositStatus']),
      userName: serializer.fromJson<String>(json['userName']),
      denominator: serializer.fromJson<double>(json['denominator']),
      denominatorType: serializer.fromJson<String>(json['denominatorType']),
      depositDescription:
          serializer.fromJson<String>(json['depositDescription']),
      amount: serializer.fromJson<double>(json['amount']),
      currency: serializer.fromJson<String>(json['currency']),
      exchangeRate: serializer.fromJson<double>(json['exchangeRate']),
      subTotal: serializer.fromJson<double>(json['subTotal']),
      grandTotal: serializer.fromJson<double>(json['grandTotal']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'clockInDaySessionId': serializer.toJson<String>(clockInDaySessionId),
      'clockOutDaySessionId': serializer.toJson<String>(clockOutDaySessionId),
      'depositId': serializer.toJson<String>(depositId),
      'type': serializer.toJson<String>(type),
      'startDate': serializer.toJson<DateTime>(startDate),
      'endDate': serializer.toJson<DateTime>(endDate),
      'depositStatus': serializer.toJson<String>(depositStatus),
      'userName': serializer.toJson<String>(userName),
      'denominator': serializer.toJson<double>(denominator),
      'denominatorType': serializer.toJson<String>(denominatorType),
      'depositDescription': serializer.toJson<String>(depositDescription),
      'amount': serializer.toJson<double>(amount),
      'currency': serializer.toJson<String>(currency),
      'exchangeRate': serializer.toJson<double>(exchangeRate),
      'subTotal': serializer.toJson<double>(subTotal),
      'grandTotal': serializer.toJson<double>(grandTotal),
    };
  }

  MoneyDepositData copyWith(
          {int tenantId,
          int id,
          String clockInDaySessionId,
          String clockOutDaySessionId,
          String depositId,
          String type,
          DateTime startDate,
          DateTime endDate,
          String depositStatus,
          String userName,
          double denominator,
          String denominatorType,
          String depositDescription,
          double amount,
          String currency,
          double exchangeRate,
          double subTotal,
          double grandTotal}) =>
      MoneyDepositData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        clockInDaySessionId: clockInDaySessionId ?? this.clockInDaySessionId,
        clockOutDaySessionId: clockOutDaySessionId ?? this.clockOutDaySessionId,
        depositId: depositId ?? this.depositId,
        type: type ?? this.type,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        depositStatus: depositStatus ?? this.depositStatus,
        userName: userName ?? this.userName,
        denominator: denominator ?? this.denominator,
        denominatorType: denominatorType ?? this.denominatorType,
        depositDescription: depositDescription ?? this.depositDescription,
        amount: amount ?? this.amount,
        currency: currency ?? this.currency,
        exchangeRate: exchangeRate ?? this.exchangeRate,
        subTotal: subTotal ?? this.subTotal,
        grandTotal: grandTotal ?? this.grandTotal,
      );
  @override
  String toString() {
    return (StringBuffer('MoneyDepositData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('clockInDaySessionId: $clockInDaySessionId, ')
          ..write('clockOutDaySessionId: $clockOutDaySessionId, ')
          ..write('depositId: $depositId, ')
          ..write('type: $type, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('depositStatus: $depositStatus, ')
          ..write('userName: $userName, ')
          ..write('denominator: $denominator, ')
          ..write('denominatorType: $denominatorType, ')
          ..write('depositDescription: $depositDescription, ')
          ..write('amount: $amount, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      clockInDaySessionId,
      clockOutDaySessionId,
      depositId,
      type,
      startDate,
      endDate,
      depositStatus,
      userName,
      denominator,
      denominatorType,
      depositDescription,
      amount,
      currency,
      exchangeRate,
      subTotal,
      grandTotal);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MoneyDepositData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.clockInDaySessionId == this.clockInDaySessionId &&
          other.clockOutDaySessionId == this.clockOutDaySessionId &&
          other.depositId == this.depositId &&
          other.type == this.type &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.depositStatus == this.depositStatus &&
          other.userName == this.userName &&
          other.denominator == this.denominator &&
          other.denominatorType == this.denominatorType &&
          other.depositDescription == this.depositDescription &&
          other.amount == this.amount &&
          other.currency == this.currency &&
          other.exchangeRate == this.exchangeRate &&
          other.subTotal == this.subTotal &&
          other.grandTotal == this.grandTotal);
}

class MoneyDepositCompanion extends UpdateCompanion<MoneyDepositData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> clockInDaySessionId;
  final Value<String> clockOutDaySessionId;
  final Value<String> depositId;
  final Value<String> type;
  final Value<DateTime> startDate;
  final Value<DateTime> endDate;
  final Value<String> depositStatus;
  final Value<String> userName;
  final Value<double> denominator;
  final Value<String> denominatorType;
  final Value<String> depositDescription;
  final Value<double> amount;
  final Value<String> currency;
  final Value<double> exchangeRate;
  final Value<double> subTotal;
  final Value<double> grandTotal;
  const MoneyDepositCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.clockInDaySessionId = const Value.absent(),
    this.clockOutDaySessionId = const Value.absent(),
    this.depositId = const Value.absent(),
    this.type = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.depositStatus = const Value.absent(),
    this.userName = const Value.absent(),
    this.denominator = const Value.absent(),
    this.denominatorType = const Value.absent(),
    this.depositDescription = const Value.absent(),
    this.amount = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.subTotal = const Value.absent(),
    this.grandTotal = const Value.absent(),
  });
  MoneyDepositCompanion.insert({
    this.tenantId = const Value.absent(),
    @required int id,
    this.clockInDaySessionId = const Value.absent(),
    this.clockOutDaySessionId = const Value.absent(),
    this.depositId = const Value.absent(),
    this.type = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.depositStatus = const Value.absent(),
    this.userName = const Value.absent(),
    this.denominator = const Value.absent(),
    this.denominatorType = const Value.absent(),
    this.depositDescription = const Value.absent(),
    this.amount = const Value.absent(),
    this.currency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.subTotal = const Value.absent(),
    this.grandTotal = const Value.absent(),
  }) : id = Value(id);
  static Insertable<MoneyDepositData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> clockInDaySessionId,
    Expression<String> clockOutDaySessionId,
    Expression<String> depositId,
    Expression<String> type,
    Expression<DateTime> startDate,
    Expression<DateTime> endDate,
    Expression<String> depositStatus,
    Expression<String> userName,
    Expression<double> denominator,
    Expression<String> denominatorType,
    Expression<String> depositDescription,
    Expression<double> amount,
    Expression<String> currency,
    Expression<double> exchangeRate,
    Expression<double> subTotal,
    Expression<double> grandTotal,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (clockInDaySessionId != null)
        'clock_in_day_session_id': clockInDaySessionId,
      if (clockOutDaySessionId != null)
        'clock_out_day_session_id': clockOutDaySessionId,
      if (depositId != null) 'deposit_id': depositId,
      if (type != null) 'type': type,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (depositStatus != null) 'deposit_status': depositStatus,
      if (userName != null) 'user_name': userName,
      if (denominator != null) 'denominator': denominator,
      if (denominatorType != null) 'denominator_type': denominatorType,
      if (depositDescription != null) 'deposit_description': depositDescription,
      if (amount != null) 'amount': amount,
      if (currency != null) 'currency': currency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (subTotal != null) 'sub_total': subTotal,
      if (grandTotal != null) 'grand_total': grandTotal,
    });
  }

  MoneyDepositCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> clockInDaySessionId,
      Value<String> clockOutDaySessionId,
      Value<String> depositId,
      Value<String> type,
      Value<DateTime> startDate,
      Value<DateTime> endDate,
      Value<String> depositStatus,
      Value<String> userName,
      Value<double> denominator,
      Value<String> denominatorType,
      Value<String> depositDescription,
      Value<double> amount,
      Value<String> currency,
      Value<double> exchangeRate,
      Value<double> subTotal,
      Value<double> grandTotal}) {
    return MoneyDepositCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      clockInDaySessionId: clockInDaySessionId ?? this.clockInDaySessionId,
      clockOutDaySessionId: clockOutDaySessionId ?? this.clockOutDaySessionId,
      depositId: depositId ?? this.depositId,
      type: type ?? this.type,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      depositStatus: depositStatus ?? this.depositStatus,
      userName: userName ?? this.userName,
      denominator: denominator ?? this.denominator,
      denominatorType: denominatorType ?? this.denominatorType,
      depositDescription: depositDescription ?? this.depositDescription,
      amount: amount ?? this.amount,
      currency: currency ?? this.currency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      subTotal: subTotal ?? this.subTotal,
      grandTotal: grandTotal ?? this.grandTotal,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (clockInDaySessionId.present) {
      map['clock_in_day_session_id'] =
          Variable<String>(clockInDaySessionId.value);
    }
    if (clockOutDaySessionId.present) {
      map['clock_out_day_session_id'] =
          Variable<String>(clockOutDaySessionId.value);
    }
    if (depositId.present) {
      map['deposit_id'] = Variable<String>(depositId.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<DateTime>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<DateTime>(endDate.value);
    }
    if (depositStatus.present) {
      map['deposit_status'] = Variable<String>(depositStatus.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (denominator.present) {
      map['denominator'] = Variable<double>(denominator.value);
    }
    if (denominatorType.present) {
      map['denominator_type'] = Variable<String>(denominatorType.value);
    }
    if (depositDescription.present) {
      map['deposit_description'] = Variable<String>(depositDescription.value);
    }
    if (amount.present) {
      map['amount'] = Variable<double>(amount.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (subTotal.present) {
      map['sub_total'] = Variable<double>(subTotal.value);
    }
    if (grandTotal.present) {
      map['grand_total'] = Variable<double>(grandTotal.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MoneyDepositCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('clockInDaySessionId: $clockInDaySessionId, ')
          ..write('clockOutDaySessionId: $clockOutDaySessionId, ')
          ..write('depositId: $depositId, ')
          ..write('type: $type, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('depositStatus: $depositStatus, ')
          ..write('userName: $userName, ')
          ..write('denominator: $denominator, ')
          ..write('denominatorType: $denominatorType, ')
          ..write('depositDescription: $depositDescription, ')
          ..write('amount: $amount, ')
          ..write('currency: $currency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('subTotal: $subTotal, ')
          ..write('grandTotal: $grandTotal')
          ..write(')'))
        .toString();
  }
}

class $MoneyDepositTable extends MoneyDeposit
    with TableInfo<$MoneyDepositTable, MoneyDepositData> {
  final GeneratedDatabase _db;
  final String _alias;
  $MoneyDepositTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _clockInDaySessionIdMeta =
      const VerificationMeta('clockInDaySessionId');
  GeneratedColumn<String> _clockInDaySessionId;
  @override
  GeneratedColumn<String> get clockInDaySessionId => _clockInDaySessionId ??=
      GeneratedColumn<String>('clock_in_day_session_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _clockOutDaySessionIdMeta =
      const VerificationMeta('clockOutDaySessionId');
  GeneratedColumn<String> _clockOutDaySessionId;
  @override
  GeneratedColumn<String> get clockOutDaySessionId => _clockOutDaySessionId ??=
      GeneratedColumn<String>('clock_out_day_session_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _depositIdMeta = const VerificationMeta('depositId');
  GeneratedColumn<String> _depositId;
  @override
  GeneratedColumn<String> get depositId =>
      _depositId ??= GeneratedColumn<String>('deposit_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _typeMeta = const VerificationMeta('type');
  GeneratedColumn<String> _type;
  @override
  GeneratedColumn<String> get type =>
      _type ??= GeneratedColumn<String>('type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _startDateMeta = const VerificationMeta('startDate');
  GeneratedColumn<DateTime> _startDate;
  @override
  GeneratedColumn<DateTime> get startDate =>
      _startDate ??= GeneratedColumn<DateTime>('start_date', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _endDateMeta = const VerificationMeta('endDate');
  GeneratedColumn<DateTime> _endDate;
  @override
  GeneratedColumn<DateTime> get endDate =>
      _endDate ??= GeneratedColumn<DateTime>('end_date', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _depositStatusMeta =
      const VerificationMeta('depositStatus');
  GeneratedColumn<String> _depositStatus;
  @override
  GeneratedColumn<String> get depositStatus => _depositStatus ??=
      GeneratedColumn<String>('deposit_status', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _denominatorMeta =
      const VerificationMeta('denominator');
  GeneratedColumn<double> _denominator;
  @override
  GeneratedColumn<double> get denominator =>
      _denominator ??= GeneratedColumn<double>('denominator', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _denominatorTypeMeta =
      const VerificationMeta('denominatorType');
  GeneratedColumn<String> _denominatorType;
  @override
  GeneratedColumn<String> get denominatorType => _denominatorType ??=
      GeneratedColumn<String>('denominator_type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _depositDescriptionMeta =
      const VerificationMeta('depositDescription');
  GeneratedColumn<String> _depositDescription;
  @override
  GeneratedColumn<String> get depositDescription => _depositDescription ??=
      GeneratedColumn<String>('deposit_description', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _amountMeta = const VerificationMeta('amount');
  GeneratedColumn<double> _amount;
  @override
  GeneratedColumn<double> get amount =>
      _amount ??= GeneratedColumn<double>('amount', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _currencyMeta = const VerificationMeta('currency');
  GeneratedColumn<String> _currency;
  @override
  GeneratedColumn<String> get currency =>
      _currency ??= GeneratedColumn<String>('currency', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  GeneratedColumn<double> _exchangeRate;
  @override
  GeneratedColumn<double> get exchangeRate => _exchangeRate ??=
      GeneratedColumn<double>('exchange_rate', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _subTotalMeta = const VerificationMeta('subTotal');
  GeneratedColumn<double> _subTotal;
  @override
  GeneratedColumn<double> get subTotal =>
      _subTotal ??= GeneratedColumn<double>('sub_total', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _grandTotalMeta = const VerificationMeta('grandTotal');
  GeneratedColumn<double> _grandTotal;
  @override
  GeneratedColumn<double> get grandTotal =>
      _grandTotal ??= GeneratedColumn<double>('grand_total', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        clockInDaySessionId,
        clockOutDaySessionId,
        depositId,
        type,
        startDate,
        endDate,
        depositStatus,
        userName,
        denominator,
        denominatorType,
        depositDescription,
        amount,
        currency,
        exchangeRate,
        subTotal,
        grandTotal
      ];
  @override
  String get aliasedName => _alias ?? 'money_deposit';
  @override
  String get actualTableName => 'money_deposit';
  @override
  VerificationContext validateIntegrity(Insertable<MoneyDepositData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('clock_in_day_session_id')) {
      context.handle(
          _clockInDaySessionIdMeta,
          clockInDaySessionId.isAcceptableOrUnknown(
              data['clock_in_day_session_id'], _clockInDaySessionIdMeta));
    }
    if (data.containsKey('clock_out_day_session_id')) {
      context.handle(
          _clockOutDaySessionIdMeta,
          clockOutDaySessionId.isAcceptableOrUnknown(
              data['clock_out_day_session_id'], _clockOutDaySessionIdMeta));
    }
    if (data.containsKey('deposit_id')) {
      context.handle(_depositIdMeta,
          depositId.isAcceptableOrUnknown(data['deposit_id'], _depositIdMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type'], _typeMeta));
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date'], _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date'], _endDateMeta));
    }
    if (data.containsKey('deposit_status')) {
      context.handle(
          _depositStatusMeta,
          depositStatus.isAcceptableOrUnknown(
              data['deposit_status'], _depositStatusMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    }
    if (data.containsKey('denominator')) {
      context.handle(
          _denominatorMeta,
          denominator.isAcceptableOrUnknown(
              data['denominator'], _denominatorMeta));
    }
    if (data.containsKey('denominator_type')) {
      context.handle(
          _denominatorTypeMeta,
          denominatorType.isAcceptableOrUnknown(
              data['denominator_type'], _denominatorTypeMeta));
    }
    if (data.containsKey('deposit_description')) {
      context.handle(
          _depositDescriptionMeta,
          depositDescription.isAcceptableOrUnknown(
              data['deposit_description'], _depositDescriptionMeta));
    }
    if (data.containsKey('amount')) {
      context.handle(_amountMeta,
          amount.isAcceptableOrUnknown(data['amount'], _amountMeta));
    }
    if (data.containsKey('currency')) {
      context.handle(_currencyMeta,
          currency.isAcceptableOrUnknown(data['currency'], _currencyMeta));
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate'], _exchangeRateMeta));
    }
    if (data.containsKey('sub_total')) {
      context.handle(_subTotalMeta,
          subTotal.isAcceptableOrUnknown(data['sub_total'], _subTotalMeta));
    }
    if (data.containsKey('grand_total')) {
      context.handle(
          _grandTotalMeta,
          grandTotal.isAcceptableOrUnknown(
              data['grand_total'], _grandTotalMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => <GeneratedColumn>{};
  @override
  MoneyDepositData map(Map<String, dynamic> data, {String tablePrefix}) {
    return MoneyDepositData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $MoneyDepositTable createAlias(String alias) {
    return $MoneyDepositTable(_db, alias);
  }
}

class ClockInData extends DataClass implements Insertable<ClockInData> {
  final int tenantId;
  final int id;
  final String clockInDaySessionId;
  final String clockOutDaySessionId;
  final String inventoryCycleId;
  final String fullName;
  final DateTime startDate;
  final DateTime endDate;
  final DateTime warehouseName;
  final String shiftName;
  final String fleetNumber;
  final String licensePlate;
  final String userName;
  final String sesionType;
  final String sessionStatus;
  final String deviceId;
  final double depositAmount;
  final double totalSales;
  final double arPayment;
  final double totalAmountDue;
  final double balanceBroughtForward;
  final double balanceAmount;
  final String balanceText;
  final double cashTransfer;
  final double creditSales;
  ClockInData(
      {this.tenantId,
      @required this.id,
      this.clockInDaySessionId,
      this.clockOutDaySessionId,
      this.inventoryCycleId,
      this.fullName,
      this.startDate,
      this.endDate,
      this.warehouseName,
      this.shiftName,
      this.fleetNumber,
      this.licensePlate,
      this.userName,
      this.sesionType,
      this.sessionStatus,
      this.deviceId,
      this.depositAmount,
      this.totalSales,
      this.arPayment,
      this.totalAmountDue,
      this.balanceBroughtForward,
      this.balanceAmount,
      this.balanceText,
      this.cashTransfer,
      this.creditSales});
  factory ClockInData.fromData(Map<String, dynamic> data, {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return ClockInData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      clockInDaySessionId: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}clock_in_day_session_id']),
      clockOutDaySessionId: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}clock_out_day_session_id']),
      inventoryCycleId: const StringType().mapFromDatabaseResponse(
          data['${effectivePrefix}inventory_cycle_id']),
      fullName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}full_name']),
      startDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}start_date']),
      endDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}end_date']),
      warehouseName: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}warehouse_name']),
      shiftName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}shift_name']),
      fleetNumber: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}fleet_number']),
      licensePlate: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}license_plate']),
      userName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}user_name']),
      sesionType: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}sesion_type']),
      sessionStatus: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}session_status']),
      deviceId: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}device_id']),
      depositAmount: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}deposit_amount']),
      totalSales: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}total_sales']),
      arPayment: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}ar_payment']),
      totalAmountDue: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}total_amount_due']),
      balanceBroughtForward: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}balance_brought_forward']),
      balanceAmount: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}balance_amount']),
      balanceText: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}balance_text']),
      cashTransfer: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}cash_transfer']),
      creditSales: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}credit_sales']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || clockInDaySessionId != null) {
      map['clock_in_day_session_id'] = Variable<String>(clockInDaySessionId);
    }
    if (!nullToAbsent || clockOutDaySessionId != null) {
      map['clock_out_day_session_id'] = Variable<String>(clockOutDaySessionId);
    }
    if (!nullToAbsent || inventoryCycleId != null) {
      map['inventory_cycle_id'] = Variable<String>(inventoryCycleId);
    }
    if (!nullToAbsent || fullName != null) {
      map['full_name'] = Variable<String>(fullName);
    }
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<DateTime>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<DateTime>(endDate);
    }
    if (!nullToAbsent || warehouseName != null) {
      map['warehouse_name'] = Variable<DateTime>(warehouseName);
    }
    if (!nullToAbsent || shiftName != null) {
      map['shift_name'] = Variable<String>(shiftName);
    }
    if (!nullToAbsent || fleetNumber != null) {
      map['fleet_number'] = Variable<String>(fleetNumber);
    }
    if (!nullToAbsent || licensePlate != null) {
      map['license_plate'] = Variable<String>(licensePlate);
    }
    if (!nullToAbsent || userName != null) {
      map['user_name'] = Variable<String>(userName);
    }
    if (!nullToAbsent || sesionType != null) {
      map['sesion_type'] = Variable<String>(sesionType);
    }
    if (!nullToAbsent || sessionStatus != null) {
      map['session_status'] = Variable<String>(sessionStatus);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || depositAmount != null) {
      map['deposit_amount'] = Variable<double>(depositAmount);
    }
    if (!nullToAbsent || totalSales != null) {
      map['total_sales'] = Variable<double>(totalSales);
    }
    if (!nullToAbsent || arPayment != null) {
      map['ar_payment'] = Variable<double>(arPayment);
    }
    if (!nullToAbsent || totalAmountDue != null) {
      map['total_amount_due'] = Variable<double>(totalAmountDue);
    }
    if (!nullToAbsent || balanceBroughtForward != null) {
      map['balance_brought_forward'] = Variable<double>(balanceBroughtForward);
    }
    if (!nullToAbsent || balanceAmount != null) {
      map['balance_amount'] = Variable<double>(balanceAmount);
    }
    if (!nullToAbsent || balanceText != null) {
      map['balance_text'] = Variable<String>(balanceText);
    }
    if (!nullToAbsent || cashTransfer != null) {
      map['cash_transfer'] = Variable<double>(cashTransfer);
    }
    if (!nullToAbsent || creditSales != null) {
      map['credit_sales'] = Variable<double>(creditSales);
    }
    return map;
  }

  ClockInCompanion toCompanion(bool nullToAbsent) {
    return ClockInCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      clockInDaySessionId: clockInDaySessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(clockInDaySessionId),
      clockOutDaySessionId: clockOutDaySessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(clockOutDaySessionId),
      inventoryCycleId: inventoryCycleId == null && nullToAbsent
          ? const Value.absent()
          : Value(inventoryCycleId),
      fullName: fullName == null && nullToAbsent
          ? const Value.absent()
          : Value(fullName),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      warehouseName: warehouseName == null && nullToAbsent
          ? const Value.absent()
          : Value(warehouseName),
      shiftName: shiftName == null && nullToAbsent
          ? const Value.absent()
          : Value(shiftName),
      fleetNumber: fleetNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(fleetNumber),
      licensePlate: licensePlate == null && nullToAbsent
          ? const Value.absent()
          : Value(licensePlate),
      userName: userName == null && nullToAbsent
          ? const Value.absent()
          : Value(userName),
      sesionType: sesionType == null && nullToAbsent
          ? const Value.absent()
          : Value(sesionType),
      sessionStatus: sessionStatus == null && nullToAbsent
          ? const Value.absent()
          : Value(sessionStatus),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      depositAmount: depositAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(depositAmount),
      totalSales: totalSales == null && nullToAbsent
          ? const Value.absent()
          : Value(totalSales),
      arPayment: arPayment == null && nullToAbsent
          ? const Value.absent()
          : Value(arPayment),
      totalAmountDue: totalAmountDue == null && nullToAbsent
          ? const Value.absent()
          : Value(totalAmountDue),
      balanceBroughtForward: balanceBroughtForward == null && nullToAbsent
          ? const Value.absent()
          : Value(balanceBroughtForward),
      balanceAmount: balanceAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(balanceAmount),
      balanceText: balanceText == null && nullToAbsent
          ? const Value.absent()
          : Value(balanceText),
      cashTransfer: cashTransfer == null && nullToAbsent
          ? const Value.absent()
          : Value(cashTransfer),
      creditSales: creditSales == null && nullToAbsent
          ? const Value.absent()
          : Value(creditSales),
    );
  }

  factory ClockInData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ClockInData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      clockInDaySessionId:
          serializer.fromJson<String>(json['clockInDaySessionId']),
      clockOutDaySessionId:
          serializer.fromJson<String>(json['clockOutDaySessionId']),
      inventoryCycleId: serializer.fromJson<String>(json['inventoryCycleId']),
      fullName: serializer.fromJson<String>(json['fullName']),
      startDate: serializer.fromJson<DateTime>(json['startDate']),
      endDate: serializer.fromJson<DateTime>(json['endDate']),
      warehouseName: serializer.fromJson<DateTime>(json['warehouseName']),
      shiftName: serializer.fromJson<String>(json['shiftName']),
      fleetNumber: serializer.fromJson<String>(json['fleetNumber']),
      licensePlate: serializer.fromJson<String>(json['licensePlate']),
      userName: serializer.fromJson<String>(json['userName']),
      sesionType: serializer.fromJson<String>(json['sesionType']),
      sessionStatus: serializer.fromJson<String>(json['sessionStatus']),
      deviceId: serializer.fromJson<String>(json['deviceId']),
      depositAmount: serializer.fromJson<double>(json['depositAmount']),
      totalSales: serializer.fromJson<double>(json['totalSales']),
      arPayment: serializer.fromJson<double>(json['arPayment']),
      totalAmountDue: serializer.fromJson<double>(json['totalAmountDue']),
      balanceBroughtForward:
          serializer.fromJson<double>(json['balanceBroughtForward']),
      balanceAmount: serializer.fromJson<double>(json['balanceAmount']),
      balanceText: serializer.fromJson<String>(json['balanceText']),
      cashTransfer: serializer.fromJson<double>(json['cashTransfer']),
      creditSales: serializer.fromJson<double>(json['creditSales']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'clockInDaySessionId': serializer.toJson<String>(clockInDaySessionId),
      'clockOutDaySessionId': serializer.toJson<String>(clockOutDaySessionId),
      'inventoryCycleId': serializer.toJson<String>(inventoryCycleId),
      'fullName': serializer.toJson<String>(fullName),
      'startDate': serializer.toJson<DateTime>(startDate),
      'endDate': serializer.toJson<DateTime>(endDate),
      'warehouseName': serializer.toJson<DateTime>(warehouseName),
      'shiftName': serializer.toJson<String>(shiftName),
      'fleetNumber': serializer.toJson<String>(fleetNumber),
      'licensePlate': serializer.toJson<String>(licensePlate),
      'userName': serializer.toJson<String>(userName),
      'sesionType': serializer.toJson<String>(sesionType),
      'sessionStatus': serializer.toJson<String>(sessionStatus),
      'deviceId': serializer.toJson<String>(deviceId),
      'depositAmount': serializer.toJson<double>(depositAmount),
      'totalSales': serializer.toJson<double>(totalSales),
      'arPayment': serializer.toJson<double>(arPayment),
      'totalAmountDue': serializer.toJson<double>(totalAmountDue),
      'balanceBroughtForward': serializer.toJson<double>(balanceBroughtForward),
      'balanceAmount': serializer.toJson<double>(balanceAmount),
      'balanceText': serializer.toJson<String>(balanceText),
      'cashTransfer': serializer.toJson<double>(cashTransfer),
      'creditSales': serializer.toJson<double>(creditSales),
    };
  }

  ClockInData copyWith(
          {int tenantId,
          int id,
          String clockInDaySessionId,
          String clockOutDaySessionId,
          String inventoryCycleId,
          String fullName,
          DateTime startDate,
          DateTime endDate,
          DateTime warehouseName,
          String shiftName,
          String fleetNumber,
          String licensePlate,
          String userName,
          String sesionType,
          String sessionStatus,
          String deviceId,
          double depositAmount,
          double totalSales,
          double arPayment,
          double totalAmountDue,
          double balanceBroughtForward,
          double balanceAmount,
          String balanceText,
          double cashTransfer,
          double creditSales}) =>
      ClockInData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        clockInDaySessionId: clockInDaySessionId ?? this.clockInDaySessionId,
        clockOutDaySessionId: clockOutDaySessionId ?? this.clockOutDaySessionId,
        inventoryCycleId: inventoryCycleId ?? this.inventoryCycleId,
        fullName: fullName ?? this.fullName,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        warehouseName: warehouseName ?? this.warehouseName,
        shiftName: shiftName ?? this.shiftName,
        fleetNumber: fleetNumber ?? this.fleetNumber,
        licensePlate: licensePlate ?? this.licensePlate,
        userName: userName ?? this.userName,
        sesionType: sesionType ?? this.sesionType,
        sessionStatus: sessionStatus ?? this.sessionStatus,
        deviceId: deviceId ?? this.deviceId,
        depositAmount: depositAmount ?? this.depositAmount,
        totalSales: totalSales ?? this.totalSales,
        arPayment: arPayment ?? this.arPayment,
        totalAmountDue: totalAmountDue ?? this.totalAmountDue,
        balanceBroughtForward:
            balanceBroughtForward ?? this.balanceBroughtForward,
        balanceAmount: balanceAmount ?? this.balanceAmount,
        balanceText: balanceText ?? this.balanceText,
        cashTransfer: cashTransfer ?? this.cashTransfer,
        creditSales: creditSales ?? this.creditSales,
      );
  @override
  String toString() {
    return (StringBuffer('ClockInData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('clockInDaySessionId: $clockInDaySessionId, ')
          ..write('clockOutDaySessionId: $clockOutDaySessionId, ')
          ..write('inventoryCycleId: $inventoryCycleId, ')
          ..write('fullName: $fullName, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('warehouseName: $warehouseName, ')
          ..write('shiftName: $shiftName, ')
          ..write('fleetNumber: $fleetNumber, ')
          ..write('licensePlate: $licensePlate, ')
          ..write('userName: $userName, ')
          ..write('sesionType: $sesionType, ')
          ..write('sessionStatus: $sessionStatus, ')
          ..write('deviceId: $deviceId, ')
          ..write('depositAmount: $depositAmount, ')
          ..write('totalSales: $totalSales, ')
          ..write('arPayment: $arPayment, ')
          ..write('totalAmountDue: $totalAmountDue, ')
          ..write('balanceBroughtForward: $balanceBroughtForward, ')
          ..write('balanceAmount: $balanceAmount, ')
          ..write('balanceText: $balanceText, ')
          ..write('cashTransfer: $cashTransfer, ')
          ..write('creditSales: $creditSales')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        tenantId,
        id,
        clockInDaySessionId,
        clockOutDaySessionId,
        inventoryCycleId,
        fullName,
        startDate,
        endDate,
        warehouseName,
        shiftName,
        fleetNumber,
        licensePlate,
        userName,
        sesionType,
        sessionStatus,
        deviceId,
        depositAmount,
        totalSales,
        arPayment,
        totalAmountDue,
        balanceBroughtForward,
        balanceAmount,
        balanceText,
        cashTransfer,
        creditSales
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ClockInData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.clockInDaySessionId == this.clockInDaySessionId &&
          other.clockOutDaySessionId == this.clockOutDaySessionId &&
          other.inventoryCycleId == this.inventoryCycleId &&
          other.fullName == this.fullName &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.warehouseName == this.warehouseName &&
          other.shiftName == this.shiftName &&
          other.fleetNumber == this.fleetNumber &&
          other.licensePlate == this.licensePlate &&
          other.userName == this.userName &&
          other.sesionType == this.sesionType &&
          other.sessionStatus == this.sessionStatus &&
          other.deviceId == this.deviceId &&
          other.depositAmount == this.depositAmount &&
          other.totalSales == this.totalSales &&
          other.arPayment == this.arPayment &&
          other.totalAmountDue == this.totalAmountDue &&
          other.balanceBroughtForward == this.balanceBroughtForward &&
          other.balanceAmount == this.balanceAmount &&
          other.balanceText == this.balanceText &&
          other.cashTransfer == this.cashTransfer &&
          other.creditSales == this.creditSales);
}

class ClockInCompanion extends UpdateCompanion<ClockInData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> clockInDaySessionId;
  final Value<String> clockOutDaySessionId;
  final Value<String> inventoryCycleId;
  final Value<String> fullName;
  final Value<DateTime> startDate;
  final Value<DateTime> endDate;
  final Value<DateTime> warehouseName;
  final Value<String> shiftName;
  final Value<String> fleetNumber;
  final Value<String> licensePlate;
  final Value<String> userName;
  final Value<String> sesionType;
  final Value<String> sessionStatus;
  final Value<String> deviceId;
  final Value<double> depositAmount;
  final Value<double> totalSales;
  final Value<double> arPayment;
  final Value<double> totalAmountDue;
  final Value<double> balanceBroughtForward;
  final Value<double> balanceAmount;
  final Value<String> balanceText;
  final Value<double> cashTransfer;
  final Value<double> creditSales;
  const ClockInCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.clockInDaySessionId = const Value.absent(),
    this.clockOutDaySessionId = const Value.absent(),
    this.inventoryCycleId = const Value.absent(),
    this.fullName = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.warehouseName = const Value.absent(),
    this.shiftName = const Value.absent(),
    this.fleetNumber = const Value.absent(),
    this.licensePlate = const Value.absent(),
    this.userName = const Value.absent(),
    this.sesionType = const Value.absent(),
    this.sessionStatus = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.depositAmount = const Value.absent(),
    this.totalSales = const Value.absent(),
    this.arPayment = const Value.absent(),
    this.totalAmountDue = const Value.absent(),
    this.balanceBroughtForward = const Value.absent(),
    this.balanceAmount = const Value.absent(),
    this.balanceText = const Value.absent(),
    this.cashTransfer = const Value.absent(),
    this.creditSales = const Value.absent(),
  });
  ClockInCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.clockInDaySessionId = const Value.absent(),
    this.clockOutDaySessionId = const Value.absent(),
    this.inventoryCycleId = const Value.absent(),
    this.fullName = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.warehouseName = const Value.absent(),
    this.shiftName = const Value.absent(),
    this.fleetNumber = const Value.absent(),
    this.licensePlate = const Value.absent(),
    this.userName = const Value.absent(),
    this.sesionType = const Value.absent(),
    this.sessionStatus = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.depositAmount = const Value.absent(),
    this.totalSales = const Value.absent(),
    this.arPayment = const Value.absent(),
    this.totalAmountDue = const Value.absent(),
    this.balanceBroughtForward = const Value.absent(),
    this.balanceAmount = const Value.absent(),
    this.balanceText = const Value.absent(),
    this.cashTransfer = const Value.absent(),
    this.creditSales = const Value.absent(),
  });
  static Insertable<ClockInData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> clockInDaySessionId,
    Expression<String> clockOutDaySessionId,
    Expression<String> inventoryCycleId,
    Expression<String> fullName,
    Expression<DateTime> startDate,
    Expression<DateTime> endDate,
    Expression<DateTime> warehouseName,
    Expression<String> shiftName,
    Expression<String> fleetNumber,
    Expression<String> licensePlate,
    Expression<String> userName,
    Expression<String> sesionType,
    Expression<String> sessionStatus,
    Expression<String> deviceId,
    Expression<double> depositAmount,
    Expression<double> totalSales,
    Expression<double> arPayment,
    Expression<double> totalAmountDue,
    Expression<double> balanceBroughtForward,
    Expression<double> balanceAmount,
    Expression<String> balanceText,
    Expression<double> cashTransfer,
    Expression<double> creditSales,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (clockInDaySessionId != null)
        'clock_in_day_session_id': clockInDaySessionId,
      if (clockOutDaySessionId != null)
        'clock_out_day_session_id': clockOutDaySessionId,
      if (inventoryCycleId != null) 'inventory_cycle_id': inventoryCycleId,
      if (fullName != null) 'full_name': fullName,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (warehouseName != null) 'warehouse_name': warehouseName,
      if (shiftName != null) 'shift_name': shiftName,
      if (fleetNumber != null) 'fleet_number': fleetNumber,
      if (licensePlate != null) 'license_plate': licensePlate,
      if (userName != null) 'user_name': userName,
      if (sesionType != null) 'sesion_type': sesionType,
      if (sessionStatus != null) 'session_status': sessionStatus,
      if (deviceId != null) 'device_id': deviceId,
      if (depositAmount != null) 'deposit_amount': depositAmount,
      if (totalSales != null) 'total_sales': totalSales,
      if (arPayment != null) 'ar_payment': arPayment,
      if (totalAmountDue != null) 'total_amount_due': totalAmountDue,
      if (balanceBroughtForward != null)
        'balance_brought_forward': balanceBroughtForward,
      if (balanceAmount != null) 'balance_amount': balanceAmount,
      if (balanceText != null) 'balance_text': balanceText,
      if (cashTransfer != null) 'cash_transfer': cashTransfer,
      if (creditSales != null) 'credit_sales': creditSales,
    });
  }

  ClockInCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> clockInDaySessionId,
      Value<String> clockOutDaySessionId,
      Value<String> inventoryCycleId,
      Value<String> fullName,
      Value<DateTime> startDate,
      Value<DateTime> endDate,
      Value<DateTime> warehouseName,
      Value<String> shiftName,
      Value<String> fleetNumber,
      Value<String> licensePlate,
      Value<String> userName,
      Value<String> sesionType,
      Value<String> sessionStatus,
      Value<String> deviceId,
      Value<double> depositAmount,
      Value<double> totalSales,
      Value<double> arPayment,
      Value<double> totalAmountDue,
      Value<double> balanceBroughtForward,
      Value<double> balanceAmount,
      Value<String> balanceText,
      Value<double> cashTransfer,
      Value<double> creditSales}) {
    return ClockInCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      clockInDaySessionId: clockInDaySessionId ?? this.clockInDaySessionId,
      clockOutDaySessionId: clockOutDaySessionId ?? this.clockOutDaySessionId,
      inventoryCycleId: inventoryCycleId ?? this.inventoryCycleId,
      fullName: fullName ?? this.fullName,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      warehouseName: warehouseName ?? this.warehouseName,
      shiftName: shiftName ?? this.shiftName,
      fleetNumber: fleetNumber ?? this.fleetNumber,
      licensePlate: licensePlate ?? this.licensePlate,
      userName: userName ?? this.userName,
      sesionType: sesionType ?? this.sesionType,
      sessionStatus: sessionStatus ?? this.sessionStatus,
      deviceId: deviceId ?? this.deviceId,
      depositAmount: depositAmount ?? this.depositAmount,
      totalSales: totalSales ?? this.totalSales,
      arPayment: arPayment ?? this.arPayment,
      totalAmountDue: totalAmountDue ?? this.totalAmountDue,
      balanceBroughtForward:
          balanceBroughtForward ?? this.balanceBroughtForward,
      balanceAmount: balanceAmount ?? this.balanceAmount,
      balanceText: balanceText ?? this.balanceText,
      cashTransfer: cashTransfer ?? this.cashTransfer,
      creditSales: creditSales ?? this.creditSales,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (clockInDaySessionId.present) {
      map['clock_in_day_session_id'] =
          Variable<String>(clockInDaySessionId.value);
    }
    if (clockOutDaySessionId.present) {
      map['clock_out_day_session_id'] =
          Variable<String>(clockOutDaySessionId.value);
    }
    if (inventoryCycleId.present) {
      map['inventory_cycle_id'] = Variable<String>(inventoryCycleId.value);
    }
    if (fullName.present) {
      map['full_name'] = Variable<String>(fullName.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<DateTime>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<DateTime>(endDate.value);
    }
    if (warehouseName.present) {
      map['warehouse_name'] = Variable<DateTime>(warehouseName.value);
    }
    if (shiftName.present) {
      map['shift_name'] = Variable<String>(shiftName.value);
    }
    if (fleetNumber.present) {
      map['fleet_number'] = Variable<String>(fleetNumber.value);
    }
    if (licensePlate.present) {
      map['license_plate'] = Variable<String>(licensePlate.value);
    }
    if (userName.present) {
      map['user_name'] = Variable<String>(userName.value);
    }
    if (sesionType.present) {
      map['sesion_type'] = Variable<String>(sesionType.value);
    }
    if (sessionStatus.present) {
      map['session_status'] = Variable<String>(sessionStatus.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (depositAmount.present) {
      map['deposit_amount'] = Variable<double>(depositAmount.value);
    }
    if (totalSales.present) {
      map['total_sales'] = Variable<double>(totalSales.value);
    }
    if (arPayment.present) {
      map['ar_payment'] = Variable<double>(arPayment.value);
    }
    if (totalAmountDue.present) {
      map['total_amount_due'] = Variable<double>(totalAmountDue.value);
    }
    if (balanceBroughtForward.present) {
      map['balance_brought_forward'] =
          Variable<double>(balanceBroughtForward.value);
    }
    if (balanceAmount.present) {
      map['balance_amount'] = Variable<double>(balanceAmount.value);
    }
    if (balanceText.present) {
      map['balance_text'] = Variable<String>(balanceText.value);
    }
    if (cashTransfer.present) {
      map['cash_transfer'] = Variable<double>(cashTransfer.value);
    }
    if (creditSales.present) {
      map['credit_sales'] = Variable<double>(creditSales.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ClockInCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('clockInDaySessionId: $clockInDaySessionId, ')
          ..write('clockOutDaySessionId: $clockOutDaySessionId, ')
          ..write('inventoryCycleId: $inventoryCycleId, ')
          ..write('fullName: $fullName, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('warehouseName: $warehouseName, ')
          ..write('shiftName: $shiftName, ')
          ..write('fleetNumber: $fleetNumber, ')
          ..write('licensePlate: $licensePlate, ')
          ..write('userName: $userName, ')
          ..write('sesionType: $sesionType, ')
          ..write('sessionStatus: $sessionStatus, ')
          ..write('deviceId: $deviceId, ')
          ..write('depositAmount: $depositAmount, ')
          ..write('totalSales: $totalSales, ')
          ..write('arPayment: $arPayment, ')
          ..write('totalAmountDue: $totalAmountDue, ')
          ..write('balanceBroughtForward: $balanceBroughtForward, ')
          ..write('balanceAmount: $balanceAmount, ')
          ..write('balanceText: $balanceText, ')
          ..write('cashTransfer: $cashTransfer, ')
          ..write('creditSales: $creditSales')
          ..write(')'))
        .toString();
  }
}

class $ClockInTable extends ClockIn with TableInfo<$ClockInTable, ClockInData> {
  final GeneratedDatabase _db;
  final String _alias;
  $ClockInTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _clockInDaySessionIdMeta =
      const VerificationMeta('clockInDaySessionId');
  GeneratedColumn<String> _clockInDaySessionId;
  @override
  GeneratedColumn<String> get clockInDaySessionId => _clockInDaySessionId ??=
      GeneratedColumn<String>('clock_in_day_session_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _clockOutDaySessionIdMeta =
      const VerificationMeta('clockOutDaySessionId');
  GeneratedColumn<String> _clockOutDaySessionId;
  @override
  GeneratedColumn<String> get clockOutDaySessionId => _clockOutDaySessionId ??=
      GeneratedColumn<String>('clock_out_day_session_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _inventoryCycleIdMeta =
      const VerificationMeta('inventoryCycleId');
  GeneratedColumn<String> _inventoryCycleId;
  @override
  GeneratedColumn<String> get inventoryCycleId => _inventoryCycleId ??=
      GeneratedColumn<String>('inventory_cycle_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _fullNameMeta = const VerificationMeta('fullName');
  GeneratedColumn<String> _fullName;
  @override
  GeneratedColumn<String> get fullName =>
      _fullName ??= GeneratedColumn<String>('full_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _startDateMeta = const VerificationMeta('startDate');
  GeneratedColumn<DateTime> _startDate;
  @override
  GeneratedColumn<DateTime> get startDate =>
      _startDate ??= GeneratedColumn<DateTime>('start_date', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _endDateMeta = const VerificationMeta('endDate');
  GeneratedColumn<DateTime> _endDate;
  @override
  GeneratedColumn<DateTime> get endDate =>
      _endDate ??= GeneratedColumn<DateTime>('end_date', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _warehouseNameMeta =
      const VerificationMeta('warehouseName');
  GeneratedColumn<DateTime> _warehouseName;
  @override
  GeneratedColumn<DateTime> get warehouseName => _warehouseName ??=
      GeneratedColumn<DateTime>('warehouse_name', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _shiftNameMeta = const VerificationMeta('shiftName');
  GeneratedColumn<String> _shiftName;
  @override
  GeneratedColumn<String> get shiftName =>
      _shiftName ??= GeneratedColumn<String>('shift_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _fleetNumberMeta =
      const VerificationMeta('fleetNumber');
  GeneratedColumn<String> _fleetNumber;
  @override
  GeneratedColumn<String> get fleetNumber => _fleetNumber ??=
      GeneratedColumn<String>('fleet_number', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _licensePlateMeta =
      const VerificationMeta('licensePlate');
  GeneratedColumn<String> _licensePlate;
  @override
  GeneratedColumn<String> get licensePlate => _licensePlate ??=
      GeneratedColumn<String>('license_plate', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _userNameMeta = const VerificationMeta('userName');
  GeneratedColumn<String> _userName;
  @override
  GeneratedColumn<String> get userName =>
      _userName ??= GeneratedColumn<String>('user_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _sesionTypeMeta = const VerificationMeta('sesionType');
  GeneratedColumn<String> _sesionType;
  @override
  GeneratedColumn<String> get sesionType =>
      _sesionType ??= GeneratedColumn<String>('sesion_type', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _sessionStatusMeta =
      const VerificationMeta('sessionStatus');
  GeneratedColumn<String> _sessionStatus;
  @override
  GeneratedColumn<String> get sessionStatus => _sessionStatus ??=
      GeneratedColumn<String>('session_status', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _deviceIdMeta = const VerificationMeta('deviceId');
  GeneratedColumn<String> _deviceId;
  @override
  GeneratedColumn<String> get deviceId =>
      _deviceId ??= GeneratedColumn<String>('device_id', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _depositAmountMeta =
      const VerificationMeta('depositAmount');
  GeneratedColumn<double> _depositAmount;
  @override
  GeneratedColumn<double> get depositAmount => _depositAmount ??=
      GeneratedColumn<double>('deposit_amount', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _totalSalesMeta = const VerificationMeta('totalSales');
  GeneratedColumn<double> _totalSales;
  @override
  GeneratedColumn<double> get totalSales =>
      _totalSales ??= GeneratedColumn<double>('total_sales', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _arPaymentMeta = const VerificationMeta('arPayment');
  GeneratedColumn<double> _arPayment;
  @override
  GeneratedColumn<double> get arPayment =>
      _arPayment ??= GeneratedColumn<double>('ar_payment', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _totalAmountDueMeta =
      const VerificationMeta('totalAmountDue');
  GeneratedColumn<double> _totalAmountDue;
  @override
  GeneratedColumn<double> get totalAmountDue => _totalAmountDue ??=
      GeneratedColumn<double>('total_amount_due', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _balanceBroughtForwardMeta =
      const VerificationMeta('balanceBroughtForward');
  GeneratedColumn<double> _balanceBroughtForward;
  @override
  GeneratedColumn<double> get balanceBroughtForward =>
      _balanceBroughtForward ??= GeneratedColumn<double>(
          'balance_brought_forward', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _balanceAmountMeta =
      const VerificationMeta('balanceAmount');
  GeneratedColumn<double> _balanceAmount;
  @override
  GeneratedColumn<double> get balanceAmount => _balanceAmount ??=
      GeneratedColumn<double>('balance_amount', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _balanceTextMeta =
      const VerificationMeta('balanceText');
  GeneratedColumn<String> _balanceText;
  @override
  GeneratedColumn<String> get balanceText => _balanceText ??=
      GeneratedColumn<String>('balance_text', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _cashTransferMeta =
      const VerificationMeta('cashTransfer');
  GeneratedColumn<double> _cashTransfer;
  @override
  GeneratedColumn<double> get cashTransfer => _cashTransfer ??=
      GeneratedColumn<double>('cash_transfer', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _creditSalesMeta =
      const VerificationMeta('creditSales');
  GeneratedColumn<double> _creditSales;
  @override
  GeneratedColumn<double> get creditSales => _creditSales ??=
      GeneratedColumn<double>('credit_sales', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        clockInDaySessionId,
        clockOutDaySessionId,
        inventoryCycleId,
        fullName,
        startDate,
        endDate,
        warehouseName,
        shiftName,
        fleetNumber,
        licensePlate,
        userName,
        sesionType,
        sessionStatus,
        deviceId,
        depositAmount,
        totalSales,
        arPayment,
        totalAmountDue,
        balanceBroughtForward,
        balanceAmount,
        balanceText,
        cashTransfer,
        creditSales
      ];
  @override
  String get aliasedName => _alias ?? 'clock_in';
  @override
  String get actualTableName => 'clock_in';
  @override
  VerificationContext validateIntegrity(Insertable<ClockInData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('clock_in_day_session_id')) {
      context.handle(
          _clockInDaySessionIdMeta,
          clockInDaySessionId.isAcceptableOrUnknown(
              data['clock_in_day_session_id'], _clockInDaySessionIdMeta));
    }
    if (data.containsKey('clock_out_day_session_id')) {
      context.handle(
          _clockOutDaySessionIdMeta,
          clockOutDaySessionId.isAcceptableOrUnknown(
              data['clock_out_day_session_id'], _clockOutDaySessionIdMeta));
    }
    if (data.containsKey('inventory_cycle_id')) {
      context.handle(
          _inventoryCycleIdMeta,
          inventoryCycleId.isAcceptableOrUnknown(
              data['inventory_cycle_id'], _inventoryCycleIdMeta));
    }
    if (data.containsKey('full_name')) {
      context.handle(_fullNameMeta,
          fullName.isAcceptableOrUnknown(data['full_name'], _fullNameMeta));
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date'], _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date'], _endDateMeta));
    }
    if (data.containsKey('warehouse_name')) {
      context.handle(
          _warehouseNameMeta,
          warehouseName.isAcceptableOrUnknown(
              data['warehouse_name'], _warehouseNameMeta));
    }
    if (data.containsKey('shift_name')) {
      context.handle(_shiftNameMeta,
          shiftName.isAcceptableOrUnknown(data['shift_name'], _shiftNameMeta));
    }
    if (data.containsKey('fleet_number')) {
      context.handle(
          _fleetNumberMeta,
          fleetNumber.isAcceptableOrUnknown(
              data['fleet_number'], _fleetNumberMeta));
    }
    if (data.containsKey('license_plate')) {
      context.handle(
          _licensePlateMeta,
          licensePlate.isAcceptableOrUnknown(
              data['license_plate'], _licensePlateMeta));
    }
    if (data.containsKey('user_name')) {
      context.handle(_userNameMeta,
          userName.isAcceptableOrUnknown(data['user_name'], _userNameMeta));
    }
    if (data.containsKey('sesion_type')) {
      context.handle(
          _sesionTypeMeta,
          sesionType.isAcceptableOrUnknown(
              data['sesion_type'], _sesionTypeMeta));
    }
    if (data.containsKey('session_status')) {
      context.handle(
          _sessionStatusMeta,
          sessionStatus.isAcceptableOrUnknown(
              data['session_status'], _sessionStatusMeta));
    }
    if (data.containsKey('device_id')) {
      context.handle(_deviceIdMeta,
          deviceId.isAcceptableOrUnknown(data['device_id'], _deviceIdMeta));
    }
    if (data.containsKey('deposit_amount')) {
      context.handle(
          _depositAmountMeta,
          depositAmount.isAcceptableOrUnknown(
              data['deposit_amount'], _depositAmountMeta));
    }
    if (data.containsKey('total_sales')) {
      context.handle(
          _totalSalesMeta,
          totalSales.isAcceptableOrUnknown(
              data['total_sales'], _totalSalesMeta));
    }
    if (data.containsKey('ar_payment')) {
      context.handle(_arPaymentMeta,
          arPayment.isAcceptableOrUnknown(data['ar_payment'], _arPaymentMeta));
    }
    if (data.containsKey('total_amount_due')) {
      context.handle(
          _totalAmountDueMeta,
          totalAmountDue.isAcceptableOrUnknown(
              data['total_amount_due'], _totalAmountDueMeta));
    }
    if (data.containsKey('balance_brought_forward')) {
      context.handle(
          _balanceBroughtForwardMeta,
          balanceBroughtForward.isAcceptableOrUnknown(
              data['balance_brought_forward'], _balanceBroughtForwardMeta));
    }
    if (data.containsKey('balance_amount')) {
      context.handle(
          _balanceAmountMeta,
          balanceAmount.isAcceptableOrUnknown(
              data['balance_amount'], _balanceAmountMeta));
    }
    if (data.containsKey('balance_text')) {
      context.handle(
          _balanceTextMeta,
          balanceText.isAcceptableOrUnknown(
              data['balance_text'], _balanceTextMeta));
    }
    if (data.containsKey('cash_transfer')) {
      context.handle(
          _cashTransferMeta,
          cashTransfer.isAcceptableOrUnknown(
              data['cash_transfer'], _cashTransferMeta));
    }
    if (data.containsKey('credit_sales')) {
      context.handle(
          _creditSalesMeta,
          creditSales.isAcceptableOrUnknown(
              data['credit_sales'], _creditSalesMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ClockInData map(Map<String, dynamic> data, {String tablePrefix}) {
    return ClockInData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $ClockInTable createAlias(String alias) {
    return $ClockInTable(_db, alias);
  }
}

class SystemCurrencyData extends DataClass
    implements Insertable<SystemCurrencyData> {
  final int tenantId;
  final int id;
  final String currencyName;
  final String fraction;
  final String numberFormat;
  final String symbol;
  final double smallestCurrencyFractionValue;
  final DateTime effectiveDate;
  final bool isActive;
  final bool isDeleted;
  SystemCurrencyData(
      {this.tenantId,
      @required this.id,
      this.currencyName,
      this.fraction,
      this.numberFormat,
      this.symbol,
      this.smallestCurrencyFractionValue,
      @required this.effectiveDate,
      @required this.isActive,
      @required this.isDeleted});
  factory SystemCurrencyData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return SystemCurrencyData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      currencyName: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}currency_name']),
      fraction: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}fraction']),
      numberFormat: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}number_format']),
      symbol: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}symbol']),
      smallestCurrencyFractionValue: const RealType().mapFromDatabaseResponse(
          data['${effectivePrefix}smallest_currency_fraction_value']),
      effectiveDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}effective_date']),
      isActive: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_active']),
      isDeleted: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_deleted']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || currencyName != null) {
      map['currency_name'] = Variable<String>(currencyName);
    }
    if (!nullToAbsent || fraction != null) {
      map['fraction'] = Variable<String>(fraction);
    }
    if (!nullToAbsent || numberFormat != null) {
      map['number_format'] = Variable<String>(numberFormat);
    }
    if (!nullToAbsent || symbol != null) {
      map['symbol'] = Variable<String>(symbol);
    }
    if (!nullToAbsent || smallestCurrencyFractionValue != null) {
      map['smallest_currency_fraction_value'] =
          Variable<double>(smallestCurrencyFractionValue);
    }
    if (!nullToAbsent || effectiveDate != null) {
      map['effective_date'] = Variable<DateTime>(effectiveDate);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    return map;
  }

  SystemCurrencyCompanion toCompanion(bool nullToAbsent) {
    return SystemCurrencyCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      currencyName: currencyName == null && nullToAbsent
          ? const Value.absent()
          : Value(currencyName),
      fraction: fraction == null && nullToAbsent
          ? const Value.absent()
          : Value(fraction),
      numberFormat: numberFormat == null && nullToAbsent
          ? const Value.absent()
          : Value(numberFormat),
      symbol:
          symbol == null && nullToAbsent ? const Value.absent() : Value(symbol),
      smallestCurrencyFractionValue:
          smallestCurrencyFractionValue == null && nullToAbsent
              ? const Value.absent()
              : Value(smallestCurrencyFractionValue),
      effectiveDate: effectiveDate == null && nullToAbsent
          ? const Value.absent()
          : Value(effectiveDate),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
    );
  }

  factory SystemCurrencyData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SystemCurrencyData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      currencyName: serializer.fromJson<String>(json['currencyName']),
      fraction: serializer.fromJson<String>(json['fraction']),
      numberFormat: serializer.fromJson<String>(json['numberFormat']),
      symbol: serializer.fromJson<String>(json['symbol']),
      smallestCurrencyFractionValue:
          serializer.fromJson<double>(json['smallestCurrencyFractionValue']),
      effectiveDate: serializer.fromJson<DateTime>(json['effectiveDate']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'currencyName': serializer.toJson<String>(currencyName),
      'fraction': serializer.toJson<String>(fraction),
      'numberFormat': serializer.toJson<String>(numberFormat),
      'symbol': serializer.toJson<String>(symbol),
      'smallestCurrencyFractionValue':
          serializer.toJson<double>(smallestCurrencyFractionValue),
      'effectiveDate': serializer.toJson<DateTime>(effectiveDate),
      'isActive': serializer.toJson<bool>(isActive),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  SystemCurrencyData copyWith(
          {int tenantId,
          int id,
          String currencyName,
          String fraction,
          String numberFormat,
          String symbol,
          double smallestCurrencyFractionValue,
          DateTime effectiveDate,
          bool isActive,
          bool isDeleted}) =>
      SystemCurrencyData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        currencyName: currencyName ?? this.currencyName,
        fraction: fraction ?? this.fraction,
        numberFormat: numberFormat ?? this.numberFormat,
        symbol: symbol ?? this.symbol,
        smallestCurrencyFractionValue:
            smallestCurrencyFractionValue ?? this.smallestCurrencyFractionValue,
        effectiveDate: effectiveDate ?? this.effectiveDate,
        isActive: isActive ?? this.isActive,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  @override
  String toString() {
    return (StringBuffer('SystemCurrencyData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('currencyName: $currencyName, ')
          ..write('fraction: $fraction, ')
          ..write('numberFormat: $numberFormat, ')
          ..write('symbol: $symbol, ')
          ..write(
              'smallestCurrencyFractionValue: $smallestCurrencyFractionValue, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      tenantId,
      id,
      currencyName,
      fraction,
      numberFormat,
      symbol,
      smallestCurrencyFractionValue,
      effectiveDate,
      isActive,
      isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SystemCurrencyData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.currencyName == this.currencyName &&
          other.fraction == this.fraction &&
          other.numberFormat == this.numberFormat &&
          other.symbol == this.symbol &&
          other.smallestCurrencyFractionValue ==
              this.smallestCurrencyFractionValue &&
          other.effectiveDate == this.effectiveDate &&
          other.isActive == this.isActive &&
          other.isDeleted == this.isDeleted);
}

class SystemCurrencyCompanion extends UpdateCompanion<SystemCurrencyData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> currencyName;
  final Value<String> fraction;
  final Value<String> numberFormat;
  final Value<String> symbol;
  final Value<double> smallestCurrencyFractionValue;
  final Value<DateTime> effectiveDate;
  final Value<bool> isActive;
  final Value<bool> isDeleted;
  const SystemCurrencyCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.currencyName = const Value.absent(),
    this.fraction = const Value.absent(),
    this.numberFormat = const Value.absent(),
    this.symbol = const Value.absent(),
    this.smallestCurrencyFractionValue = const Value.absent(),
    this.effectiveDate = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  SystemCurrencyCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.currencyName = const Value.absent(),
    this.fraction = const Value.absent(),
    this.numberFormat = const Value.absent(),
    this.symbol = const Value.absent(),
    this.smallestCurrencyFractionValue = const Value.absent(),
    @required DateTime effectiveDate,
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
  }) : effectiveDate = Value(effectiveDate);
  static Insertable<SystemCurrencyData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> currencyName,
    Expression<String> fraction,
    Expression<String> numberFormat,
    Expression<String> symbol,
    Expression<double> smallestCurrencyFractionValue,
    Expression<DateTime> effectiveDate,
    Expression<bool> isActive,
    Expression<bool> isDeleted,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (currencyName != null) 'currency_name': currencyName,
      if (fraction != null) 'fraction': fraction,
      if (numberFormat != null) 'number_format': numberFormat,
      if (symbol != null) 'symbol': symbol,
      if (smallestCurrencyFractionValue != null)
        'smallest_currency_fraction_value': smallestCurrencyFractionValue,
      if (effectiveDate != null) 'effective_date': effectiveDate,
      if (isActive != null) 'is_active': isActive,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  SystemCurrencyCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> currencyName,
      Value<String> fraction,
      Value<String> numberFormat,
      Value<String> symbol,
      Value<double> smallestCurrencyFractionValue,
      Value<DateTime> effectiveDate,
      Value<bool> isActive,
      Value<bool> isDeleted}) {
    return SystemCurrencyCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      currencyName: currencyName ?? this.currencyName,
      fraction: fraction ?? this.fraction,
      numberFormat: numberFormat ?? this.numberFormat,
      symbol: symbol ?? this.symbol,
      smallestCurrencyFractionValue:
          smallestCurrencyFractionValue ?? this.smallestCurrencyFractionValue,
      effectiveDate: effectiveDate ?? this.effectiveDate,
      isActive: isActive ?? this.isActive,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (currencyName.present) {
      map['currency_name'] = Variable<String>(currencyName.value);
    }
    if (fraction.present) {
      map['fraction'] = Variable<String>(fraction.value);
    }
    if (numberFormat.present) {
      map['number_format'] = Variable<String>(numberFormat.value);
    }
    if (symbol.present) {
      map['symbol'] = Variable<String>(symbol.value);
    }
    if (smallestCurrencyFractionValue.present) {
      map['smallest_currency_fraction_value'] =
          Variable<double>(smallestCurrencyFractionValue.value);
    }
    if (effectiveDate.present) {
      map['effective_date'] = Variable<DateTime>(effectiveDate.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SystemCurrencyCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('currencyName: $currencyName, ')
          ..write('fraction: $fraction, ')
          ..write('numberFormat: $numberFormat, ')
          ..write('symbol: $symbol, ')
          ..write(
              'smallestCurrencyFractionValue: $smallestCurrencyFractionValue, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $SystemCurrencyTable extends SystemCurrency
    with TableInfo<$SystemCurrencyTable, SystemCurrencyData> {
  final GeneratedDatabase _db;
  final String _alias;
  $SystemCurrencyTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(),
          requiredDuringInsert: false,
          defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
  final VerificationMeta _currencyNameMeta =
      const VerificationMeta('currencyName');
  GeneratedColumn<String> _currencyName;
  @override
  GeneratedColumn<String> get currencyName => _currencyName ??=
      GeneratedColumn<String>('currency_name', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _fractionMeta = const VerificationMeta('fraction');
  GeneratedColumn<String> _fraction;
  @override
  GeneratedColumn<String> get fraction =>
      _fraction ??= GeneratedColumn<String>('fraction', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _numberFormatMeta =
      const VerificationMeta('numberFormat');
  GeneratedColumn<String> _numberFormat;
  @override
  GeneratedColumn<String> get numberFormat => _numberFormat ??=
      GeneratedColumn<String>('number_format', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _symbolMeta = const VerificationMeta('symbol');
  GeneratedColumn<String> _symbol;
  @override
  GeneratedColumn<String> get symbol =>
      _symbol ??= GeneratedColumn<String>('symbol', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _smallestCurrencyFractionValueMeta =
      const VerificationMeta('smallestCurrencyFractionValue');
  GeneratedColumn<double> _smallestCurrencyFractionValue;
  @override
  GeneratedColumn<double> get smallestCurrencyFractionValue =>
      _smallestCurrencyFractionValue ??= GeneratedColumn<double>(
          'smallest_currency_fraction_value', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _effectiveDateMeta =
      const VerificationMeta('effectiveDate');
  GeneratedColumn<DateTime> _effectiveDate;
  @override
  GeneratedColumn<DateTime> get effectiveDate => _effectiveDate ??=
      GeneratedColumn<DateTime>('effective_date', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _isActiveMeta = const VerificationMeta('isActive');
  GeneratedColumn<bool> _isActive;
  @override
  GeneratedColumn<bool> get isActive =>
      _isActive ??= GeneratedColumn<bool>('is_active', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_active IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isDeletedMeta = const VerificationMeta('isDeleted');
  GeneratedColumn<bool> _isDeleted;
  @override
  GeneratedColumn<bool> get isDeleted =>
      _isDeleted ??= GeneratedColumn<bool>('is_deleted', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_deleted IN (0, 1))',
          defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        currencyName,
        fraction,
        numberFormat,
        symbol,
        smallestCurrencyFractionValue,
        effectiveDate,
        isActive,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? 'system_currency';
  @override
  String get actualTableName => 'system_currency';
  @override
  VerificationContext validateIntegrity(Insertable<SystemCurrencyData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('currency_name')) {
      context.handle(
          _currencyNameMeta,
          currencyName.isAcceptableOrUnknown(
              data['currency_name'], _currencyNameMeta));
    }
    if (data.containsKey('fraction')) {
      context.handle(_fractionMeta,
          fraction.isAcceptableOrUnknown(data['fraction'], _fractionMeta));
    }
    if (data.containsKey('number_format')) {
      context.handle(
          _numberFormatMeta,
          numberFormat.isAcceptableOrUnknown(
              data['number_format'], _numberFormatMeta));
    }
    if (data.containsKey('symbol')) {
      context.handle(_symbolMeta,
          symbol.isAcceptableOrUnknown(data['symbol'], _symbolMeta));
    }
    if (data.containsKey('smallest_currency_fraction_value')) {
      context.handle(
          _smallestCurrencyFractionValueMeta,
          smallestCurrencyFractionValue.isAcceptableOrUnknown(
              data['smallest_currency_fraction_value'],
              _smallestCurrencyFractionValueMeta));
    }
    if (data.containsKey('effective_date')) {
      context.handle(
          _effectiveDateMeta,
          effectiveDate.isAcceptableOrUnknown(
              data['effective_date'], _effectiveDateMeta));
    } else if (isInserting) {
      context.missing(_effectiveDateMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active'], _isActiveMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted'], _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SystemCurrencyData map(Map<String, dynamic> data, {String tablePrefix}) {
    return SystemCurrencyData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $SystemCurrencyTable createAlias(String alias) {
    return $SystemCurrencyTable(_db, alias);
  }
}

class ExchangeRateData extends DataClass
    implements Insertable<ExchangeRateData> {
  final int tenantId;
  final int id;
  final String toCurrency;
  final String fromCurrency;
  final double exchangeRate;
  final DateTime effectiveDate;
  final bool isActive;
  final bool isDeleted;
  ExchangeRateData(
      {this.tenantId,
      @required this.id,
      this.toCurrency,
      this.fromCurrency,
      this.exchangeRate,
      @required this.effectiveDate,
      @required this.isActive,
      @required this.isDeleted});
  factory ExchangeRateData.fromData(Map<String, dynamic> data,
      {String prefix}) {
    final effectivePrefix = prefix ?? '';
    return ExchangeRateData(
      tenantId: const IntType()
          .mapFromDatabaseResponse(data['${effectivePrefix}tenant_id']),
      id: const IntType().mapFromDatabaseResponse(data['${effectivePrefix}id']),
      toCurrency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}to_currency']),
      fromCurrency: const StringType()
          .mapFromDatabaseResponse(data['${effectivePrefix}from_currency']),
      exchangeRate: const RealType()
          .mapFromDatabaseResponse(data['${effectivePrefix}exchange_rate']),
      effectiveDate: const DateTimeType()
          .mapFromDatabaseResponse(data['${effectivePrefix}effective_date']),
      isActive: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_active']),
      isDeleted: const BoolType()
          .mapFromDatabaseResponse(data['${effectivePrefix}is_deleted']),
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (!nullToAbsent || tenantId != null) {
      map['tenant_id'] = Variable<int>(tenantId);
    }
    if (!nullToAbsent || id != null) {
      map['id'] = Variable<int>(id);
    }
    if (!nullToAbsent || toCurrency != null) {
      map['to_currency'] = Variable<String>(toCurrency);
    }
    if (!nullToAbsent || fromCurrency != null) {
      map['from_currency'] = Variable<String>(fromCurrency);
    }
    if (!nullToAbsent || exchangeRate != null) {
      map['exchange_rate'] = Variable<double>(exchangeRate);
    }
    if (!nullToAbsent || effectiveDate != null) {
      map['effective_date'] = Variable<DateTime>(effectiveDate);
    }
    if (!nullToAbsent || isActive != null) {
      map['is_active'] = Variable<bool>(isActive);
    }
    if (!nullToAbsent || isDeleted != null) {
      map['is_deleted'] = Variable<bool>(isDeleted);
    }
    return map;
  }

  ExchangeRateCompanion toCompanion(bool nullToAbsent) {
    return ExchangeRateCompanion(
      tenantId: tenantId == null && nullToAbsent
          ? const Value.absent()
          : Value(tenantId),
      id: id == null && nullToAbsent ? const Value.absent() : Value(id),
      toCurrency: toCurrency == null && nullToAbsent
          ? const Value.absent()
          : Value(toCurrency),
      fromCurrency: fromCurrency == null && nullToAbsent
          ? const Value.absent()
          : Value(fromCurrency),
      exchangeRate: exchangeRate == null && nullToAbsent
          ? const Value.absent()
          : Value(exchangeRate),
      effectiveDate: effectiveDate == null && nullToAbsent
          ? const Value.absent()
          : Value(effectiveDate),
      isActive: isActive == null && nullToAbsent
          ? const Value.absent()
          : Value(isActive),
      isDeleted: isDeleted == null && nullToAbsent
          ? const Value.absent()
          : Value(isDeleted),
    );
  }

  factory ExchangeRateData.fromJson(Map<String, dynamic> json,
      {ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ExchangeRateData(
      tenantId: serializer.fromJson<int>(json['tenantId']),
      id: serializer.fromJson<int>(json['id']),
      toCurrency: serializer.fromJson<String>(json['toCurrency']),
      fromCurrency: serializer.fromJson<String>(json['fromCurrency']),
      exchangeRate: serializer.fromJson<double>(json['exchangeRate']),
      effectiveDate: serializer.fromJson<DateTime>(json['effectiveDate']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'tenantId': serializer.toJson<int>(tenantId),
      'id': serializer.toJson<int>(id),
      'toCurrency': serializer.toJson<String>(toCurrency),
      'fromCurrency': serializer.toJson<String>(fromCurrency),
      'exchangeRate': serializer.toJson<double>(exchangeRate),
      'effectiveDate': serializer.toJson<DateTime>(effectiveDate),
      'isActive': serializer.toJson<bool>(isActive),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  ExchangeRateData copyWith(
          {int tenantId,
          int id,
          String toCurrency,
          String fromCurrency,
          double exchangeRate,
          DateTime effectiveDate,
          bool isActive,
          bool isDeleted}) =>
      ExchangeRateData(
        tenantId: tenantId ?? this.tenantId,
        id: id ?? this.id,
        toCurrency: toCurrency ?? this.toCurrency,
        fromCurrency: fromCurrency ?? this.fromCurrency,
        exchangeRate: exchangeRate ?? this.exchangeRate,
        effectiveDate: effectiveDate ?? this.effectiveDate,
        isActive: isActive ?? this.isActive,
        isDeleted: isDeleted ?? this.isDeleted,
      );
  @override
  String toString() {
    return (StringBuffer('ExchangeRateData(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('toCurrency: $toCurrency, ')
          ..write('fromCurrency: $fromCurrency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(tenantId, id, toCurrency, fromCurrency,
      exchangeRate, effectiveDate, isActive, isDeleted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ExchangeRateData &&
          other.tenantId == this.tenantId &&
          other.id == this.id &&
          other.toCurrency == this.toCurrency &&
          other.fromCurrency == this.fromCurrency &&
          other.exchangeRate == this.exchangeRate &&
          other.effectiveDate == this.effectiveDate &&
          other.isActive == this.isActive &&
          other.isDeleted == this.isDeleted);
}

class ExchangeRateCompanion extends UpdateCompanion<ExchangeRateData> {
  final Value<int> tenantId;
  final Value<int> id;
  final Value<String> toCurrency;
  final Value<String> fromCurrency;
  final Value<double> exchangeRate;
  final Value<DateTime> effectiveDate;
  final Value<bool> isActive;
  final Value<bool> isDeleted;
  const ExchangeRateCompanion({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.toCurrency = const Value.absent(),
    this.fromCurrency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.effectiveDate = const Value.absent(),
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
  });
  ExchangeRateCompanion.insert({
    this.tenantId = const Value.absent(),
    this.id = const Value.absent(),
    this.toCurrency = const Value.absent(),
    this.fromCurrency = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    @required DateTime effectiveDate,
    this.isActive = const Value.absent(),
    this.isDeleted = const Value.absent(),
  }) : effectiveDate = Value(effectiveDate);
  static Insertable<ExchangeRateData> custom({
    Expression<int> tenantId,
    Expression<int> id,
    Expression<String> toCurrency,
    Expression<String> fromCurrency,
    Expression<double> exchangeRate,
    Expression<DateTime> effectiveDate,
    Expression<bool> isActive,
    Expression<bool> isDeleted,
  }) {
    return RawValuesInsertable({
      if (tenantId != null) 'tenant_id': tenantId,
      if (id != null) 'id': id,
      if (toCurrency != null) 'to_currency': toCurrency,
      if (fromCurrency != null) 'from_currency': fromCurrency,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (effectiveDate != null) 'effective_date': effectiveDate,
      if (isActive != null) 'is_active': isActive,
      if (isDeleted != null) 'is_deleted': isDeleted,
    });
  }

  ExchangeRateCompanion copyWith(
      {Value<int> tenantId,
      Value<int> id,
      Value<String> toCurrency,
      Value<String> fromCurrency,
      Value<double> exchangeRate,
      Value<DateTime> effectiveDate,
      Value<bool> isActive,
      Value<bool> isDeleted}) {
    return ExchangeRateCompanion(
      tenantId: tenantId ?? this.tenantId,
      id: id ?? this.id,
      toCurrency: toCurrency ?? this.toCurrency,
      fromCurrency: fromCurrency ?? this.fromCurrency,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      effectiveDate: effectiveDate ?? this.effectiveDate,
      isActive: isActive ?? this.isActive,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (tenantId.present) {
      map['tenant_id'] = Variable<int>(tenantId.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (toCurrency.present) {
      map['to_currency'] = Variable<String>(toCurrency.value);
    }
    if (fromCurrency.present) {
      map['from_currency'] = Variable<String>(fromCurrency.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (effectiveDate.present) {
      map['effective_date'] = Variable<DateTime>(effectiveDate.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ExchangeRateCompanion(')
          ..write('tenantId: $tenantId, ')
          ..write('id: $id, ')
          ..write('toCurrency: $toCurrency, ')
          ..write('fromCurrency: $fromCurrency, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('effectiveDate: $effectiveDate, ')
          ..write('isActive: $isActive, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }
}

class $ExchangeRateTable extends ExchangeRate
    with TableInfo<$ExchangeRateTable, ExchangeRateData> {
  final GeneratedDatabase _db;
  final String _alias;
  $ExchangeRateTable(this._db, [this._alias]);
  final VerificationMeta _tenantIdMeta = const VerificationMeta('tenantId');
  GeneratedColumn<int> _tenantId;
  @override
  GeneratedColumn<int> get tenantId =>
      _tenantId ??= GeneratedColumn<int>('tenant_id', aliasedName, true,
          type: const IntType(), requiredDuringInsert: false);
  final VerificationMeta _idMeta = const VerificationMeta('id');
  GeneratedColumn<int> _id;
  @override
  GeneratedColumn<int> get id =>
      _id ??= GeneratedColumn<int>('id', aliasedName, false,
          type: const IntType(),
          requiredDuringInsert: false,
          defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
  final VerificationMeta _toCurrencyMeta = const VerificationMeta('toCurrency');
  GeneratedColumn<String> _toCurrency;
  @override
  GeneratedColumn<String> get toCurrency =>
      _toCurrency ??= GeneratedColumn<String>('to_currency', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _fromCurrencyMeta =
      const VerificationMeta('fromCurrency');
  GeneratedColumn<String> _fromCurrency;
  @override
  GeneratedColumn<String> get fromCurrency => _fromCurrency ??=
      GeneratedColumn<String>('from_currency', aliasedName, true,
          type: const StringType(), requiredDuringInsert: false);
  final VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  GeneratedColumn<double> _exchangeRate;
  @override
  GeneratedColumn<double> get exchangeRate => _exchangeRate ??=
      GeneratedColumn<double>('exchange_rate', aliasedName, true,
          type: const RealType(), requiredDuringInsert: false);
  final VerificationMeta _effectiveDateMeta =
      const VerificationMeta('effectiveDate');
  GeneratedColumn<DateTime> _effectiveDate;
  @override
  GeneratedColumn<DateTime> get effectiveDate => _effectiveDate ??=
      GeneratedColumn<DateTime>('effective_date', aliasedName, false,
          type: const IntType(), requiredDuringInsert: true);
  final VerificationMeta _isActiveMeta = const VerificationMeta('isActive');
  GeneratedColumn<bool> _isActive;
  @override
  GeneratedColumn<bool> get isActive =>
      _isActive ??= GeneratedColumn<bool>('is_active', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_active IN (0, 1))',
          defaultValue: Constant(false));
  final VerificationMeta _isDeletedMeta = const VerificationMeta('isDeleted');
  GeneratedColumn<bool> _isDeleted;
  @override
  GeneratedColumn<bool> get isDeleted =>
      _isDeleted ??= GeneratedColumn<bool>('is_deleted', aliasedName, false,
          type: const BoolType(),
          requiredDuringInsert: false,
          defaultConstraints: 'CHECK (is_deleted IN (0, 1))',
          defaultValue: Constant(false));
  @override
  List<GeneratedColumn> get $columns => [
        tenantId,
        id,
        toCurrency,
        fromCurrency,
        exchangeRate,
        effectiveDate,
        isActive,
        isDeleted
      ];
  @override
  String get aliasedName => _alias ?? 'exchange_rate';
  @override
  String get actualTableName => 'exchange_rate';
  @override
  VerificationContext validateIntegrity(Insertable<ExchangeRateData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('tenant_id')) {
      context.handle(_tenantIdMeta,
          tenantId.isAcceptableOrUnknown(data['tenant_id'], _tenantIdMeta));
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id'], _idMeta));
    }
    if (data.containsKey('to_currency')) {
      context.handle(
          _toCurrencyMeta,
          toCurrency.isAcceptableOrUnknown(
              data['to_currency'], _toCurrencyMeta));
    }
    if (data.containsKey('from_currency')) {
      context.handle(
          _fromCurrencyMeta,
          fromCurrency.isAcceptableOrUnknown(
              data['from_currency'], _fromCurrencyMeta));
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate'], _exchangeRateMeta));
    }
    if (data.containsKey('effective_date')) {
      context.handle(
          _effectiveDateMeta,
          effectiveDate.isAcceptableOrUnknown(
              data['effective_date'], _effectiveDateMeta));
    } else if (isInserting) {
      context.missing(_effectiveDateMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active'], _isActiveMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted'], _isDeletedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ExchangeRateData map(Map<String, dynamic> data, {String tablePrefix}) {
    return ExchangeRateData.fromData(data,
        prefix: tablePrefix != null ? '$tablePrefix.' : null);
  }

  @override
  $ExchangeRateTable createAlias(String alias) {
    return $ExchangeRateTable(_db, alias);
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(SqlTypeSystem.defaultInstance, e);
  $UsersTable _users;
  $UsersTable get users => _users ??= $UsersTable(this);
  $CommunicationTable _communication;
  $CommunicationTable get communication =>
      _communication ??= $CommunicationTable(this);
  $BackgroundJobScheduleTable _backgroundJobSchedule;
  $BackgroundJobScheduleTable get backgroundJobSchedule =>
      _backgroundJobSchedule ??= $BackgroundJobScheduleTable(this);
  $BackgroundJobLogsTable _backgroundJobLogs;
  $BackgroundJobLogsTable get backgroundJobLogs =>
      _backgroundJobLogs ??= $BackgroundJobLogsTable(this);
  $PreferenceTable _preference;
  $PreferenceTable get preference => _preference ??= $PreferenceTable(this);
  $MobileDeviceTable _mobileDevice;
  $MobileDeviceTable get mobileDevice =>
      _mobileDevice ??= $MobileDeviceTable(this);
  $BusinessRuleTable _businessRule;
  $BusinessRuleTable get businessRule =>
      _businessRule ??= $BusinessRuleTable(this);
  $NonGlobalBusinessRuleTable _nonGlobalBusinessRule;
  $NonGlobalBusinessRuleTable get nonGlobalBusinessRule =>
      _nonGlobalBusinessRule ??= $NonGlobalBusinessRuleTable(this);
  $ApplicationLoggerTable _applicationLogger;
  $ApplicationLoggerTable get applicationLogger =>
      _applicationLogger ??= $ApplicationLoggerTable(this);
  $TenantTable _tenant;
  $TenantTable get tenant => _tenant ??= $TenantTable(this);
  $NonGlobalPreferenceTable _nonGlobalPreference;
  $NonGlobalPreferenceTable get nonGlobalPreference =>
      _nonGlobalPreference ??= $NonGlobalPreferenceTable(this);
  $DesktopTable _desktop;
  $DesktopTable get desktop => _desktop ??= $DesktopTable(this);
  $SalesOrderHeaderTable _salesOrderHeader;
  $SalesOrderHeaderTable get salesOrderHeader =>
      _salesOrderHeader ??= $SalesOrderHeaderTable(this);
  $SalesOrderDetailTable _salesOrderDetail;
  $SalesOrderDetailTable get salesOrderDetail =>
      _salesOrderDetail ??= $SalesOrderDetailTable(this);
  $SalesOrderDetailTempTable _salesOrderDetailTemp;
  $SalesOrderDetailTempTable get salesOrderDetailTemp =>
      _salesOrderDetailTemp ??= $SalesOrderDetailTempTable(this);
  $SeriesNumberGeneratorTable _seriesNumberGenerator;
  $SeriesNumberGeneratorTable get seriesNumberGenerator =>
      _seriesNumberGenerator ??= $SeriesNumberGeneratorTable(this);
  $SalesTaxTable _salesTax;
  $SalesTaxTable get salesTax => _salesTax ??= $SalesTaxTable(this);
  $TempNumberLogsTable _tempNumberLogs;
  $TempNumberLogsTable get tempNumberLogs =>
      _tempNumberLogs ??= $TempNumberLogsTable(this);
  $CustomerTable _customer;
  $CustomerTable get customer => _customer ??= $CustomerTable(this);
  $AddressTable _address;
  $AddressTable get address => _address ??= $AddressTable(this);
  $ContactTable _contact;
  $ContactTable get contact => _contact ??= $ContactTable(this);
  $ItemsTable _items;
  $ItemsTable get items => _items ??= $ItemsTable(this);
  $ItemsPricesTable _itemsPrices;
  $ItemsPricesTable get itemsPrices => _itemsPrices ??= $ItemsPricesTable(this);
  $ItemPricingRuleTable _itemPricingRule;
  $ItemPricingRuleTable get itemPricingRule =>
      _itemPricingRule ??= $ItemPricingRuleTable(this);
  $CategoresTable _categores;
  $CategoresTable get categores => _categores ??= $CategoresTable(this);
  $ItemGroupsTable _itemGroups;
  $ItemGroupsTable get itemGroups => _itemGroups ??= $ItemGroupsTable(this);
  $PriceListTable _priceList;
  $PriceListTable get priceList => _priceList ??= $PriceListTable(this);
  $UnitOfMeasureTable _unitOfMeasure;
  $UnitOfMeasureTable get unitOfMeasure =>
      _unitOfMeasure ??= $UnitOfMeasureTable(this);
  $StockUnitOfMeasureTable _stockUnitOfMeasure;
  $StockUnitOfMeasureTable get stockUnitOfMeasure =>
      _stockUnitOfMeasure ??= $StockUnitOfMeasureTable(this);
  $JourneyPlanTable _journeyPlan;
  $JourneyPlanTable get journeyPlan => _journeyPlan ??= $JourneyPlanTable(this);
  $UPCCodeTable _uPCCode;
  $UPCCodeTable get uPCCode => _uPCCode ??= $UPCCodeTable(this);
  $InventoryItemsTable _inventoryItems;
  $InventoryItemsTable get inventoryItems =>
      _inventoryItems ??= $InventoryItemsTable(this);
  $InventoryTransactionTable _inventoryTransaction;
  $InventoryTransactionTable get inventoryTransaction =>
      _inventoryTransaction ??= $InventoryTransactionTable(this);
  $MoneyDepositTable _moneyDeposit;
  $MoneyDepositTable get moneyDeposit =>
      _moneyDeposit ??= $MoneyDepositTable(this);
  $ClockInTable _clockIn;
  $ClockInTable get clockIn => _clockIn ??= $ClockInTable(this);
  $SystemCurrencyTable _systemCurrency;
  $SystemCurrencyTable get systemCurrency =>
      _systemCurrency ??= $SystemCurrencyTable(this);
  $ExchangeRateTable _exchangeRate;
  $ExchangeRateTable get exchangeRate =>
      _exchangeRate ??= $ExchangeRateTable(this);
  @override
  Iterable<TableInfo> get allTables => allSchemaEntities.whereType<TableInfo>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        users,
        communication,
        backgroundJobSchedule,
        backgroundJobLogs,
        preference,
        mobileDevice,
        businessRule,
        nonGlobalBusinessRule,
        applicationLogger,
        tenant,
        nonGlobalPreference,
        desktop,
        salesOrderHeader,
        salesOrderDetail,
        salesOrderDetailTemp,
        seriesNumberGenerator,
        salesTax,
        tempNumberLogs,
        customer,
        address,
        contact,
        items,
        itemsPrices,
        itemPricingRule,
        categores,
        itemGroups,
        priceList,
        unitOfMeasure,
        stockUnitOfMeasure,
        journeyPlan,
        uPCCode,
        inventoryItems,
        inventoryTransaction,
        moneyDeposit,
        clockIn,
        systemCurrency,
        exchangeRate
      ];
}
